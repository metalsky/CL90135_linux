#! /usr/bin/env bash
# Patch: -pro_musb_hdrc_Search_and_replace_MGC_M__with_MUSB_
# Date: Fri Sep 19 14:11:03 2008
# From be9ad2d706cd9f29563206ba080cff9c3836f6ac Mon Sep 17 00:00:00 2001
# From: Tony Lindgren <tony@atomide.com>
# Date: Wed, 15 Aug 2007 06:16:13 -0700
# Subject: [PATCH] musb_hdrc: Search and replace MGC_M_ with MUSB_
# 
# Search and replace MGC_M_ with MUSB_
# 
# Signed-off-by: Tony Lindgren <tony@atomide.com>
# (cherry picked from commit 0c25660e32f8ccf2a59547d8b7d2fadf77384f72)

PATCHNUM=1716
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
From be9ad2d706cd9f29563206ba080cff9c3836f6ac Mon Sep 17 00:00:00 2001
From: Tony Lindgren <tony@atomide.com>
Date: Wed, 15 Aug 2007 06:16:13 -0700
Subject: [PATCH] musb_hdrc: Search and replace MGC_M_ with MUSB_

Search and replace MGC_M_ with MUSB_

Signed-off-by: Tony Lindgren <tony@atomide.com>
(cherry picked from commit 0c25660e32f8ccf2a59547d8b7d2fadf77384f72)
Index: linux-2.6.18/drivers/usb/musb/cppi_dma.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/cppi_dma.c
+++ linux-2.6.18/drivers/usb/musb/cppi_dma.c
@@ -501,8 +501,8 @@ static inline int cppi_autoreq_update(st
 		void		*__iomem regs = rx->hw_ep->regs;
 
 		val = musb_readw(regs, MUSB_RXCSR);
-		if (!(val & MGC_M_RXCSR_H_REQPKT)) {
-			val |= MGC_M_RXCSR_H_REQPKT | MGC_M_RXCSR_H_WZC_BITS;
+		if (!(val & MUSB_RXCSR_H_REQPKT)) {
+			val |= MUSB_RXCSR_H_REQPKT | MUSB_RXCSR_H_WZC_BITS;
 			musb_writew(regs, MUSB_RXCSR, val);
 			/* flush writebufer */
 			val = musb_readw(regs, MUSB_RXCSR);
@@ -1096,7 +1096,7 @@ static int cppi_rx_scan(struct cppi *cpp
 		}
 		musb_ep_select(cppi->pCoreBase, rx->chNo + 1);
 		csr = musb_readw(regs, MUSB_RXCSR);
-		if (csr & MGC_M_RXCSR_DMAENAB) {
+		if (csr & MUSB_RXCSR_DMAENAB) {
 			DBG(4, "list%d %p/%p, last %08x%s, csr %04x\n",
 				rx->chNo,
 				rx->activeQueueHead, rx->activeQueueTail,
@@ -1119,10 +1119,10 @@ static int cppi_rx_scan(struct cppi *cpp
 		csr = musb_readw(rx->hw_ep->regs, MUSB_RXCSR);
 		if (is_host_active(cppi->musb)
 				&& bd
-				&& !(csr & MGC_M_RXCSR_H_REQPKT)) {
-			csr |= MGC_M_RXCSR_H_REQPKT;
+				&& !(csr & MUSB_RXCSR_H_REQPKT)) {
+			csr |= MUSB_RXCSR_H_REQPKT;
 			musb_writew(regs, MUSB_RXCSR,
-					MGC_M_RXCSR_H_WZC_BITS | csr);
+					MUSB_RXCSR_H_WZC_BITS | csr);
 			csr = musb_readw(rx->hw_ep->regs, MUSB_RXCSR);
 		}
 	} else {
@@ -1247,7 +1247,7 @@ void cppi_completion(struct musb *musb, 
 
 						csr = musb_readw(hw_ep->regs,
 							MUSB_TXCSR);
-						if (csr & MGC_M_TXCSR_TXPKTRDY)
+						if (csr & MUSB_TXCSR_TXPKTRDY)
 #endif
 							bReqComplete = 0;
 					}
@@ -1439,8 +1439,8 @@ static int cppi_channel_abort(struct dma
 		 */
 
 		regVal = musb_readw(regs, MUSB_TXCSR);
-		regVal &= ~MGC_M_TXCSR_DMAENAB;
-		regVal |= MGC_M_TXCSR_FLUSHFIFO;
+		regVal &= ~MUSB_TXCSR_DMAENAB;
+		regVal |= MUSB_TXCSR_FLUSHFIFO;
 		musb_writew(regs, MUSB_TXCSR, regVal);
 		musb_writew(regs, MUSB_TXCSR, regVal);
 
@@ -1500,13 +1500,13 @@ static int cppi_channel_abort(struct dma
 
 		/* for host, clear (just) ReqPkt at end of current packet(s) */
 		if (is_host_active(otgCh->pController->musb)) {
-			csr |= MGC_M_RXCSR_H_WZC_BITS;
-			csr &= ~MGC_M_RXCSR_H_REQPKT;
+			csr |= MUSB_RXCSR_H_WZC_BITS;
+			csr &= ~MUSB_RXCSR_H_REQPKT;
 		} else
-			csr |= MGC_M_RXCSR_P_WZC_BITS;
+			csr |= MUSB_RXCSR_P_WZC_BITS;
 
 		/* clear dma enable */
-		csr &= ~(MGC_M_RXCSR_DMAENAB);
+		csr &= ~(MUSB_RXCSR_DMAENAB);
 		musb_writew(regs, MUSB_RXCSR, csr);
 		csr = musb_readw(regs, MUSB_RXCSR);
 
Index: linux-2.6.18/drivers/usb/musb/davinci.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/davinci.c
+++ linux-2.6.18/drivers/usb/musb/davinci.c
@@ -86,7 +86,7 @@ void musb_platform_enable(struct musb *m
 	musb_writel(musb->ctrl_base, DAVINCI_USB_INT_MASK_SET_REG, tmp);
 	tmp |= old;
 
-	val = ~MGC_M_INTR_SOF;
+	val = ~MUSB_INTR_SOF;
 	tmp |= ((val & 0x01ff) << DAVINCI_USB_USBINT_SHIFT);
 	musb_writel(musb->ctrl_base, DAVINCI_USB_INT_MASK_SET_REG, tmp);
 
@@ -218,13 +218,13 @@ static void otg_timer(unsigned long _mus
 		 * case "recover"), in routine "VBUS was valid by the time
 		 * VBUSERR got reported during enumeration" cases.
 		 */
-		if (devctl & MGC_M_DEVCTL_VBUS) {
+		if (devctl & MUSB_DEVCTL_VBUS) {
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 			break;
 		}
 		musb->xceiv.state = OTG_STATE_A_WAIT_VRISE;
 		musb_writel(musb->ctrl_base, DAVINCI_USB_INT_SET_REG,
-			MGC_M_INTR_VBUSERROR << DAVINCI_USB_USBINT_SHIFT);
+			MUSB_INTR_VBUSERROR << DAVINCI_USB_USBINT_SHIFT);
 		break;
 	case OTG_STATE_B_IDLE:
 		if (!is_peripheral_enabled(musb))
@@ -242,9 +242,9 @@ static void otg_timer(unsigned long _mus
 		 * SRP, but clearly it doesn't.
 		 */
 		musb_writeb(mregs, MUSB_DEVCTL,
-				devctl | MGC_M_DEVCTL_SESSION);
+				devctl | MUSB_DEVCTL_SESSION);
 		devctl = musb_readb(mregs, MUSB_DEVCTL);
-		if (devctl & MGC_M_DEVCTL_BDEVICE)
+		if (devctl & MUSB_DEVCTL_BDEVICE)
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 		else
 			musb->xceiv.state = OTG_STATE_A_IDLE;
@@ -311,10 +311,10 @@ static irqreturn_t davinci_interrupt(int
 		int	drvvbus = musb_readl(tibase, DAVINCI_USB_STAT_REG);
 		void	*__iomem mregs = musb->mregs;
 		u8	devctl = musb_readb(mregs, MUSB_DEVCTL);
-		int	err = musb->int_usb & MGC_M_INTR_VBUSERROR;
+		int	err = musb->int_usb & MUSB_INTR_VBUSERROR;
 
 		err = is_host_enabled(musb)
-				&& (musb->int_usb & MGC_M_INTR_VBUSERROR);
+				&& (musb->int_usb & MUSB_INTR_VBUSERROR);
 		if (err) {
 			/* The Mentor core doesn't debounce VBUS as needed
 			 * to cope with device connect current spikes. This
@@ -326,7 +326,7 @@ static irqreturn_t davinci_interrupt(int
 			 * without waiting (on EVM, a **long** time) for VBUS
 			 * to stop registering in devctl.
 			 */
-			musb->int_usb &= ~MGC_M_INTR_VBUSERROR;
+			musb->int_usb &= ~MUSB_INTR_VBUSERROR;
 			musb->xceiv.state = OTG_STATE_A_WAIT_VFALL;
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 			WARN("VBUS error workaround (delay coming)\n");
@@ -441,10 +441,10 @@ int musb_platform_exit(struct musb *musb
 		 */
 		do {
 			devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
-			if (!(devctl & MGC_M_DEVCTL_VBUS))
+			if (!(devctl & MUSB_DEVCTL_VBUS))
 				break;
-			if ((devctl & MGC_M_DEVCTL_VBUS) != warn) {
-				warn = devctl & MGC_M_DEVCTL_VBUS;
+			if ((devctl & MUSB_DEVCTL_VBUS) != warn) {
+				warn = devctl & MUSB_DEVCTL_VBUS;
 				DBG(1, "VBUS %d\n", warn >> MGC_S_DEVCTL_VBUS);
 			}
 			msleep(1000);
@@ -452,7 +452,7 @@ int musb_platform_exit(struct musb *musb
 		} while (maxdelay > 0);
 
 		/* in OTG mode, another host might be connected */
-		if (devctl & MGC_M_DEVCTL_VBUS)
+		if (devctl & MUSB_DEVCTL_VBUS)
 			DBG(1, "VBUS off timeout (devctl %02x)\n", devctl);
 	}
 
Index: linux-2.6.18/drivers/usb/musb/g_ep0.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/g_ep0.c
+++ linux-2.6.18/drivers/usb/musb/g_ep0.c
@@ -130,10 +130,10 @@ static int service_tx_status_request(
 		musb_ep_select(mbase, epnum);
 		if (is_in)
 			tmp = musb_readw(regs, MUSB_TXCSR)
-						& MGC_M_TXCSR_P_SENDSTALL;
+						& MUSB_TXCSR_P_SENDSTALL;
 		else
 			tmp = musb_readw(regs, MUSB_RXCSR)
-						& MGC_M_RXCSR_P_SENDSTALL;
+						& MUSB_RXCSR_P_SENDSTALL;
 		musb_ep_select(mbase, 0);
 
 		result[0] = tmp ? 1 : 0;
@@ -210,7 +210,7 @@ static inline void musb_try_b_hnp_enable
 
 	DBG(1, "HNP: Setting HR\n");
 	devctl = musb_readb(mbase, MUSB_DEVCTL);
-	musb_writeb(mbase, MUSB_DEVCTL, devctl | MGC_M_DEVCTL_HR);
+	musb_writeb(mbase, MUSB_DEVCTL, devctl | MUSB_DEVCTL_HR);
 }
 
 /*
@@ -307,25 +307,25 @@ __acquires(musb->lock)
 						pr_debug("TEST_J\n");
 						/* TEST_J */
 						musb->test_mode_nr =
-							MGC_M_TEST_J;
+							MUSB_TEST_J;
 						break;
 					case 2:
 						/* TEST_K */
 						pr_debug("TEST_K\n");
 						musb->test_mode_nr =
-							MGC_M_TEST_K;
+							MUSB_TEST_K;
 						break;
 					case 3:
 						/* TEST_SE0_NAK */
 						pr_debug("TEST_SE0_NAK\n");
 						musb->test_mode_nr =
-							MGC_M_TEST_SE0_NAK;
+							MUSB_TEST_SE0_NAK;
 						break;
 					case 4:
 						/* TEST_PACKET */
 						pr_debug("TEST_PACKET\n");
 						musb->test_mode_nr =
-							MGC_M_TEST_PACKET;
+							MUSB_TEST_PACKET;
 						break;
 					default:
 						goto stall;
@@ -392,20 +392,20 @@ stall:
 				if (is_in) {
 					csr = musb_readw(regs,
 							MUSB_TXCSR);
-					if (csr & MGC_M_TXCSR_FIFONOTEMPTY)
-						csr |= MGC_M_TXCSR_FLUSHFIFO;
-					csr |= MGC_M_TXCSR_P_SENDSTALL
-						| MGC_M_TXCSR_CLRDATATOG
-						| MGC_M_TXCSR_P_WZC_BITS;
+					if (csr & MUSB_TXCSR_FIFONOTEMPTY)
+						csr |= MUSB_TXCSR_FLUSHFIFO;
+					csr |= MUSB_TXCSR_P_SENDSTALL
+						| MUSB_TXCSR_CLRDATATOG
+						| MUSB_TXCSR_P_WZC_BITS;
 					musb_writew(regs, MUSB_TXCSR,
 							csr);
 				} else {
 					csr = musb_readw(regs,
 							MUSB_RXCSR);
-					csr |= MGC_M_RXCSR_P_SENDSTALL
-						| MGC_M_RXCSR_FLUSHFIFO
-						| MGC_M_RXCSR_CLRDATATOG
-						| MGC_M_TXCSR_P_WZC_BITS;
+					csr |= MUSB_RXCSR_P_SENDSTALL
+						| MUSB_RXCSR_FLUSHFIFO
+						| MUSB_RXCSR_CLRDATATOG
+						| MUSB_TXCSR_P_WZC_BITS;
 					musb_writew(regs, MUSB_RXCSR,
 							csr);
 				}
@@ -456,14 +456,14 @@ static void ep0_rxstate(struct musb *thi
 		}
 		musb_read_fifo(&this->endpoints[0], tmp, buf);
 		req->actual += tmp;
-		tmp = MGC_M_CSR0_P_SVDRXPKTRDY;
+		tmp = MUSB_CSR0_P_SVDRXPKTRDY;
 		if (tmp < 64 || req->actual == req->length) {
 			this->ep0_state = MGC_END0_STAGE_STATUSIN;
-			tmp |= MGC_M_CSR0_P_DATAEND;
+			tmp |= MUSB_CSR0_P_DATAEND;
 		} else
 			req = NULL;
 	} else
-		tmp = MGC_M_CSR0_P_SVDRXPKTRDY | MGC_M_CSR0_P_SENDSTALL;
+		tmp = MUSB_CSR0_P_SVDRXPKTRDY | MUSB_CSR0_P_SENDSTALL;
 	musb_writew(regs, MUSB_CSR0, tmp);
 
 
@@ -485,7 +485,7 @@ static void ep0_txstate(struct musb *mus
 {
 	void __iomem		*regs = musb->control_ep->regs;
 	struct usb_request	*request = next_ep0_request(musb);
-	u16			csr = MGC_M_CSR0_TXPKTRDY;
+	u16			csr = MUSB_CSR0_TXPKTRDY;
 	u8			*pFifoSource;
 	u8			fifo_count;
 
@@ -506,7 +506,7 @@ static void ep0_txstate(struct musb *mus
 	if (fifo_count < MUSB_MAX_END0_PACKET
 			|| request->actual == request->length) {
 		musb->ep0_state = MGC_END0_STAGE_STATUSOUT;
-		csr |= MGC_M_CSR0_P_DATAEND;
+		csr |= MUSB_CSR0_P_DATAEND;
 	} else
 		request = NULL;
 
@@ -560,16 +560,16 @@ musb_read_setup(struct musb *musb, struc
 	 * to switch modes...
 	 */
 	musb->set_address = FALSE;
-	musb->ackpend = MGC_M_CSR0_P_SVDRXPKTRDY;
+	musb->ackpend = MUSB_CSR0_P_SVDRXPKTRDY;
 	if (req->wLength == 0) {
 		if (req->bRequestType & USB_DIR_IN)
-			musb->ackpend |= MGC_M_CSR0_TXPKTRDY;
+			musb->ackpend |= MUSB_CSR0_TXPKTRDY;
 		musb->ep0_state = MGC_END0_STAGE_ACKWAIT;
 	} else if (req->bRequestType & USB_DIR_IN) {
 		musb->ep0_state = MGC_END0_STAGE_TX;
-		musb_writew(regs, MUSB_CSR0, MGC_M_CSR0_P_SVDRXPKTRDY);
+		musb_writew(regs, MUSB_CSR0, MUSB_CSR0_P_SVDRXPKTRDY);
 		while ((musb_readw(regs, MUSB_CSR0)
-				& MGC_M_CSR0_RXPKTRDY) != 0)
+				& MUSB_CSR0_RXPKTRDY) != 0)
 			cpu_relax();
 		musb->ackpend = 0;
 	} else
@@ -614,17 +614,17 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 			decode_ep0stage(musb->ep0_state));
 
 	/* I sent a stall.. need to acknowledge it now.. */
-	if (csr & MGC_M_CSR0_P_SENTSTALL) {
+	if (csr & MUSB_CSR0_P_SENTSTALL) {
 		musb_writew(regs, MUSB_CSR0,
-				csr & ~MGC_M_CSR0_P_SENTSTALL);
+				csr & ~MUSB_CSR0_P_SENTSTALL);
 		retval = IRQ_HANDLED;
 		musb->ep0_state = MGC_END0_STAGE_SETUP;
 		csr = musb_readw(regs, MUSB_CSR0);
 	}
 
 	/* request ended "early" */
-	if (csr & MGC_M_CSR0_P_SETUPEND) {
-		musb_writew(regs, MUSB_CSR0, MGC_M_CSR0_P_SVDSETUPEND);
+	if (csr & MUSB_CSR0_P_SETUPEND) {
+		musb_writew(regs, MUSB_CSR0, MUSB_CSR0_P_SVDSETUPEND);
 		retval = IRQ_HANDLED;
 		musb->ep0_state = MGC_END0_STAGE_SETUP;
 		csr = musb_readw(regs, MUSB_CSR0);
@@ -639,7 +639,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 
 	case MGC_END0_STAGE_TX:
 		/* irq on clearing txpktrdy */
-		if ((csr & MGC_M_CSR0_TXPKTRDY) == 0) {
+		if ((csr & MUSB_CSR0_TXPKTRDY) == 0) {
 			ep0_txstate(musb);
 			retval = IRQ_HANDLED;
 		}
@@ -647,7 +647,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 
 	case MGC_END0_STAGE_RX:
 		/* irq on set rxpktrdy */
-		if (csr & MGC_M_CSR0_RXPKTRDY) {
+		if (csr & MUSB_CSR0_RXPKTRDY) {
 			ep0_rxstate(musb);
 			retval = IRQ_HANDLED;
 		}
@@ -670,7 +670,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 		else if (musb->test_mode) {
 			DBG(1, "entering TESTMODE\n");
 
-			if (MGC_M_TEST_PACKET == musb->test_mode_nr)
+			if (MUSB_TEST_PACKET == musb->test_mode_nr)
 				musb_load_testpacket(musb);
 
 			musb_writeb(mbase, MUSB_TESTMODE,
@@ -692,7 +692,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 		/* FALLTHROUGH */
 
 	case MGC_END0_STAGE_SETUP:
-		if (csr & MGC_M_CSR0_RXPKTRDY) {
+		if (csr & MUSB_CSR0_RXPKTRDY) {
 			struct usb_ctrlrequest	setup;
 			int			handled = 0;
 
@@ -711,7 +711,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 						"irq lost!\n",
 						musb_driver_name);
 				power = musb_readb(mbase, MUSB_POWER);
-				musb->g.speed = (power & MGC_M_POWER_HSMODE)
+				musb->g.speed = (power & MUSB_POWER_HSMODE)
 					? USB_SPEED_HIGH : USB_SPEED_FULL;
 
 			}
@@ -729,7 +729,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 
 				/* status stage might be immediate */
 				if (handled > 0) {
-					musb->ackpend |= MGC_M_CSR0_P_DATAEND;
+					musb->ackpend |= MUSB_CSR0_P_DATAEND;
 					musb->ep0_state =
 						MGC_END0_STAGE_STATUSIN;
 				}
@@ -742,8 +742,8 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 			case MGC_END0_STAGE_TX:
 				handled = service_in_request(musb, &setup);
 				if (handled > 0) {
-					musb->ackpend = MGC_M_CSR0_TXPKTRDY
-						| MGC_M_CSR0_P_DATAEND;
+					musb->ackpend = MUSB_CSR0_TXPKTRDY
+						| MUSB_CSR0_P_DATAEND;
 					musb->ep0_state =
 						MGC_END0_STAGE_STATUSOUT;
 				}
@@ -772,7 +772,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 				musb_ep_select(mbase, 0);
 stall:
 				DBG(3, "stall (%d)\n", handled);
-				musb->ackpend |= MGC_M_CSR0_P_SENDSTALL;
+				musb->ackpend |= MUSB_CSR0_P_SENDSTALL;
 				musb->ep0_state = MGC_END0_STAGE_SETUP;
 finish:
 				musb_writew(regs, MUSB_CSR0,
@@ -792,7 +792,7 @@ finish:
 	default:
 		/* "can't happen" */
 		WARN_ON(1);
-		musb_writew(regs, MUSB_CSR0, MGC_M_CSR0_P_SENDSTALL);
+		musb_writew(regs, MUSB_CSR0, MUSB_CSR0_P_SENDSTALL);
 		musb->ep0_state = MGC_END0_STAGE_SETUP;
 		break;
 	}
@@ -890,7 +890,7 @@ musb_g_ep0_queue(struct usb_ep *e, struc
 		else {
 			musb->ep0_state = MGC_END0_STAGE_STATUSIN;
 			musb_writew(regs, MUSB_CSR0,
-					musb->ackpend | MGC_M_CSR0_P_DATAEND);
+					musb->ackpend | MUSB_CSR0_P_DATAEND);
 			musb->ackpend = 0;
 			musb_g_ep0_giveback(ep->musb, r);
 		}
@@ -948,7 +948,7 @@ static int musb_g_ep0_halt(struct usb_ep
 
 		musb_ep_select(base, 0);
 		csr = musb_readw(regs, MUSB_CSR0);
-		csr |= MGC_M_CSR0_P_SENDSTALL;
+		csr |= MUSB_CSR0_P_SENDSTALL;
 		musb_writew(regs, MUSB_CSR0, csr);
 		musb->ep0_state = MGC_END0_STAGE_SETUP;
 		break;
Index: linux-2.6.18/drivers/usb/musb/musb_gadget.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_gadget.c
+++ linux-2.6.18/drivers/usb/musb/musb_gadget.c
@@ -168,14 +168,14 @@ static void nuke(struct musb_ep *ep, con
 		int value;
 		if (ep->is_in) {
 			musb_writew(epio, MUSB_TXCSR,
-					0 | MGC_M_TXCSR_FLUSHFIFO);
+					0 | MUSB_TXCSR_FLUSHFIFO);
 			musb_writew(epio, MUSB_TXCSR,
-					0 | MGC_M_TXCSR_FLUSHFIFO);
+					0 | MUSB_TXCSR_FLUSHFIFO);
 		} else {
 			musb_writew(epio, MUSB_RXCSR,
-					0 | MGC_M_RXCSR_FLUSHFIFO);
+					0 | MUSB_RXCSR_FLUSHFIFO);
 			musb_writew(epio, MUSB_RXCSR,
-					0 | MGC_M_RXCSR_FLUSHFIFO);
+					0 | MUSB_RXCSR_FLUSHFIFO);
 		}
 
 		value = c->channel_abort(ep->dma);
@@ -274,13 +274,13 @@ static void txstate(struct musb *musb, s
 	fifo_count = min(max_ep_writesize(musb, musb_ep),
 			(int)(request->length - request->actual));
 
-	if (csr & MGC_M_TXCSR_TXPKTRDY) {
+	if (csr & MUSB_TXCSR_TXPKTRDY) {
 		DBG(5, "%s old packet still ready , txcsr %03x\n",
 				musb_ep->end_point.name, csr);
 		return;
 	}
 
-	if (csr & MGC_M_TXCSR_P_SENDSTALL) {
+	if (csr & MUSB_TXCSR_P_SENDSTALL) {
 		DBG(5, "%s stalling, txcsr %03x\n",
 				musb_ep->end_point.name, csr);
 		return;
@@ -296,7 +296,7 @@ static void txstate(struct musb *musb, s
 
 		use_dma = (request->dma != DMA_ADDR_INVALID);
 
-		/* MGC_M_TXCSR_P_ISO is still set correctly */
+		/* MUSB_TXCSR_P_ISO is still set correctly */
 
 #ifdef CONFIG_USB_INVENTRA_DMA
 		{
@@ -317,32 +317,32 @@ static void txstate(struct musb *musb, s
 			if (use_dma) {
 				if (musb_ep->dma->desired_mode == 0) {
 					/* ASSERT: DMAENAB is clear */
-					csr &= ~(MGC_M_TXCSR_AUTOSET |
-							MGC_M_TXCSR_DMAMODE);
-					csr |= (MGC_M_TXCSR_DMAENAB |
-							MGC_M_TXCSR_MODE);
+					csr &= ~(MUSB_TXCSR_AUTOSET |
+							MUSB_TXCSR_DMAMODE);
+					csr |= (MUSB_TXCSR_DMAENAB |
+							MUSB_TXCSR_MODE);
 					// against programming guide
 				}
 				else
-					csr |= (MGC_M_TXCSR_AUTOSET
-							| MGC_M_TXCSR_DMAENAB
-							| MGC_M_TXCSR_DMAMODE
-							| MGC_M_TXCSR_MODE);
+					csr |= (MUSB_TXCSR_AUTOSET
+							| MUSB_TXCSR_DMAENAB
+							| MUSB_TXCSR_DMAMODE
+							| MUSB_TXCSR_MODE);
 
-				csr &= ~MGC_M_TXCSR_P_UNDERRUN;
+				csr &= ~MUSB_TXCSR_P_UNDERRUN;
 				musb_writew(epio, MUSB_TXCSR, csr);
 			}
 		}
 
 #elif defined(CONFIG_USB_TI_CPPI_DMA)
 		/* program endpoint CSR first, then setup DMA */
-		csr &= ~(MGC_M_TXCSR_AUTOSET
-				| MGC_M_TXCSR_DMAMODE
-				| MGC_M_TXCSR_P_UNDERRUN
-				| MGC_M_TXCSR_TXPKTRDY);
-		csr |= MGC_M_TXCSR_MODE | MGC_M_TXCSR_DMAENAB;
+		csr &= ~(MUSB_TXCSR_AUTOSET
+				| MUSB_TXCSR_DMAMODE
+				| MUSB_TXCSR_P_UNDERRUN
+				| MUSB_TXCSR_TXPKTRDY);
+		csr |= MUSB_TXCSR_MODE | MUSB_TXCSR_DMAENAB;
 		musb_writew(epio, MUSB_TXCSR,
-			(MGC_M_TXCSR_P_WZC_BITS & ~MGC_M_TXCSR_P_UNDERRUN)
+			(MUSB_TXCSR_P_WZC_BITS & ~MUSB_TXCSR_P_UNDERRUN)
 				| csr);
 
 		/* ensure writebuffer is empty */
@@ -367,7 +367,7 @@ static void txstate(struct musb *musb, s
 			c->channel_release(musb_ep->dma);
 			musb_ep->dma = NULL;
 			/* ASSERT: DMAENAB clear */
-			csr &= ~(MGC_M_TXCSR_DMAMODE | MGC_M_TXCSR_MODE);
+			csr &= ~(MUSB_TXCSR_DMAMODE | MUSB_TXCSR_MODE);
 			/* invariant: prequest->buf is non-null */
 		}
 #elif defined(CONFIG_USB_TUSB_OMAP_DMA)
@@ -384,8 +384,8 @@ static void txstate(struct musb *musb, s
 		musb_write_fifo(musb_ep->hw_ep, fifo_count,
 				(u8 *) (request->buf + request->actual));
 		request->actual += fifo_count;
-		csr |= MGC_M_TXCSR_TXPKTRDY;
-		csr &= ~MGC_M_TXCSR_P_UNDERRUN;
+		csr |= MUSB_TXCSR_TXPKTRDY;
+		csr &= ~MUSB_TXCSR_P_UNDERRUN;
 		musb_writew(epio, MUSB_TXCSR, csr);
 	}
 
@@ -419,12 +419,12 @@ void musb_g_tx(struct musb *musb, u8 epn
 
 	dma = is_dma_capable() ? musb_ep->dma : NULL;
 	do {
-		/* REVISIT for high bandwidth, MGC_M_TXCSR_P_INCOMPTX
+		/* REVISIT for high bandwidth, MUSB_TXCSR_P_INCOMPTX
 		 * probably rates reporting as a host error
 		 */
-		if (csr & MGC_M_TXCSR_P_SENTSTALL) {
-			csr |= MGC_M_TXCSR_P_WZC_BITS;
-			csr &= ~MGC_M_TXCSR_P_SENTSTALL;
+		if (csr & MUSB_TXCSR_P_SENTSTALL) {
+			csr |= MUSB_TXCSR_P_WZC_BITS;
+			csr &= ~MUSB_TXCSR_P_SENTSTALL;
 			musb_writew(epio, MUSB_TXCSR, csr);
 			if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
 				dma->status = MGC_DMA_STATUS_CORE_ABORT;
@@ -437,11 +437,11 @@ void musb_g_tx(struct musb *musb, u8 epn
 			break;
 		}
 
-		if (csr & MGC_M_TXCSR_P_UNDERRUN) {
+		if (csr & MUSB_TXCSR_P_UNDERRUN) {
 			/* we NAKed, no big deal ... little reason to care */
-			csr |= MGC_M_TXCSR_P_WZC_BITS;
-			csr &= ~(MGC_M_TXCSR_P_UNDERRUN
-					| MGC_M_TXCSR_TXPKTRDY);
+			csr |= MUSB_TXCSR_P_WZC_BITS;
+			csr &= ~(MUSB_TXCSR_P_UNDERRUN
+					| MUSB_TXCSR_TXPKTRDY);
 			musb_writew(epio, MUSB_TXCSR, csr);
 			DBG(20, "underrun on ep%d, req %p\n", epnum, request);
 		}
@@ -457,12 +457,12 @@ void musb_g_tx(struct musb *musb, u8 epn
 		if (request) {
 			u8	is_dma = 0;
 
-			if (dma && (csr & MGC_M_TXCSR_DMAENAB)) {
+			if (dma && (csr & MUSB_TXCSR_DMAENAB)) {
 				is_dma = 1;
-				csr |= MGC_M_TXCSR_P_WZC_BITS;
-				csr &= ~(MGC_M_TXCSR_DMAENAB
-						| MGC_M_TXCSR_P_UNDERRUN
-						| MGC_M_TXCSR_TXPKTRDY);
+				csr |= MUSB_TXCSR_P_WZC_BITS;
+				csr &= ~(MUSB_TXCSR_DMAENAB
+						| MUSB_TXCSR_P_UNDERRUN
+						| MUSB_TXCSR_TXPKTRDY);
 				musb_writew(epio, MUSB_TXCSR, csr);
 				/* ensure writebuffer is empty */
 				csr = musb_readw(epio, MUSB_TXCSR);
@@ -495,13 +495,13 @@ void musb_g_tx(struct musb *musb, u8 epn
 					/* on dma completion, fifo may not
 					 * be available yet ...
 					 */
-					if (csr & MGC_M_TXCSR_TXPKTRDY)
+					if (csr & MUSB_TXCSR_TXPKTRDY)
 						break;
 
 					DBG(4, "sending zero pkt\n");
 					musb_writew(epio, MUSB_TXCSR,
-							MGC_M_TXCSR_MODE
-							| MGC_M_TXCSR_TXPKTRDY);
+							MUSB_TXCSR_MODE
+							| MUSB_TXCSR_TXPKTRDY);
 					request->zero = 0;
 				}
 
@@ -516,7 +516,7 @@ void musb_g_tx(struct musb *musb, u8 epn
 				 */
 				musb_ep_select(mbase, epnum);
 				csr = musb_readw(epio, MUSB_TXCSR);
-				if (csr & MGC_M_TXCSR_FIFONOTEMPTY)
+				if (csr & MUSB_TXCSR_FIFONOTEMPTY)
 					break;
 				request = musb_ep->desc
 						? next_request(musb_ep)
@@ -601,15 +601,15 @@ static void rxstate(struct musb *musb, s
 			 * the cppi engine will be ready to take it as soon
 			 * as DMA is enabled
 			 */
-			csr &= ~(MGC_M_RXCSR_AUTOCLEAR
-					| MGC_M_RXCSR_DMAMODE);
-			csr |= MGC_M_RXCSR_DMAENAB | MGC_M_RXCSR_P_WZC_BITS;
+			csr &= ~(MUSB_RXCSR_AUTOCLEAR
+					| MUSB_RXCSR_DMAMODE);
+			csr |= MUSB_RXCSR_DMAENAB | MUSB_RXCSR_P_WZC_BITS;
 			musb_writew(epio, MUSB_RXCSR, csr);
 			return;
 		}
 	}
 
-	if (csr & MGC_M_RXCSR_RXPKTRDY) {
+	if (csr & MUSB_RXCSR_RXPKTRDY) {
 		len = musb_readw(epio, MUSB_RXCOUNT);
 		if (request->actual < request->length) {
 #ifdef CONFIG_USB_INVENTRA_DMA
@@ -642,17 +642,17 @@ static void rxstate(struct musb *musb, s
 	 * then becomes usable as a runtime "use mode 1" hint...
 	 */
 
-				csr |= MGC_M_RXCSR_DMAENAB;
+				csr |= MUSB_RXCSR_DMAENAB;
 #ifdef USE_MODE1
-				csr |= MGC_M_RXCSR_AUTOCLEAR;
-//				csr |= MGC_M_RXCSR_DMAMODE;
+				csr |= MUSB_RXCSR_AUTOCLEAR;
+//				csr |= MUSB_RXCSR_DMAMODE;
 
 				/* this special sequence (enabling and then
-				   disabling MGC_M_RXCSR_DMAMODE) is required
+				   disabling MUSB_RXCSR_DMAMODE) is required
 				   to get DMAReq to activate
 				 */
 				musb_writew(epio, MUSB_RXCSR,
-					csr | MGC_M_RXCSR_DMAMODE);
+					csr | MUSB_RXCSR_DMAMODE);
 #endif
 				musb_writew(epio, MUSB_RXCSR,
 						csr);
@@ -718,8 +718,8 @@ static void rxstate(struct musb *musb, s
 			 */
 
 			/* ack the read! */
-			csr |= MGC_M_RXCSR_P_WZC_BITS;
-			csr &= ~MGC_M_RXCSR_RXPKTRDY;
+			csr |= MUSB_RXCSR_P_WZC_BITS;
+			csr &= ~MUSB_RXCSR_RXPKTRDY;
 			musb_writew(epio, MUSB_RXCSR, csr);
 		}
 	}
@@ -751,15 +751,15 @@ void musb_g_rx(struct musb *musb, u8 epn
 	DBG(4, "<== %s, rxcsr %04x%s %p\n", musb_ep->end_point.name,
 			csr, dma ? " (dma)" : "", request);
 
-	if (csr & MGC_M_RXCSR_P_SENTSTALL) {
+	if (csr & MUSB_RXCSR_P_SENTSTALL) {
 		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
 			dma->status = MGC_DMA_STATUS_CORE_ABORT;
 			(void) musb->dma_controller->channel_abort(dma);
 			request->actual += musb_ep->dma->actual_len;
 		}
 
-		csr |= MGC_M_RXCSR_P_WZC_BITS;
-		csr &= ~MGC_M_RXCSR_P_SENTSTALL;
+		csr |= MUSB_RXCSR_P_WZC_BITS;
+		csr &= ~MUSB_RXCSR_P_SENTSTALL;
 		musb_writew(epio, MUSB_RXCSR, csr);
 
 		if (request)
@@ -767,34 +767,34 @@ void musb_g_rx(struct musb *musb, u8 epn
 		goto done;
 	}
 
-	if (csr & MGC_M_RXCSR_P_OVERRUN) {
-		// csr |= MGC_M_RXCSR_P_WZC_BITS;
-		csr &= ~MGC_M_RXCSR_P_OVERRUN;
+	if (csr & MUSB_RXCSR_P_OVERRUN) {
+		// csr |= MUSB_RXCSR_P_WZC_BITS;
+		csr &= ~MUSB_RXCSR_P_OVERRUN;
 		musb_writew(epio, MUSB_RXCSR, csr);
 
 		DBG(3, "%s iso overrun on %p\n", musb_ep->name, request);
 		if (request && request->status == -EINPROGRESS)
 			request->status = -EOVERFLOW;
 	}
-	if (csr & MGC_M_RXCSR_INCOMPRX) {
+	if (csr & MUSB_RXCSR_INCOMPRX) {
 		/* REVISIT not necessarily an error */
 		DBG(4, "%s, incomprx\n", musb_ep->end_point.name);
 	}
 
 	if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
 		/* "should not happen"; likely RXPKTRDY pending for DMA */
-		DBG((csr & MGC_M_RXCSR_DMAENAB) ? 4 : 1,
+		DBG((csr & MUSB_RXCSR_DMAENAB) ? 4 : 1,
 			"%s busy, csr %04x\n",
 			musb_ep->end_point.name, csr);
 		goto done;
 	}
 
-	if (dma && (csr & MGC_M_RXCSR_DMAENAB)) {
-		csr &= ~(MGC_M_RXCSR_AUTOCLEAR
-				| MGC_M_RXCSR_DMAENAB
-				| MGC_M_RXCSR_DMAMODE);
+	if (dma && (csr & MUSB_RXCSR_DMAENAB)) {
+		csr &= ~(MUSB_RXCSR_AUTOCLEAR
+				| MUSB_RXCSR_DMAENAB
+				| MUSB_RXCSR_DMAMODE);
 		musb_writew(epio, MUSB_RXCSR,
-			MGC_M_RXCSR_P_WZC_BITS | csr);
+			MUSB_RXCSR_P_WZC_BITS | csr);
 
 		request->actual += musb_ep->dma->actual_len;
 
@@ -809,7 +809,7 @@ void musb_g_rx(struct musb *musb, u8 epn
 				|| (dma->actual_len
 					& (musb_ep->packet_sz - 1))) {
 			/* ack the read! */
-			csr &= ~MGC_M_RXCSR_RXPKTRDY;
+			csr &= ~MUSB_RXCSR_RXPKTRDY;
 			musb_writew(epio, MUSB_RXCSR, csr);
 		}
 
@@ -828,7 +828,7 @@ void musb_g_rx(struct musb *musb, u8 epn
 		/* don't start more i/o till the stall clears */
 		musb_ep_select(mbase, epnum);
 		csr = musb_readw(epio, MUSB_RXCSR);
-		if (csr & MGC_M_RXCSR_P_SENDSTALL)
+		if (csr & MUSB_RXCSR_P_SENDSTALL)
 			goto done;
 	}
 
@@ -911,12 +911,12 @@ static int musb_gadget_enable(struct usb
 		 */
 		musb_writew(regs, MUSB_TXMAXP, tmp);
 
-		csr = MGC_M_TXCSR_MODE | MGC_M_TXCSR_CLRDATATOG;
+		csr = MUSB_TXCSR_MODE | MUSB_TXCSR_CLRDATATOG;
 		if (musb_readw(regs, MUSB_TXCSR)
-				& MGC_M_TXCSR_FIFONOTEMPTY)
-			csr |= MGC_M_TXCSR_FLUSHFIFO;
+				& MUSB_TXCSR_FIFONOTEMPTY)
+			csr |= MUSB_TXCSR_FLUSHFIFO;
 		if (musb_ep->type == USB_ENDPOINT_XFER_ISOC)
-			csr |= MGC_M_TXCSR_P_ISO;
+			csr |= MUSB_TXCSR_P_ISO;
 
 		/* set twice in case of double buffering */
 		musb_writew(regs, MUSB_TXCSR, csr);
@@ -944,15 +944,15 @@ static int musb_gadget_enable(struct usb
 		/* force shared fifo to OUT-only mode */
 		if (hw_ep->is_shared_fifo) {
 			csr = musb_readw(regs, MUSB_TXCSR);
-			csr &= ~(MGC_M_TXCSR_MODE | MGC_M_TXCSR_TXPKTRDY);
+			csr &= ~(MUSB_TXCSR_MODE | MUSB_TXCSR_TXPKTRDY);
 			musb_writew(regs, MUSB_TXCSR, csr);
 		}
 
-		csr = MGC_M_RXCSR_FLUSHFIFO | MGC_M_RXCSR_CLRDATATOG;
+		csr = MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_CLRDATATOG;
 		if (musb_ep->type == USB_ENDPOINT_XFER_ISOC)
-			csr |= MGC_M_RXCSR_P_ISO;
+			csr |= MUSB_RXCSR_P_ISO;
 		else if (musb_ep->type == USB_ENDPOINT_XFER_INT)
-			csr |= MGC_M_RXCSR_DISNYET;
+			csr |= MUSB_RXCSR_DISNYET;
 
 		/* set twice in case of double buffering */
 		musb_writew(regs, MUSB_RXCSR, csr);
@@ -1308,7 +1308,7 @@ int musb_gadget_set_halt(struct usb_ep *
 	request = to_musb_request(next_request(musb_ep));
 	if (value && musb_ep->is_in) {
 		wCsr = musb_readw(epio, MUSB_TXCSR);
-		if (wCsr & MGC_M_TXCSR_FIFONOTEMPTY) {
+		if (wCsr & MUSB_TXCSR_FIFONOTEMPTY) {
 			DBG(3, "%s fifo busy, cannot halt\n", ep->name);
 			spin_unlock_irqrestore(&musb->lock, flags);
 			return -EAGAIN;
@@ -1320,27 +1320,27 @@ int musb_gadget_set_halt(struct usb_ep *
 	DBG(2, "%s: %s stall\n", ep->name, value ? "set" : "clear");
 	if (musb_ep->is_in) {
 		wCsr = musb_readw(epio, MUSB_TXCSR);
-		if (wCsr & MGC_M_TXCSR_FIFONOTEMPTY)
-			wCsr |= MGC_M_TXCSR_FLUSHFIFO;
-		wCsr |= MGC_M_TXCSR_P_WZC_BITS
-			| MGC_M_TXCSR_CLRDATATOG;
+		if (wCsr & MUSB_TXCSR_FIFONOTEMPTY)
+			wCsr |= MUSB_TXCSR_FLUSHFIFO;
+		wCsr |= MUSB_TXCSR_P_WZC_BITS
+			| MUSB_TXCSR_CLRDATATOG;
 		if (value)
-			wCsr |= MGC_M_TXCSR_P_SENDSTALL;
+			wCsr |= MUSB_TXCSR_P_SENDSTALL;
 		else
-			wCsr &= ~(MGC_M_TXCSR_P_SENDSTALL
-				| MGC_M_TXCSR_P_SENTSTALL);
-		wCsr &= ~MGC_M_TXCSR_TXPKTRDY;
+			wCsr &= ~(MUSB_TXCSR_P_SENDSTALL
+				| MUSB_TXCSR_P_SENTSTALL);
+		wCsr &= ~MUSB_TXCSR_TXPKTRDY;
 		musb_writew(epio, MUSB_TXCSR, wCsr);
 	} else {
 		wCsr = musb_readw(epio, MUSB_RXCSR);
-		wCsr |= MGC_M_RXCSR_P_WZC_BITS
-			| MGC_M_RXCSR_FLUSHFIFO
-			| MGC_M_RXCSR_CLRDATATOG;
+		wCsr |= MUSB_RXCSR_P_WZC_BITS
+			| MUSB_RXCSR_FLUSHFIFO
+			| MUSB_RXCSR_CLRDATATOG;
 		if (value)
-			wCsr |= MGC_M_RXCSR_P_SENDSTALL;
+			wCsr |= MUSB_RXCSR_P_SENDSTALL;
 		else
-			wCsr &= ~(MGC_M_RXCSR_P_SENDSTALL
-				| MGC_M_RXCSR_P_SENTSTALL);
+			wCsr &= ~(MUSB_RXCSR_P_SENDSTALL
+				| MUSB_RXCSR_P_SENTSTALL);
 		musb_writew(epio, MUSB_RXCSR, wCsr);
 	}
 
@@ -1400,15 +1400,15 @@ static void musb_gadget_fifo_flush(struc
 
 	if (musb_ep->is_in) {
 		wCsr = musb_readw(epio, MUSB_TXCSR);
-		if (wCsr & MGC_M_TXCSR_FIFONOTEMPTY) {
-			wCsr |= MGC_M_TXCSR_FLUSHFIFO | MGC_M_TXCSR_P_WZC_BITS;
+		if (wCsr & MUSB_TXCSR_FIFONOTEMPTY) {
+			wCsr |= MUSB_TXCSR_FLUSHFIFO | MUSB_TXCSR_P_WZC_BITS;
 			musb_writew(epio, MUSB_TXCSR, wCsr);
 			/* REVISIT may be inappropriate w/o FIFONOTEMPTY ... */
 			musb_writew(epio, MUSB_TXCSR, wCsr);
 		}
 	} else {
 		wCsr = musb_readw(epio, MUSB_RXCSR);
-		wCsr |= MGC_M_RXCSR_FLUSHFIFO | MGC_M_RXCSR_P_WZC_BITS;
+		wCsr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_P_WZC_BITS;
 		musb_writew(epio, MUSB_RXCSR, wCsr);
 		musb_writew(epio, MUSB_RXCSR, wCsr);
 	}
@@ -1465,17 +1465,17 @@ static int musb_gadget_wakeup(struct usb
 		/* Start SRP ... OTG not required. */
 		devctl = musb_readb(mregs, MUSB_DEVCTL);
 		DBG(2, "Sending SRP: devctl: %02x\n", devctl);
-		devctl |= MGC_M_DEVCTL_SESSION;
+		devctl |= MUSB_DEVCTL_SESSION;
 		musb_writeb(mregs, MUSB_DEVCTL, devctl);
 		devctl = musb_readb(mregs, MUSB_DEVCTL);
 		retries = 100;
-		while (!(devctl & MGC_M_DEVCTL_SESSION)) {
+		while (!(devctl & MUSB_DEVCTL_SESSION)) {
 			devctl = musb_readb(mregs, MUSB_DEVCTL);
 			if (retries-- < 1)
 				break;
 		}
 		retries = 10000;
-		while (devctl & MGC_M_DEVCTL_SESSION) {
+		while (devctl & MUSB_DEVCTL_SESSION) {
 			devctl = musb_readb(mregs, MUSB_DEVCTL);
 			if (retries-- < 1)
 				break;
@@ -1494,7 +1494,7 @@ static int musb_gadget_wakeup(struct usb
 	status = 0;
 
 	power = musb_readb(mregs, MUSB_POWER);
-	power |= MGC_M_POWER_RESUME;
+	power |= MUSB_POWER_RESUME;
 	musb_writeb(mregs, MUSB_POWER, power);
 	DBG(2, "issue wakeup\n");
 
@@ -1502,7 +1502,7 @@ static int musb_gadget_wakeup(struct usb
 	mdelay(2);
 
 	power = musb_readb(mregs, MUSB_POWER);
-	power &= ~MGC_M_POWER_RESUME;
+	power &= ~MUSB_POWER_RESUME;
 	musb_writeb(mregs, MUSB_POWER, power);
 done:
 	spin_unlock_irqrestore(&musb->lock, flags);
@@ -1524,9 +1524,9 @@ static void musb_pullup(struct musb *mus
 
 	power = musb_readb(musb->mregs, MUSB_POWER);
 	if (is_on)
-		power |= MGC_M_POWER_SOFTCONN;
+		power |= MUSB_POWER_SOFTCONN;
 	else
-		power &= ~MGC_M_POWER_SOFTCONN;
+		power &= ~MUSB_POWER_SOFTCONN;
 
 	/* FIXME if on, HdrcStart; if off, HdrcStop */
 
@@ -1965,7 +1965,7 @@ void musb_g_suspend(struct musb *musb)
 
 	switch (musb->xceiv.state) {
 	case OTG_STATE_B_IDLE:
-		if ((devctl & MGC_M_DEVCTL_VBUS) == MGC_M_DEVCTL_VBUS)
+		if ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS)
 			musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
 		break;
 	case OTG_STATE_B_PERIPHERAL:
@@ -2000,7 +2000,7 @@ void musb_g_disconnect(struct musb *musb
 	DBG(3, "devctl %02x\n", devctl);
 
 	/* clear HR */
-	musb_writeb(mregs, MUSB_DEVCTL, devctl & MGC_M_DEVCTL_SESSION);
+	musb_writeb(mregs, MUSB_DEVCTL, devctl & MUSB_DEVCTL_SESSION);
 
 	/* don't draw vbus until new b-default session */
 	(void) musb_gadget_vbus_draw(&musb->g, 0);
@@ -2042,7 +2042,7 @@ __acquires(musb->lock)
 	u8		power;
 
 	DBG(3, "<== %s addr=%x driver '%s'\n",
-			(devctl & MGC_M_DEVCTL_BDEVICE)
+			(devctl & MUSB_DEVCTL_BDEVICE)
 				? "B-Device" : "A-Device",
 			musb_readb(mbase, MUSB_FADDR),
 			musb->gadget_driver
@@ -2055,13 +2055,13 @@ __acquires(musb->lock)
 		musb_g_disconnect(musb);
 
 	/* clear HR */
-	else if (devctl & MGC_M_DEVCTL_HR)
-		musb_writeb(mbase, MUSB_DEVCTL, MGC_M_DEVCTL_SESSION);
+	else if (devctl & MUSB_DEVCTL_HR)
+		musb_writeb(mbase, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);
 
 
 	/* what speed did we negotiate? */
 	power = musb_readb(mbase, MUSB_POWER);
-	musb->g.speed = (power & MGC_M_POWER_HSMODE)
+	musb->g.speed = (power & MUSB_POWER_HSMODE)
 			? USB_SPEED_HIGH : USB_SPEED_FULL;
 
 	/* start in USB_STATE_DEFAULT */
@@ -2079,7 +2079,7 @@ __acquires(musb->lock)
 	/* Normal reset, as B-Device;
 	 * or else after HNP, as A-Device
 	 */
-	if (devctl & MGC_M_DEVCTL_BDEVICE) {
+	if (devctl & MUSB_DEVCTL_BDEVICE) {
 		musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
 		musb->g.is_a_peripheral = 0;
 	} else if (is_otg_enabled(musb)) {
Index: linux-2.6.18/drivers/usb/musb/musb_host.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_host.c
+++ linux-2.6.18/drivers/usb/musb/musb_host.c
@@ -117,9 +117,9 @@ static inline void musb_h_tx_flush_fifo(
 	int		retries = 1000;
 
 	csr = musb_readw(epio, MUSB_TXCSR);
-	while (csr & MGC_M_TXCSR_FIFONOTEMPTY) {
+	while (csr & MUSB_TXCSR_FIFONOTEMPTY) {
 		DBG(5, "Host TX FIFONOTEMPTY csr: %02x\n", csr);
-		csr |= MGC_M_TXCSR_FLUSHFIFO;
+		csr |= MUSB_TXCSR_FLUSHFIFO;
 		musb_writew(epio, MUSB_TXCSR, csr);
 		csr = musb_readw(epio, MUSB_TXCSR);
 		if (retries-- < 1) {
@@ -141,10 +141,10 @@ static inline void musb_h_tx_start(struc
 	/* NOTE: no locks here; caller should lock and select EP */
 	if (ep->epnum) {
 		txcsr = musb_readw(ep->regs, MUSB_TXCSR);
-		txcsr |= MGC_M_TXCSR_TXPKTRDY | MGC_M_TXCSR_H_WZC_BITS;
+		txcsr |= MUSB_TXCSR_TXPKTRDY | MUSB_TXCSR_H_WZC_BITS;
 		musb_writew(ep->regs, MUSB_TXCSR, txcsr);
 	} else {
-		txcsr = MGC_M_CSR0_H_SETUPPKT | MGC_M_CSR0_TXPKTRDY;
+		txcsr = MUSB_CSR0_H_SETUPPKT | MUSB_CSR0_TXPKTRDY;
 		musb_writew(ep->regs, MUSB_CSR0, txcsr);
 	}
 
@@ -156,7 +156,7 @@ static inline void cppi_host_txdma_start
 
 	/* NOTE: no locks here; caller should lock and select EP */
 	txcsr = musb_readw(ep->regs, MUSB_TXCSR);
-	txcsr |= MGC_M_TXCSR_DMAENAB | MGC_M_TXCSR_H_WZC_BITS;
+	txcsr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_H_WZC_BITS;
 	musb_writew(ep->regs, MUSB_TXCSR, txcsr);
 }
 
@@ -330,12 +330,12 @@ static inline void musb_save_toggle(stru
 	if (!is_in) {
 		csr = musb_readw(epio, MUSB_TXCSR);
 		usb_settoggle(udev, qh->epnum, 1,
-			(csr & MGC_M_TXCSR_H_DATATOGGLE)
+			(csr & MUSB_TXCSR_H_DATATOGGLE)
 				? 1 : 0);
 	} else {
 		csr = musb_readw(epio, MUSB_RXCSR);
 		usb_settoggle(udev, qh->epnum, 0,
-			(csr & MGC_M_RXCSR_H_DATATOGGLE)
+			(csr & MUSB_RXCSR_H_DATATOGGLE)
 				? 1 : 0);
 	}
 }
@@ -449,10 +449,10 @@ static inline u16 musb_h_flush_rxfifo(st
 	 * ignore dma (various models),
 	 * leave toggle alone (may not have been saved yet)
 	 */
-	csr |= MGC_M_RXCSR_FLUSHFIFO | MGC_M_RXCSR_RXPKTRDY;
-	csr &= ~( MGC_M_RXCSR_H_REQPKT
-		| MGC_M_RXCSR_H_AUTOREQ
-		| MGC_M_RXCSR_AUTOCLEAR
+	csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_RXPKTRDY;
+	csr &= ~( MUSB_RXCSR_H_REQPKT
+		| MUSB_RXCSR_H_AUTOREQ
+		| MUSB_RXCSR_AUTOCLEAR
 		);
 
 	/* write 2x to allow double buffering */
@@ -545,14 +545,14 @@ static u8 musb_host_packet_rx(struct mus
 	musb_read_fifo(hw_ep, length, pBuffer);
 
 	wCsr = musb_readw(epio, MUSB_RXCSR);
-	wCsr |= MGC_M_RXCSR_H_WZC_BITS;
+	wCsr |= MUSB_RXCSR_H_WZC_BITS;
 	if (unlikely(do_flush))
 		musb_h_flush_rxfifo(hw_ep, wCsr);
 	else {
 		/* REVISIT this assumes AUTOCLEAR is never set */
-		wCsr &= ~(MGC_M_RXCSR_RXPKTRDY | MGC_M_RXCSR_H_REQPKT);
+		wCsr &= ~(MUSB_RXCSR_RXPKTRDY | MUSB_RXCSR_H_REQPKT);
 		if (!bDone)
-			wCsr |= MGC_M_RXCSR_H_REQPKT;
+			wCsr |= MUSB_RXCSR_H_REQPKT;
 		musb_writew(epio, MUSB_RXCSR, wCsr);
 	}
 
@@ -580,10 +580,10 @@ musb_rx_reinit(struct musb *musb, struct
 	/* if programmed for Tx, put it in RX mode */
 	if (ep->is_shared_fifo) {
 		csr = musb_readw(ep->regs, MUSB_TXCSR);
-		if (csr & MGC_M_TXCSR_MODE) {
+		if (csr & MUSB_TXCSR_MODE) {
 			musb_h_tx_flush_fifo(ep);
 			musb_writew(ep->regs, MUSB_TXCSR,
-					MGC_M_TXCSR_FRCDATATOG);
+					MUSB_TXCSR_FRCDATATOG);
 		}
 		/* clear mode (and everything else) to enable Rx */
 		musb_writew(ep->regs, MUSB_TXCSR, 0);
@@ -591,11 +591,11 @@ musb_rx_reinit(struct musb *musb, struct
 	/* scrub all previous state, clearing toggle */
 	} else {
 		csr = musb_readw(ep->regs, MUSB_RXCSR);
-		if (csr & MGC_M_RXCSR_RXPKTRDY)
+		if (csr & MUSB_RXCSR_RXPKTRDY)
 			WARN("rx%d, packet/%d ready?\n", ep->epnum,
 				musb_readw(ep->regs, MUSB_RXCOUNT));
 
-		musb_h_flush_rxfifo(ep, MGC_M_RXCSR_CLRDATATOG);
+		musb_h_flush_rxfifo(ep, MUSB_RXCSR_CLRDATATOG);
 	}
 
 	/* target addr and (for multipoint) hub addr/port */
@@ -690,21 +690,21 @@ static void musb_ep_program(struct musb 
 
 			/* flush all old state, set default */
 			musb_h_tx_flush_fifo(hw_ep);
-			csr &= ~(MGC_M_TXCSR_H_NAKTIMEOUT
-					| MGC_M_TXCSR_DMAMODE
-					| MGC_M_TXCSR_FRCDATATOG
-					| MGC_M_TXCSR_H_RXSTALL
-					| MGC_M_TXCSR_H_ERROR
-					| MGC_M_TXCSR_TXPKTRDY
+			csr &= ~(MUSB_TXCSR_H_NAKTIMEOUT
+					| MUSB_TXCSR_DMAMODE
+					| MUSB_TXCSR_FRCDATATOG
+					| MUSB_TXCSR_H_RXSTALL
+					| MUSB_TXCSR_H_ERROR
+					| MUSB_TXCSR_TXPKTRDY
 					);
-			csr |= MGC_M_TXCSR_MODE;
+			csr |= MUSB_TXCSR_MODE;
 
 			if (usb_gettoggle(pUrb->dev,
 					qh->epnum, 1))
-				csr |= MGC_M_TXCSR_H_WR_DATATOGGLE
-					| MGC_M_TXCSR_H_DATATOGGLE;
+				csr |= MUSB_TXCSR_H_WR_DATATOGGLE
+					| MUSB_TXCSR_H_DATATOGGLE;
 			else
-				csr |= MGC_M_TXCSR_CLRDATATOG;
+				csr |= MUSB_TXCSR_CLRDATATOG;
 
 			/* twice in case of double packet buffering */
 			musb_writew(epio, MUSB_TXCSR, csr);
@@ -714,9 +714,9 @@ static void musb_ep_program(struct musb 
 		} else {
 			/* endpoint 0: just flush */
 			musb_writew(epio, MUSB_CSR0,
-				wCsr | MGC_M_CSR0_FLUSHFIFO);
+				wCsr | MUSB_CSR0_FLUSHFIFO);
 			musb_writew(epio, MUSB_CSR0,
-				wCsr | MGC_M_CSR0_FLUSHFIFO);
+				wCsr | MUSB_CSR0_FLUSHFIFO);
 		}
 
 		/* target addr and (for multipoint) hub addr/port */
@@ -764,12 +764,12 @@ static void musb_ep_program(struct musb 
 
 			/* clear previous state */
 			wCsr = musb_readw(epio, MUSB_TXCSR);
-			wCsr &= ~(MGC_M_TXCSR_AUTOSET
-				| MGC_M_TXCSR_DMAMODE
-				| MGC_M_TXCSR_DMAENAB);
-                        wCsr |= MGC_M_TXCSR_MODE;
+			wCsr &= ~(MUSB_TXCSR_AUTOSET
+				| MUSB_TXCSR_DMAMODE
+				| MUSB_TXCSR_DMAENAB);
+                        wCsr |= MUSB_TXCSR_MODE;
 			musb_writew(epio, MUSB_TXCSR,
-				wCsr | MGC_M_TXCSR_MODE);
+				wCsr | MUSB_TXCSR_MODE);
 
 			qh->segsize = min(dwLength, pDmaChannel->max_len);
 
@@ -780,14 +780,14 @@ static void musb_ep_program(struct musb 
 
 
 			if (pDmaChannel->desired_mode == 0) {
-				wCsr &= ~(MGC_M_TXCSR_AUTOSET
-					| MGC_M_TXCSR_DMAMODE);
-				wCsr |= (MGC_M_TXCSR_DMAENAB);
+				wCsr &= ~(MUSB_TXCSR_AUTOSET
+					| MUSB_TXCSR_DMAMODE);
+				wCsr |= (MUSB_TXCSR_DMAENAB);
 					// against programming guide
 			} else
-				wCsr |= (MGC_M_TXCSR_AUTOSET
-					| MGC_M_TXCSR_DMAENAB
-					| MGC_M_TXCSR_DMAMODE);
+				wCsr |= (MUSB_TXCSR_AUTOSET
+					| MUSB_TXCSR_DMAENAB
+					| MUSB_TXCSR_DMAMODE);
 
 			musb_writew(epio, MUSB_TXCSR, wCsr);
 
@@ -817,12 +817,12 @@ static void musb_ep_program(struct musb 
 			 * defer enabling dma.
 			 */
 			wCsr = musb_readw(epio, MUSB_TXCSR);
-			wCsr &= ~(MGC_M_TXCSR_AUTOSET
-					| MGC_M_TXCSR_DMAMODE
-					| MGC_M_TXCSR_DMAENAB);
-			wCsr |= MGC_M_TXCSR_MODE;
+			wCsr &= ~(MUSB_TXCSR_AUTOSET
+					| MUSB_TXCSR_DMAMODE
+					| MUSB_TXCSR_DMAENAB);
+			wCsr |= MUSB_TXCSR_MODE;
 			musb_writew(epio, MUSB_TXCSR,
-				wCsr | MGC_M_TXCSR_MODE);
+				wCsr | MUSB_TXCSR_MODE);
 
 			pDmaChannel->actual_len = 0L;
 			qh->segsize = dwLength;
@@ -857,11 +857,11 @@ static void musb_ep_program(struct musb 
 			qh->segsize = wLoadCount;
 			musb_write_fifo(hw_ep, wLoadCount, pBuffer);
 			wCsr = musb_readw(epio, MUSB_TXCSR);
-			wCsr &= ~(MGC_M_TXCSR_DMAENAB
-				| MGC_M_TXCSR_DMAMODE
-				| MGC_M_TXCSR_AUTOSET);
+			wCsr &= ~(MUSB_TXCSR_DMAENAB
+				| MUSB_TXCSR_DMAMODE
+				| MUSB_TXCSR_AUTOSET);
 			/* write CSR */
-			wCsr |= MGC_M_TXCSR_MODE;
+			wCsr |= MUSB_TXCSR_MODE;
 
 			if (epnum)
 				musb_writew(epio, MUSB_TXCSR, wCsr);
@@ -879,24 +879,24 @@ static void musb_ep_program(struct musb 
 
 			/* init new state: toggle and NYET, maybe DMA later */
 			if (usb_gettoggle(pUrb->dev, qh->epnum, 0))
-				csr = MGC_M_RXCSR_H_WR_DATATOGGLE
-					| MGC_M_RXCSR_H_DATATOGGLE;
+				csr = MUSB_RXCSR_H_WR_DATATOGGLE
+					| MUSB_RXCSR_H_DATATOGGLE;
 			else
 				csr = 0;
 			if (qh->type == USB_ENDPOINT_XFER_INT)
-				csr |= MGC_M_RXCSR_DISNYET;
+				csr |= MUSB_RXCSR_DISNYET;
 
 		} else {
 			csr = musb_readw(hw_ep->regs, MUSB_RXCSR);
 
-			if (csr & (MGC_M_RXCSR_RXPKTRDY
-					| MGC_M_RXCSR_DMAENAB
-					| MGC_M_RXCSR_H_REQPKT))
+			if (csr & (MUSB_RXCSR_RXPKTRDY
+					| MUSB_RXCSR_DMAENAB
+					| MUSB_RXCSR_H_REQPKT))
 				ERR("broken !rx_reinit, ep%d csr %04x\n",
 						hw_ep->epnum, csr);
 
 			/* scrub any stale state, leaving toggle alone */
-			csr &= MGC_M_RXCSR_DISNYET;
+			csr &= MUSB_RXCSR_DISNYET;
 		}
 
 		/* kick things off */
@@ -926,11 +926,11 @@ static void musb_ep_program(struct musb 
 							pDmaChannel);
 					pDmaChannel = hw_ep->rx_channel = NULL;
 				} else
-					csr |= MGC_M_RXCSR_DMAENAB;
+					csr |= MUSB_RXCSR_DMAENAB;
 			}
 		}
 
-		csr |= MGC_M_RXCSR_H_REQPKT;
+		csr |= MUSB_RXCSR_H_REQPKT;
 		DBG(7, "RXCSR%d := %04x\n", epnum, csr);
 		musb_writew(hw_ep->regs, MUSB_RXCSR, csr);
 		csr = musb_readw(hw_ep->regs, MUSB_RXCSR);
@@ -1035,7 +1035,7 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 
 	musb_ep_select(mbase, 0);
 	csr = musb_readw(epio, MUSB_CSR0);
-	len = (csr & MGC_M_CSR0_RXPKTRDY)
+	len = (csr & MUSB_CSR0_RXPKTRDY)
 			? musb_readb(epio, MUSB_COUNT0)
 			: 0;
 
@@ -1049,15 +1049,15 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 	}
 
 	/* prepare status */
-	if (csr & MGC_M_CSR0_H_RXSTALL) {
+	if (csr & MUSB_CSR0_H_RXSTALL) {
 		DBG(6, "STALLING ENDPOINT\n");
 		status = -EPIPE;
 
-	} else if (csr & MGC_M_CSR0_H_ERROR) {
+	} else if (csr & MUSB_CSR0_H_ERROR) {
 		DBG(2, "no response, csr0 %04x\n", csr);
 		status = -EPROTO;
 
-	} else if (csr & MGC_M_CSR0_H_NAKTIMEOUT) {
+	} else if (csr & MUSB_CSR0_H_NAKTIMEOUT) {
 		DBG(2, "control NAK timeout\n");
 
 		/* NOTE:  this code path would be a good place to PAUSE a
@@ -1079,16 +1079,16 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 		bComplete = TRUE;
 
 		/* use the proper sequence to abort the transfer */
-		if (csr & MGC_M_CSR0_H_REQPKT) {
-			csr &= ~MGC_M_CSR0_H_REQPKT;
+		if (csr & MUSB_CSR0_H_REQPKT) {
+			csr &= ~MUSB_CSR0_H_REQPKT;
 			musb_writew(epio, MUSB_CSR0, csr);
-			csr &= ~MGC_M_CSR0_H_NAKTIMEOUT;
+			csr &= ~MUSB_CSR0_H_NAKTIMEOUT;
 			musb_writew(epio, MUSB_CSR0, csr);
 		} else {
-			csr |= MGC_M_CSR0_FLUSHFIFO;
+			csr |= MUSB_CSR0_FLUSHFIFO;
 			musb_writew(epio, MUSB_CSR0, csr);
 			musb_writew(epio, MUSB_CSR0, csr);
-			csr &= ~MGC_M_CSR0_H_NAKTIMEOUT;
+			csr &= ~MUSB_CSR0_H_NAKTIMEOUT;
 			musb_writew(epio, MUSB_CSR0, csr);
 		}
 
@@ -1103,8 +1103,8 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 		 * SHOULD NEVER HAPPEN! */
 		ERR("no URB for end 0\n");
 
-		musb_writew(epio, MUSB_CSR0, MGC_M_CSR0_FLUSHFIFO);
-		musb_writew(epio, MUSB_CSR0, MGC_M_CSR0_FLUSHFIFO);
+		musb_writew(epio, MUSB_CSR0, MUSB_CSR0_FLUSHFIFO);
+		musb_writew(epio, MUSB_CSR0, MUSB_CSR0_FLUSHFIFO);
 		musb_writew(epio, MUSB_CSR0, 0);
 
 		goto done;
@@ -1115,16 +1115,16 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 		if (musb_h_ep0_continue(musb, len, pUrb)) {
 			/* more packets required */
 			csr = (MGC_END0_IN == musb->ep0_stage)
-				?  MGC_M_CSR0_H_REQPKT : MGC_M_CSR0_TXPKTRDY;
+				?  MUSB_CSR0_H_REQPKT : MUSB_CSR0_TXPKTRDY;
 		} else {
 			/* data transfer complete; perform status phase */
 			if (usb_pipeout(pUrb->pipe)
 					|| !pUrb->transfer_buffer_length)
-				csr = MGC_M_CSR0_H_STATUSPKT
-					| MGC_M_CSR0_H_REQPKT;
+				csr = MUSB_CSR0_H_STATUSPKT
+					| MUSB_CSR0_H_REQPKT;
 			else
-				csr = MGC_M_CSR0_H_STATUSPKT
-					| MGC_M_CSR0_TXPKTRDY;
+				csr = MUSB_CSR0_H_STATUSPKT
+					| MUSB_CSR0_TXPKTRDY;
 
 			/* flag status stage */
 			musb->ep0_stage = MGC_END0_STATUS;
@@ -1194,20 +1194,20 @@ void musb_host_tx(struct musb *musb, u8 
 			dma ? ", dma" : "");
 
 	/* check for errors */
-	if (wTxCsrVal & MGC_M_TXCSR_H_RXSTALL) {
+	if (wTxCsrVal & MUSB_TXCSR_H_RXSTALL) {
 		/* dma was disabled, fifo flushed */
 		DBG(3, "TX end %d stall\n", epnum);
 
 		/* stall; record URB status */
 		status = -EPIPE;
 
-	} else if (wTxCsrVal & MGC_M_TXCSR_H_ERROR) {
+	} else if (wTxCsrVal & MUSB_TXCSR_H_ERROR) {
 		/* (NON-ISO) dma was disabled, fifo flushed */
 		DBG(3, "TX 3strikes on ep=%d\n", epnum);
 
 		status = -ETIMEDOUT;
 
-	} else if (wTxCsrVal & MGC_M_TXCSR_H_NAKTIMEOUT) {
+	} else if (wTxCsrVal & MUSB_TXCSR_H_NAKTIMEOUT) {
 		DBG(6, "TX end=%d device not responding\n", epnum);
 
 		/* NOTE:  this code path would be a good place to PAUSE a
@@ -1219,8 +1219,8 @@ void musb_host_tx(struct musb *musb, u8 
 		 */
 		musb_ep_select(mbase, epnum);
 		musb_writew(epio, MUSB_CSR0,
-				MGC_M_TXCSR_H_WZC_BITS
-				| MGC_M_TXCSR_TXPKTRDY);
+				MUSB_TXCSR_H_WZC_BITS
+				| MUSB_TXCSR_TXPKTRDY);
 		goto finish;
 	}
 
@@ -1234,11 +1234,11 @@ void musb_host_tx(struct musb *musb, u8 
 		 * usb core; the dma engine should already be stopped.
 		 */
 		musb_h_tx_flush_fifo(hw_ep);
-		wTxCsrVal &= ~(MGC_M_TXCSR_AUTOSET
-				| MGC_M_TXCSR_DMAENAB
-				| MGC_M_TXCSR_H_ERROR
-				| MGC_M_TXCSR_H_RXSTALL
-				| MGC_M_TXCSR_H_NAKTIMEOUT
+		wTxCsrVal &= ~(MUSB_TXCSR_AUTOSET
+				| MUSB_TXCSR_DMAENAB
+				| MUSB_TXCSR_H_ERROR
+				| MUSB_TXCSR_H_RXSTALL
+				| MUSB_TXCSR_H_NAKTIMEOUT
 				);
 
 		musb_ep_select(mbase, epnum);
@@ -1311,7 +1311,7 @@ void musb_host_tx(struct musb *musb, u8 
 		pUrb->actual_length = qh->offset;
 		musb_advance_schedule(musb, pUrb, hw_ep, USB_DIR_OUT);
 
-	} else if (!(wTxCsrVal & MGC_M_TXCSR_DMAENAB)) {
+	} else if (!(wTxCsrVal & MUSB_TXCSR_DMAENAB)) {
 		// WARN_ON(!pBuffer);
 
 		/* REVISIT:  some docs say that when hw_ep->tx_double_buffered,
@@ -1325,7 +1325,7 @@ void musb_host_tx(struct musb *musb, u8 
 
 		musb_ep_select(mbase, epnum);
 		musb_writew(epio, MUSB_TXCSR,
-				MGC_M_TXCSR_H_WZC_BITS | MGC_M_TXCSR_TXPKTRDY);
+				MUSB_TXCSR_H_WZC_BITS | MUSB_TXCSR_TXPKTRDY);
 	} else
 		DBG(1, "not complete, but dma enabled?\n");
 
@@ -1408,7 +1408,7 @@ void musb_host_rx(struct musb *musb, u8 
 		 */
 		DBG(3, "BOGUS RX%d ready, csr %04x, count %d\n", epnum, wVal,
 			musb_readw(epio, MUSB_RXCOUNT));
-		musb_h_flush_rxfifo(hw_ep, MGC_M_RXCSR_CLRDATATOG);
+		musb_h_flush_rxfifo(hw_ep, MUSB_RXCSR_CLRDATATOG);
 		return;
 	}
 
@@ -1420,19 +1420,19 @@ void musb_host_rx(struct musb *musb, u8 
 
 	/* check for errors, concurrent stall & unlink is not really
 	 * handled yet! */
-	if (wRxCsrVal & MGC_M_RXCSR_H_RXSTALL) {
+	if (wRxCsrVal & MUSB_RXCSR_H_RXSTALL) {
 		DBG(3, "RX end %d STALL\n", epnum);
 
 		/* stall; record URB status */
 		status = -EPIPE;
 
-	} else if (wRxCsrVal & MGC_M_RXCSR_H_ERROR) {
+	} else if (wRxCsrVal & MUSB_RXCSR_H_ERROR) {
 		DBG(3, "end %d RX proto error\n", epnum);
 
 		status = -EPROTO;
 		musb_writeb(epio, MUSB_RXINTERVAL, 0);
 
-	} else if (wRxCsrVal & MGC_M_RXCSR_DATAERROR) {
+	} else if (wRxCsrVal & MUSB_RXCSR_DATAERROR) {
 
 		if (USB_ENDPOINT_XFER_ISOC != qh->type) {
 			/* NOTE this code path would be a good place to PAUSE a
@@ -1445,8 +1445,8 @@ void musb_host_rx(struct musb *musb, u8 
 			DBG(6, "RX end %d NAK timeout\n", epnum);
 			musb_ep_select(mbase, epnum);
 			musb_writew(epio, MUSB_RXCSR,
-					MGC_M_RXCSR_H_WZC_BITS
-					| MGC_M_RXCSR_H_REQPKT);
+					MUSB_RXCSR_H_WZC_BITS
+					| MUSB_RXCSR_H_REQPKT);
 
 			goto finish;
 		} else {
@@ -1484,7 +1484,7 @@ void musb_host_rx(struct musb *musb, u8 
 	/* FIXME this is _way_ too much in-line logic for Mentor DMA */
 
 #ifndef CONFIG_USB_INVENTRA_DMA
-	if (wRxCsrVal & MGC_M_RXCSR_H_REQPKT)  {
+	if (wRxCsrVal & MUSB_RXCSR_H_REQPKT)  {
 		/* REVISIT this happened for a while on some short reads...
 		 * the cleanup still needs investigation... looks bad...
 		 * and also duplicates dma cleanup code above ... plus,
@@ -1499,20 +1499,20 @@ void musb_host_rx(struct musb *musb, u8 
 
 		DBG(2, "RXCSR%d %04x, reqpkt, len %zd%s\n", epnum, wRxCsrVal,
 				xfer_len, dma ? ", dma" : "");
-		wRxCsrVal &= ~MGC_M_RXCSR_H_REQPKT;
+		wRxCsrVal &= ~MUSB_RXCSR_H_REQPKT;
 
 		musb_ep_select(mbase, epnum);
 		musb_writew(epio, MUSB_RXCSR,
-				MGC_M_RXCSR_H_WZC_BITS | wRxCsrVal);
+				MUSB_RXCSR_H_WZC_BITS | wRxCsrVal);
 	}
 #endif
-	if (dma && (wRxCsrVal & MGC_M_RXCSR_DMAENAB)) {
+	if (dma && (wRxCsrVal & MUSB_RXCSR_DMAENAB)) {
 		xfer_len = dma->actual_len;
 
-		wVal &= ~(MGC_M_RXCSR_DMAENAB
-			| MGC_M_RXCSR_H_AUTOREQ
-			| MGC_M_RXCSR_AUTOCLEAR
-			| MGC_M_RXCSR_RXPKTRDY);
+		wVal &= ~(MUSB_RXCSR_DMAENAB
+			| MUSB_RXCSR_H_AUTOREQ
+			| MUSB_RXCSR_AUTOCLEAR
+			| MUSB_RXCSR_RXPKTRDY);
 		musb_writew(hw_ep->regs, MUSB_RXCSR, wVal);
 
 #ifdef CONFIG_USB_INVENTRA_DMA
@@ -1523,9 +1523,9 @@ void musb_host_rx(struct musb *musb, u8 
 
 		/* send IN token for next packet, without AUTOREQ */
 		if (!bDone) {
-			wVal |= MGC_M_RXCSR_H_REQPKT;
+			wVal |= MUSB_RXCSR_H_REQPKT;
 			musb_writew(epio, MUSB_RXCSR,
-				MGC_M_RXCSR_H_WZC_BITS | wVal);
+				MUSB_RXCSR_H_WZC_BITS | wVal);
 		}
 
 		DBG(4, "ep %d dma %s, rxcsr %04x, rxcount %d\n", epnum,
@@ -1537,7 +1537,7 @@ void musb_host_rx(struct musb *musb, u8 
 #endif
 	} else if (pUrb->status == -EINPROGRESS) {
 		/* if no errors, be sure a packet is ready for unloading */
-		if (unlikely(!(wRxCsrVal & MGC_M_RXCSR_RXPKTRDY))) {
+		if (unlikely(!(wRxCsrVal & MUSB_RXCSR_RXPKTRDY))) {
 			status = -EPROTO;
 			ERR("Rx interrupt with no errors or packet!\n");
 
@@ -1546,7 +1546,7 @@ void musb_host_rx(struct musb *musb, u8 
 // SCRUB (RX)
 			/* do the proper sequence to abort the transfer */
 			musb_ep_select(mbase, epnum);
-			wVal &= ~MGC_M_RXCSR_H_REQPKT;
+			wVal &= ~MUSB_RXCSR_H_REQPKT;
 			musb_writew(epio, MUSB_RXCSR, wVal);
 			goto finish;
 		}
@@ -1600,16 +1600,16 @@ void musb_host_rx(struct musb *musb, u8 
  */
 
 			wVal = musb_readw(epio, MUSB_RXCSR);
-			wVal &= ~MGC_M_RXCSR_H_REQPKT;
+			wVal &= ~MUSB_RXCSR_H_REQPKT;
 
 			if (dma->desired_mode == 0)
-				wVal &= ~MGC_M_RXCSR_H_AUTOREQ;
+				wVal &= ~MUSB_RXCSR_H_AUTOREQ;
 			else
-				wVal |= MGC_M_RXCSR_H_AUTOREQ;
-			wVal |= MGC_M_RXCSR_AUTOCLEAR | MGC_M_RXCSR_DMAENAB;
+				wVal |= MUSB_RXCSR_H_AUTOREQ;
+			wVal |= MUSB_RXCSR_AUTOCLEAR | MUSB_RXCSR_DMAENAB;
 
 			musb_writew(epio, MUSB_RXCSR,
-				MGC_M_RXCSR_H_WZC_BITS | wVal);
+				MUSB_RXCSR_H_WZC_BITS | wVal);
 
 			/* REVISIT if when actual_length != 0,
 			 * transfer_buffer_length needs to be
@@ -1936,12 +1936,12 @@ static int musb_cleanup_urb(struct urb *
 	} else {
 		musb_h_tx_flush_fifo(ep);
 		csr = musb_readw(epio, MUSB_TXCSR);
-		csr &= ~( MGC_M_TXCSR_AUTOSET
-			| MGC_M_TXCSR_DMAENAB
-			| MGC_M_TXCSR_H_RXSTALL
-			| MGC_M_TXCSR_H_NAKTIMEOUT
-			| MGC_M_TXCSR_H_ERROR
-			| MGC_M_TXCSR_TXPKTRDY
+		csr &= ~( MUSB_TXCSR_AUTOSET
+			| MUSB_TXCSR_DMAENAB
+			| MUSB_TXCSR_H_RXSTALL
+			| MUSB_TXCSR_H_NAKTIMEOUT
+			| MUSB_TXCSR_H_ERROR
+			| MUSB_TXCSR_TXPKTRDY
 			);
 		musb_writew(epio, MUSB_TXCSR, csr);
 		/* REVISIT may need to clear FLUSHFIFO ... */
Index: linux-2.6.18/drivers/usb/musb/musb_procfs.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_procfs.c
+++ linux-2.6.18/drivers/usb/musb/musb_procfs.c
@@ -664,7 +664,7 @@ static int musb_proc_write(struct file *
 	case 'C':
 		if (mbase) {
 			bReg = musb_readb(mbase, MUSB_POWER)
-					| MGC_M_POWER_SOFTCONN;
+					| MUSB_POWER_SOFTCONN;
 			musb_writeb(mbase, MUSB_POWER, bReg);
 		}
 		break;
@@ -672,7 +672,7 @@ static int musb_proc_write(struct file *
 	case 'c':
 		if (mbase) {
 			bReg = musb_readb(mbase, MUSB_POWER)
-					& ~MGC_M_POWER_SOFTCONN;
+					& ~MUSB_POWER_SOFTCONN;
 			musb_writeb(mbase, MUSB_POWER, bReg);
 		}
 		break;
@@ -680,7 +680,7 @@ static int musb_proc_write(struct file *
 	case 'I':
 		if (mbase) {
 			bReg = musb_readb(mbase, MUSB_POWER)
-					| MGC_M_POWER_HSENAB;
+					| MUSB_POWER_HSENAB;
 			musb_writeb(mbase, MUSB_POWER, bReg);
 		}
 		break;
@@ -688,21 +688,21 @@ static int musb_proc_write(struct file *
 	case 'i':
 		if (mbase) {
 			bReg = musb_readb(mbase, MUSB_POWER)
-					& ~MGC_M_POWER_HSENAB;
+					& ~MUSB_POWER_HSENAB;
 			musb_writeb(mbase, MUSB_POWER, bReg);
 		}
 		break;
 
 	case 'F':
 		bReg = musb_readb(mbase, MUSB_DEVCTL);
-		bReg |= MGC_M_DEVCTL_SESSION;
+		bReg |= MUSB_DEVCTL_SESSION;
 		musb_writeb(mbase, MUSB_DEVCTL, bReg);
 		break;
 
 	case 'H':
 		if (mbase) {
 			bReg = musb_readb(mbase, MUSB_DEVCTL);
-			bReg |= MGC_M_DEVCTL_HR;
+			bReg |= MUSB_DEVCTL_HR;
 			musb_writeb(mbase, MUSB_DEVCTL, bReg);
 			//MUSB_HST_MODE( ((struct musb*)data) );
 			//WARN("Host Mode\n");
@@ -712,7 +712,7 @@ static int musb_proc_write(struct file *
 	case 'h':
 		if (mbase) {
 			bReg = musb_readb(mbase, MUSB_DEVCTL);
-			bReg &= ~MGC_M_DEVCTL_HR;
+			bReg &= ~MUSB_DEVCTL_HR;
 			musb_writeb(mbase, MUSB_DEVCTL, bReg);
 		}
 		break;
@@ -721,7 +721,7 @@ static int musb_proc_write(struct file *
 		if (mbase) {
 			musb_load_testpacket(musb);
 			musb_writeb(mbase, MUSB_TESTMODE,
-					MGC_M_TEST_PACKET);
+					MUSB_TEST_PACKET);
 		}
 		break;
 
Index: linux-2.6.18/drivers/usb/musb/musbdefs.h
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musbdefs.h
+++ linux-2.6.18/drivers/usb/musb/musbdefs.h
@@ -242,7 +242,7 @@ enum musb_g_ep0_state {
 	{ (_musb)->is_host=FALSE; }
 
 #define test_devctl_hst_mode(_x) \
-	(musb_readb((_x)->mregs, MUSB_DEVCTL)&MGC_M_DEVCTL_HM)
+	(musb_readb((_x)->mregs, MUSB_DEVCTL)&MUSB_DEVCTL_HM)
 
 #define MUSB_MODE(musb) ((musb)->is_host ? "Host" : "Peripheral")
 
Index: linux-2.6.18/drivers/usb/musb/musbhdrc.h
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musbhdrc.h
+++ linux-2.6.18/drivers/usb/musb/musbhdrc.h
@@ -139,183 +139,183 @@
 
 /* POWER */
 
-#define MGC_M_POWER_ISOUPDATE   0x80
-#define MGC_M_POWER_SOFTCONN    0x40
-#define MGC_M_POWER_HSENAB	0x20
-#define MGC_M_POWER_HSMODE	0x10
-#define MGC_M_POWER_RESET       0x08
-#define MGC_M_POWER_RESUME      0x04
-#define MGC_M_POWER_SUSPENDM    0x02
-#define MGC_M_POWER_ENSUSPEND   0x01
+#define MUSB_POWER_ISOUPDATE   0x80
+#define MUSB_POWER_SOFTCONN    0x40
+#define MUSB_POWER_HSENAB	0x20
+#define MUSB_POWER_HSMODE	0x10
+#define MUSB_POWER_RESET       0x08
+#define MUSB_POWER_RESUME      0x04
+#define MUSB_POWER_SUSPENDM    0x02
+#define MUSB_POWER_ENSUSPEND   0x01
 
 /* INTRUSB */
-#define MGC_M_INTR_SUSPEND    0x01
-#define MGC_M_INTR_RESUME     0x02
-#define MGC_M_INTR_RESET      0x04
-#define MGC_M_INTR_BABBLE     0x04
-#define MGC_M_INTR_SOF        0x08
-#define MGC_M_INTR_CONNECT    0x10
-#define MGC_M_INTR_DISCONNECT 0x20
-#define MGC_M_INTR_SESSREQ    0x40
-#define MGC_M_INTR_VBUSERROR  0x80	/* FOR SESSION END */
+#define MUSB_INTR_SUSPEND    0x01
+#define MUSB_INTR_RESUME     0x02
+#define MUSB_INTR_RESET      0x04
+#define MUSB_INTR_BABBLE     0x04
+#define MUSB_INTR_SOF        0x08
+#define MUSB_INTR_CONNECT    0x10
+#define MUSB_INTR_DISCONNECT 0x20
+#define MUSB_INTR_SESSREQ    0x40
+#define MUSB_INTR_VBUSERROR  0x80	/* FOR SESSION END */
 
 /* DEVCTL */
-#define MGC_M_DEVCTL_BDEVICE    0x80
-#define MGC_M_DEVCTL_FSDEV      0x40
-#define MGC_M_DEVCTL_LSDEV      0x20
-#define MGC_M_DEVCTL_VBUS       0x18
+#define MUSB_DEVCTL_BDEVICE    0x80
+#define MUSB_DEVCTL_FSDEV      0x40
+#define MUSB_DEVCTL_LSDEV      0x20
+#define MUSB_DEVCTL_VBUS       0x18
 #define MGC_S_DEVCTL_VBUS       3
-#define MGC_M_DEVCTL_HM         0x04
-#define MGC_M_DEVCTL_HR         0x02
-#define MGC_M_DEVCTL_SESSION    0x01
+#define MUSB_DEVCTL_HM         0x04
+#define MUSB_DEVCTL_HR         0x02
+#define MUSB_DEVCTL_SESSION    0x01
 
 /* TESTMODE */
 
-#define MGC_M_TEST_FORCE_HOST   0x80
-#define MGC_M_TEST_FIFO_ACCESS  0x40
-#define MGC_M_TEST_FORCE_FS     0x20
-#define MGC_M_TEST_FORCE_HS     0x10
-#define MGC_M_TEST_PACKET       0x08
-#define MGC_M_TEST_K            0x04
-#define MGC_M_TEST_J            0x02
-#define MGC_M_TEST_SE0_NAK      0x01
+#define MUSB_TEST_FORCE_HOST   0x80
+#define MUSB_TEST_FIFO_ACCESS  0x40
+#define MUSB_TEST_FORCE_FS     0x20
+#define MUSB_TEST_FORCE_HS     0x10
+#define MUSB_TEST_PACKET       0x08
+#define MUSB_TEST_K            0x04
+#define MUSB_TEST_J            0x02
+#define MUSB_TEST_SE0_NAK      0x01
 
 /* allocate for double-packet buffering (effectively doubles assigned _SIZE) */
-#define MGC_M_FIFOSZ_DPB	0x10
+#define MUSB_FIFOSZ_DPB	0x10
 /* allocation size (8, 16, 32, ... 4096) */
-#define MGC_M_FIFOSZ_SIZE	0x0f
+#define MUSB_FIFOSZ_SIZE	0x0f
 
 /* CSR0 */
-#define MGC_M_CSR0_FLUSHFIFO      0x0100
-#define MGC_M_CSR0_TXPKTRDY       0x0002
-#define MGC_M_CSR0_RXPKTRDY       0x0001
+#define MUSB_CSR0_FLUSHFIFO      0x0100
+#define MUSB_CSR0_TXPKTRDY       0x0002
+#define MUSB_CSR0_RXPKTRDY       0x0001
 
 /* CSR0 in Peripheral mode */
-#define MGC_M_CSR0_P_SVDSETUPEND  0x0080
-#define MGC_M_CSR0_P_SVDRXPKTRDY  0x0040
-#define MGC_M_CSR0_P_SENDSTALL    0x0020
-#define MGC_M_CSR0_P_SETUPEND     0x0010
-#define MGC_M_CSR0_P_DATAEND      0x0008
-#define MGC_M_CSR0_P_SENTSTALL    0x0004
+#define MUSB_CSR0_P_SVDSETUPEND  0x0080
+#define MUSB_CSR0_P_SVDRXPKTRDY  0x0040
+#define MUSB_CSR0_P_SENDSTALL    0x0020
+#define MUSB_CSR0_P_SETUPEND     0x0010
+#define MUSB_CSR0_P_DATAEND      0x0008
+#define MUSB_CSR0_P_SENTSTALL    0x0004
 
 /* CSR0 in Host mode */
-#define MGC_M_CSR0_H_DIS_PING	0x0800
-#define MGC_M_CSR0_H_WR_DATATOGGLE   0x0400	/* set to allow setting: */
-#define MGC_M_CSR0_H_DATATOGGLE	    0x0200	/* data toggle control */
-#define MGC_M_CSR0_H_NAKTIMEOUT   0x0080
-#define MGC_M_CSR0_H_STATUSPKT    0x0040
-#define MGC_M_CSR0_H_REQPKT       0x0020
-#define MGC_M_CSR0_H_ERROR        0x0010
-#define MGC_M_CSR0_H_SETUPPKT     0x0008
-#define MGC_M_CSR0_H_RXSTALL      0x0004
+#define MUSB_CSR0_H_DIS_PING	0x0800
+#define MUSB_CSR0_H_WR_DATATOGGLE   0x0400	/* set to allow setting: */
+#define MUSB_CSR0_H_DATATOGGLE	    0x0200	/* data toggle control */
+#define MUSB_CSR0_H_NAKTIMEOUT   0x0080
+#define MUSB_CSR0_H_STATUSPKT    0x0040
+#define MUSB_CSR0_H_REQPKT       0x0020
+#define MUSB_CSR0_H_ERROR        0x0010
+#define MUSB_CSR0_H_SETUPPKT     0x0008
+#define MUSB_CSR0_H_RXSTALL      0x0004
 
 /* CSR0 bits to avoid zeroing (write zero clears, write 1 ignored) */
-#define MGC_M_CSR0_P_WZC_BITS	\
-	( MGC_M_CSR0_P_SENTSTALL )
-#define MGC_M_CSR0_H_WZC_BITS	\
-	( MGC_M_CSR0_H_NAKTIMEOUT | MGC_M_CSR0_H_RXSTALL \
-	| MGC_M_CSR0_RXPKTRDY )
+#define MUSB_CSR0_P_WZC_BITS	\
+	( MUSB_CSR0_P_SENTSTALL )
+#define MUSB_CSR0_H_WZC_BITS	\
+	( MUSB_CSR0_H_NAKTIMEOUT | MUSB_CSR0_H_RXSTALL \
+	| MUSB_CSR0_RXPKTRDY )
 
 
 /* TxType/RxType */
-#define MGC_M_TYPE_SPEED	0xc0
+#define MUSB_TYPE_SPEED	0xc0
 #define MGC_S_TYPE_SPEED	6
 #define MGC_TYPE_SPEED_HIGH	1
 #define MGC_TYPE_SPEED_FULL	2
 #define MGC_TYPE_SPEED_LOW	3
-#define MGC_M_TYPE_PROTO	0x30	/* implicitly zero for ep0 */
+#define MUSB_TYPE_PROTO	0x30	/* implicitly zero for ep0 */
 #define MGC_S_TYPE_PROTO	4
-#define MGC_M_TYPE_REMOTE_END	0xf	/* implicitly zero for ep0 */
+#define MUSB_TYPE_REMOTE_END	0xf	/* implicitly zero for ep0 */
 
 /* CONFIGDATA */
 
-#define MGC_M_CONFIGDATA_MPRXE      0x80	/* auto bulk pkt combining */
-#define MGC_M_CONFIGDATA_MPTXE      0x40	/* auto bulk pkt splitting */
-#define MGC_M_CONFIGDATA_BIGENDIAN  0x20
-#define MGC_M_CONFIGDATA_HBRXE      0x10	/* HB-ISO for RX */
-#define MGC_M_CONFIGDATA_HBTXE      0x08	/* HB-ISO for TX */
-#define MGC_M_CONFIGDATA_DYNFIFO    0x04	/* dynamic FIFO sizing */
-#define MGC_M_CONFIGDATA_SOFTCONE   0x02	/* SoftConnect */
-#define MGC_M_CONFIGDATA_UTMIDW     0x01	/* data width 0/1 => 8/16bits */
+#define MUSB_CONFIGDATA_MPRXE      0x80	/* auto bulk pkt combining */
+#define MUSB_CONFIGDATA_MPTXE      0x40	/* auto bulk pkt splitting */
+#define MUSB_CONFIGDATA_BIGENDIAN  0x20
+#define MUSB_CONFIGDATA_HBRXE      0x10	/* HB-ISO for RX */
+#define MUSB_CONFIGDATA_HBTXE      0x08	/* HB-ISO for TX */
+#define MUSB_CONFIGDATA_DYNFIFO    0x04	/* dynamic FIFO sizing */
+#define MUSB_CONFIGDATA_SOFTCONE   0x02	/* SoftConnect */
+#define MUSB_CONFIGDATA_UTMIDW     0x01	/* data width 0/1 => 8/16bits */
 
 /* TXCSR in Peripheral and Host mode */
 
-#define MGC_M_TXCSR_AUTOSET       0x8000
-#define MGC_M_TXCSR_MODE          0x2000
-#define MGC_M_TXCSR_DMAENAB       0x1000
-#define MGC_M_TXCSR_FRCDATATOG    0x0800
-#define MGC_M_TXCSR_DMAMODE       0x0400
-#define MGC_M_TXCSR_CLRDATATOG    0x0040
-#define MGC_M_TXCSR_FLUSHFIFO     0x0008
-#define MGC_M_TXCSR_FIFONOTEMPTY  0x0002
-#define MGC_M_TXCSR_TXPKTRDY      0x0001
+#define MUSB_TXCSR_AUTOSET       0x8000
+#define MUSB_TXCSR_MODE          0x2000
+#define MUSB_TXCSR_DMAENAB       0x1000
+#define MUSB_TXCSR_FRCDATATOG    0x0800
+#define MUSB_TXCSR_DMAMODE       0x0400
+#define MUSB_TXCSR_CLRDATATOG    0x0040
+#define MUSB_TXCSR_FLUSHFIFO     0x0008
+#define MUSB_TXCSR_FIFONOTEMPTY  0x0002
+#define MUSB_TXCSR_TXPKTRDY      0x0001
 
 /* TXCSR in Peripheral mode */
 
-#define MGC_M_TXCSR_P_ISO         0x4000
-#define MGC_M_TXCSR_P_INCOMPTX    0x0080
-#define MGC_M_TXCSR_P_SENTSTALL   0x0020
-#define MGC_M_TXCSR_P_SENDSTALL   0x0010
-#define MGC_M_TXCSR_P_UNDERRUN    0x0004
+#define MUSB_TXCSR_P_ISO         0x4000
+#define MUSB_TXCSR_P_INCOMPTX    0x0080
+#define MUSB_TXCSR_P_SENTSTALL   0x0020
+#define MUSB_TXCSR_P_SENDSTALL   0x0010
+#define MUSB_TXCSR_P_UNDERRUN    0x0004
 
 /* TXCSR in Host mode */
 
-#define MGC_M_TXCSR_H_WR_DATATOGGLE   0x0200
-#define MGC_M_TXCSR_H_DATATOGGLE      0x0100
-#define MGC_M_TXCSR_H_NAKTIMEOUT  0x0080
-#define MGC_M_TXCSR_H_RXSTALL     0x0020
-#define MGC_M_TXCSR_H_ERROR       0x0004
+#define MUSB_TXCSR_H_WR_DATATOGGLE   0x0200
+#define MUSB_TXCSR_H_DATATOGGLE      0x0100
+#define MUSB_TXCSR_H_NAKTIMEOUT  0x0080
+#define MUSB_TXCSR_H_RXSTALL     0x0020
+#define MUSB_TXCSR_H_ERROR       0x0004
 
 /* TXCSR bits to avoid zeroing (write zero clears, write 1 ignored) */
-#define MGC_M_TXCSR_P_WZC_BITS	\
-	( MGC_M_TXCSR_P_INCOMPTX | MGC_M_TXCSR_P_SENTSTALL \
-	| MGC_M_TXCSR_P_UNDERRUN | MGC_M_TXCSR_FIFONOTEMPTY )
-#define MGC_M_TXCSR_H_WZC_BITS	\
-	( MGC_M_TXCSR_H_NAKTIMEOUT | MGC_M_TXCSR_H_RXSTALL \
-	| MGC_M_TXCSR_H_ERROR | MGC_M_TXCSR_FIFONOTEMPTY )
+#define MUSB_TXCSR_P_WZC_BITS	\
+	( MUSB_TXCSR_P_INCOMPTX | MUSB_TXCSR_P_SENTSTALL \
+	| MUSB_TXCSR_P_UNDERRUN | MUSB_TXCSR_FIFONOTEMPTY )
+#define MUSB_TXCSR_H_WZC_BITS	\
+	( MUSB_TXCSR_H_NAKTIMEOUT | MUSB_TXCSR_H_RXSTALL \
+	| MUSB_TXCSR_H_ERROR | MUSB_TXCSR_FIFONOTEMPTY )
 
 
 /* RXCSR in Peripheral and Host mode */
 
-#define MGC_M_RXCSR_AUTOCLEAR     0x8000
-#define MGC_M_RXCSR_DMAENAB       0x2000
-#define MGC_M_RXCSR_DISNYET       0x1000
-#define MGC_M_RXCSR_PID_ERR       0x1000
-#define MGC_M_RXCSR_DMAMODE       0x0800
-#define MGC_M_RXCSR_INCOMPRX      0x0100
-#define MGC_M_RXCSR_CLRDATATOG    0x0080
-#define MGC_M_RXCSR_FLUSHFIFO     0x0010
-#define MGC_M_RXCSR_DATAERROR     0x0008
-#define MGC_M_RXCSR_FIFOFULL      0x0002
-#define MGC_M_RXCSR_RXPKTRDY      0x0001
+#define MUSB_RXCSR_AUTOCLEAR     0x8000
+#define MUSB_RXCSR_DMAENAB       0x2000
+#define MUSB_RXCSR_DISNYET       0x1000
+#define MUSB_RXCSR_PID_ERR       0x1000
+#define MUSB_RXCSR_DMAMODE       0x0800
+#define MUSB_RXCSR_INCOMPRX      0x0100
+#define MUSB_RXCSR_CLRDATATOG    0x0080
+#define MUSB_RXCSR_FLUSHFIFO     0x0010
+#define MUSB_RXCSR_DATAERROR     0x0008
+#define MUSB_RXCSR_FIFOFULL      0x0002
+#define MUSB_RXCSR_RXPKTRDY      0x0001
 
 /* RXCSR in Peripheral mode */
 
-#define MGC_M_RXCSR_P_ISO         0x4000
-#define MGC_M_RXCSR_P_SENTSTALL   0x0040
-#define MGC_M_RXCSR_P_SENDSTALL   0x0020
-#define MGC_M_RXCSR_P_OVERRUN     0x0004
+#define MUSB_RXCSR_P_ISO         0x4000
+#define MUSB_RXCSR_P_SENTSTALL   0x0040
+#define MUSB_RXCSR_P_SENDSTALL   0x0020
+#define MUSB_RXCSR_P_OVERRUN     0x0004
 
 /* RXCSR in Host mode */
 
-#define MGC_M_RXCSR_H_AUTOREQ     0x4000
-#define MGC_M_RXCSR_H_WR_DATATOGGLE   0x0400
-#define MGC_M_RXCSR_H_DATATOGGLE        0x0200
-#define MGC_M_RXCSR_H_RXSTALL     0x0040
-#define MGC_M_RXCSR_H_REQPKT      0x0020
-#define MGC_M_RXCSR_H_ERROR       0x0004
+#define MUSB_RXCSR_H_AUTOREQ     0x4000
+#define MUSB_RXCSR_H_WR_DATATOGGLE   0x0400
+#define MUSB_RXCSR_H_DATATOGGLE        0x0200
+#define MUSB_RXCSR_H_RXSTALL     0x0040
+#define MUSB_RXCSR_H_REQPKT      0x0020
+#define MUSB_RXCSR_H_ERROR       0x0004
 
 /* RXCSR bits to avoid zeroing (write zero clears, write 1 ignored) */
-#define MGC_M_RXCSR_P_WZC_BITS	\
-	( MGC_M_RXCSR_P_SENTSTALL | MGC_M_RXCSR_P_OVERRUN \
-	| MGC_M_RXCSR_RXPKTRDY )
-#define MGC_M_RXCSR_H_WZC_BITS	\
-	( MGC_M_RXCSR_H_RXSTALL | MGC_M_RXCSR_H_ERROR \
-	| MGC_M_RXCSR_DATAERROR | MGC_M_RXCSR_RXPKTRDY )
+#define MUSB_RXCSR_P_WZC_BITS	\
+	( MUSB_RXCSR_P_SENTSTALL | MUSB_RXCSR_P_OVERRUN \
+	| MUSB_RXCSR_RXPKTRDY )
+#define MUSB_RXCSR_H_WZC_BITS	\
+	( MUSB_RXCSR_H_RXSTALL | MUSB_RXCSR_H_ERROR \
+	| MUSB_RXCSR_DATAERROR | MUSB_RXCSR_RXPKTRDY )
 
 
 /* HUBADDR */
-#define MGC_M_HUBADDR_MULTI_TT		0x80
+#define MUSB_HUBADDR_MULTI_TT		0x80
 
 
 #endif	/* __MUSB_HDRC_DEFS_H__ */
Index: linux-2.6.18/drivers/usb/musb/musbhsdma.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musbhsdma.c
+++ linux-2.6.18/drivers/usb/musb/musbhsdma.c
@@ -61,7 +61,7 @@
 #define MGC_S_HSDMA_ENDPOINT		4
 #define MGC_S_HSDMA_BUSERROR		8
 #define MGC_S_HSDMA_BURSTMODE		9
-#define MGC_M_HSDMA_BURSTMODE		(3 << MGC_S_HSDMA_BURSTMODE)
+#define MUSB_HSDMA_BURSTMODE		(3 << MGC_S_HSDMA_BURSTMODE)
 #define MGC_HSDMA_BURSTMODE_UNSPEC	0
 #define MGC_HSDMA_BURSTMODE_INCR4	1
 #define MGC_HSDMA_BURSTMODE_INCR8	2
@@ -264,9 +264,9 @@ static int dma_channel_abort(struct dma_
 
 			csr = musb_readw(mbase,
 				MGC_END_OFFSET(pImplChannel->epnum,MUSB_TXCSR));
-			csr &= ~(MGC_M_TXCSR_AUTOSET |
-				 MGC_M_TXCSR_DMAENAB |
-				 MGC_M_TXCSR_DMAMODE);
+			csr &= ~(MUSB_TXCSR_AUTOSET |
+				 MUSB_TXCSR_DMAENAB |
+				 MUSB_TXCSR_DMAMODE);
 			musb_writew(mbase,
 					MGC_END_OFFSET(pImplChannel->epnum,MUSB_TXCSR),
 					csr);
@@ -274,9 +274,9 @@ static int dma_channel_abort(struct dma_
 		else {
 			csr = musb_readw(mbase,
 				MGC_END_OFFSET(pImplChannel->epnum,MUSB_RXCSR));
-			csr &= ~(MGC_M_RXCSR_AUTOCLEAR |
-				 MGC_M_RXCSR_DMAENAB |
-				 MGC_M_RXCSR_DMAMODE);
+			csr &= ~(MUSB_RXCSR_AUTOCLEAR |
+				 MUSB_RXCSR_DMAENAB |
+				 MUSB_RXCSR_DMAMODE);
 			musb_writew(mbase,
 					MGC_END_OFFSET(pImplChannel->epnum,MUSB_RXCSR),
 					csr);
@@ -346,7 +346,7 @@ static irqreturn_t dma_controller_irq(in
 				pChannel->status = MGC_DMA_STATUS_FREE;
 
 				/* completed */
-				if ((devctl & MGC_M_DEVCTL_HM)
+				if ((devctl & MUSB_DEVCTL_HM)
 				    && (pImplChannel->bTransmit)
 				    && ((pChannel->desired_mode == 0)
 					|| (pChannel->actual_len &
@@ -357,7 +357,7 @@ static irqreturn_t dma_controller_irq(in
 						pImplChannel->epnum);
 					musb_writew(mbase,
 						MGC_END_OFFSET(pImplChannel->epnum,MUSB_TXCSR),
-						MGC_M_TXCSR_TXPKTRDY);
+						MUSB_TXCSR_TXPKTRDY);
 				} else
 					musb_dma_completion(
 						pController->pDmaPrivate,
Index: linux-2.6.18/drivers/usb/musb/omap2430.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/omap2430.c
+++ linux-2.6.18/drivers/usb/musb/omap2430.c
@@ -65,7 +65,7 @@ static void omap_set_vbus(struct musb *m
 		musb->is_active = 1;
 		musb->xceiv.default_a = 1;
 		musb->xceiv.state = OTG_STATE_A_WAIT_VRISE;
-		devctl |= MGC_M_DEVCTL_SESSION;
+		devctl |= MUSB_DEVCTL_SESSION;
 
 		MUSB_HST_MODE(musb);
 	} else {
@@ -77,7 +77,7 @@ static void omap_set_vbus(struct musb *m
 
 		musb->xceiv.default_a = 0;
 		musb->xceiv.state = OTG_STATE_B_IDLE;
-		devctl &= ~MGC_M_DEVCTL_SESSION;
+		devctl &= ~MUSB_DEVCTL_SESSION;
 
 		MUSB_DEV_MODE(musb);
 	}
Index: linux-2.6.18/drivers/usb/musb/plat_uds.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/plat_uds.c
+++ linux-2.6.18/drivers/usb/musb/plat_uds.c
@@ -276,7 +276,7 @@ void musb_load_testpacket(struct musb *m
 	musb_ep_select(musb->mregs, 0);
 	musb_write_fifo(musb->control_ep,
 			sizeof(musb_test_packet), musb_test_packet);
-	musb_writew(regs, MUSB_CSR0, MGC_M_CSR0_TXPKTRDY);
+	musb_writew(regs, MUSB_CSR0, MUSB_CSR0_TXPKTRDY);
 }
 
 /*-------------------------------------------------------------------------*/
@@ -332,7 +332,7 @@ void musb_hnp_stop(struct musb *musb)
 		hcd->self.is_b_host = 0;
 		musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
 		reg = musb_readb(mbase, MUSB_POWER);
-		reg |= MGC_M_POWER_SUSPENDM;
+		reg |= MUSB_POWER_SUSPENDM;
 		musb_writeb(mbase, MUSB_POWER, reg);
 		/* REVISIT: Start SESSION_REQUEST here? */
 		break;
@@ -356,9 +356,9 @@ void musb_hnp_stop(struct musb *musb)
  * @param power
  */
 
-#define STAGE0_MASK (MGC_M_INTR_RESUME | MGC_M_INTR_SESSREQ \
-		| MGC_M_INTR_VBUSERROR | MGC_M_INTR_CONNECT \
-		| MGC_M_INTR_RESET )
+#define STAGE0_MASK (MUSB_INTR_RESUME | MUSB_INTR_SESSREQ \
+		| MUSB_INTR_VBUSERROR | MUSB_INTR_CONNECT \
+		| MUSB_INTR_RESET )
 
 static irqreturn_t musb_stage0_irq(struct musb * musb, u8 bIntrUSB,
 				u8 devctl, u8 power)
@@ -375,11 +375,11 @@ static irqreturn_t musb_stage0_irq(struc
 	 * in peripheral mode, the host may resume the link.
 	 * spurious RESUME irqs happen too, paired with SUSPEND.
 	 */
-	if (bIntrUSB & MGC_M_INTR_RESUME) {
+	if (bIntrUSB & MUSB_INTR_RESUME) {
 		handled = IRQ_HANDLED;
 		DBG(3, "RESUME (%s)\n", otg_state_string(musb));
 
-		if (devctl & MGC_M_DEVCTL_HM) {
+		if (devctl & MUSB_DEVCTL_HM) {
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 			switch (musb->xceiv.state) {
 			case OTG_STATE_A_SUSPEND:
@@ -387,16 +387,16 @@ static irqreturn_t musb_stage0_irq(struc
 				 * will stop RESUME signaling
 				 */
 
-				if (power & MGC_M_POWER_SUSPENDM) {
+				if (power & MUSB_POWER_SUSPENDM) {
 					/* spurious */
-					musb->int_usb &= ~MGC_M_INTR_SUSPEND;
+					musb->int_usb &= ~MUSB_INTR_SUSPEND;
 					DBG(2, "Spurious SUSPENDM\n");
 					break;
 				}
 
-				power &= ~MGC_M_POWER_SUSPENDM;
+				power &= ~MUSB_POWER_SUSPENDM;
 				musb_writeb(mbase, MUSB_POWER,
-						power | MGC_M_POWER_RESUME);
+						power | MUSB_POWER_RESUME);
 
 				musb->port1_status |=
 						(USB_PORT_STAT_C_SUSPEND << 16)
@@ -434,16 +434,16 @@ static irqreturn_t musb_stage0_irq(struc
 				/* disconnect while suspended?  we may
 				 * not get a disconnect irq...
 				 */
-				if ((devctl & MGC_M_DEVCTL_VBUS)
+				if ((devctl & MUSB_DEVCTL_VBUS)
 						!= (3 << MGC_S_DEVCTL_VBUS)) {
-					musb->int_usb |= MGC_M_INTR_DISCONNECT;
-					musb->int_usb &= ~MGC_M_INTR_SUSPEND;
+					musb->int_usb |= MUSB_INTR_DISCONNECT;
+					musb->int_usb &= ~MUSB_INTR_SUSPEND;
 					break;
 				}
 				musb_g_resume(musb);
 				break;
 			case OTG_STATE_B_IDLE:
-				musb->int_usb &= ~MGC_M_INTR_SUSPEND;
+				musb->int_usb &= ~MUSB_INTR_SUSPEND;
 				break;
 #endif
 			default:
@@ -456,7 +456,7 @@ static irqreturn_t musb_stage0_irq(struc
 
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 	/* see manual for the order of the tests */
-	if (bIntrUSB & MGC_M_INTR_SESSREQ) {
+	if (bIntrUSB & MUSB_INTR_SESSREQ) {
 		DBG(1, "SESSION_REQUEST (%s)\n", otg_state_string(musb));
 
 		/* IRQ arrives from ID pin sense or (later, if VBUS power
@@ -466,7 +466,7 @@ static irqreturn_t musb_stage0_irq(struc
 		 *  - ... to A_WAIT_BCON.
 		 * a_wait_vrise_tmout triggers VBUS_ERROR transitions
 		 */
-		musb_writeb(mbase, MUSB_DEVCTL, MGC_M_DEVCTL_SESSION);
+		musb_writeb(mbase, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);
 		musb->ep0_stage = MGC_END0_START;
 		musb->xceiv.state = OTG_STATE_A_IDLE;
 		MUSB_HST_MODE(musb);
@@ -475,7 +475,7 @@ static irqreturn_t musb_stage0_irq(struc
 		handled = IRQ_HANDLED;
 	}
 
-	if (bIntrUSB & MGC_M_INTR_VBUSERROR) {
+	if (bIntrUSB & MUSB_INTR_VBUSERROR) {
 		int	ignore = 0;
 
 		/* During connection as an A-Device, we may see a short
@@ -507,7 +507,7 @@ static irqreturn_t musb_stage0_irq(struc
 			if (musb->vbuserr_retry) {
 				musb->vbuserr_retry--;
 				ignore = 1;
-				devctl |= MGC_M_DEVCTL_SESSION;
+				devctl |= MUSB_DEVCTL_SESSION;
 				musb_writeb(mbase, MUSB_DEVCTL, devctl);
 			} else {
 				musb->port1_status |=
@@ -523,7 +523,7 @@ static irqreturn_t musb_stage0_irq(struc
 				otg_state_string(musb),
 				devctl,
 				({ char *s;
-				switch (devctl & MGC_M_DEVCTL_VBUS) {
+				switch (devctl & MUSB_DEVCTL_VBUS) {
 				case 0 << MGC_S_DEVCTL_VBUS:
 					s = "<SessEnd"; break;
 				case 1 << MGC_S_DEVCTL_VBUS:
@@ -543,7 +543,7 @@ static irqreturn_t musb_stage0_irq(struc
 		handled = IRQ_HANDLED;
 	}
 
-	if (bIntrUSB & MGC_M_INTR_CONNECT) {
+	if (bIntrUSB & MUSB_INTR_CONNECT) {
 		struct usb_hcd *hcd = musb_to_hcd(musb);
 
 		handled = IRQ_HANDLED;
@@ -570,7 +570,7 @@ static irqreturn_t musb_stage0_irq(struc
 					|(USB_PORT_STAT_C_CONNECTION << 16);
 
 		/* high vs full speed is just a guess until after reset */
-		if (devctl & MGC_M_DEVCTL_LSDEV)
+		if (devctl & MUSB_DEVCTL_LSDEV)
 			musb->port1_status |= USB_PORT_STAT_LOW_SPEED;
 
 		if (hcd->status_urb)
@@ -588,7 +588,7 @@ static irqreturn_t musb_stage0_irq(struc
 			hcd->self.is_b_host = 1;
 			break;
 		default:
-			if ((devctl & MGC_M_DEVCTL_VBUS)
+			if ((devctl & MUSB_DEVCTL_VBUS)
 					== (3 << MGC_S_DEVCTL_VBUS)) {
 				musb->xceiv.state = OTG_STATE_A_HOST;
 				hcd->self.is_b_host = 0;
@@ -603,8 +603,8 @@ static irqreturn_t musb_stage0_irq(struc
 	/* mentor saves a bit: bus reset and babble share the same irq.
 	 * only host sees babble; only peripheral sees bus reset.
 	 */
-	if (bIntrUSB & MGC_M_INTR_RESET) {
-		if (devctl & MGC_M_DEVCTL_HM) {
+	if (bIntrUSB & MUSB_INTR_RESET) {
+		if (devctl & MUSB_DEVCTL_HM) {
 			/*
 			 * Looks like non-HS BABBLE can be ignored, but
 			 * HS BABBLE is an error condition. For HS the solution
@@ -612,7 +612,7 @@ static irqreturn_t musb_stage0_irq(struc
 			 * causes BABBLE. When HS BABBLE happens we can only stop
 			 * the session.
 			 */
-			if (devctl & (MGC_M_DEVCTL_FSDEV | MGC_M_DEVCTL_LSDEV))
+			if (devctl & (MUSB_DEVCTL_FSDEV | MUSB_DEVCTL_LSDEV))
 				DBG(1, "BABBLE devctl: %02x\n", devctl);
 			else {
 				ERR("Stopping host session because of babble\n");
@@ -659,7 +659,7 @@ static irqreturn_t musb_stage2_irq(struc
  * endpoints, relies on TX/RX interval registers, and isn't claimed
  * to support ISO transfers yet.
  */
-	if (bIntrUSB & MGC_M_INTR_SOF) {
+	if (bIntrUSB & MUSB_INTR_SOF) {
 		void __iomem *mbase = musb->mregs;
 		struct musb_hw_ep	*ep;
 		u8 epnum;
@@ -690,7 +690,7 @@ static irqreturn_t musb_stage2_irq(struc
 	}
 #endif
 
-	if ((bIntrUSB & MGC_M_INTR_DISCONNECT) && !musb->ignore_disconnect) {
+	if ((bIntrUSB & MUSB_INTR_DISCONNECT) && !musb->ignore_disconnect) {
 		DBG(1, "DISCONNECT (%s) as %s, devctl %02x\n",
 				otg_state_string(musb),
 				MUSB_MODE(musb), devctl);
@@ -731,7 +731,7 @@ static irqreturn_t musb_stage2_irq(struc
 		schedule_work(&musb->irq_work);
 	}
 
-	if (bIntrUSB & MGC_M_INTR_SUSPEND) {
+	if (bIntrUSB & MUSB_INTR_SUSPEND) {
 		DBG(1, "SUSPEND (%s) devctl %02x power %02x\n",
 				otg_state_string(musb), devctl, power);
 		handled = IRQ_HANDLED;
@@ -799,16 +799,16 @@ void musb_start(struct musb *musb)
 	musb_writeb(regs, MUSB_TESTMODE, 0);
 
 	/* put into basic highspeed mode and start session */
-	musb_writeb(regs, MUSB_POWER, MGC_M_POWER_ISOUPDATE
-						| MGC_M_POWER_SOFTCONN
-						| MGC_M_POWER_HSENAB
+	musb_writeb(regs, MUSB_POWER, MUSB_POWER_ISOUPDATE
+						| MUSB_POWER_SOFTCONN
+						| MUSB_POWER_HSENAB
 						/* ENSUSPEND wedges tusb */
-						// | MGC_M_POWER_ENSUSPEND
+						// | MUSB_POWER_ENSUSPEND
 						);
 
 	musb->is_active = 0;
 	devctl = musb_readb(regs, MUSB_DEVCTL);
-	devctl &= ~MGC_M_DEVCTL_SESSION;
+	devctl &= ~MUSB_DEVCTL_SESSION;
 
 	if (is_otg_enabled(musb)) {
 		/* session started after:
@@ -816,17 +816,17 @@ void musb_start(struct musb *musb)
 		 * (b) vbus present/connect IRQ, peripheral mode;
 		 * (c) peripheral initiates, using SRP
 		 */
-		if ((devctl & MGC_M_DEVCTL_VBUS) == MGC_M_DEVCTL_VBUS)
+		if ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS)
 			musb->is_active = 1;
 		else
-			devctl |= MGC_M_DEVCTL_SESSION;
+			devctl |= MUSB_DEVCTL_SESSION;
 
 	} else if (is_host_enabled(musb)) {
 		/* assume ID pin is hard-wired to ground */
-		devctl |= MGC_M_DEVCTL_SESSION;
+		devctl |= MUSB_DEVCTL_SESSION;
 
 	} else /* peripheral is enabled */ {
-		if ((devctl & MGC_M_DEVCTL_VBUS) == MGC_M_DEVCTL_VBUS)
+		if ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS)
 			musb->is_active = 1;
 	}
 	musb_platform_enable(musb);
@@ -1038,7 +1038,7 @@ fifo_setup(struct musb *musb, struct mus
 	if (cfg->mode == BUF_DOUBLE) {
 		if ((offset + (maxpacket << 1)) > DYN_FIFO_SIZE)
 			return -EMSGSIZE;
-		c_size |= MGC_M_FIFOSZ_DPB;
+		c_size |= MUSB_FIFOSZ_DPB;
 	} else {
 		if ((offset + maxpacket) > DYN_FIFO_SIZE)
 			return -EMSGSIZE;
@@ -1059,19 +1059,19 @@ fifo_setup(struct musb *musb, struct mus
 	case FIFO_TX:
 		musb_writeb(mbase, MUSB_TXFIFOSZ, c_size);
 		musb_writew(mbase, MUSB_TXFIFOADD, c_off);
-		hw_ep->tx_double_buffered = !!(c_size & MGC_M_FIFOSZ_DPB);
+		hw_ep->tx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);
 		hw_ep->max_packet_sz_tx = maxpacket;
 		break;
 	case FIFO_RX:
 		musb_writeb(mbase, MUSB_RXFIFOSZ, c_size);
 		musb_writew(mbase, MUSB_RXFIFOADD, c_off);
-		hw_ep->rx_double_buffered = !!(c_size & MGC_M_FIFOSZ_DPB);
+		hw_ep->rx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);
 		hw_ep->max_packet_sz_rx = maxpacket;
 		break;
 	case FIFO_RXTX:
 		musb_writeb(mbase, MUSB_TXFIFOSZ, c_size);
 		musb_writew(mbase, MUSB_TXFIFOADD, c_off);
-		hw_ep->rx_double_buffered = !!(c_size & MGC_M_FIFOSZ_DPB);
+		hw_ep->rx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);
 		hw_ep->max_packet_sz_rx = maxpacket;
 
 		musb_writeb(mbase, MUSB_RXFIFOSZ, c_size);
@@ -1088,7 +1088,7 @@ fifo_setup(struct musb *musb, struct mus
 	 */
 	musb->wEndMask |= (1 << hw_ep->epnum);
 
-	return offset + (maxpacket << ((c_size & MGC_M_FIFOSZ_DPB) ? 1 : 0));
+	return offset + (maxpacket << ((c_size & MUSB_FIFOSZ_DPB) ? 1 : 0));
 }
 
 static struct fifo_cfg __initdata ep0_cfg = {
@@ -1261,11 +1261,11 @@ static int __init musb_core_init(u16 wTy
 	musb_ep_select(mbase, 0);
 	reg = musb_readb(mbase, 0x10 + MUSB_CONFIGDATA);
 
-	strcpy(aInfo, (reg & MGC_M_CONFIGDATA_UTMIDW) ? "UTMI-16" : "UTMI-8");
-	if (reg & MGC_M_CONFIGDATA_DYNFIFO) {
+	strcpy(aInfo, (reg & MUSB_CONFIGDATA_UTMIDW) ? "UTMI-16" : "UTMI-8");
+	if (reg & MUSB_CONFIGDATA_DYNFIFO) {
 		strcat(aInfo, ", dyn FIFOs");
 	}
-	if (reg & MGC_M_CONFIGDATA_MPRXE) {
+	if (reg & MUSB_CONFIGDATA_MPRXE) {
 		strcat(aInfo, ", bulk combine");
 #ifdef C_MP_RX
 		musb->bulk_combine = TRUE;
@@ -1273,7 +1273,7 @@ static int __init musb_core_init(u16 wTy
 		strcat(aInfo, " (X)");		/* no driver support */
 #endif
 	}
-	if (reg & MGC_M_CONFIGDATA_MPTXE) {
+	if (reg & MUSB_CONFIGDATA_MPTXE) {
 		strcat(aInfo, ", bulk split");
 #ifdef C_MP_TX
 		musb->bulk_split = TRUE;
@@ -1281,15 +1281,15 @@ static int __init musb_core_init(u16 wTy
 		strcat(aInfo, " (X)");		/* no driver support */
 #endif
 	}
-	if (reg & MGC_M_CONFIGDATA_HBRXE) {
+	if (reg & MUSB_CONFIGDATA_HBRXE) {
 		strcat(aInfo, ", HB-ISO Rx");
 		strcat(aInfo, " (X)");		/* no driver support */
 	}
-	if (reg & MGC_M_CONFIGDATA_HBTXE) {
+	if (reg & MUSB_CONFIGDATA_HBTXE) {
 		strcat(aInfo, ", HB-ISO Tx");
 		strcat(aInfo, " (X)");		/* no driver support */
 	}
-	if (reg & MGC_M_CONFIGDATA_SOFTCONE) {
+	if (reg & MUSB_CONFIGDATA_SOFTCONE) {
 		strcat(aInfo, ", SoftConn");
 	}
 
@@ -1342,7 +1342,7 @@ static int __init musb_core_init(u16 wTy
 	musb->nr_endpoints = 1;
 	musb->wEndMask = 1;
 
-	if (reg & MGC_M_CONFIGDATA_DYNFIFO) {
+	if (reg & MUSB_CONFIGDATA_DYNFIFO) {
 		if (can_dynfifo())
 			status = ep_config_from_table(musb);
 		else {
@@ -1462,7 +1462,7 @@ irqreturn_t musb_interrupt(struct musb *
 	power = musb_readb(musb->mregs, MUSB_POWER);
 
 	DBG(4, "** IRQ %s usb%04x tx%04x rx%04x\n",
-		(devctl & MGC_M_DEVCTL_HM) ? "host" : "peripheral",
+		(devctl & MUSB_DEVCTL_HM) ? "host" : "peripheral",
 		musb->int_usb, musb->int_tx, musb->int_rx);
 
 	/* the core can interrupt us for multiple reasons; docs have
@@ -1476,7 +1476,7 @@ irqreturn_t musb_interrupt(struct musb *
 
 	/* handle endpoint 0 first */
 	if (musb->int_tx & 1) {
-		if (devctl & MGC_M_DEVCTL_HM)
+		if (devctl & MUSB_DEVCTL_HM)
 			retval |= musb_h_ep0_irq(musb);
 		else
 			retval |= musb_g_ep0_irq(musb);
@@ -1490,7 +1490,7 @@ irqreturn_t musb_interrupt(struct musb *
 			// musb_ep_select(musb->mregs, ep_num);
 			/* REVISIT just retval = ep->rx_irq(...) */
 			retval = IRQ_HANDLED;
-			if (devctl & MGC_M_DEVCTL_HM) {
+			if (devctl & MUSB_DEVCTL_HM) {
 				if (is_host_capable())
 					musb_host_rx(musb, ep_num);
 			} else {
@@ -1511,7 +1511,7 @@ irqreturn_t musb_interrupt(struct musb *
 			// musb_ep_select(musb->mregs, ep_num);
 			/* REVISIT just retval |= ep->tx_irq(...) */
 			retval = IRQ_HANDLED;
-			if (devctl & MGC_M_DEVCTL_HM) {
+			if (devctl & MUSB_DEVCTL_HM) {
 				if (is_host_capable())
 					musb_host_tx(musb, ep_num);
 			} else {
@@ -1549,7 +1549,7 @@ void musb_dma_completion(struct musb *mu
 #ifndef CONFIG_USB_TUSB_OMAP_DMA
 		if (!is_cppi_enabled()) {
 			/* endpoint 0 */
-			if (devctl & MGC_M_DEVCTL_HM)
+			if (devctl & MUSB_DEVCTL_HM)
 				musb_h_ep0_irq(musb);
 			else
 				musb_g_ep0_irq(musb);
@@ -1558,7 +1558,7 @@ void musb_dma_completion(struct musb *mu
 	} else {
 		/* endpoints 1..15 */
 		if (bTransmit) {
-			if (devctl & MGC_M_DEVCTL_HM) {
+			if (devctl & MUSB_DEVCTL_HM) {
 				if (is_host_capable())
 					musb_host_tx(musb, epnum);
 			} else {
@@ -1567,7 +1567,7 @@ void musb_dma_completion(struct musb *mu
 			}
 		} else {
 			/* receive */
-			if (devctl & MGC_M_DEVCTL_HM) {
+			if (devctl & MUSB_DEVCTL_HM) {
 				if (is_host_capable())
 					musb_host_rx(musb, epnum);
 			} else {
@@ -1653,7 +1653,7 @@ musb_cable_show(struct device *dev, stru
 			break;
 		case MUSB_OTG:
 			v1 = "Mini-";
-			v2 = (vbus & MGC_M_DEVCTL_BDEVICE) ? "B" : "A";
+			v2 = (vbus & MUSB_DEVCTL_BDEVICE) ? "B" : "A";
 			break;
 		}
 	} else	/* VBUS level below A-Valid */
@@ -1993,7 +1993,7 @@ musb_init_controller(struct device *dev,
 			"HOST", status,
 			musb_readb(musb->mregs, MUSB_DEVCTL),
 			(musb_readb(musb->mregs, MUSB_DEVCTL)
-					& MGC_M_DEVCTL_BDEVICE
+					& MUSB_DEVCTL_BDEVICE
 				? 'B' : 'A'));
 
 	} else /* peripheral is enabled */ {
Index: linux-2.6.18/drivers/usb/musb/tusb6010.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/tusb6010.c
+++ linux-2.6.18/drivers/usb/musb/tusb6010.c
@@ -536,7 +536,7 @@ static void tusb_source_power(struct mus
 		timer = OTG_TIMER_MS(OTG_TIME_A_WAIT_VRISE);
 		musb->xceiv.default_a = 1;
 		musb->xceiv.state = OTG_STATE_A_WAIT_VRISE;
-		devctl |= MGC_M_DEVCTL_SESSION;
+		devctl |= MUSB_DEVCTL_SESSION;
 
 		conf |= TUSB_DEV_CONF_USB_HOST_MODE;
 		MUSB_HST_MODE(musb);
@@ -550,7 +550,7 @@ static void tusb_source_power(struct mus
 
 		musb->xceiv.default_a = 0;
 		musb->xceiv.state = OTG_STATE_B_IDLE;
-		devctl &= ~MGC_M_DEVCTL_SESSION;
+		devctl &= ~MUSB_DEVCTL_SESSION;
 
 		conf &= ~TUSB_DEV_CONF_USB_HOST_MODE;
 		MUSB_DEV_MODE(musb);
@@ -688,7 +688,7 @@ tusb_otg_ints(struct musb *musb, u32 int
 				if (musb->xceiv.state != OTG_STATE_B_IDLE) {
 					/* INTR_DISCONNECT can hide... */
 					musb->xceiv.state = OTG_STATE_B_IDLE;
-					musb->int_usb |= MGC_M_INTR_DISCONNECT;
+					musb->int_usb |= MUSB_INTR_DISCONNECT;
 				}
 				musb->is_active = 0;
 			}
@@ -708,7 +708,7 @@ tusb_otg_ints(struct musb *musb, u32 int
 				DBG(2, "Got SRP, turning on VBUS\n");
 				devctl = musb_readb(musb->mregs,
 							MUSB_DEVCTL);
-				devctl |= MGC_M_DEVCTL_SESSION;
+				devctl |= MUSB_DEVCTL_SESSION;
 				musb_writeb(musb->mregs, MUSB_DEVCTL,
 							devctl);
 				musb->xceiv.state = OTG_STATE_A_WAIT_VRISE;
@@ -755,8 +755,8 @@ tusb_otg_ints(struct musb *musb, u32 int
 			 */
 			devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 			if (otg_stat & TUSB_DEV_OTG_STAT_VBUS_VALID) {
-				if ((devctl & MGC_M_DEVCTL_VBUS)
-						!= MGC_M_DEVCTL_VBUS) {
+				if ((devctl & MUSB_DEVCTL_VBUS)
+						!= MUSB_DEVCTL_VBUS) {
 					DBG(2, "devctl %02x\n", devctl);
 					break;
 				}
Index: linux-2.6.18/drivers/usb/musb/tusb6010_omap.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/tusb6010_omap.c
+++ linux-2.6.18/drivers/usb/musb/tusb6010_omap.c
@@ -224,8 +224,8 @@ static void tusb_omap_dma_cb(int lch, u1
 			DBG(2, "terminating short tx packet\n");
 			musb_ep_select(musb_base, chdat->epnum);
 			csr = musb_readw(hw_ep->regs, MUSB_TXCSR);
-			csr |= MGC_M_TXCSR_MODE | MGC_M_TXCSR_TXPKTRDY
-				| MGC_M_TXCSR_P_WZC_BITS;
+			csr |= MUSB_TXCSR_MODE | MUSB_TXCSR_TXPKTRDY
+				| MUSB_TXCSR_P_WZC_BITS;
 			musb_writew(hw_ep->regs, MUSB_TXCSR, csr);
 		}
 	}
@@ -377,17 +377,17 @@ static int tusb_omap_dma_program(struct 
 	if (chdat->tx) {
 		musb_ep_select(musb_base, chdat->epnum);
 		csr = musb_readw(hw_ep->regs, MUSB_TXCSR);
-		csr |= (MGC_M_TXCSR_AUTOSET | MGC_M_TXCSR_DMAENAB
-			| MGC_M_TXCSR_DMAMODE | MGC_M_TXCSR_MODE);
-		csr &= ~MGC_M_TXCSR_P_UNDERRUN;
+		csr |= (MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAENAB
+			| MUSB_TXCSR_DMAMODE | MUSB_TXCSR_MODE);
+		csr &= ~MUSB_TXCSR_P_UNDERRUN;
 		musb_writew(hw_ep->regs, MUSB_TXCSR, csr);
 	} else {
 		musb_ep_select(musb_base, chdat->epnum);
 		csr = musb_readw(hw_ep->regs, MUSB_RXCSR);
-		csr |= MGC_M_RXCSR_DMAENAB;
-		csr &= ~(MGC_M_RXCSR_AUTOCLEAR | MGC_M_RXCSR_DMAMODE);
+		csr |= MUSB_RXCSR_DMAENAB;
+		csr &= ~(MUSB_RXCSR_AUTOCLEAR | MUSB_RXCSR_DMAMODE);
 		musb_writew(hw_ep->regs, MUSB_RXCSR,
-			csr | MGC_M_RXCSR_P_WZC_BITS);
+			csr | MUSB_RXCSR_P_WZC_BITS);
 	}
 
 	/*
Index: linux-2.6.18/drivers/usb/musb/virthub.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/virthub.c
+++ linux-2.6.18/drivers/usb/musb/virthub.c
@@ -56,20 +56,20 @@ static void musb_port_suspend(struct mus
 
 	/* NOTE:  this doesn't necessarily put PHY into low power mode,
 	 * turning off its clock; that's a function of PHY integration and
-	 * MGC_M_POWER_ENSUSPEND.  PHY may need a clock (sigh) to detect
+	 * MUSB_POWER_ENSUSPEND.  PHY may need a clock (sigh) to detect
 	 * SE0 changing to connect (J) or wakeup (K) states.
 	 */
 	power = musb_readb(mbase, MUSB_POWER);
 	if (bSuspend) {
 		int retries = 10000;
 
-		power &= ~MGC_M_POWER_RESUME;
-		power |= MGC_M_POWER_SUSPENDM;
+		power &= ~MUSB_POWER_RESUME;
+		power |= MUSB_POWER_SUSPENDM;
 		musb_writeb(mbase, MUSB_POWER, power);
 
 		/* Needed for OPT A tests */
 		power = musb_readb(mbase, MUSB_POWER);
-		while (power & MGC_M_POWER_SUSPENDM) {
+		while (power & MUSB_POWER_SUSPENDM) {
 			power = musb_readb(mbase, MUSB_POWER);
 			if (retries-- < 1)
 				break;
@@ -88,15 +88,15 @@ static void musb_port_suspend(struct mus
 		case OTG_STATE_B_HOST:
 			musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
 			MUSB_DEV_MODE(musb);
-			/* REVISIT restore setting of MGC_M_DEVCTL_HR */
+			/* REVISIT restore setting of MUSB_DEVCTL_HR */
 			break;
 		default:
 			DBG(1, "bogus rh suspend? %s\n",
 				otg_state_string(musb));
 		}
-	} else if (power & MGC_M_POWER_SUSPENDM) {
-		power &= ~MGC_M_POWER_SUSPENDM;
-		power |= MGC_M_POWER_RESUME;
+	} else if (power & MUSB_POWER_SUSPENDM) {
+		power &= ~MUSB_POWER_SUSPENDM;
+		power |= MUSB_POWER_RESUME;
 		musb_writeb(mbase, MUSB_POWER, power);
 
 		DBG(3, "Root port resuming, power %02x\n", power);
@@ -116,7 +116,7 @@ static void musb_port_reset(struct musb 
 	/* REVISIT this looks wrong for HNP */
 	u8 devctl = musb_readb(mbase, MUSB_DEVCTL);
 
-	if (musb->delay_port_power_off || !(devctl & MGC_M_DEVCTL_HM)) {
+	if (musb->delay_port_power_off || !(devctl & MUSB_DEVCTL_HM)) {
 		return;
 	}
 #endif
@@ -137,18 +137,18 @@ static void musb_port_reset(struct musb 
 		 * fail with "Error! Did not receive an SOF before suspend
 		 * detected".
 		 */
-		if (power &  MGC_M_POWER_RESUME) {
+		if (power &  MUSB_POWER_RESUME) {
 			while (time_before(jiffies, musb->rh_timer))
 				msleep(1);
 			musb_writeb(mbase, MUSB_POWER,
-				power & ~MGC_M_POWER_RESUME);
+				power & ~MUSB_POWER_RESUME);
 			msleep(1);
 		}
 
 		musb->ignore_disconnect = TRUE;
 		power &= 0xf0;
 		musb_writeb(mbase, MUSB_POWER,
-				power | MGC_M_POWER_RESET);
+				power | MUSB_POWER_RESET);
 
 		musb->port1_status |= USB_PORT_STAT_RESET;
 		musb->port1_status &= ~USB_PORT_STAT_ENABLE;
@@ -156,12 +156,12 @@ static void musb_port_reset(struct musb 
 	} else {
 		DBG(4, "root port reset stopped\n");
 		musb_writeb(mbase, MUSB_POWER,
-				power & ~MGC_M_POWER_RESET);
+				power & ~MUSB_POWER_RESET);
 
 		musb->ignore_disconnect = FALSE;
 
 		power = musb_readb(mbase, MUSB_POWER);
-		if (power & MGC_M_POWER_HSMODE) {
+		if (power & MUSB_POWER_HSMODE) {
 			DBG(4, "high-speed device connected\n");
 			musb->port1_status |= USB_PORT_STAT_HIGH_SPEED;
 		}
@@ -309,7 +309,7 @@ int musb_hub_control(
 			u8		power;
 
 			power = musb_readb(musb->mregs, MUSB_POWER);
-			power &= ~MGC_M_POWER_RESUME;
+			power &= ~MUSB_POWER_RESUME;
 			DBG(4, "root port resume stopped, power %02x\n",
 					power);
 			musb_writeb(musb->mregs, MUSB_POWER, power);
@@ -368,31 +368,31 @@ int musb_hub_control(
 			switch (wIndex) {
 			case 1:
 				pr_debug("TEST_J\n");
-				temp = MGC_M_TEST_J;
+				temp = MUSB_TEST_J;
 				break;
 			case 2:
 				pr_debug("TEST_K\n");
-				temp = MGC_M_TEST_K;
+				temp = MUSB_TEST_K;
 				break;
 			case 3:
 				pr_debug("TEST_SE0_NAK\n");
-				temp = MGC_M_TEST_SE0_NAK;
+				temp = MUSB_TEST_SE0_NAK;
 				break;
 			case 4:
 				pr_debug("TEST_PACKET\n");
-				temp = MGC_M_TEST_PACKET;
+				temp = MUSB_TEST_PACKET;
 				musb_load_testpacket(musb);
 				break;
 			case 5:
 				pr_debug("TEST_FORCE_ENABLE\n");
-				temp = MGC_M_TEST_FORCE_HOST
-					| MGC_M_TEST_FORCE_HS;
+				temp = MUSB_TEST_FORCE_HOST
+					| MUSB_TEST_FORCE_HS;
 
-				musb_writeb(musb->mregs, MUSB_DEVCTL, MGC_M_DEVCTL_SESSION);
+				musb_writeb(musb->mregs, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);
 				break;
 			case 6:
 				pr_debug("TEST_FIFO_ACCESS\n");
-				temp = MGC_M_TEST_FIFO_ACCESS;
+				temp = MUSB_TEST_FIFO_ACCESS;
 				break;
 			default:
 				goto error;
Index: linux-2.6.18/mvl_patches/pro50-1716.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-1716.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1716);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

