#! /usr/bin/env bash
# Patch: -pro_emac_convert_to_platform_dev_and_remove_enum
# Date: Thu Feb 19 15:01:55 2009
# Source: MontaVista Software, Inc.
# MR: 28780
# Type: Enhancement
# Disposition: local
# Signed-off-by: Aleksey Makarov <amakarov@ru.mvista.com>
# Signed-off-by: Steve Chen <schen@mvista.com>
# Signed-off-by: Mikhail Cherkashin <mcherkashin@ru.mvista.com>
# Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
# Description:
# A step to introduce platform device support into DaVinci EMAC driver, plus
# some Linuxization of the code.
# 
#  drivers/net/davinci_emac.c | 1251 ++++++++++++++-------------------------------
#  1 files changed, 401 insertions(+), 850 deletions(-)
# 

PATCHNUM=2122
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc.
MR: 28780
Type: Enhancement
Disposition: local
Signed-off-by: Aleksey Makarov <amakarov@ru.mvista.com>
Signed-off-by: Steve Chen <schen@mvista.com>
Signed-off-by: Mikhail Cherkashin <mcherkashin@ru.mvista.com>
Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Description:
A step to introduce platform device support into DaVinci EMAC driver, plus
some Linuxization of the code.

 drivers/net/davinci_emac.c | 1251 ++++++++++++++-------------------------------
 mvl_patches/pro50-2122.c   |   16 
 2 files changed, 417 insertions(+), 850 deletions(-)

Index: linux-2.6.18/drivers/net/davinci_emac.c
===================================================================
--- linux-2.6.18.orig/drivers/net/davinci_emac.c
+++ linux-2.6.18/drivers/net/davinci_emac.c
@@ -77,6 +77,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/clk.h>
 #include <linux/platform_device.h>
+#include <linux/davinci_emac.h>
 
 #include <asm/irq.h>
 #include <asm/bitops.h>
@@ -105,11 +106,6 @@ static char *cfg_link_mode = "auto";
 module_param(cfg_link_mode, charp, 0);
 MODULE_PARM_DESC(cfg_link_mode, "Fixed mode of the Link: <fd/hd>");
 
-static int debug_mode = 0;
-module_param(debug_mode, int, 0);
-MODULE_PARM_DESC(debug_mode,
-		 "Turn on the debug info: <0/1>. Default is 0 (off)");
-
 /* version info */
 #define EMAC_MAJOR_VERSION         4
 #define EMAC_MINOR_VERSION         0
@@ -138,34 +134,14 @@ typedef void *emac_net_data_token;
 /* NO PHY used in case of external ethernet switches */
 #define CONFIG_EMAC_NOPHY              9999
 
-/* DaVinci specific configuration */
-#define EMAC_BASE_ADDR         IO_ADDRESS(DAVINCI_EMAC_CNTRL_REGS_BASE)
-#define EMAC_WRAPPER_REGS_ADDR IO_ADDRESS(DAVINCI_EMAC_WRAPPER_CNTRL_REGS_BASE)
-#define EMAC_WRAPPER_RAM_ADDR  IO_ADDRESS(DAVINCI_EMAC_WRAPPER_RAM_BASE)
-#define EMAC_WRAPPER_RAM_SIZE  (8 << 10)
-#define EMAC_MDIO_BASE_ADDR    IO_ADDRESS(DAVINCI_MDIO_CNTRL_REGS_BASE)
-
-/* DM646X defines */
-#define EMAC_DM646X_INTERRUPT         24
-#define EMAC_DM646X_NUM_INTERRUPTS    4
-/* NOTE:: on DavinciHD emac freqency is PLL0/4 = ARM Freq/2, update */
-#define EMAC_DM646X_BUS_FREQUENCY     148500000 /* PLL/4 i.e 148.5 MHz */
-#define EMAC_DM646X_MDIO_FREQUENCY    2200000   /* PHY bus frequency */
-#define EMAC_DM646X_PHY_MASK          0x3       /* PHY chip is at address 1 */
-
-/* DM644X defines */
-#define EMAC_INTERRUPT         13
-#define EMAC_NUM_INTERRUPTS      1
-#define EMAC_BUS_FREQUENCY     76500000	/* PLL/6 i.e 76.5 MHz */
-#define EMAC_MDIO_FREQUENCY    2200000	/* PHY bus frequency */
-#define EMAC_PHY_MASK          0x2	/* PHY chip is located at address 1 */
-#define EMAC_MAX_INTERRUPTS  EMAC_DM646X_NUM_INTERRUPTS
-
-#define EMAC_MAX_INTNAME_LENTH 20
 /* Note: For DaVinci, Buffer Descriptors are located in Wrapper RAM
  * (4K).  Half of the Wrapper memory is for RX BD's and other half for
  * TX BD's
  */
+#define EMAC_BASE_ADDR         IO_ADDRESS(DAVINCI_EMAC_CNTRL_REGS_BASE)
+#define EMAC_WRAPPER_REGS_ADDR IO_ADDRESS(DAVINCI_EMAC_WRAPPER_CNTRL_REGS_BASE)
+#define EMAC_WRAPPER_RAM_ADDR  IO_ADDRESS(DAVINCI_EMAC_WRAPPER_RAM_BASE)
+#define EMAC_WRAPPER_RAM_SIZE  (8 << 10)
 #define EMAC_TX_BD_MEM  EMAC_WRAPPER_RAM_ADDR
 #define EMAC_RX_BD_MEM (EMAC_WRAPPER_RAM_ADDR + (EMAC_WRAPPER_RAM_SIZE >> 1))
 
@@ -179,7 +155,6 @@ typedef void *emac_net_data_token;
 
 
 /* config macros */
-#define EMAC_MAX_INSTANCES                     1
 #define EMAC_MIN_ETHERNET_PKT_SIZE             60
 
 /* max RX fragments calculation - 1500 byte packet and 64 byte
@@ -493,7 +468,6 @@ typedef void *emac_net_data_token;
 #define EMAC_DEFAULT_BROADCAST_CHANNEL                 0
 #define EMAC_DEFAULT_MULTICAST_CHANNEL                 0
 #define EMAC_DEFAULT_BUFFER_OFFSET                     0
-#define EMAC_DEFAULT_TX_PRIO_TYPE                      EMAC_TXPRIO_FIXED
 #define EMAC_DEFAULT_TX_SHORT_GAP_ENABLE               FALSE
 #define EMAC_DEFAULT_TX_PACING_ENABLE                  FALSE
 #define EMAC_DEFAULT_MII_ENABLE                        TRUE
@@ -508,9 +482,6 @@ typedef void *emac_net_data_token;
 #define EMAC_DEFAULT_BROADCAST_ENABLE                  1
 #define EMAC_DEFAULT_MULTICAST_ENABLE                  1
 
-/* NOT EXPLICIT SUPPORT PROVIDED AS OF NOW - vlan support in the driver */
-#define EMAC_DEFAULT_VLAN_ENABLE       FALSE
-
 /* system value for ticks per seconds */
 #define EMAC_TICKS_PER_SEC             HZ
 
@@ -565,14 +536,6 @@ typedef void *emac_net_data_token;
  */
 #define EMAC_DEFAULT_EMAC_SIZE        0x4800
 
-/* ENV variable names for obtaining MAC addresses */
-#define EMAC_MAC_ADDR_A    "maca"
-#define EMAC_MAC_ADDR_B    "macb"
-#define EMAC_MAC_ADDR_C    "macc"
-#define EMAC_MAC_ADDR_D    "macd"
-#define EMAC_MAC_ADDR_E    "mace"
-#define EMAC_MAC_ADDR_F    "macf"
-
 /* Maximum multicast addresses list to be handled by the driver - If
  * this is not restricted then the driver will spend considerable time
  * in handling multicast lists
@@ -582,9 +545,6 @@ typedef void *emac_net_data_token;
 #define NETDEV_PRIV(net_dev)  netdev_priv(net_dev)
 #define FREE_NETDEV(net_dev)  free_netdev(net_dev)
 
-#define dbg_print if (emac_debug_mode) printk
-#define err_print printk
-
 /* misc error codes */
 #define EMAC_INTERNAL_FAILURE  -1
 
@@ -598,17 +558,6 @@ typedef void *emac_net_data_token;
 #define EMAC_TX_ACTIVITY       6
 #define EMAC_RX_ACTIVITY       7
 
-/*
- * L3 Alignment mechanism: The below given macro returns the number of
- * bytes required to align the given size to a L3 frame 4 byte
- * boundry. This is typically required to add 2 bytes to the ethernet
- * frame start to make sure the IP header (L3) is aligned on a 4 byte
- * boundry
- */
-static char emac_L3_align[] = { 0x02, 0x01, 0x00, 0x03 };
-
-#define EMAC_L3_ALIGN(size)    emac_L3_align[(size) & 0x3]
-
 /* 4 Byte alignment for skb's:
  *
  * Currently Skb's dont need to be on a 4 byte boundry, but other OS's
@@ -638,13 +587,10 @@ char emac_4byte_align[] = { 0x0, 0x03, 0
  */
 #ifdef EMAC_DEBUG
 #define LOG(lvl, format, args...) \
-  printk(lvl "%s:%d[%d]" format, __FUNCTION__, __LINE__, \
-         dev->init_cfg.inst_id, ##args)
+  printk(lvl "%s:%d" format, __func__, __LINE__, ##args)
 #define LOGERR(format, args...) LOG(KERN_ERR, format, ##args)
 #define LOGMSG(flag, format, args... )	\
   do { if (flag & emac_debug) LOG(KERN_DEBUG, #flag format, ##args); } while(0)
-#define DBG(format, args...) \
-  if (emac_debug_mode) printk(KERN_DEBUG "davinci_emac: " format, ##args)
 #define ERR(format, args...) \
   printk(KERN_ERR "ERROR: davinci_emac: " format, ##args)
 
@@ -738,7 +684,7 @@ typedef enum {
  * SOC memory map directly.
  * This is a template only, no memory is ever allocated for this!
  */
-typedef struct {
+struct emac_regs {
 	u32 tx_id_ver;
 	u32 tx_control;
 	u32 tx_teardown;
@@ -834,7 +780,9 @@ typedef struct {
 	u32 tx_CP[8];
 	u32 rx_CP[8];
 } emac_regs;
+#if 0
 typedef volatile emac_regs *emac_regs_ovly;
+#endif
 
 /**
  *  EMAC Peripheral Device Register Enumerations
@@ -1256,91 +1204,6 @@ typedef struct {
 	int buf_size;		/* buffer size (applicable for RX only) */
 } emac_ch_info;
 
-/**
- *  EMAC RX configuration
- *
- *  This data structure configures the RX module of the device
- */
-typedef struct {
-	bool pass_crc;		/* pass CRC bytes to packet memory */
-	bool qos_enable;	/* receive qo_s enable ? */
-	bool no_buffer_chaining;	/* DEBUG ONLY - ALWAYS SET TO FALSE */
-	bool copy_maccontrol_frames_enable;
-	bool copy_short_frames_enable;
-	bool copy_error_frames_enable;
-	bool promiscous_enable;
-	u32 promiscous_channel;	/* promiscous receive channel */
-	bool broadcast_enable;	/* receive broadcast frames ? */
-	u32 broadcast_channel;	/* broadcast receive channel */
-	bool multicast_enable;	/* receive multicast frames ? */
-	u32 multicast_channel;	/* multicast receive channel */
-	u32 max_rx_pkt_length;	/* max receive packet length */
-	u32 buffer_offset;	/* buffer offset for all RX channels */
-} emac_rx_config;
-
-/**
- *  Transmit Queue priority type
- *
- *  Enums for transmit queue priority type - fixed/round robin
- *  available in hardware
- */
-typedef enum {
-	EMAC_TXPRIO_ROUND_ROBIN = 0,
-	EMAC_TXPRIO_FIXED = 1
-} emac_tx_queue_priority_type;
-
-/**
- *  EMAC MAC configuration
- *
- *  This data structure configures the MAC module parameters of the device
- */
-typedef struct {
-	emac_tx_queue_priority_type p_type;
-	bool tx_short_gap_enable;
-	bool giga_bit_enable;
-	bool tx_pacing_enable;
-	bool mii_enable;	/* DEBUG ONLY - ALWAYS SET TO TRUE */
-	bool tx_flow_enable;
-	bool rx_flow_enable;
-	bool loopback_enable;
-	bool full_duplex_enable;	/* DEBUG ONLY - based upon phy_mode */
-	bool tx_interrupt_disable;
-} emac_mac_config;
-
-/**
- *  EMAC Init Configuration
- *
- *  Configuration information provided to DDC layer during
- *  initialization.  DDA gets the config information from the OS/PAL
- *  layer and passes the relevant config to the DDC during
- *  initialization. The config info can come from various sources -
- *  static compiled in info, boot time (ENV, Flash) info etc.
- */
-typedef struct {
-	u32 inst_id;
-	u32 num_tx_channels;
-	u32 num_rx_channels;
-	u32 emac_bus_frequency;
-	u32 base_address;
-	u32 e_wrap_base_address;
-	u32 intr_line;
-        u32 num_intr_lines;
-        char interrupt_name[EMAC_MAX_INTERRUPTS][EMAC_MAX_INTNAME_LENTH];
-	u32 reset_line;
-	u32 mdio_base_address;
-	u32 mdio_reset_line;
-	u32 mdio_intr_line;
-	u32 phy_mask;
-	u32 MLink_mask;
-	u32 mdio_bus_frequency;
-	u32 mdio_clock_frequency;
-	u32 mdio_tick_msec;
-	u32 mib64cnt_msec;
-	u32 phy_mode;
-	emac_rx_config rx_cfg;
-	emac_mac_config mac_cfg;
-} emac_init_config;
-
 typedef struct {
 	u32 rx_pkts;		/* number of rx pkts to be processed */
 	u32 tx_pkts;		/* number of tx pkts to be processed */
@@ -1373,7 +1236,7 @@ typedef struct {
 /**************************************************************************
  * Register Overlay Structure
  **************************************************************************/
-typedef struct {
+struct ewrap_dm646x_regs {
         u32 IDVER;
         u32 SOFTRST;
         u32 EMCTRL;
@@ -1408,18 +1271,18 @@ typedef struct {
         u32 C1_TXIMAX;
         u32 C2_RXIMAX;
         u32 C2_TXIMAX;
-} ewrap_dm646x_regs;
+};
 
-typedef struct {
+struct ewrap_dm644x_regs {
         u32 RSVD0;
         u32 EWCTL;
         u32 EWINTCNT;
-} ewrap_dm644x_regs;
+};
 
-typedef union {
-        ewrap_dm646x_regs wrapper_646x_regs;
-        ewrap_dm644x_regs wrapper_644x_regs;
-} ewrap_regs;
+union ewrap_regs {
+	struct ewrap_dm646x_regs wrapper_646x_regs;
+	struct ewrap_dm644x_regs wrapper_644x_regs;
+};
 
 /*
  *  TX Buffer Descriptor
@@ -1542,9 +1405,8 @@ typedef struct _emac_rx_cppi_ch_t {
  * member pointing to the net_device structure and the net_device data
  * structure's "priv" member points back to this data structure.
  */
-typedef struct emac_dev_s {
+struct emac_dev {
 	void *owner;		/* pointer to the net_device struct */
-	unsigned int instance_num;	/* instance number of the device */
 	struct net_device *next_device;
 	unsigned int link_speed;
 	unsigned int link_mode;
@@ -1556,13 +1418,10 @@ typedef struct emac_dev_s {
 
 	/* configuration parameters */
 	unsigned char mac_addr[6];
-	emac_init_config init_cfg;
+	struct emac_init_config init_cfg;
 	unsigned int rx_buf_size;
 	unsigned int rx_buf_offset;
 
-	/* TODO: VLAN TX not supported as of now */
-	bool vlan_enable;
-
 	/* channel configuration - though only 1 TX/RX channel is
 	 * supported, provision is made for max */
 	emac_ch_info tx_ch_info[EMAC_MAX_TX_CHANNELS];
@@ -1621,8 +1480,10 @@ typedef struct emac_dev_s {
 	/* EMAC/CPGMAC addressing mechanism */
 	u32 rx_addr_type;	/* 0 (EMAC), 1 or 2 (CPGMAC) */
 
-	emac_regs_ovly regs;
-	ewrap_regs *e_wrap_regs;
+	volatile struct emac_regs *regs;
+	volatile union ewrap_regs *ewrap_regs;
+	char *ewrap_ram;
+	unsigned long ewrap_ram_size;
 
 	struct mib2_if_hccounters mib2if_hccounter;
 
@@ -1631,38 +1492,25 @@ typedef struct emac_dev_s {
         u32 rx_en;
         u32 tx_en;
         u32 misc_en;
-} emac_dev_t;
+};
 
 /* ---------------------------------------------------------------
  * globals
  * --------------------------------------------------------------- */
 
-/* debug tracing */
-static int emac_link_status = 1;
-static int emac_debug_mode = 0;
-
 /* global variables required during initialization */
 static int g_link_speed = 0;	/* 0=auto negotiate, 100=100mbps, 10=10mbps */
 static int g_link_mode = 0;	/* 0=Auto Negotiate, Full Duplex = 3;
 				 * Half Duplex = 2 Unknown = 1 */
 static int g_init_enable_flag = 0;
 
-/* global device array */
-static struct net_device *emac_net_dev[EMAC_MAX_INSTANCES] = { NULL };
-
 static struct net_device *last_emac_device = NULL;
 static int emac_devices_installed = 0;	/* number of EMAC instances */
 
 static struct proc_dir_entry *gp_stats_file = NULL;	/* proc entries */
 
-static char emac_cfg[EMAC_MAX_INSTANCES][260];
-
 /* clock frequency for EMAC */
 static struct clk *emac_clk;
-static unsigned long emac_bus_frequency;
-
-/* MAC ethernet address string in 00:00:00:00:00:00 format */
-static unsigned char emac_eth_string[20] = "deadbeaf";
 
 static const char emac_ddcversion_string[] = "EMAC DDC version 0.5";
 
@@ -1681,19 +1529,19 @@ static int emac_dev_tx(struct sk_buff *s
 
 static irqreturn_t emac_hal_isr(int irq, void *dev_id, struct pt_regs *regs);
 
-static void *emac_net_alloc_rx_buf(emac_dev_t * dev, int buf_size,
+static void *emac_net_alloc_rx_buf(struct emac_dev *dev, int buf_size,
 				   emac_net_data_token * data_token,
 				   u32 channel, void *alloc_args);
 
-static int emac_net_free_rx_buf(emac_dev_t * dev, void *buffer,
+static int emac_net_free_rx_buf(struct emac_dev *dev, void *buffer,
 				emac_net_data_token data_token,
 				u32 channel, void *free_args);
 
-static int emac_net_tx_complete(emac_dev_t * dev,
+static int emac_net_tx_complete(struct emac_dev *dev,
 				emac_net_data_token * net_data_tokens,
 				int num_tokens, u32 channel);
 
-static int emac_net_rx_cb(emac_dev_t * dev,
+static int emac_net_rx_cb(struct emac_dev *dev,
 		   	  net_pkt_obj * net_pkt_list,
 			  void *rx_args);
 
@@ -1720,7 +1568,7 @@ static struct net_device_stats *emac_dev
 						       *dev);
 
 /* internal function prototypes */
-static int __init emac_p_detect_manual_cfg(int, char *, int);
+static int __init emac_p_detect_manual_cfg(int, char *);
 
 static int emac_p_read_stats(char *buf, char **start, off_t offset, int count,
 			     int *eof, void *data);
@@ -1745,100 +1593,103 @@ static int emac_p_reset_statistics(struc
 static int emac_p_read_rfc2665_stats(char *buf, char **start, off_t offset,
 				     int count, int *eof, void *data);
 
-static int emac_p_dev_enable(emac_dev_t * dev);
+static int emac_p_dev_enable(struct emac_dev *dev);
 
-static int emac_p_dev_disable(emac_dev_t * dev);
+static int emac_p_dev_disable(struct emac_dev *dev);
 
-static void emac_p_tick_timer_expiry(emac_dev_t * dev);
+static void emac_p_tick_timer_expiry(struct emac_dev *dev);
 
 static int emac_dev_set_mac_addr(struct net_device *netdev, void *addr);
 
-static void emac_disable_interrupt(emac_dev_t *edev);
+static void emac_disable_interrupt(struct emac_dev *edev);
 
-static void emac_enable_interrupt(emac_dev_t *edev, int ack_eoi);
+static void emac_enable_interrupt(struct emac_dev *edev, int ack_eoi);
 
 /* function prototype for emac_p_tick_timer_expiry() function as per
  * linux timer API */
 typedef void (*timer_tick_func) (unsigned long);
 
 /* DDA function table */
-static int emac_control_cb(emac_dev_t * dev, int cmd,
+static int emac_control_cb(struct emac_dev *dev, int cmd,
 			   void *cmd_arg, void *param);
 
 /* function prototypes */
-static int emac_send(emac_dev_t * dev, net_pkt_obj * pkt,
+static int emac_send(struct emac_dev *dev, net_pkt_obj *pkt,
 		     int channel, bool send_args);
 
-static int emac_tick(emac_dev_t * dev, void *tick_args);
+static int emac_tick(struct emac_dev *dev, void *tick_args);
 
-static int emac_pkt_process(emac_dev_t * dev, int *pkts_pending,
+static int emac_pkt_process(struct emac_dev *dev, int *pkts_pending,
 			    void *pkt_args);
 
-static int emac_pkt_process_end(emac_dev_t * dev, void *proc_args);
+static int emac_pkt_process_end(struct emac_dev *dev, void *proc_args);
 
-static int emac_tx_bdproc(emac_dev_t * dev, u32 channel, u32 * more_pkts,
+static int emac_tx_bdproc(struct emac_dev *dev, u32 channel, u32 *more_pkts,
 			  bool * is_eoq);
 
-static int emac_rx_bdproc(emac_dev_t * dev, u32 channel, int *more_pkts);
+static int emac_rx_bdproc(struct emac_dev *dev, u32 channel, int *more_pkts);
 
 #ifdef EMAC_MULTIFRAGMENT
-static void emac_add_bdto_rx_queue(emac_dev_t * dev, emac_rx_cppi_ch * rx_cppi,
-				   emac_rx_bd * sop_bd, emac_rx_bd * eop_bd,
-				   u32 * buffer,
-				   emac_net_data_token * buf_token, u32 num_bd);
+static void emac_add_bdto_rx_queue(struct emac_dev *dev,
+		emac_rx_cppi_ch *rx_cppi, emac_rx_bd *sop_bd,
+		emac_rx_bd *eop_bd, u32 *buffer,
+		emac_net_data_token *buf_token, u32 num_bd);
 
 #else
-static void emac_add_bdto_rx_queue(emac_dev_t * dev, emac_rx_cppi_ch * rx_cppi,
-				   emac_rx_bd * curr_bd, char *buffer,
-				   emac_net_data_token buf_token);
+static void emac_add_bdto_rx_queue(struct emac_dev *dev,
+		emac_rx_cppi_ch *rx_cppi, emac_rx_bd *curr_bd, char *buffer,
+		emac_net_data_token buf_token);
 #endif
 
-static int emac_update_phy_status(emac_dev_t * dev);
+static int emac_update_phy_status(struct emac_dev *dev);
 
-static int emac_init(emac_dev_t * dev, emac_init_config * init_cfg);
+static int emac_init(struct emac_dev *dev, struct emac_init_config *init_cfg);
 
-static int emac_de_init(emac_dev_t * dev, void *param);
+static int emac_de_init(struct emac_dev *dev, void *param);
 
-static int emac_open(emac_dev_t * dev, void *param);
+static int emac_open(struct emac_dev *dev, void *param);
 
-static int emac_close(emac_dev_t * dev, void *param);
+static int emac_close(struct emac_dev *dev, void *param);
 
-static int emac_control(emac_dev_t * dev, int cmd, void *cmd_arg, void *param);
+static int emac_control(struct emac_dev *dev, int cmd, void *cmd_arg,
+		void *param);
 
-static int emac_ch_open(emac_dev_t * dev, emac_ch_info * ch_info,
+static int emac_ch_open(struct emac_dev *dev, emac_ch_info *ch_info,
 			void *ch_open_args);
 
-static int emac_ch_close(emac_dev_t * dev, int channel,
+static int emac_ch_close(struct emac_dev *dev, int channel,
 			 int direction, void *ch_close_args);
 
-static int emac_wait_for_teardown_complete(emac_dev_t * dev,
+static int emac_wait_for_teardown_complete(struct emac_dev *dev,
 					   u32 channel,
 					   net_ch_dir direction, bool blocking);
 
-static int emac_enable_channel(emac_dev_t * dev, u32 channel, u32 direction);
+static int emac_enable_channel(struct emac_dev *dev, u32 channel,
+		u32 direction);
 
-static int emac_disable_channel(emac_dev_t * dev, u32 channel,
+static int emac_disable_channel(struct emac_dev *dev, u32 channel,
 				net_ch_dir direction);
 
-static int emac_init_tx_channel(emac_dev_t * dev, emac_ch_info * ch_info,
+static int emac_init_tx_channel(struct emac_dev *dev, emac_ch_info *ch_info,
 				void *ch_open_args);
 
-static int emac_init_rx_channel(emac_dev_t * dev, emac_ch_info * ch_info,
+static int emac_init_rx_channel(struct emac_dev *dev, emac_ch_info *ch_info,
 				void *ch_open_args);
 
-static int emac_un_init_tx_channel(emac_dev_t * dev, u32 channel,
+static int emac_un_init_tx_channel(struct emac_dev *dev, u32 channel,
 				   void *ch_close_args);
 
-static int emac_un_init_rx_channel(emac_dev_t * dev, u32 channel,
+static int emac_un_init_rx_channel(struct emac_dev *dev, u32 channel,
 				   void *ch_close_args);
 
-static void emac_set_mac_address(emac_dev_t * dev, u32 channel, char *mac_addr);
+static void emac_set_mac_address(struct emac_dev *dev, u32 channel,
+		char *mac_addr);
 
-static void emac_ddcifcnt_clear(emac_dev_t * dev);
+static void emac_ddcifcnt_clear(struct emac_dev *dev);
 
-static void emac_ddcifcnt_updt(emac_dev_t * dev);
+static void emac_ddcifcnt_updt(struct emac_dev *dev);
 
-static void emac_ddcphycnt(emac_dev_t * dev, u32 * cmd_arg);
+static void emac_ddcphycnt(struct emac_dev *dev, u32 *cmd_arg);
 
 /* ---------------------------------------------------------------
  * internal utility functions
@@ -1917,92 +1768,15 @@ static void emac_str_to_ethaddr(unsigned
 	}
 }
 
-static int emac_cfg_build(int connect, int external_switch)
-{
-
-	static int cfg_instance = 0;
-
-	unsigned int speed = 0;
-
-	speed = (external_switch) ? CONFIG_EMAC_NOPHY : 0;
-
-	if (device_is_dm646x)
-        sprintf(emac_cfg[cfg_instance],
-                "%d:%x:%d:%d:%u:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%x:%d:%d:%u:%u:%x:%d:%d:%s:%s:%s:%s:",
-                cfg_instance, EMAC_BASE_ADDR,
-                EMAC_DM646X_INTERRUPT, 0, EMAC_DM646X_BUS_FREQUENCY,
-                g_link_speed, g_link_mode, EMAC_DEFAULT_PROMISCOUS_ENABLE,
-		EMAC_DEFAULT_BROADCAST_ENABLE,
-                EMAC_DEFAULT_MULTICAST_ENABLE,
-                EMAC_DEFAULT_MAX_FRAME_SIZE,
-                EMAC_DEFAULT_TX_NUM_BD,
-                EMAC_DEFAULT_TX_MAX_SERVICE, EMAC_DEFAULT_RX_NUM_BD,
-                EMAC_DEFAULT_RX_MAX_SERVICE, 0,
-                EMAC_MDIO_BASE_ADDR, 0, 0,
-                EMAC_DM646X_BUS_FREQUENCY, EMAC_DM646X_MDIO_FREQUENCY,
-		EMAC_DM646X_PHY_MASK, 10,EMAC_DM646X_NUM_INTERRUPTS,
-		"EMAC RX Threshold","EMAC Receive","EMAC Transmit","EMAC Misc");
-	else
-	sprintf(emac_cfg[cfg_instance],
-		"%d:%x:%d:%d:%u:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%x:%d:%d:%u:%u:%x:%d:%d:%s:",
-		cfg_instance, EMAC_BASE_ADDR,
-		EMAC_INTERRUPT, 0, EMAC_BUS_FREQUENCY,
-		g_link_speed, g_link_mode, EMAC_DEFAULT_PROMISCOUS_ENABLE,
-		EMAC_DEFAULT_BROADCAST_ENABLE,
-		EMAC_DEFAULT_MULTICAST_ENABLE,
-		EMAC_DEFAULT_MAX_FRAME_SIZE,
-		EMAC_DEFAULT_TX_NUM_BD,
-		EMAC_DEFAULT_TX_MAX_SERVICE, EMAC_DEFAULT_RX_NUM_BD,
-		EMAC_DEFAULT_RX_MAX_SERVICE, 0,
-		EMAC_MDIO_BASE_ADDR, 0, 0,
-		EMAC_BUS_FREQUENCY, EMAC_MDIO_FREQUENCY, EMAC_PHY_MASK,10,
-		EMAC_NUM_INTERRUPTS,"EMAC");
-
-	DBG("Driver Config:\n%s\n", emac_cfg[cfg_instance]);
-
-	cfg_instance++;
-
-	return (0);
-
-}
-
-/* emac_eth_setup() invokes a board specific function that provides
- * MAC address for this adapter. For DaVinci EVM, the function invoked
- * is davinci_get_macaddr();
- */
-static int emac_eth_setup(void)
-{
-	if (davinci_get_macaddr(&emac_eth_string[0]) != 0) {
-		printk("TI DaVinci EMAC: Error getting board specific "
-		       "MAC address\n");
-		printk("Assuming default MAC address\n");
-		return (-1);
-	} else {
-		printk("TI DaVinci EMAC: MAC address is %s\n", emac_eth_string);
-	}
-
-	return (0);
-}
-
-static int emac_cfg_probe(void)
-{
-
-	/* for DaVinci there is only 1 EMAC instance */
-	if (emac_cfg_build(0, 0))
-		return (-1);
-	else
-		return (0);
-}
-
 /******************************************************************************
  *  DDA Callback functions
  *****************************************************************************/
 
 /* emac_control_cb - ioctl function to be called by the DDC */
-static int emac_control_cb(emac_dev_t * dev, int cmd,
+static int emac_control_cb(struct emac_dev *dev, int cmd,
 			   void *cmd_arg, void *param)
 {
-	emac_mac_config *cfg;
+	struct emac_mac_config *cfg;
 
 	switch (cmd) {
 	case EMAC_IOCTL_TIMER_START:
@@ -2095,8 +1869,7 @@ static int emac_control_cb(emac_dev_t * 
 				}
 			}
 
-			if (emac_link_status)
-				DBG("%s, PhyNum %d,  %s, %s, %s\n",
+				pr_debug("%s, PhyNum %d,  %s, %s, %s\n",
 				    ((struct net_device *)dev->owner)->name,
 				    status->phy_num,
 				    ((status->phy_duplex == PHY_DUPLEX_FULL) ?
@@ -2137,7 +1910,7 @@ static int emac_control_cb(emac_dev_t * 
 		break;
 
 	default:
-		DBG("Unhandled ioctl code %d\n", cmd);
+		pr_debug("Unhandled ioctl code %d\n", cmd);
 		break;
 	}
 
@@ -2157,152 +1930,28 @@ static int emac_control_cb(emac_dev_t * 
  *
  * RETURNS: OK or ERROR.
  */
-static int emac_net_get_config(emac_dev_t * dev)
+static int emac_net_get_config(struct emac_dev *dev)
 {
-#define EMAC_TOKEN_PARSE(str) \
-  { if ((tok = (char *)strsep ((str), ":")) == NULL) return -1; }
-#define EMAC_TOKEN_GET_INTEGER simple_strtoul (tok, NULL, 10)
-#define EMAC_TOKEN_GET_HEX     simple_strtoul (tok, NULL, 16)
-	emac_init_config *i_cfg = &dev->init_cfg;
+	struct emac_init_config *i_cfg = &dev->init_cfg;
 	emac_ch_info *tx_ch_cfg = &dev->tx_ch_info[0];
 	emac_ch_info *rx_ch_cfg = &dev->rx_ch_info[0];
-	int speed, duplex, extra, i;
-	char local_string_val[260];
-	char *local_string = NULL;
-	char *tok;
-	char *p_holder = NULL;
-
-	/* use static config string */
-	switch (dev->instance_num) {
-	case 0:
-		local_string = emac_cfg[0];
-		break;
-	case 1:
-		local_string = emac_cfg[1];
-		break;
-	default:
-		local_string = emac_cfg[0];
-		break;
-	}
 
-	strcpy(&local_string_val[0], local_string);
-	local_string = &local_string_val[0];
-	p_holder = NULL;
-	tok = (char *)strsep(&local_string, ":");
-	if (tok == NULL)
-		return (-1);
+	i_cfg->rx_cfg.promiscous_enable = 0;
+	i_cfg->rx_cfg.broadcast_enable = 1;
+	i_cfg->rx_cfg.multicast_enable = 1;
+
+	i_cfg->rx_cfg.max_rx_pkt_length = EMAC_DEFAULT_MAX_FRAME_SIZE;
+
+	tx_ch_cfg->num_bd = EMAC_DEFAULT_TX_NUM_BD;
+	tx_ch_cfg->service_max = EMAC_DEFAULT_TX_MAX_SERVICE;
+	rx_ch_cfg->num_bd = EMAC_DEFAULT_RX_NUM_BD;
+	rx_ch_cfg->service_max = EMAC_DEFAULT_RX_MAX_SERVICE;
 
-	i_cfg->inst_id = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("i_cfg->instId=%d", i_cfg->inst_id);
-
-	i_cfg->base_address = EMAC_TOKEN_GET_HEX;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->baseAddress=%08X", i_cfg->base_address);
-
-	i_cfg->intr_line = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->intrLine=%d", i_cfg->intr_line);
-
-	i_cfg->reset_line = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->resetLine=%d", i_cfg->reset_line);
-
-	i_cfg->emac_bus_frequency = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->emacBusFrequency=%d", i_cfg->emac_bus_frequency);
-
-	speed = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\nspeed=%d", speed);
-
-	duplex = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\nduplex=%d", duplex);
-
-	i_cfg->rx_cfg.promiscous_enable = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->rxCfg.promiscousEnable=%d",
-	    i_cfg->rx_cfg.promiscous_enable);
-
-	i_cfg->rx_cfg.broadcast_enable = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->rxCfg.broadcastEnable=%d",
-	    i_cfg->rx_cfg.broadcast_enable);
-
-	i_cfg->rx_cfg.multicast_enable = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->rxCfg.multicastEnable=%d",
-	    i_cfg->rx_cfg.multicast_enable);
-
-	i_cfg->rx_cfg.max_rx_pkt_length = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->rxCfg.maxRxPktLength=%d",
-	    i_cfg->rx_cfg.max_rx_pkt_length);
-
-	tx_ch_cfg->num_bd = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ntx_ch_cfg->num_bd=%d", tx_ch_cfg->num_bd);
-
-	tx_ch_cfg->service_max = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ntx_ch_cfg->service_max=%d", tx_ch_cfg->service_max);
-
-	rx_ch_cfg->num_bd = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\nrx_ch_cfg->num_bd=%d", rx_ch_cfg->num_bd);
-
-	rx_ch_cfg->service_max = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\nrx_ch_cfg->service_max=%d", rx_ch_cfg->service_max);
-
-	extra = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\nextra=%d", extra);
-
-	i_cfg->mdio_base_address = EMAC_TOKEN_GET_HEX;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->mdioBaseAddress=%08X", i_cfg->mdio_base_address);
-
-	i_cfg->mdio_intr_line = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->mdioIntrLine=%d", i_cfg->mdio_intr_line);
-
-	i_cfg->mdio_reset_line = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->mdioResetLine=%d", i_cfg->mdio_reset_line);
-
-	i_cfg->mdio_bus_frequency = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->MdioBusFrequency=%d", i_cfg->mdio_bus_frequency);
-
-	i_cfg->mdio_clock_frequency = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->MdioClockFrequency=%d", i_cfg->mdio_clock_frequency);
-
-	i_cfg->phy_mask = EMAC_TOKEN_GET_HEX;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->PhyMask=%08X", i_cfg->phy_mask);
-
-	i_cfg->mdio_tick_msec = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->MdioTickMSec=%d", i_cfg->mdio_tick_msec);
-
-	i_cfg->num_intr_lines = EMAC_TOKEN_GET_INTEGER;
-	EMAC_TOKEN_PARSE(&local_string);
-	DBG("\ni_cfg->num_intr_lines=%d", i_cfg->num_intr_lines);
-
-        for (i = 0; i < i_cfg->num_intr_lines; i++) {
-		strncpy(i_cfg->interrupt_name[i],tok,EMAC_MAX_INTNAME_LENTH);
-	        EMAC_TOKEN_PARSE(&local_string);
-		DBG("\ni_cfg->interrupt_name[%d]=%s",i, i_cfg->interrupt_name[i]);
-	}
-	DBG("\n");
+	i_cfg->mdio_tick_msec = 10;
 
 	i_cfg->mib64cnt_msec = CONFIG_EMAC_MIB_TIMER_TIMEOUT;
 	rx_ch_cfg->buf_size = i_cfg->rx_cfg.max_rx_pkt_length;
-	dev->rx_buf_offset =
-	    EMAC_L3_ALIGN(extra) + EMAC_DEFAULT_EXTRA_RXBUF_SIZE;
+	dev->rx_buf_offset = EMAC_DEFAULT_EXTRA_RXBUF_SIZE;
 	dev->rx_buf_size = (rx_ch_cfg->buf_size + dev->rx_buf_offset);
 
 	/* align skb's on 4 byte boundry - no hard requirement currently - done for future use */
@@ -2310,34 +1959,34 @@ static int emac_net_get_config(emac_dev_
 
 	/* determine phy speed/duplex mode - to be built as per MDIO
 	 * module requirements */
-	if (speed == CONFIG_EMAC_NOPHY) {
+	if (g_link_speed == CONFIG_EMAC_NOPHY) {
 		i_cfg->phy_mode = SNWAY_NOPHY;
 	} else {
-		if ((speed == 0) && (duplex == PHY_DUPLEX_AUTO)) {
+		if ((g_link_speed == 0) && (g_link_mode == PHY_DUPLEX_AUTO)) {
 			i_cfg->phy_mode = SNWAY_AUTOALL;
-		} else if (speed == 10) {
-			if (duplex == PHY_DUPLEX_HALF)
+		} else if (g_link_speed == 10) {
+			if (g_link_mode == PHY_DUPLEX_HALF)
 				i_cfg->phy_mode = SNWAY_HD10;
-			else if (duplex == PHY_DUPLEX_FULL)
+			else if (g_link_mode == PHY_DUPLEX_FULL)
 				i_cfg->phy_mode = SNWAY_FD10;
 			else
 				i_cfg->phy_mode = SNWAY_HD10 | SNWAY_FD10;
-		} else if (speed == 100) {
-			if (duplex == PHY_DUPLEX_HALF)
+		} else if (g_link_speed == 100) {
+			if (g_link_mode == PHY_DUPLEX_HALF)
 				i_cfg->phy_mode = SNWAY_HD100;
-			else if (duplex == PHY_DUPLEX_FULL)
+			else if (g_link_mode == PHY_DUPLEX_FULL)
 				i_cfg->phy_mode = SNWAY_FD100;
 			else
 				i_cfg->phy_mode = SNWAY_HD100 | SNWAY_FD100;
-		} else if (speed == 1000) {
-			if (duplex == PHY_DUPLEX_HALF)
+		} else if (g_link_speed == 1000) {
+			if (g_link_mode == PHY_DUPLEX_HALF)
 				i_cfg->phy_mode = SNWAY_HD1000;
-			else if (duplex == PHY_DUPLEX_FULL)
+			else if (g_link_mode == PHY_DUPLEX_FULL)
 				i_cfg->phy_mode = SNWAY_FD1000;
 			else
 				i_cfg->phy_mode = SNWAY_HD1000 | SNWAY_FD1000;
 		} else {
-			if (duplex == PHY_DUPLEX_FULL) {
+			if (g_link_mode == PHY_DUPLEX_FULL) {
 				i_cfg->phy_mode = SNWAY_FD10 | SNWAY_FD100;
                                 if (device_is_dm646x)
                                         i_cfg->phy_mode |= SNWAY_FD1000;
@@ -2350,10 +1999,9 @@ static int emac_net_get_config(emac_dev_
 		}
 	}
 
-	dev->vlan_enable = EMAC_DEFAULT_VLAN_ENABLE;
 	i_cfg->num_tx_channels = EMAC_DEFAULT_NUM_TX_CHANNELS;
 	i_cfg->num_rx_channels = EMAC_DEFAULT_NUM_RX_CHANNELS;
-	i_cfg->MLink_mask = EMAC_DEFAULT_MLINK_MASK;
+	i_cfg->m_link_mask = EMAC_DEFAULT_MLINK_MASK;
 	i_cfg->rx_cfg.pass_crc = EMAC_DEFAULT_PASS_CRC;
 	i_cfg->rx_cfg.qos_enable = EMAC_DEFAULT_QOS_ENABLE;
 	i_cfg->rx_cfg.no_buffer_chaining = EMAC_DEFAULT_NO_BUFFER_CHAINING;
@@ -2367,10 +2015,10 @@ static int emac_net_get_config(emac_dev_
 	i_cfg->rx_cfg.broadcast_channel = EMAC_DEFAULT_BROADCAST_CHANNEL;
 	i_cfg->rx_cfg.multicast_channel = EMAC_DEFAULT_MULTICAST_CHANNEL;
 	i_cfg->rx_cfg.buffer_offset = EMAC_DEFAULT_BUFFER_OFFSET;
-	i_cfg->mac_cfg.p_type = EMAC_TXPRIO_FIXED;
+	i_cfg->mac_cfg.priority_is_fixed = 1;
 	i_cfg->mac_cfg.tx_short_gap_enable = FALSE;
 
-	if (speed == 1000)
+	if (g_link_speed == 1000)
 		i_cfg->mac_cfg.giga_bit_enable = TRUE;
 	else
 		i_cfg->mac_cfg.giga_bit_enable = FALSE;
@@ -2392,31 +2040,24 @@ static int emac_net_get_config(emac_dev_
 	/* module control EWrap base address for DaVinci */
 	i_cfg->e_wrap_base_address = EMAC_WRAPPER_REGS_ADDR;
 
-	DBG("\n");
 	return (0);
 }
 
 /* detect manual config */
-static int __init emac_p_detect_manual_cfg(int link_speed, char *link_mode,
-					   int debug)
+static int __init emac_p_detect_manual_cfg(int link_speed, char *link_mode)
 {
-	if (debug == 1) {
-		emac_debug_mode = 1;
-		DBG("Enabled debug print.\n");
-	}
-
 	if ((link_speed == 0) && (!strcmp(link_mode, "auto"))) {
 		/* Auto negotiation */
 		g_link_speed = 0;
 		g_link_mode = 0;
-		DBG("auto negotiation selected\n");
+		pr_debug("auto negotiation selected\n");
 	}
 
 	if (!link_speed || (link_speed != 10 && link_speed != 100
 				&& link_speed != 1000)) {
 		g_link_speed = 0;
 		g_link_mode = 0;
-		DBG("Invalid or No value of link speed specified,"
+		pr_debug("Invalid or No value of link speed specified,"
 		    "defaulting to auto negotiation .\n");
 	}
 
@@ -2424,7 +2065,7 @@ static int __init emac_p_detect_manual_c
 	    || (!strcmp(link_mode, "fd") && !strcmp(link_mode, "hd"))) {
 		g_link_speed = 0;
 		g_link_mode = 0;
-		DBG("Invalid or No value of link mode specified,"
+		pr_debug("Invalid or No value of link mode specified,"
 		    "defaulting to auto mode.\n");
 	}
 
@@ -2448,7 +2089,7 @@ static int __init emac_p_detect_manual_c
 		g_link_mode = 0;
 	}
 
-	DBG("Link is set to the speed of"
+	pr_debug("Link is set to the speed of"
 	    "%s speed and %s mode.\n",
 	    ((g_link_speed ==
 		0) ? "auto" : ((g_link_speed == 100) ? "100" :
@@ -2465,7 +2106,7 @@ static int emac_p_read_link(char *buf, c
 {
 	int len = 0;
 	struct net_device *netdev;
-	emac_dev_t *dev;
+	struct emac_dev *dev;
 	struct net_device *emac_dev_list[emac_devices_installed];
 	int i;
 
@@ -2489,9 +2130,9 @@ static int emac_p_read_link(char *buf, c
 		if (netif_carrier_ok(netdev)) {
 			len +=
 			    sprintf(buf + len,
-				    "eth%d: Link State: %s    "
+				    "%s: Link State: %s    "
 				    "Phy %d, Speed = %s, Duplex = %s\n",
-				    dev->instance_num, "UP",
+				    netdev->name, "UP",
 				    dev->ddc_status.phy_num,
 				    (dev->link_speed ==
 				     100000000) ? "100" :
@@ -2501,8 +2142,8 @@ static int emac_p_read_link(char *buf, c
 
 		} else {
 			len +=
-			    sprintf(buf + len, "eth%d: Link State: DOWN\n",
-				    dev->instance_num);
+			    sprintf(buf + len, "%s: Link State: DOWN\n",
+				    netdev->name);
 		}
 		netdev = dev->next_device;
 	}
@@ -2518,7 +2159,7 @@ static int emac_dump_config(char *buf, c
 	struct net_device *netdev;
 	struct net_device *emac_dev_list[emac_devices_installed];
 	int i;
-	emac_dev_t *dev;
+	struct emac_dev *dev;
 
 	len +=
 	    sprintf(buf + len, "EMAC devices = %d\n", emac_devices_installed);
@@ -2539,11 +2180,8 @@ static int emac_dump_config(char *buf, c
 
 		len +=
 		    sprintf(buf + len,
-			    "\nEMAC Driver Internal Config Info for Unit %d\n",
-			    dev->instance_num);
-		len +=
-		    sprintf(buf + len, "vlanEnable         = %d\n",
-			    dev->vlan_enable);
+			    "\nEMAC Driver Internal Config Info for %s\n",
+			    netdev->name);
 		len +=
 		    sprintf(buf + len, "rxBufSize          = %d\n",
 			    dev->rx_buf_size);
@@ -2551,9 +2189,6 @@ static int emac_dump_config(char *buf, c
 		    sprintf(buf + len, "rxBufOffset        = %d\n",
 			    dev->rx_buf_offset);
 		len +=
-		    sprintf(buf + len, "instId             = %d\n",
-			    dev->init_cfg.inst_id);
-		len +=
 		    sprintf(buf + len, "numTxChannels      = %d\n",
 			    dev->init_cfg.num_tx_channels);
 		len +=
@@ -2585,7 +2220,7 @@ static int emac_dump_config(char *buf, c
 			    dev->init_cfg.phy_mask);
 		len +=
 		    sprintf(buf + len, "MLinkMask          = %08X\n",
-			    dev->init_cfg.MLink_mask);
+			    dev->init_cfg.m_link_mask);
 		len +=
 		    sprintf(buf + len, "MdioBusFrequency   = %d\n",
 			    dev->init_cfg.mdio_bus_frequency);
@@ -2642,7 +2277,7 @@ static int emac_dump_config(char *buf, c
 			    dev->init_cfg.rx_cfg.buffer_offset);
 		len +=
 		    sprintf(buf + len, "pType              = %d\n",
-			    dev->init_cfg.mac_cfg.p_type);
+			    dev->init_cfg.mac_cfg.priority_is_fixed);
 		len +=
 		    sprintf(buf + len, "txShortGapEnable   = %d\n",
 			    dev->init_cfg.mac_cfg.tx_short_gap_enable);
@@ -2682,7 +2317,7 @@ static int emac_p_read_stats(char *buf, 
 	int limit = count - 80;
 	int i;
 	struct net_device *emac_dev_list[emac_devices_installed];
-	emac_dev_t *dev;
+	struct emac_dev *dev;
 	emac_hw_statistics *p_device_mib;
 
 	/* reverse the the device link list to list eth0,eth1...in
@@ -2860,7 +2495,7 @@ static int emac_p_write_stats(struct fil
 		struct net_device *netdev = last_emac_device;
 		int i;
 		struct net_device *emac_dev_list[emac_devices_installed];
-		emac_dev_t *dev;
+		struct emac_dev *dev;
 
 		/* valid command */
 		printk("Resetting statistics for EMAC interface.\n");
@@ -2911,7 +2546,7 @@ static int emac_p_read_rfc2665_stats(cha
 /* reset statistics */
 static int emac_p_reset_statistics(struct net_device *netdev)
 {
-	emac_dev_t *dev = NETDEV_PRIV(netdev);
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
 
 	memset(&dev->device_mib, 0, sizeof(emac_hw_statistics));
 	memset(&dev->device_stats, 0, sizeof(emac_drv_stats));
@@ -2939,7 +2574,7 @@ static int emac_p_update_statistics(stru
 	unsigned long if_in_discards = 0;
 	unsigned long if_out_errors = 0;
 	unsigned long if_in_errors = 0;
-	emac_dev_t *dev = NETDEV_PRIV(netdev);
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
 	emac_hw_statistics *p_device_mib = &dev->device_mib;
 	emac_drv_stats *p_stats = &dev->device_stats;
 	emac_hw_statistics local_mib;
@@ -3228,7 +2863,7 @@ static int emac_p_get_version(char *buf,
 }
 
 /* tick timer */
-static void emac_p_tick_timer_expiry(emac_dev_t * dev)
+static void emac_p_tick_timer_expiry(struct emac_dev *dev)
 {
 	struct timer_list *p_timer = &dev->periodic_timer;
 
@@ -3246,7 +2881,7 @@ static void emac_p_tick_timer_expiry(ema
 }
 
 /* mib timer */
-static void emac_p_mib_timer_expiry(emac_dev_t * dev)
+static void emac_p_mib_timer_expiry(struct emac_dev *dev)
 {
 	struct timer_list *p_timer = &dev->mib_timer;
 
@@ -3268,7 +2903,7 @@ static void emac_p_mib_timer_expiry(emac
  *****************************************************************************/
 
 /* enable the device - init TX/RX channels and open DDC */
-static int emac_p_dev_enable(emac_dev_t * dev)
+static int emac_p_dev_enable(struct emac_dev *dev)
 {
 	int ret_code;
 	struct net_device *netdev = dev->owner;
@@ -3308,7 +2943,7 @@ static int emac_p_dev_enable(emac_dev_t 
 }
 
 /* disable the device - teardown chanels and close DDC */
-static int emac_p_dev_disable(emac_dev_t * dev)
+static int emac_p_dev_disable(struct emac_dev *dev)
 {
 	int ret_code;
 	struct net_device *netdev = dev->owner;
@@ -3333,7 +2968,7 @@ static int emac_p_dev_disable(emac_dev_t
 			dev->timer_active = FALSE;
 		}
 
-		DBG("Device %s Closed.\n", netdev->name);
+		pr_debug("Device %s Closed.\n", netdev->name);
 		dev->device_stats.start_tick = jiffies;
 		dev->link_speed = 100000000;
 		dev->link_mode = 1;
@@ -3351,7 +2986,7 @@ static int emac_p_dev_disable(emac_dev_t
 static struct net_device_stats *emac_dev_get_net_stats(struct net_device
 						       *netdev)
 {
-	emac_dev_t *dev = NETDEV_PRIV(netdev);
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
 
 	emac_p_update_statistics(netdev, NULL, 0, NULL);
 	return &dev->net_dev_stats;
@@ -3360,7 +2995,7 @@ static struct net_device_stats *emac_dev
 /* set multicast address in the driver */
 static void emac_dev_mcast_set(struct net_device *netdev)
 {
-	emac_dev_t *dev = NETDEV_PRIV(netdev);
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
 
 	if (netdev->flags & IFF_PROMISC) {
 		/* enable promiscous mode */
@@ -3414,7 +3049,7 @@ static void emac_dev_mcast_set(struct ne
 				     mc_ptr->dmi_addr);
 		}
 	} else {
-		DBG("%s:No Multicast address to set.\n", netdev->name);
+		pr_debug("%s:No Multicast address to set.\n", netdev->name);
 	}
 }
 
@@ -3423,7 +3058,7 @@ static int emac_dev_set_mac_addr(struct 
 	int ret_code;
 	emac_address_params address_params;
 	struct sockaddr *sa = addr;
-	emac_dev_t *dev = NETDEV_PRIV(netdev);
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
 
 	address_params.channel = EMAC_DEFAULT_RX_CHANNEL;
 	address_params.mac_address = sa->sa_data;
@@ -3447,7 +3082,7 @@ static int emac_dev_set_mac_addr(struct 
 static void emac_tx_timeout(struct net_device *netdev)
 {
 	int ret_code;
-	emac_dev_t *dev = NETDEV_PRIV(netdev);
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
 
 	printk("EMAC Tx Timeout: Closing TX channel\n");
 	emac_ch_close(dev,
@@ -3571,36 +3206,23 @@ struct ethtool_ops ethtool_ops = {
  *  addresses and assignes the device's methods.
  *
  **************************************************************/
+
 static int emac_dev_init(struct net_device *netdev)
 {
 	int cnt, init_status = 0;
 	int ret_code;
-	char *mac_name = NULL;
-	char *mac_string = NULL;
-	char *default_mac_string = NULL;
-	emac_dev_t *dev = NETDEV_PRIV(netdev);
-	int instance_num = dev->instance_num;
-
-	/* create mac name */
-	switch (instance_num) {
-	case 0:
-		mac_name = EMAC_MAC_ADDR_A;
-		emac_eth_setup();
-
-		/* we are getting default MAC address from bootloader */
-		if (strcmp(emac_eth_string, "deadbeaf") == 0) {
-			default_mac_string = "08.00.28.32.06.08";
-		} else {
-			default_mac_string = &emac_eth_string[0];
-		}
-		break;
-	default:
-		mac_name = "";
-		default_mac_string = "08.00.28.32.06.08";
-		break;
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
+	unsigned char mac_eeprom[20];
+
+	if (davinci_get_macaddr(mac_eeprom)) {
+		pr_err("Error getting board specific MAC address\n");
+		pr_err("Assuming default MAC address\n");
+		emac_str_to_ethaddr(dev->mac_addr, "08.00.28.32.06.08");
+	} else {
+		pr_info("MAC address is %s\n", mac_eeprom);
+		emac_str_to_ethaddr(dev->mac_addr, mac_eeprom);
 	}
-	mac_string = default_mac_string;
-	emac_str_to_ethaddr(dev->mac_addr, mac_string);
+
 	for (cnt = 0; cnt <= ETH_ALEN; cnt++) {
 		netdev->dev_addr[cnt] = dev->mac_addr[cnt];
 	}
@@ -3614,7 +3236,6 @@ static int emac_dev_init(struct net_devi
 		goto emac_dev_init_exit;
 	}
 
-	dev->init_cfg.inst_id = instance_num;
 	dev->drv_state = DRV_CREATED;
 	init_status = 1;	/* instance created */
 
@@ -3626,6 +3247,16 @@ static int emac_dev_init(struct net_devi
 		goto emac_dev_init_exit;
 	}
 
+	init_status = 1;	/* instance created */
+
+	/* initialize instance by passing initial configuration struct */
+	ret_code = emac_init(dev, &dev->init_cfg);
+
+	if (ret_code != EMAC_SUCCESS) {
+		ERR("Error %08X from Init()\n", ret_code);
+		goto emac_dev_init_exit;
+	}
+
 	init_status = 2;	/* instance initialized */
 
 	/* init spin lock */
@@ -3718,7 +3349,7 @@ static int emac_dev_init(struct net_devi
 /* open the adapter */
 static int emac_dev_open(struct net_device *netdev)
 {
-	emac_dev_t *dev = NETDEV_PRIV(netdev);
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
 	int i;
 
 	if (!g_init_enable_flag) {
@@ -3747,14 +3378,14 @@ static int emac_dev_open(struct net_devi
 		netif_stop_queue(netdev);
 
 	dev->device_stats.start_tick = jiffies;
-	DBG("Started the network queue for %s.\n", netdev->name);
+	pr_debug("Started the network queue for %s.\n", netdev->name);
 	return (0);
 }
 
 /* close the adapter */
 static int emac_dev_close(struct net_device *netdev)
 {
-	emac_dev_t *dev = NETDEV_PRIV(netdev);
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
 	int i;
 
 	if (!g_init_enable_flag)
@@ -3773,7 +3404,7 @@ static int emac_dev_close(struct net_dev
 static int emac_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
 {
 	emac_drv_priv_ioctl priv_ioctl;
-	emac_dev_t *dev = NETDEV_PRIV(netdev);
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
 
 	if (cmd == SIOCDEVPRIVATE) {
 		/* copy user data */
@@ -4058,9 +3689,8 @@ static u32 hash_get(u8 * addr)
  * - Returns negative if error, 0 if no change to registers, >0 if
  *   hash registers need to change
  */
-static int hash_add(emac_dev_t * _dev, u8 * mac_address)
+static int hash_add(struct emac_dev *dev, u8 *mac_address)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	u32 hash_value;
 	u32 hash_bit;
 	u32 status = 0;
@@ -4097,9 +3727,8 @@ static int hash_add(emac_dev_t * _dev, u
  * - Returns negative if error, 0 if no change to registers, >0 if
  *   hash registers need to change
  */
-static int hash_del(emac_dev_t * _dev, u8 * mac_address)
+static int hash_del(struct emac_dev *dev, u8 *mac_address)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	u32 hash_value;
 	u32 hash_bit;
 
@@ -4130,19 +3759,18 @@ static int hash_del(emac_dev_t * _dev, u
 
 /* updates hash register bits with single multicast address add/delete
  * operation */
-static void emac_single_multi(emac_dev_t * _dev, emac_single_multi_oper oper,
+static void emac_single_multi(struct emac_dev *dev, emac_single_multi_oper oper,
 			      u8 * addr)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	int status = -1;
 
 	switch (oper) {
 	case EMAC_MULTICAST_ADD:
-		status = hash_add(_dev, addr);
+		status = hash_add(dev, addr);
 		break;
 
 	case EMAC_MULTICAST_DEL:
-		status = hash_del(_dev, addr);
+		status = hash_del(dev, addr);
 		break;
 
 	default:
@@ -4158,10 +3786,8 @@ static void emac_single_multi(emac_dev_t
 }
 
 /* updates hash register bits for all multi operation (set/clear) */
-static void emac_all_multi(emac_dev_t * _dev, emac_all_multi_oper oper)
+static void emac_all_multi(struct emac_dev *dev, emac_all_multi_oper oper)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	switch (oper) {
 	case EMAC_ALL_MULTI_SET:
 		dev->mac_hash1 = EMAC_ALL_MULTI_REG_VALUE;
@@ -4185,9 +3811,8 @@ static void emac_all_multi(emac_dev_t * 
 /************************ PHY related functions ************************/
 
 /* Cpmac Update Phy Status - updates phy status variables in hDDC->status "CpmacDDCStatus" structure */
-static int emac_update_phy_status(emac_dev_t * _dev)
+static int emac_update_phy_status(struct emac_dev *dev)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	u32 set_phy_mode;
 
 	LOGMSG(EMAC_DEBUG_BUSY_FUNCTION_ENTRY, "");
@@ -4258,9 +3883,8 @@ static int emac_update_phy_status(emac_d
 }
 
 /* set phy mode */
-static int emac_set_phy_mode(emac_dev_t * _dev)
+static int emac_set_phy_mode(struct emac_dev *dev)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	u32 set_phy_mode;
 	u32 phy_mode;
 
@@ -4331,7 +3955,7 @@ static int emac_set_phy_mode(emac_dev_t 
 	       (phy_mode & NWAY_FD100), (phy_mode & NWAY_HD100),
 	       (phy_mode & NWAY_FD1000), (phy_mode & NWAY_HD1000));
 	emac_mdio_set_phy_mode(phy_mode);
-	emac_update_phy_status(_dev);
+	emac_update_phy_status(dev);
 	LOGMSG(EMAC_DEBUG_BUSY_FUNCTION_EXIT, "");
 
 	return (EMAC_SUCCESS);
@@ -4340,10 +3964,8 @@ static int emac_set_phy_mode(emac_dev_t 
 /***************** MAC ADDRESSING MODE SUPPORT FUNCTIONS ********************/
 
 /* this function sets / clears the unicast flag in hardware */
-static void emac_rx_uni_cast(emac_dev_t * _dev, u32 channel, bool enable)
+static void emac_rx_uni_cast(struct emac_dev *dev, u32 channel, bool enable)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	/* update local copy of register to save cycles in reading the
 	 * register */
 	if (enable == TRUE) {
@@ -4371,18 +3993,16 @@ static void emac_rx_uni_cast(emac_dev_t 
  * not required.  It is assumed that this function will get the
  * correct channel number always
  */
-static void emac_add_type0addr(emac_dev_t * _dev, u32 channel,
+static void emac_add_type0addr(struct emac_dev *dev, u32 channel,
 			       char *mac_address)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	dev->regs->mac_src_addr_lo = (mac_address[0] << 8) | (mac_address[1]);
 	dev->regs->mac_src_addr_hi = (mac_address[2] << 24) |
 		(mac_address[3] << 16) | (mac_address[4] << 8) |
 		(mac_address[5]);
 
 	/* enable unicast */
-	emac_rx_uni_cast(_dev, channel, TRUE);
+	emac_rx_uni_cast(dev, channel, TRUE);
 }
 
 /**
@@ -4393,11 +4013,9 @@ static void emac_add_type0addr(emac_dev_
  * API which does channel number range checking and hence its not required.
  * It is assumed that this function will get the correct channel number always
  */
-static void emac_add_type1addr(emac_dev_t * _dev, u32 channel,
+static void emac_add_type1addr(struct emac_dev *dev, u32 channel,
 			       char *mac_address)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	/* set mac_index register with channel number */
 	dev->regs->mac_index = channel;
 
@@ -4416,14 +4034,14 @@ static void emac_add_type1addr(emac_dev_
 	/* As per discussion with hardware folks, it is mandatory to
 	   set the source address of the mac, else correct behaviour
 	   is not guaranteed */
-	emac_add_type0addr(_dev, channel, mac_address);
+	emac_add_type0addr(dev, channel, mac_address);
 
 	/* enable unicast */
-	emac_rx_uni_cast(_dev, channel, TRUE);
+	emac_rx_uni_cast(dev, channel, TRUE);
 }
 
 /* CPGMAC CFIG 2/3 type addressing - filtering */
-static void emac_add_type2addr(emac_dev_t * _dev, u32 channel,
+static void emac_add_type2addr(struct emac_dev *dev, u32 channel,
 			       char *mac_address,
 			       int index, bool valid, int match)
 {
@@ -4433,10 +4051,9 @@ static void emac_add_type2addr(emac_dev_
 /************************ HARDWARE CONFIGURATION SUPPORT FUNCTIONS ************************/
 
 /* set RX hardware configuration */
-void emac_set_rx_hw_cfg(emac_dev_t * _dev)
+void emac_set_rx_hw_cfg(struct emac_dev *dev)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-	emac_rx_config *rx_cfg;
+	struct emac_rx_config *rx_cfg;
 	u32 rx_mbp_enable;
 
 	if (dev->drv_state != DRV_OPENED) {
@@ -4475,12 +4092,12 @@ void emac_set_rx_hw_cfg(emac_dev_t * _de
 
 		/* disable unicast - warning!! assuming only one
 		 * channel open */
-		emac_rx_uni_cast(_dev, (dev->rx_cppi[0])->ch_info.ch_num,
+		emac_rx_uni_cast(dev, (dev->rx_cppi[0])->ch_info.ch_num,
 				 FALSE);
 	} else {
 		/* enable unicast - warning!! assuming only one
 		 * channel open */
-		emac_rx_uni_cast(_dev, (dev->rx_cppi[0])->ch_info.ch_num, TRUE);
+		emac_rx_uni_cast(dev, (dev->rx_cppi[0])->ch_info.ch_num, TRUE);
 	}
 
 	if (dev->rx_MBP_enable != rx_mbp_enable) {
@@ -4501,10 +4118,9 @@ void emac_set_rx_hw_cfg(emac_dev_t * _de
 }
 
 /* set MAC configuration - MACControl register */
-static void emac_set_mac_hw_cfg(emac_dev_t * _dev)
+static void emac_set_mac_hw_cfg(struct emac_dev *dev)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-	emac_mac_config *mac_cfg;
+	struct emac_mac_config *mac_cfg;
 	u32 mac_control;
 
 	if (dev->drv_state != DRV_OPENED) {
@@ -4516,7 +4132,7 @@ static void emac_set_mac_hw_cfg(emac_dev
 	mac_control =
 	    ((mac_cfg->
 	      tx_short_gap_enable & 0x1) << EMAC_MACCONTROL_TXSHORTGAPEN_SHIFT)
-	    | (((mac_cfg->p_type == EMAC_TXPRIO_FIXED) ? 0x1 : 0) <<
+	    | ((mac_cfg->priority_is_fixed ? 0x1 : 0) <<
 	       EMAC_MACCONTROL_TXPTYPE_SHIFT)
 	    | ((mac_cfg->giga_bit_enable & 0x1) <<
 	       EMAC_MACCONTROL_GIGABITEN_SHIFT) | ((mac_cfg->
@@ -4545,10 +4161,8 @@ static void emac_set_mac_hw_cfg(emac_dev
  *
  * Initial configuration passed by via the "init_cfg" parameter
  */
-static int emac_init(emac_dev_t * _dev, emac_init_config * init_cfg)
+static int emac_init(struct emac_dev *dev, struct emac_init_config *init_cfg)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	LOGMSG(EMAC_DEBUG_FUNCTION_ENTRY, "");
 
 	/* validate num_tx and num_rx channels */
@@ -4568,10 +4182,8 @@ static int emac_init(emac_dev_t * _dev, 
 /* EMAC DDC DeInit
  * Stub function - no functionality required as per this implementation
  */
-static int emac_de_init(emac_dev_t * _dev, void *param)
+static int emac_de_init(struct emac_dev *dev, void *param)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	LOGMSG(EMAC_DEBUG_FUNCTION_ENTRY, "");
 	LOGMSG(EMAC_DEBUG_FUNCTION_EXIT, "");
 
@@ -4588,14 +4200,13 @@ static int emac_de_init(emac_dev_t * _de
  *
  * "param" not used in this implementation
  */
-static int emac_open(emac_dev_t * _dev, void *param)
+static int emac_open(struct emac_dev *dev, void *param)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	u32 channel;
 	u32 mii_mod_id, mii_rev_maj, mii_rev_min;
 	int ret_val;
-	emac_init_config *init_cfg;
-        ewrap_dm646x_regs *dm646x_wrap = NULL;
+	struct emac_init_config *init_cfg;
+        volatile struct ewrap_dm646x_regs *dm646x_wrap = NULL;
 
 	LOGMSG(EMAC_DEBUG_FUNCTION_ENTRY, "");
 
@@ -4606,8 +4217,8 @@ static int emac_open(emac_dev_t * _dev, 
 
 	/* get init config info structure pointer for easy access */
 	init_cfg = &dev->init_cfg;
-	dev->regs = (emac_regs_ovly) init_cfg->base_address;
-	dev->e_wrap_regs = (ewrap_regs *) init_cfg->e_wrap_base_address;
+	dev->regs = (volatile struct emac_regs *) init_cfg->base_address;
+	dev->ewrap_regs = (volatile union ewrap_regs *) init_cfg->e_wrap_base_address;
 
 	/* set the BD memory pointer */
 	emac_wrapper_ptr = EMAC_WRAPPER_RAM_ADDR;
@@ -4616,7 +4227,7 @@ static int emac_open(emac_dev_t * _dev, 
 		/* bring EMAC out of reset - for clean implementation, reset
 		 * and then unreset the module */
 		/* for EMAC 2.6 and beyond, reset is internal to the module */
-                dm646x_wrap = &dev->e_wrap_regs->wrapper_646x_regs;
+                dm646x_wrap = &dev->ewrap_regs->wrapper_646x_regs;
                 dm646x_wrap->SOFTRST = 1;
                 while (dm646x_wrap->SOFTRST) {
                         /* wait for reset to complete */
@@ -4661,7 +4272,7 @@ static int emac_open(emac_dev_t * _dev, 
 	dev->drv_state = DRV_OPENED;
 
 	/* set the mac_control register */
-	emac_set_mac_hw_cfg(_dev);
+	emac_set_mac_hw_cfg(dev);
 
 	/* start MDIO autonegotiation and set phy mode */
 	emac_mdio_get_ver(init_cfg->mdio_base_address,
@@ -4675,9 +4286,8 @@ static int emac_open(emac_dev_t * _dev, 
 
 	/* no failure code returned from this function */
 	emac_mdio_init(init_cfg->mdio_base_address,
-		       dev->init_cfg.inst_id,
 		       init_cfg->phy_mask,
-		       init_cfg->MLink_mask,
+		       init_cfg->m_link_mask,
 		       init_cfg->mdio_bus_frequency,
 		       init_cfg->mdio_clock_frequency,
 		       (emac_debug & EMAC_DEBUG_MII)
@@ -4685,7 +4295,7 @@ static int emac_open(emac_dev_t * _dev, 
 
 	/* set the PHY to a given mode - as per config parameters and
 	 * update DDA layer */
-	emac_set_phy_mode(_dev);
+	emac_set_phy_mode(dev);
 
 	emac_control_cb(dev,
 			EMAC_IOCTL_STATUS_UPDATE, (void *)&dev->status, NULL);
@@ -4699,7 +4309,7 @@ static int emac_open(emac_dev_t * _dev, 
 	for (channel = 0; channel < EMAC_MAX_TX_CHANNELS; channel++) {
 		if (dev->tx_cppi[channel] != NULL) {
 			ret_val =
-			    emac_enable_channel(_dev, channel, NET_CH_DIR_TX);
+			    emac_enable_channel(dev, channel, NET_CH_DIR_TX);
 			if (ret_val != EMAC_SUCCESS) {
 				LOGERR("Error enabling TX channel %d", channel);
 
@@ -4724,7 +4334,7 @@ static int emac_open(emac_dev_t * _dev, 
 
 	/* RX MBP, RX pkt length and RX buffer offset registers taken
 	 * care by this function */
-	emac_set_rx_hw_cfg(_dev);
+	emac_set_rx_hw_cfg(dev);
 
 	/* read RX address matching/filtering type (0/1/2) */
 	dev->rx_addr_type = (dev->regs->mac_cfig >> 8) & 0xFF;
@@ -4733,7 +4343,7 @@ static int emac_open(emac_dev_t * _dev, 
 	for (channel = 0; channel < EMAC_MAX_RX_CHANNELS; channel++) {
 		if (dev->rx_cppi[channel] != NULL) {
 			ret_val =
-			    emac_enable_channel(_dev, channel, NET_CH_DIR_RX);
+			    emac_enable_channel(dev, channel, NET_CH_DIR_RX);
 			if (ret_val != EMAC_SUCCESS) {
 				LOGERR("Error enabling RX channel %d", channel);
 
@@ -4777,9 +4387,8 @@ static int emac_open(emac_dev_t * _dev, 
  *
  * "param" not used in this implementation
  */
-static int emac_close(emac_dev_t * _dev, void *param)
+static int emac_close(struct emac_dev *dev, void *param)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	int ret_val;
 	int err_val = EMAC_SUCCESS;
 	u32 channel;
@@ -4800,7 +4409,7 @@ static int emac_close(emac_dev_t * _dev,
 	for (channel = 0; channel < EMAC_MAX_TX_CHANNELS; channel++) {
 		if (dev->tx_cppi[channel] != NULL) {
 			ret_val =
-			    emac_ch_close(_dev, channel, NET_CH_DIR_TX, NULL);
+			    emac_ch_close(dev, channel, NET_CH_DIR_TX, NULL);
 			if (ret_val != EMAC_SUCCESS) {
 				LOGERR("Error closing TX channel %d", channel);
 
@@ -4816,7 +4425,7 @@ static int emac_close(emac_dev_t * _dev,
 	for (channel = 0; channel < EMAC_MAX_RX_CHANNELS; channel++) {
 		if (dev->rx_cppi[channel] != NULL) {
 			ret_val =
-			    emac_ch_close(_dev, channel, NET_CH_DIR_RX, NULL);
+			    emac_ch_close(dev, channel, NET_CH_DIR_RX, NULL);
 
 			if (ret_val != EMAC_SUCCESS) {
 				LOGERR("Error closing RX channel %d", channel);
@@ -4858,10 +4467,9 @@ static int emac_close(emac_dev_t * _dev,
  *
  * "param" not used in this implementation
  */
-static int emac_control(emac_dev_t * _dev, int cmd, void *cmd_arg, void *param)
+static int
+emac_control(struct emac_dev *dev, int cmd, void *cmd_arg, void *param)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	/* sanity check */
 	if (dev->drv_state != DRV_OPENED) {
 		LOGERR("ioctl called when device is NOT open");
@@ -4887,8 +4495,9 @@ static int emac_control(emac_dev_t * _de
 		/* rx configuration structure passed in structure
 		 * pointed by cmd_arg, params not used */
 		if (cmd_arg != NULL) {
-			dev->init_cfg.rx_cfg = *((emac_rx_config *) cmd_arg);
-			emac_set_rx_hw_cfg(_dev);
+			dev->init_cfg.rx_cfg =
+				*((struct emac_rx_config *) cmd_arg);
+			emac_set_rx_hw_cfg(dev);
 		} else {
 			return (EMAC_INVALID_PARAM);
 		}
@@ -4898,8 +4507,9 @@ static int emac_control(emac_dev_t * _de
 		/* mac configuration structure passed in a structure
 		 * pointed by cmd_arg, params not used */
 		if (cmd_arg != NULL) {
-			dev->init_cfg.mac_cfg = *((emac_mac_config *) cmd_arg);
-			emac_set_mac_hw_cfg(_dev);
+			dev->init_cfg.mac_cfg =
+				*((struct emac_mac_config *) cmd_arg);
+			emac_set_mac_hw_cfg(dev);
 		} else {
 			return (EMAC_INVALID_PARAM);
 		}
@@ -4972,7 +4582,7 @@ static int emac_control(emac_dev_t * _de
 			for (cnt = 0; cnt < EMAC_NUM_STAT_REGS; cnt++, addr++) {
 				*addr = EMAC_STAT_CLEAR;	/* 0xFFFFFFFF value */
 			}
-			emac_ddcifcnt_clear(_dev);
+			emac_ddcifcnt_clear(dev);
 		}
 		break;
 
@@ -4981,7 +4591,7 @@ static int emac_control(emac_dev_t * _de
 		 * to multicast address - u8 */
 		{
 			u8 *addr = (u8 *) param;
-			emac_single_multi(_dev,
+			emac_single_multi(dev,
 					  (emac_single_multi_oper) cmd_arg,
 					  addr);
 		}
@@ -4989,7 +4599,7 @@ static int emac_control(emac_dev_t * _de
 
 	case EMAC_IOCTL_ALL_MULTI:
 		/* cmd_arg= emac_all_multi_oper enum, param=not used */
-		emac_all_multi(_dev, (emac_all_multi_oper) cmd_arg);
+		emac_all_multi(dev, (emac_all_multi_oper) cmd_arg);
 		break;
 
 	case EMAC_IOCTL_TYPE2_3_FILTERING:
@@ -5001,7 +4611,7 @@ static int emac_control(emac_dev_t * _de
 
 			addr_params =
 			    (emac_type2_3_addr_filter_params *) cmd_arg;
-			emac_add_type2addr(_dev, addr_params->channel,
+			emac_add_type2addr(dev, addr_params->channel,
 					   addr_params->mac_address,
 					   addr_params->index,
 					   addr_params->valid,
@@ -5038,24 +4648,24 @@ static int emac_control(emac_dev_t * _de
 				    addr_params->mac_address[cnt];
 
 			/* set interface MAC address */
-			emac_set_mac_address(_dev, addr_params->channel,
+			emac_set_mac_address(dev, addr_params->channel,
 					     addr_params->mac_address);
 		}
 		break;
 
 	case EMAC_IOCTL_IF_COUNTERS:
-		emac_ddcifcnt_updt(_dev);
+		emac_ddcifcnt_updt(dev);
 
 		memcpy(cmd_arg, &dev->mib2if_hccounter.mib2if_counter,
 		       sizeof(struct mib2_if_counters));
 		break;
 
 	case EMAC_IOCTL_ETHER_COUNTERS:
-		emac_ddcphycnt(_dev, cmd_arg);
+		emac_ddcphycnt(dev, cmd_arg);
 		break;
 
 	case EMAC_IOCTL_IF_PARAMS_UPDT:
-		emac_ddcifcnt_updt(_dev);
+		emac_ddcifcnt_updt(dev);
 		break;
 
 	default:
@@ -5075,10 +4685,9 @@ static int emac_control(emac_dev_t * _de
  * 1. If DDC instance is in "Opened" state, the channel is enabled in hardware
  *       2. "chOpenArgs" is used only for opening RX channel
  */
-static int emac_ch_open(emac_dev_t * _dev, emac_ch_info * ch_info,
+static int emac_ch_open(struct emac_dev *dev, emac_ch_info *ch_info,
 			void *ch_open_args)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	int ret_val;
 
 	LOGMSG(EMAC_DEBUG_FUNCTION_ENTRY,
@@ -5111,7 +4720,7 @@ static int emac_ch_open(emac_dev_t * _de
 
 		/* allocate channel memory and perform other book-keep
 		 * functions for the channel */
-		ret_val = emac_init_tx_channel(_dev, ch_info, ch_open_args);
+		ret_val = emac_init_tx_channel(dev, ch_info, ch_open_args);
 		if (ret_val != EMAC_SUCCESS) {
 			LOGERR
 			    ("Error in initializing TX channel %d",
@@ -5133,7 +4742,7 @@ static int emac_ch_open(emac_dev_t * _de
 
 		/* allocate channel memory and perform other book-keep
 		 * functions for the channel */
-		ret_val = emac_init_rx_channel(_dev, ch_info, ch_open_args);
+		ret_val = emac_init_rx_channel(dev, ch_info, ch_open_args);
 
 		if (ret_val != EMAC_SUCCESS) {
 			LOGERR
@@ -5146,7 +4755,7 @@ static int emac_ch_open(emac_dev_t * _de
 	/* if device is opened already, enable this channel for use */
 	if (dev->drv_state == DRV_OPENED) {
 		ret_val =
-		    emac_enable_channel(_dev, ch_info->ch_num, ch_info->ch_dir);
+		    emac_enable_channel(dev, ch_info->ch_num, ch_info->ch_dir);
 		if (ret_val != EMAC_SUCCESS) {
 			LOGERR
 			    ("Error enabling channel %d in %d direction",
@@ -5168,10 +4777,9 @@ static int emac_ch_open(emac_dev_t * _de
  *  - If DDC instance is in "Opened" state, disable the channel in hardware
  *  - Un-initialize the channel (free memory previously allocated)
  */
-static int emac_ch_close(emac_dev_t * _dev, int channel,
+static int emac_ch_close(struct emac_dev *dev, int channel,
 			 int direction, void *ch_close_args)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	int ret_val;
 
 	LOGMSG(EMAC_DEBUG_FUNCTION_ENTRY,
@@ -5180,7 +4788,7 @@ static int emac_ch_close(emac_dev_t * _d
 
 	/* disable this channel */
 	if (dev->drv_state == DRV_OPENED) {
-		ret_val = emac_disable_channel(_dev, channel, direction);
+		ret_val = emac_disable_channel(dev, channel, direction);
 		if (ret_val != EMAC_SUCCESS) {
 			LOGERR
 			    ("Error disabling channel %d in %s direction",
@@ -5192,7 +4800,7 @@ static int emac_ch_close(emac_dev_t * _d
 
 	/* un_init channel */
 	if (direction == NET_CH_DIR_TX) {
-		ret_val = emac_un_init_tx_channel(_dev, channel, ch_close_args);
+		ret_val = emac_un_init_tx_channel(dev, channel, ch_close_args);
 		if (ret_val != EMAC_SUCCESS) {
 			LOGERR("Error in UnInit of TX channel %d", channel);
 			return (ret_val);
@@ -5200,7 +4808,7 @@ static int emac_ch_close(emac_dev_t * _d
 	}
 
 	else if (direction == NET_CH_DIR_RX) {
-		ret_val = emac_un_init_rx_channel(_dev, channel, ch_close_args);
+		ret_val = emac_un_init_rx_channel(dev, channel, ch_close_args);
 		if (ret_val != EMAC_SUCCESS) {
 			LOGERR("Error in UnInit of TX channel %d", channel);
 			return (ret_val);
@@ -5227,10 +4835,9 @@ static int emac_ch_close(emac_dev_t * _d
  * not do any error check on these parameters to avoid duplicate error
  * checks (done in caller function).
  */
-static int emac_init_tx_channel(emac_dev_t * _dev,
+static int emac_init_tx_channel(struct emac_dev *dev,
 				emac_ch_info * ch_info, void *ch_open_args)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	u32 cnt, bd_size;
 	char *alloc_mem;
 	emac_tx_bd *curr_bd;
@@ -5264,7 +4871,7 @@ static int emac_init_tx_channel(emac_dev
 	tx_cppi->alloc_size = (((bd_size * ch_info->num_bd) + 0xF) & ~0xF);
 
 	/* alloc TX BD memory */
-	tx_cppi->bd_mem = (char *)EMAC_TX_BD_MEM;
+	tx_cppi->bd_mem = dev->ewrap_ram;
 	memzero(tx_cppi->bd_mem, tx_cppi->alloc_size);
 
 	/* initialize the BD linked list */
@@ -5298,10 +4905,9 @@ static int emac_init_tx_channel(emac_dev
  * and this function will not do any error check to avoid duplicate
  * error checks (done in caller function).
  */
-static int emac_un_init_tx_channel(emac_dev_t * _dev, u32 channel,
+static int emac_un_init_tx_channel(struct emac_dev *dev, u32 channel,
 				   void *ch_close_args)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	emac_tx_cppi_ch *tx_cppi;
 
 	LOGMSG(EMAC_DEBUG_FUNCTION_ENTRY, "ChannelNo=%d", channel);
@@ -5345,10 +4951,9 @@ static int emac_un_init_tx_channel(emac_
  * not do any error check on these parameters to avoid duplicate error
  * checks (done in caller function).
  */
-static int emac_init_rx_channel(emac_dev_t * _dev,
+static int emac_init_rx_channel(struct emac_dev *dev,
 				emac_ch_info * ch_info, void *ch_open_args)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	u32 cnt, bd_size;
 	char *alloc_mem;
 	emac_rx_bd *curr_bd;
@@ -5376,7 +4981,7 @@ static int emac_init_rx_channel(emac_dev
 	rx_cppi->alloc_size = (((bd_size * ch_info->num_bd) + 0xF) & ~0xF);
 
 	/* alloc RX BD memory */
-	rx_cppi->bd_mem = (char *)EMAC_RX_BD_MEM;
+	rx_cppi->bd_mem = dev->ewrap_ram + (dev->ewrap_ram_size / 2);
 	memzero(rx_cppi->bd_mem, rx_cppi->alloc_size);
 
 	rx_cppi->pkt_queue.buf_list = &rx_cppi->buf_queue[0];
@@ -5437,10 +5042,9 @@ static int emac_init_rx_channel(emac_dev
  * and this function will not do any error check to avoid duplicate
  * error checks (done in caller function).
  */
-static int emac_un_init_rx_channel(emac_dev_t * _dev, u32 channel,
+static int emac_un_init_rx_channel(struct emac_dev *dev, u32 channel,
 				   void *ch_close_args)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	emac_rx_cppi_ch *rx_cppi;
 	emac_rx_bd *curr_bd;
 
@@ -5487,20 +5091,19 @@ static int emac_un_init_rx_channel(emac_
  *
  * 1. It is assumed that the channel is already "initialized"
  */
-static void emac_set_mac_address(emac_dev_t * _dev, u32 channel, char *mac_addr)
+static void emac_set_mac_address(struct emac_dev *dev, u32 channel,
+		char *mac_addr)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	/* enable unicast on this channel */
 	dev->regs->rx_unicast_set = (1 << channel);
 
 	/* program MAC address for the channel depending upon emac/cpgmac */
 	if (dev->rx_addr_type == RX_ADDR_TYPE0)
-		emac_add_type0addr(_dev, channel, mac_addr);
+		emac_add_type0addr(dev, channel, mac_addr);
 	else if (dev->rx_addr_type == RX_ADDR_TYPE1)
-		emac_add_type1addr(_dev, channel, mac_addr);
+		emac_add_type1addr(dev, channel, mac_addr);
 	else if (dev->rx_addr_type == RX_ADDR_TYPE2)
-		emac_add_type2addr(_dev, channel, mac_addr, 0, 1, 1);
+		emac_add_type2addr(dev, channel, mac_addr, 0, 1, 1);
 	else
 		LOGERR
 		    ("Wrong Rx Addressing Type - (Type2) detected in hardware");
@@ -5515,10 +5118,8 @@ static void emac_set_mac_address(emac_de
  * 1. It is assumed that the channel is already "initialized"
  * 2. To enable a channel after its disabled, it needs to be initialized again
  */
-static int emac_enable_channel(emac_dev_t * _dev, u32 channel, u32 direction)
+static int emac_enable_channel(struct emac_dev *dev, u32 channel, u32 direction)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	LOGMSG(EMAC_DEBUG_FUNCTION_ENTRY,
 	       "ChannelNo=%d, Direction=%s",
 	       channel, ((direction == NET_CH_DIR_TX) ? "TX" : "RX"));
@@ -5538,7 +5139,7 @@ static int emac_enable_channel(emac_dev_
 		/* init head descriptor pointer */
 		dev->regs->tx_HDP[channel] = 0;
 		{
-			emac_mac_config *mac_cfg;
+			struct emac_mac_config *mac_cfg;
 
 			mac_cfg = &dev->init_cfg.mac_cfg;
 			if (mac_cfg->tx_interrupt_disable == TRUE) {
@@ -5547,8 +5148,8 @@ static int emac_enable_channel(emac_dev_
 				if (device_is_dm646x) {
 					/* update wrapper book-keeping fields */
 					dev->tx_en &= (~(1 << channel));
-					((volatile ewrap_dm646x_regs)dev->
-						e_wrap_regs->wrapper_646x_regs).
+					((volatile struct ewrap_dm646x_regs)dev->
+						ewrap_regs->wrapper_646x_regs).
 						C0_TXINTEN = dev->tx_en;
 				}
 				dev->tx_interrupt_disable = TRUE;
@@ -5560,8 +5161,8 @@ static int emac_enable_channel(emac_dev_
 				if (device_is_dm646x) {
 					/* update wrapper book-keeping fields */
 					dev->tx_en = (1 << channel);
-					((volatile ewrap_dm646x_regs)dev->
-					e_wrap_regs->wrapper_646x_regs).
+					((volatile struct ewrap_dm646x_regs)dev->
+					ewrap_regs->wrapper_646x_regs).
 						C0_TXINTEN = (1 << channel);
 				}
 				dev->tx_interrupt_disable = FALSE;
@@ -5586,7 +5187,7 @@ static int emac_enable_channel(emac_dev_
 		}
 
 		/* set interface MAC address */
-		emac_set_mac_address(_dev, channel, rx_cppi->mac_addr);
+		emac_set_mac_address(dev, channel, rx_cppi->mac_addr);
 
 		/* enable channel interrupt */
 		dev->regs->rx_int_mask_set = (1 << channel);
@@ -5594,8 +5195,8 @@ static int emac_enable_channel(emac_dev_
 		if (device_is_dm646x) {
 		/* update wrapper book-keeping fields */
 			dev->rx_en = (1 << channel);
-			((volatile ewrap_dm646x_regs)dev->
-				e_wrap_regs->wrapper_646x_regs).
+			((volatile struct ewrap_dm646x_regs)dev->
+				ewrap_regs->wrapper_646x_regs).
 				C0_RXINTEN = (1 << channel);
                 }
 
@@ -5630,11 +5231,9 @@ static int emac_enable_channel(emac_dev_
  * 1. It is assumed that the channel number passed is valid
  * 2. Resources for the channel will be released only when its closed
  */
-static int emac_disable_channel(emac_dev_t * _dev, u32 channel,
+static int emac_disable_channel(struct emac_dev *dev, u32 channel,
 				net_ch_dir direction)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	LOGMSG(EMAC_DEBUG_FUNCTION_ENTRY,
 	       "ChannelNo=%d, Direction=%s",
 	       channel, ((direction == NET_CH_DIR_TX) ? "TX" : "RX"));
@@ -5648,7 +5247,7 @@ static int emac_disable_channel(emac_dev
 
 		/* wait for teardown complete */
 		if (emac_wait_for_teardown_complete
-		    (_dev, channel, direction, TRUE) != EMAC_SUCCESS) {
+		    (dev, channel, direction, TRUE) != EMAC_SUCCESS) {
 
 			LOGERR("Failed to teardown TX channel %d", channel);
 
@@ -5663,8 +5262,8 @@ static int emac_disable_channel(emac_dev
                 if (device_is_dm646x) {
                 /* update wrapper book-keeping fields */
                         dev->tx_en &= (~(1 << channel));
-                        ((volatile ewrap_dm646x_regs)dev->
-                                e_wrap_regs->wrapper_646x_regs).
+                        ((volatile struct ewrap_dm646x_regs)dev->
+                                ewrap_regs->wrapper_646x_regs).
                                 C0_TXINTEN = dev->tx_en;
                 }
 
@@ -5683,7 +5282,7 @@ static int emac_disable_channel(emac_dev
 
 		/* wait for teardown complete */
 		if (emac_wait_for_teardown_complete
-		    (_dev, channel, direction, TRUE) != EMAC_SUCCESS) {
+		    (dev, channel, direction, TRUE) != EMAC_SUCCESS) {
 			LOGERR("Failed to teardown RX channel %d", channel);
 		}
 		dev->rx_teardown_pending[channel] = FALSE;
@@ -5709,11 +5308,10 @@ static int emac_disable_channel(emac_dev
  *             = FALSE (returns immediately) - NOT SUPPORTED
  * As of now this function supports blocking mode in polled mode only
  */
-static int emac_wait_for_teardown_complete(emac_dev_t * _dev,
+static int emac_wait_for_teardown_complete(struct emac_dev *dev,
 					   u32 channel,
 					   net_ch_dir direction, bool blocking)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	volatile unsigned int teardown_cnt = 0xFFFFFFF0;
 
 	if (direction == NET_CH_DIR_TX) {
@@ -5809,7 +5407,7 @@ static int emac_wait_for_teardown_comple
 	return (EMAC_SUCCESS);
 }
 
-static void emac_ddcphycnt(emac_dev_t * dev, u32 * cmd_arg)
+static void emac_ddcphycnt(struct emac_dev *dev, u32 * cmd_arg)
 {
 	int result;
 	emac_hw_statistics stats;
@@ -5846,21 +5444,18 @@ static void emac_ddcphycnt(emac_dev_t * 
 	return;
 }
 
-static void emac_ddcifcnt_clear(emac_dev_t * _dev)
+static void emac_ddcifcnt_clear(struct emac_dev *dev)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	memzero((char *)&dev->mib2if_hccounter, sizeof(dev->mib2if_hccounter));
 }
 
-static void emac_ddcifcnt_updt(emac_dev_t * _dev)
+static void emac_ddcifcnt_updt(struct emac_dev *dev)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	int result;
 	emac_hw_statistics stats;
 
 	result =
-	    emac_control(_dev, EMAC_IOCTL_GET_STATISTICS,
+	    emac_control(dev, EMAC_IOCTL_GET_STATISTICS,
 			 (u32 *) & stats, NULL);
 
 	if (result != 0) {
@@ -6126,10 +5721,8 @@ static char *emac_rx_host_error_codes[16
  *
  * "tickArgs" is not used in this implementation
  */
-static int emac_tick(emac_dev_t * _dev, void *tick_args)
+static int emac_tick(struct emac_dev *dev, void *tick_args)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	/* verify proper device state */
 	if (dev->drv_state != DRV_OPENED) {
 		return (EMAC_ERR_DEV_NOT_OPEN);
@@ -6141,7 +5734,7 @@ static int emac_tick(emac_dev_t * _dev, 
 
 		tick_change = emac_mdio_tick();
 		if (tick_change == 1) {	/*  MDIO indicated a change  */
-			emac_update_phy_status((emac_dev_t *) dev);
+			emac_update_phy_status(dev);
 			emac_control_cb(dev,
 					EMAC_IOCTL_STATUS_UPDATE,
 					(void *)&dev->status, NULL);
@@ -6160,9 +5753,8 @@ static int emac_tick(emac_dev_t * _dev, 
  *    the DDA layer about the hardware error.
  *
  */
-static void emac_process_host_error(emac_dev_t * _dev)
+static void emac_process_host_error(struct emac_dev *dev)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	u32 channel = 0;
 	u32 vector = 0;
 	u32 status = 0;
@@ -6224,10 +5816,9 @@ static void emac_process_host_error(emac
  * "pkts_pending" will contain number of packets still to be processed
  * (TX + RX)
  */
-static int emac_pkt_process(emac_dev_t * _dev, int *pkts_pending,
+static int emac_pkt_process(struct emac_dev *dev, int *pkts_pending,
 			    void *pkt_args)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	u32 channel = 0;
 	u32 vector = 0;
 	u32 handle_pkts_and_status = 0;
@@ -6282,7 +5873,7 @@ static int emac_pkt_process(emac_dev_t *
 					 handle_pkts_and_status);
 
 		pkts_processed =
-		    emac_tx_bdproc(_dev, channel, &handle_pkts_and_status,
+		    emac_tx_bdproc(dev, channel, &handle_pkts_and_status,
 				   &is_eoq);
 		if (pkt_args)
 			((rx_tx_params *) pkt_args)->ret_tx_pkts =
@@ -6296,8 +5887,8 @@ static int emac_pkt_process(emac_dev_t *
 				if (device_is_dm646x) {
 					/* update wrapper book-keeping fields */
 					dev->tx_en &= (~(1 << channel));
-					((volatile ewrap_dm646x_regs)dev->
-						e_wrap_regs->wrapper_646x_regs).
+					((volatile struct ewrap_dm646x_regs)dev->
+						ewrap_regs->wrapper_646x_regs).
 							C0_TXINTEN = dev->tx_en;
 					}
 		}
@@ -6326,7 +5917,7 @@ static int emac_pkt_process(emac_dev_t *
 					 handle_pkts_and_status);
 
 		pkts_processed =
-		    emac_rx_bdproc(_dev, channel, &handle_pkts_and_status);
+		    emac_rx_bdproc(dev, channel, &handle_pkts_and_status);
 
 		if (pkt_args)
 			((rx_tx_params *) pkt_args)->ret_rx_pkts =
@@ -6338,7 +5929,7 @@ static int emac_pkt_process(emac_dev_t *
 	/* handle host errors - being handled last does not mean its
 	 * of least priority */
 	if (vector & mac_in_vector_host_int_vec) {
-		emac_process_host_error(_dev);
+		emac_process_host_error(dev);
 	}
 
 	return (EMAC_SUCCESS);
@@ -6351,10 +5942,8 @@ static int emac_pkt_process(emac_dev_t *
  *   hardware
  */
 /* packet processing end */
-static int emac_pkt_process_end(emac_dev_t * _dev, void *proc_args)
+static int emac_pkt_process_end(struct emac_dev *dev, void *proc_args)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	/* enable interrupts via module control (wrapper) */
 	emac_enable_interrupt(dev, 1); /*TODO: ack_eoi=0,1?*/
 
@@ -6381,11 +5970,10 @@ static int emac_pkt_process_end(emac_dev
  * this function
  */
 
-static int emac_send(emac_dev_t * _dev, net_pkt_obj * pkt,
+static int emac_send(struct emac_dev *dev, net_pkt_obj *pkt,
 		     int channel, bool send_args)
 {
 	unsigned long flags;
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	int ret_val = EMAC_SUCCESS;
 	emac_tx_bd *curr_bd;
 	emac_tx_cppi_ch *tx_cppi;
@@ -6478,8 +6066,8 @@ static int emac_send(emac_dev_t * _dev, 
 				/* enable channel interrupt */
 				dev->regs->tx_int_mask_set = (1 << channel);
 				if (device_is_dm646x) {
-					ewrap_dm646x_regs *dm646x_wrap;
-					dm646x_wrap = &dev->e_wrap_regs->
+					volatile struct ewrap_dm646x_regs *dm646x_wrap;
+					dm646x_wrap = &dev->ewrap_regs->
 					wrapper_646x_regs;
 					/* update wrapper book-keeping fields*/
 					dev->tx_en = (1 << channel);
@@ -6503,7 +6091,7 @@ static int emac_send(emac_dev_t * _dev, 
 
 			handle_pkts_and_status =
 			    dev->tx_cppi[channel]->ch_info.service_max;
-			emac_tx_bdproc(_dev, channel, &handle_pkts_and_status,
+			emac_tx_bdproc(dev, channel, &handle_pkts_and_status,
 				       &is_eoq);
 			dev->tx_int_threshold[channel] =
 			    dev->tx_cppi[channel]->ch_info.service_max;
@@ -6521,11 +6109,10 @@ static int emac_send(emac_dev_t * _dev, 
  * returns number of pkts processed and 1 in morePkts if pkt
  * completion processing pending
  */
-static int emac_tx_bdproc(emac_dev_t * _dev, u32 channel,
+static int emac_tx_bdproc(struct emac_dev *dev, u32 channel,
 			  u32 * handle_pkts_and_status, bool * is_eoq)
 {
 	unsigned long flags;
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	emac_tx_bd *curr_bd;
 	emac_tx_cppi_ch *tx_cppi;
 	volatile u32 frame_status;
@@ -6641,12 +6228,10 @@ static int emac_tx_bdproc(emac_dev_t * _
  *  - returns the BD to the Receive queue
  *  - If the queue is stalled due to sync issues, re-trigger the hardware
  */
-static void emac_add_bdto_rx_queue(emac_dev_t * _dev, emac_rx_cppi_ch * rx_cppi,
-				   emac_rx_bd * curr_bd, char *buffer,
-				   emac_net_data_token buf_token)
+static void emac_add_bdto_rx_queue(struct emac_dev *dev,
+		emac_rx_cppi_ch *rx_cppi, emac_rx_bd *curr_bd, char *buffer,
+		emac_net_data_token buf_token)
 {
-	emac_dev_t *dev = (emac_dev_t *) _dev;
-
 	/* populate the hardware descriptor */
 	curr_bd->h_next = 0;
 	curr_bd->buff_ptr = EMAC_VIRT_TO_PHYS(buffer);
@@ -6699,11 +6284,10 @@ static void emac_add_bdto_rx_queue(emac_
  *  - requeues the buffer descriptor to the receive pool
  *  - If the queue is stalled due to sync issues, re-trigger the hardware
  */
-static int emac_rx_bdproc(emac_dev_t * _dev, u32 channel,
+static int emac_rx_bdproc(struct emac_dev *dev, u32 channel,
 			  int *handle_pkts_and_status)
 {
 	unsigned long flags;
-	emac_dev_t *dev = (emac_dev_t *) _dev;
 	emac_rx_cppi_ch *rx_cppi;
 	emac_rx_bd *curr_bd, *last_bd;
 	u32 frame_status;
@@ -6795,7 +6379,7 @@ static int emac_rx_bdproc(emac_dev_t * _
 		}
 
 		/* recycle BD */
-		emac_add_bdto_rx_queue(_dev, rx_cppi, last_bd, new_buffer,
+		emac_add_bdto_rx_queue(dev, rx_cppi, last_bd, new_buffer,
 				       new_buf_token);
 
 		/* return the packet to the user - BD ptr passed in
@@ -6828,7 +6412,7 @@ static int emac_rx_bdproc(emac_dev_t * _
  */
 static int emac_poll(struct net_device *netdev, int *budget)
 {
-	emac_dev_t *dev = netdev_priv(netdev);
+	struct emac_dev *dev = netdev_priv(netdev);
 	unsigned int work = min(netdev->quota, *budget);
 	unsigned int pkts_pending = 0;
 	/* this is used to pass the rx packets to be processed and
@@ -6868,7 +6452,7 @@ static int emac_poll(struct net_device *
  */
 void emac_poll_controller(struct net_device *netdev)
 {
-	emac_dev_t *dev = NETDEV_PRIV(netdev);
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
 
 	disable_irq(netdev->irq);
 	emac_hal_isr(netdev->irq, dev, NULL);
@@ -6877,7 +6461,7 @@ void emac_poll_controller(struct net_dev
 #endif
 
 /* allocate RX buffer */
-void *emac_net_alloc_rx_buf(emac_dev_t * dev, int buf_size,
+void *emac_net_alloc_rx_buf(struct emac_dev *dev, int buf_size,
 			    emac_net_data_token * data_token,
 			    u32 channel, void *alloc_args)
 {
@@ -6908,7 +6492,7 @@ void *emac_net_alloc_rx_buf(emac_dev_t *
 }
 
 /* free RX buffer */
-static int emac_net_free_rx_buf(emac_dev_t * dev, void *buffer,
+static int emac_net_free_rx_buf(struct emac_dev *dev, void *buffer,
 				emac_net_data_token data_token,
 				u32 channel, void *free_args)
 {
@@ -6926,7 +6510,7 @@ static int emac_net_free_rx_buf(emac_dev
  * Note that rxArgs contains "channel" and is ignored for this
  * implementation
 */
-static int emac_net_rx_cb(emac_dev_t * dev,
+static int emac_net_rx_cb(struct emac_dev *dev,
 		          net_pkt_obj * net_pkt_list,
 			  void *rx_args)
 {
@@ -6952,7 +6536,7 @@ static int emac_net_rx_cb(emac_dev_t * d
 
 
 /* transmit complete callback */
-static int emac_net_tx_complete(emac_dev_t * dev,
+static int emac_net_tx_complete(struct emac_dev *dev,
 				emac_net_data_token * net_data_tokens,
 				int num_tokens, u32 channel)
 {
@@ -6982,7 +6566,7 @@ static int emac_net_tx_complete(emac_dev
 
 irqreturn_t emac_hal_isr(int irq, void *dev_id, struct pt_regs *regs)
 {
-	emac_dev_t *dev = (emac_dev_t *) dev_id;
+	struct emac_dev *dev = (struct emac_dev *) dev_id;
 
 	++dev->isr_count;
 	if (!dev->set_to_close) {
@@ -7001,7 +6585,7 @@ static int emac_dev_tx(struct sk_buff *s
 	int ret_code;
 	net_buf_obj tx_buf;	/* buffer object - only single frame support */
 	net_pkt_obj tx_packet;	/* packet object */
-	emac_dev_t *dev = NETDEV_PRIV(netdev);
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
 	/* ANANT HACK: unsigned long flags; */
 
 	/* Build the buffer and packet objects - Since only single fragment is
@@ -7052,13 +6636,13 @@ static int emac_dev_tx(struct sk_buff *s
 /* emac_disable_interrupt : Turns of the interrupts from the
  * peripheral to the CPU. we have four interrupt lines
  * running to the CPU, we handle them as a set*/
-static void emac_disable_interrupt(emac_dev_t *edev)
+static void emac_disable_interrupt(struct emac_dev *edev)
 {
         if (device_is_dm646x) {
                 unsigned long flags;
-                ewrap_dm646x_regs *dm646x_wrap;
+                volatile struct ewrap_dm646x_regs *dm646x_wrap;
 
-                dm646x_wrap = &edev->e_wrap_regs->wrapper_646x_regs;
+                dm646x_wrap = &edev->ewrap_regs->wrapper_646x_regs;
                 local_irq_save(flags);
                 /* Program C0_Int_En to zero to turn off
                  * interrupts to the CPU */
@@ -7069,20 +6653,20 @@ static void emac_disable_interrupt(emac_
 
                 local_irq_restore(flags);
         } else {
-                ewrap_dm644x_regs *dm644x_wrap;
+                volatile struct ewrap_dm644x_regs *dm644x_wrap;
 
-                dm644x_wrap = &edev->e_wrap_regs->wrapper_644x_regs;
+                dm644x_wrap = &edev->ewrap_regs->wrapper_644x_regs;
                 dm644x_wrap->EWCTL = 0x0;
         }
 }
 
-static void emac_enable_interrupt(emac_dev_t *edev, int ack_eoi)
+static void emac_enable_interrupt(struct emac_dev *edev, int ack_eoi)
 {
         if (device_is_dm646x) {
                 unsigned long flags;
-                ewrap_dm646x_regs *dm646x_wrap;
+                volatile struct ewrap_dm646x_regs *dm646x_wrap;
 
-                dm646x_wrap = &edev->e_wrap_regs->wrapper_646x_regs;
+                dm646x_wrap = &edev->ewrap_regs->wrapper_646x_regs;
 
                 local_irq_save(flags);
 
@@ -7100,55 +6684,30 @@ static void emac_enable_interrupt(emac_d
                         /* ack rxthresh- only then a new pulse is generated */
                         edev->regs->mac_EOI_vector =
                             EMAC_DM646X_MAC_EOI_C0_RXTHRESH;
-                        /*ack rxen only then a new pulse will be generated */                        edev->regs->mac_EOI_vector =
-                            EMAC_DM646X_MAC_EOI_C0_RXEN;
+			/*ack rxen only then a new pulse will be generated */
+			edev->regs->mac_EOI_vector =
+				EMAC_DM646X_MAC_EOI_C0_RXEN;
                         /*ack txen- only then a new pulse will be generated */
                         edev->regs->mac_EOI_vector =
                             EMAC_DM646X_MAC_EOI_C0_TXEN;
-                        /*ack macen- only then a new pulse will be generated
-*/
+			/*ack macen- only then a new pulse will be generated */
                         edev->regs->mac_EOI_vector =
                             EMAC_DM646X_MAC_EOI_C0_MISCEN;
                 }
 
                 local_irq_restore(flags);
         } else {
-                ewrap_dm644x_regs *dm644x_wrap;
+                volatile struct ewrap_dm644x_regs *dm644x_wrap;
 
-                dm644x_wrap = &edev->e_wrap_regs->wrapper_644x_regs;
+                dm644x_wrap = &edev->ewrap_regs->wrapper_644x_regs;
                 dm644x_wrap->EWCTL = 0x1;
         }
 }
-/******************************************************************************
- *  Linux Driver Model
- *****************************************************************************/
-
-/* The real device and driver matching will be done by the
- * match routine of the platform bus. It is necessary
- * for the probe function to be non null though.
- * We have a function that just returns zero. "All matched."
- */
-static int __devinit emac_probe(struct device *dev)
-{
-	return 0;
-}
-
-/* structure describing the EMAC driver */
-static struct device_driver emac_driver = {
-	.name = "emac",
-	.bus = &platform_bus_type,
-	.probe = emac_probe,
-	.remove = NULL,		/* TODO: findout when probe would be called. */
-	.suspend = NULL,
-	.resume = NULL,
-};
 
 /******************************************************************************
  *  Linux Module Init/Exit
  *****************************************************************************/
 
-static struct platform_device *emac_dev;
-
 static ssize_t emac_show_version(struct device_driver *drv, char *buf)
 {
 	return emac_p_get_version(buf, NULL, 0, 4096, NULL, NULL);
@@ -7157,11 +6716,12 @@ static ssize_t emac_show_version(struct 
 static DRIVER_ATTR(version, S_IRUGO, emac_show_version, NULL);
 
 /* probe number of EMAC instances and register net_device structure */
-static int __init emac_dev_probe(void)
+static int __init davinci_emac_probe(struct platform_device *pdev)
 {
-	int ret_val = 0;
-	int unit;
-	int instance_count = EMAC_MAX_INSTANCES;
+	struct emac_init_config *pdata = pdev->dev.platform_data;
+	struct net_device *netdev;
+	struct emac_dev *dev;
+	int err = 0;
 
         if (cpu_is_davinci_dm6467())
                 device_is_dm646x = TRUE;
@@ -7172,85 +6732,53 @@ static int __init emac_dev_probe(void)
 	emac_clk = clk_get(0, "EMACCLK");
 	if (IS_ERR(emac_clk)) {
 		printk("TI DAVINCI EMAC: Failed to get clock. Exiting\n");
-		return (-1);
+		return -1;
 	}
 	clk_enable(emac_clk);
-	emac_bus_frequency = clk_get_rate(emac_clk);
 
-	emac_dev =
-	    platform_device_register_simple("ti_davinci_emac", -1, NULL, 0);
+	netdev = alloc_etherdev(sizeof(struct emac_dev));
+	if (!netdev) {
+		printk ("TI DaVinci EMAC: Etherdev alloc failed (1).\n");
 
-	if (IS_ERR(emac_dev)) {
+		err = -ENOMEM;
 		/* if error, free EMAC clock */
 		clk_disable(emac_clk);
-		return -1;
+		goto err;
 	}
 
-	if (driver_register(&emac_driver)) {
-		platform_device_unregister(emac_dev);
-
-		/* if error, free EMAC clock */
-		clk_disable(emac_clk);
-		return -1;
-	}
+	dev = NETDEV_PRIV(netdev);
+	dev->owner = netdev;
+	netdev->init = emac_dev_init;
+	SET_NETDEV_DEV(netdev, &(pdev->dev));
+	memcpy(&dev->init_cfg, pdata, sizeof(struct emac_init_config));
 
-	driver_create_file(&emac_driver, &driver_attr_version);
-	for (unit = 0; unit < instance_count; unit++) {
-		struct net_device *netdev;
-		emac_dev_t *dev;
-		int failed;
-
-		if (!(netdev = alloc_etherdev(sizeof(emac_dev_t)))) {
-			printk
-			    ("TI DaVinci EMAC: Etherdev alloc failed for device inst %d.\n",
-			     unit);
-
-			ret_val = -ENOMEM;
-			/* if error, free EMAC clock */
-			clk_disable(emac_clk);
-			break;
-		}
-		dev = NETDEV_PRIV(netdev);
-		dev->owner = netdev;
-		dev->instance_num = unit;
-		netdev->init = emac_dev_init;
-		SET_NETDEV_DEV(netdev, &(emac_dev->dev));
-		emac_net_dev[dev->instance_num] = netdev;
 #if defined CONFIG_EMAC_INIT_BUF_MALLOC
-		g_init_enable_flag = 1;
+	g_init_enable_flag = 1;
 #endif
-		emac_p_detect_manual_cfg(cfg_link_speed, cfg_link_mode,
-					 debug_mode);
-		if (emac_cfg_probe()) {
-			printk("TI DAVINCI EMAC: Error in configuration.\n");
-			return (-1);
-		}
+	emac_p_detect_manual_cfg(cfg_link_speed, cfg_link_mode);
 
-		/* register the network device with linux */
-		failed = register_netdev(netdev);
+	platform_set_drvdata(pdev, netdev);
 
-		if (failed) {
-			ERR("Could not register device: %d\n", failed);
+	/* register the network device with linux */
+	err = register_netdev(netdev);
 
-			ret_val = -1;
+	if (err) {
+		ERR("Could not register device: %d\n", err);
 
-			clk_disable(emac_clk);
+		clk_disable(emac_clk);
 
-			FREE_NETDEV(netdev);
-			break;
-		} else {
-			dev->next_device = last_emac_device;
-			last_emac_device = netdev;
-			DBG("%s irq=%2d io=%04x\n",
-			    netdev->name, (int)netdev->irq,
-			    (int)netdev->base_addr);
-			create_proc_read_entry("net/emac_rfc2665_stats", 0,
-					       NULL, emac_p_read_rfc2665_stats,
-					       netdev);
-		}
+		FREE_NETDEV(netdev);
+	} else {
+		dev->next_device = last_emac_device;
+		last_emac_device = netdev;
+		pr_debug("%s irq=%2d io=%04x\n",
+		    netdev->name, (int)netdev->irq,
+		    (int)netdev->base_addr);
+		create_proc_read_entry("net/emac_rfc2665_stats", 0,
+				       NULL, emac_p_read_rfc2665_stats,
+				       netdev);
 	}
-
-	if (ret_val == 0) {
+	if (err == 0) {
 		/* to maintain backward compatibility with NSP. */
 		gp_stats_file = create_proc_entry("net/emac_stats", 0644, NULL);
 		if (gp_stats_file) {
@@ -7264,69 +6792,68 @@ static int __init emac_dev_probe(void)
 		create_proc_read_entry("net/emac_config", 0, NULL,
 				       emac_dump_config, NULL);
 	}
-	emac_devices_installed = unit;
+	emac_devices_installed++;
 
 	printk("%s\n", emac_version_string);
-	printk("TI DaVinci EMAC: Installed %d instances.\n", unit);
 #if defined CONFIG_EMAC_INIT_BUF_MALLOC
 	printk
 	    ("TI DAVINCI EMAC driver is allocating buffer memory at init time.\n");
 #endif
 
-	return ((unit >= 0) ? 0 : -ENODEV);
+err:
+	return err;
 }
 
 /* frees the EMAC device structures */
-static void emac_exit(void)
+static int __devexit davinci_emac_remove(struct platform_device *pdev)
 {
-	struct net_device *netdev;
-	emac_dev_t *dev;
+	struct net_device *netdev = platform_get_drvdata(pdev);
+	struct emac_dev *dev = NETDEV_PRIV(netdev);
 	int ret_code;
 
-	while (emac_devices_installed) {
-		char proc_name[100];
-		int proc_category_name_len = 0;
-
-		netdev = last_emac_device;
-		dev = NETDEV_PRIV(netdev);
+	char proc_name[100];
+	int proc_category_name_len = 0;
 
-		DBG("Unloading %s irq=%2d io=%04x\n",
-		    netdev->name, (int)netdev->irq, (int)netdev->base_addr);
+	/* free EMAC clock */
+	clk_disable(emac_clk);
 
-		/* free EMAC clock */
-		clk_disable(emac_clk);
-
-		if (g_init_enable_flag) {
-			emac_p_dev_disable(dev);
-		}
+	if (g_init_enable_flag)
+		emac_p_dev_disable(dev);
 
-		/* deinit DDC */
-		ret_code = emac_de_init(dev, NULL);
+	/* deinit DDC */
+	ret_code = emac_de_init(dev, NULL);
 
-		if (ret_code != EMAC_SUCCESS) {
-			ERR("Error %08X from Deinit()\n", ret_code);
+	if (ret_code != EMAC_SUCCESS) {
+		ERR("Error %08X from Deinit()\n", ret_code);
 
-			/* we dont want to quit from here, lets delete
-			 * the instance also */
-		}
+		/* we dont want to quit from here, lets delete
+		 * the instance also */
+	}
 
-		/* delete the proc entry */
-		strcpy(proc_name, "davinci/");
-		strcat(proc_name, netdev->name);
-		proc_category_name_len = strlen(proc_name);
-		strcpy(proc_name + proc_category_name_len, "_rfc2665_stats");
-		remove_proc_entry(proc_name, NULL);
+	/* delete the proc entry */
+	strcpy(proc_name, "davinci/");
+	strcat(proc_name, netdev->name);
+	proc_category_name_len = strlen(proc_name);
+	strcpy(proc_name + proc_category_name_len, "_rfc2665_stats");
+	remove_proc_entry(proc_name, NULL);
 
-		/* release memory region and unregister the device */
-		release_mem_region(netdev->base_addr, EMAC_DEFAULT_EMAC_SIZE);
-		unregister_netdev(netdev);
+	if (g_init_enable_flag)
+		emac_p_dev_disable(dev);
 
-		last_emac_device = dev->next_device;
-		if (netdev)
-			FREE_NETDEV(netdev);
+	/* deinit DDC */
+	ret_code = emac_de_init(dev, NULL);
+	if (ret_code != EMAC_SUCCESS)
+		ERR("Error %08X from Deinit()\n", ret_code);
+
+	/* release memory region and unregister the device */
+	release_mem_region(netdev->base_addr, EMAC_DEFAULT_EMAC_SIZE);
+	unregister_netdev(netdev);
+
+	last_emac_device = dev->next_device;
+	if (netdev)
+		FREE_NETDEV(netdev);
 
-		emac_devices_installed--;
-	}
+	emac_devices_installed--;
 
 	if (gp_stats_file)
 		remove_proc_entry("net/emac_stats", NULL);
@@ -7335,14 +6862,38 @@ static void emac_exit(void)
 	remove_proc_entry("net/emac_ver", NULL);
 	remove_proc_entry("net/emac_config", NULL);
 
-	platform_device_unregister(emac_dev);
+	return 0;
+}
+
+static struct platform_driver davinci_emac_driver = {
+	.driver	= {
+		.name = "emac_davinci",
+		.owner = THIS_MODULE,
+	},
+	.probe = davinci_emac_probe,
+	.remove = __devexit_p(davinci_emac_remove),
+};
 
-	printk("TI DAVINCI EMAC: platform device unregistered.\n");
-	driver_remove_file(&emac_driver, &driver_attr_version);
-	printk("TI DAVINCI EMAC: driver file removed.\n");
-	driver_unregister(&emac_driver);
-	printk("TI DAVINCI EMAC: driver unregistered.\n");
+static int __init davinci_emac_init(void)
+{
+	int err = platform_driver_register(&davinci_emac_driver);
+	if (!err)
+		driver_create_file(&davinci_emac_driver.driver,
+				&driver_attr_version);
+	return err;
 }
 
-module_init(emac_dev_probe);
-module_exit(emac_exit);
+static void __exit davinci_emac_exit(void)
+{
+	driver_remove_file(&davinci_emac_driver.driver, &driver_attr_version);
+	platform_driver_unregister(&davinci_emac_driver);
+
+}
+
+module_init(davinci_emac_init);
+module_exit(davinci_emac_exit);
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_DESCRIPTION("TI DaVinci EMAC Driver");
+MODULE_LICENSE("GPL");
+
Index: linux-2.6.18/mvl_patches/pro50-2122.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-2122.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2009 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(2122);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

