#! /usr/bin/env bash
# Patch: -pro_arm_davinci_dm6467_v4l2
# Date: Fri Sep 19 14:00:57 2008
# Source: MontaVista Software, Inc.
# MR: 28149 
# Type: Integration
# Disposition: merged from pro_40
# Signed-off-by: Pavel Kiryukhin <pkiryukhin@ru.mvista.com>
# Description: DaVinci dm6467 V4L2 drivers.
# 
#  arch/arm/mach-davinci/Makefile                   |    3 
#  arch/arm/mach-davinci/video_hdevm.c              |  238 +
#  drivers/char/Kconfig                             |    7 
#  drivers/char/Makefile                            |    3 
#  drivers/char/davinci_vdce.c                      | 2959 ++++++++++++++++++++++
#  drivers/char/davinci_vdce_hw.c                   |  320 ++
#  drivers/media/video/Kconfig                      |   61 
#  drivers/media/video/davinci/Makefile             |    9 
#  drivers/media/video/davinci/adv7343.c            | 2414 ++++++++++++++++++
#  drivers/media/video/davinci/davincihd_capture.c  | 3048 +++++++++++++++++++++++
#  drivers/media/video/davinci/davincihd_display.c  | 2545 +++++++++++++++++++
#  drivers/media/video/davinci/davincihd_platform.c |   89 
#  drivers/media/video/davinci/tvp5147.c            | 1654 ++++++++++++
#  drivers/media/video/davinci/tvp7002.c            | 1325 +++++++++
#  drivers/media/video/davinci/vpif.c               |  426 +++
#  include/asm-arm/arch-davinci/davinci_vdce.h      |  460 +++
#  include/asm-arm/arch-davinci/davinci_vdce_hw.h   |  254 +
#  include/asm-arm/arch-davinci/video_hdevm.h       |   36 
#  include/media/davinci/adv7343.h                  |  768 +++++
#  include/media/davinci/davincihd_capture.h        |  238 +
#  include/media/davinci/davincihd_display.h        |  208 +
#  include/media/davinci/tvp5147.h                  |  223 +
#  include/media/davinci/tvp7002.h                  |  484 +++
#  include/media/davinci/vid_decoder_if.h           |  199 +
#  include/media/davinci/vpif.h                     |  727 +++++
#  25 files changed, 18697 insertions(+), 1 deletion(-)
# 

PATCHNUM=1579
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc.
MR: 28149 
Type: Integration
Disposition: merged from pro_40
Signed-off-by: Pavel Kiryukhin <pkiryukhin@ru.mvista.com>
Description: DaVinci dm6467 V4L2 drivers.

 arch/arm/mach-davinci/Makefile                   |    3 
 arch/arm/mach-davinci/video_hdevm.c              |  238 +
 drivers/char/Kconfig                             |    7 
 drivers/char/Makefile                            |    3 
 drivers/char/davinci_vdce.c                      | 2959 ++++++++++++++++++++++
 drivers/char/davinci_vdce_hw.c                   |  320 ++
 drivers/media/video/Kconfig                      |   61 
 drivers/media/video/davinci/Makefile             |    9 
 drivers/media/video/davinci/adv7343.c            | 2414 ++++++++++++++++++
 drivers/media/video/davinci/davincihd_capture.c  | 3048 +++++++++++++++++++++++
 drivers/media/video/davinci/davincihd_display.c  | 2545 +++++++++++++++++++
 drivers/media/video/davinci/davincihd_platform.c |   89 
 drivers/media/video/davinci/tvp5147.c            | 1654 ++++++++++++
 drivers/media/video/davinci/tvp7002.c            | 1325 +++++++++
 drivers/media/video/davinci/vpif.c               |  426 +++
 include/asm-arm/arch-davinci/davinci_vdce.h      |  460 +++
 include/asm-arm/arch-davinci/davinci_vdce_hw.h   |  254 +
 include/asm-arm/arch-davinci/video_hdevm.h       |   36 
 include/media/davinci/adv7343.h                  |  768 +++++
 include/media/davinci/davincihd_capture.h        |  238 +
 include/media/davinci/davincihd_display.h        |  208 +
 include/media/davinci/tvp5147.h                  |  223 +
 include/media/davinci/tvp7002.h                  |  484 +++
 include/media/davinci/vid_decoder_if.h           |  199 +
 include/media/davinci/vpif.h                     |  727 +++++
 mvl_patches/pro50-1579.c                         |   16 
 26 files changed, 18713 insertions(+), 1 deletion(-)

Index: linux-2.6.18/drivers/media/video/davinci/Makefile
===================================================================
--- linux-2.6.18.orig/drivers/media/video/davinci/Makefile
+++ linux-2.6.18/drivers/media/video/davinci/Makefile
@@ -2,3 +2,12 @@ obj-$(CONFIG_DAVINCI_OSD) += davinci_osd
 # Encoder Manager and Encoders
 obj-$(CONFIG_DAVINCI_ENC_MNGR)  += davinci_enc_mngr.o
 obj-$(CONFIG_VIDEO_DAVINCI_DISPLAY) += davinci_display.o
+
+# DaVinci HD
+obj-$(CONFIG_VIDEO_DAVINCIHD_VPIF) += vpif.o davincihd_platform.o
+obj-$(CONFIG_CAPTURE_DAVINCIHD) += davincihd_capture.o
+obj-$(CONFIG_VIDEO_TVP5147) += tvp5147.o
+obj-$(CONFIG_VIDEO_TVP7002) += tvp7002.o
+
+obj-$(CONFIG_DISPLAY_DAVINCIHD) += davincihd_display.o
+obj-$(CONFIG_VIDEO_ADV7343) += adv7343.o
Index: linux-2.6.18/drivers/media/video/davinci/adv7343.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/adv7343.c
@@ -0,0 +1,2414 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* adv7343.c */
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <media/davinci/adv7343.h>
+#include <asm/arch/i2c-client.h>
+#include <asm/uaccess.h>
+#include <linux/module.h>
+#include <media/davinci/vid_encoder_if.h>
+
+unsigned char reg0 = 0x20;	/* MODE_REG0 */
+unsigned char reg1 = 0x00;	/* MODE_SELECT_REG */
+unsigned char reg2 = ADV7343_SD_MODE_REG2_DEFAULT;	/* SD_MODE_REG2 */
+unsigned char reg6 = 0x00;	/* HD_MODE_REG6 */
+unsigned char reg80 = ADV7343_SD_MODE_REG1_DEFAULT;	/* SD_MODE_REG1 */
+
+unsigned char reg3 = 0x0C;	/* SD_MODE_REG6 */
+unsigned char reg4 = 0x00;	/* SD_SCALE_LSB */
+unsigned char reg5 = 0x04;	/* SD_MODE_REG7 */
+unsigned char reg7 = 0xE8;	/* HD_MODE_REG4 */
+unsigned char reg9 = 0x01;	/* HD_MODE_REG2 */
+unsigned char reg10 = 0x3C;	/* HD_MODE_REG1 */
+unsigned char reg11 = 0x80;	/* Power Mode register */
+unsigned char reg12 = 0x10;	/* SD_CGMS_WSS */
+unsigned char reg13 = 0x10;	/* SD_MODE_REG3 */
+
+static int adv7343_initialize(struct vid_encoder_device *enc, int flag);
+static int adv7343_deinitialize(struct vid_encoder_device *enc);
+
+static int adv7343_setstd(struct vid_enc_mode_info *mode_info,
+			  struct vid_encoder_device *enc);
+static int adv7343_getstd(struct vid_enc_mode_info *mode_info,
+			  struct vid_encoder_device *enc);
+
+static int adv7343_setoutput(char *output, struct vid_encoder_device *enc);
+static int adv7343_getoutput(char *output, struct vid_encoder_device *enc);
+static int adv7343_enumoutput(int index,
+			      char *output, struct vid_encoder_device *enc);
+
+static int adv7343_set_params(void *params, struct vid_encoder_device *enc);
+static int adv7343_get_params(void *params, struct vid_encoder_device *enc);
+
+static int adv7343_setcontrol(enum vid_enc_ctrl_id ctrl,
+			      unsigned char val,
+			      struct vid_encoder_device *enc);
+static int adv7343_getcontrol(enum vid_enc_ctrl_id ctrl,
+			      unsigned char *val,
+			      struct vid_encoder_device *enc);
+
+static int adv7343_set_sdparams(struct adv7343_sd_params *, void *enc);
+static int adv7343_set_hdparams(struct adv7343_hd_params *, void *enc);
+static int adv7343_set_dnrparams(struct adv7343_dnr_params *, void *enc);
+static int adv7343_set_ssafparams(struct adv7343_ssaf_params *, void *enc);
+static int adv7343_set_filterparams(struct adv7343_filter_params *, void *enc);
+static int adv7343_set_rgbmatrix(struct adv7343_rgb_matrix *, void *enc);
+static int adv7343_set_gammaparams(struct adv7343_gamma_params *params,
+				   enum adv7343_params_type type, void *enc);
+
+static int adv7343_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val);
+static int adv7343_write_vbi_data(struct vid_enc_sliced_vbi_data *data,
+				  struct vid_encoder_device *enc);
+static int adv7343_set_vbi_services(struct vid_enc_sliced_vbi_service
+				    *services, struct vid_encoder_device *enc);
+static int adv7343_get_sliced_cap(struct vid_enc_sliced_vbi_service
+				  *service, struct vid_encoder_device *enc);
+
+/* i2c function prototypes */
+static int adv7343_i2c_attach_client(struct i2c_client *,
+				     struct i2c_driver *,
+				     struct i2c_adapter *, int);
+static int adv7343_i2c_detach_client(struct i2c_client *);
+static int adv7343_i2c_probe_adapter(struct i2c_adapter *);
+static int adv7343_i2c_init(void);
+static void adv7343_i2c_cleanup(void);
+
+static int adv7343_start_display(struct vid_encoder_device *);
+static int adv7343_stop_display(struct vid_encoder_device *);
+
+/* following function is used to set ths7303 */
+static int ths7303_setvalue(struct vid_enc_mode_info *mode_info);
+
+static struct adv7343_control_info
+    adv7343_controls[ADV7343_COMPOSITE_NO_CONTROLS] = {
+	{
+	 .register_address = ADV7343_DAC1_OUTPUT_LEVEL,
+	 .value = 0,
+	 .id = VID_ENC_CTRL_GAIN,
+	 .minimum = 0,
+	 .maximum = 255},
+	{
+	 .register_address = ADV7343_SD_BRIGHTNESS_WSS,
+	 .value = 0,
+	 .id = VID_ENC_CTRL_BRIGHTNESS,
+	 .minimum = 0,
+	 .maximum = 127},
+	{
+	 .register_address = ADV7343_SD_HUE_REG,
+	 .value = 0,
+	 .id = VID_ENC_CTRL_HUE,
+	 .minimum = 0,
+	 .maximum = 255}
+};
+
+static struct vid_enc_mode_info
+    adv7343_composite_standards[ADV7343_COMPOSITE_NUM_STD] = {
+	{
+	 .name = VID_ENC_STD_NTSC,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT656,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 480,
+	 .fps = {30000, 1001},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_PAL,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT656,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 576,
+	 .fps = {25, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0}
+};
+
+static struct vid_enc_mode_info
+    adv7343_component_standards[ADV7343_COMPONENT_NUM_STD] = {
+	{
+	 .name = VID_ENC_STD_720P_60,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {60000, 1000},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_720P_25,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {25, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_720P_30,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {30, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_720P_50,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1280,
+	 .yres = 720,
+	 .fps = {50, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080I_30,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 1,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {30000, 1001},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080I_25,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 1,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {25, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_480P_60,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_YCC16,
+	 .interlaced = 0,
+	 .xres = 720,
+	 .yres = 480,
+	 .fps = {60, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_576P_50,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_YCC16,
+	 .interlaced = 0,
+	 .xres = 720,
+	 .yres = 576,
+	 .fps = {50, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_NTSC,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT656,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 480,
+	 .fps = {30000, 1001},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_PAL,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT656,
+	 .interlaced = 1,
+	 .xres = 720,
+	 .yres = 576,
+	 .fps = {25, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080P_24,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {24, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080P_25,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {25, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+	{
+	 .name = VID_ENC_STD_1080P_30,
+	 .std = 1,
+	 .if_type = VID_ENC_IF_BT1120,
+	 .interlaced = 0,
+	 .xres = 1920,
+	 .yres = 1080,
+	 .fps = {30, 1},
+	 .left_margin = 0,
+	 .right_margin = 0,
+	 .upper_margin = 0,
+	 .lower_margin = 0,
+	 .hsync_len = 0,
+	 .vsync_len = 0,
+	 .flags = 0},
+};
+
+struct adv7343_std_info adv7343_composite_std_info[ADV7343_COMPOSITE_NUM_STD] = {
+	{
+	 ADV7343_SD_MODE_REG1, &reg80, SD_INPUT_MODE, (~(SD_STD_MASK)),
+	 SD_STD_NTSC, 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_SD_MODE_REG1, &reg80, SD_INPUT_MODE, (~(SD_STD_MASK)),
+	 SD_STD_PAL_BDGHI, 0x8C, 0xCB, 0x8D, 0x8A, 0x8E, 0x09, 0x8F, 0x2A}
+};
+
+struct adv7343_std_info adv7343_component_std_info[ADV7343_COMPONENT_NUM_STD] = {
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_720P_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_720P << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_720P_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_720P_25 << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_720P_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_720P_30 << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_720P_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_720P_50 << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_1080I_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_1080I << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_1080I_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_1080I_25fps << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_720P_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_525P << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_720P_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_625P << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_SD_MODE_REG1, &reg80, SD_INPUT_MODE, (~(SD_STD_MASK)),
+	 SD_STD_NTSC, 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_SD_MODE_REG1, &reg80, SD_INPUT_MODE, (~(SD_STD_MASK)),
+	 SD_STD_PAL_BDGHI, 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_1080I_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_1080P_24 << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_1080I_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_1080P_25 << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21},
+	{
+	 ADV7343_HD_MODE_REG1, &reg10, HD_1080I_INPUT_MODE,
+	 (~(STD_MODE_MASK << STD_MODE_SHIFT)),
+	 (STD_MODE_1080P_30 << STD_MODE_SHIFT)
+	 , 0x8C, 0x1F, 0x8D, 0x7C, 0x8E, 0xF0, 0x8F, 0x21}
+};
+
+static struct adv7343_config adv7343_configuration[ADV7343_NUM_CHANNELS] = {
+	{
+	 .no_of_outputs = ADV7343_MAX_NO_OUTPUTS,
+	 .output[0] = {
+		       .output_type = ADV7343_COMPOSITE_ID,
+		       .output_name = VID_ENC_OUTPUT_COMPOSITE,
+		       .no_of_standard = ADV7343_COMPOSITE_NUM_STD,
+		       .standard = (struct vid_enc_mode_info *)
+		       &adv7343_composite_standards,
+		       .def_std = &adv7343_composite_standards[0],
+		       .std_info = (struct adv7343_std_info *)
+		       &adv7343_composite_std_info,
+		       .no_of_controls = ADV7343_COMPOSITE_NO_CONTROLS,
+		       .controls = (struct adv7343_control_info *)
+		       &adv7343_controls,
+		       .power_val = ADV7343_COMPOSITE_POWER_VALUE},
+	 .output[1] = {
+		       .output_type = ADV7343_COMPONENT_ID,
+		       .output_name = VID_ENC_OUTPUT_COMPONENT,
+		       .no_of_standard = ADV7343_COMPONENT_NUM_STD,
+		       .standard = (struct vid_enc_mode_info *)
+		       &adv7343_component_standards,
+		       .def_std = &adv7343_component_standards[0],
+		       .std_info = (struct adv7343_std_info *)
+		       &adv7343_component_std_info,
+		       .no_of_controls = ADV7343_COMPONENT_NO_CONTROLS,
+		       .controls = (struct adv7343_control_info *)
+		       &adv7343_controls,
+		       .power_val = ADV7343_COMPONENT_POWER_VALUE},
+	 .output[2] = {
+		       .output_type = ADV7343_SVIDEO_ID,
+		       .output_name = VID_ENC_OUTPUT_SVIDEO,
+		       .no_of_standard = ADV7343_SVIDEO_NUM_STD,
+		       .standard = (struct vid_enc_mode_info *)
+		       &adv7343_composite_standards,
+		       .def_std = &adv7343_composite_standards[0],
+		       .std_info = (struct adv7343_std_info *)
+		       &adv7343_composite_std_info,
+		       .no_of_controls = ADV7343_SVIDEO_NO_CONTROLS,
+		       .controls = (struct adv7343_control_info *)
+		       &adv7343_controls,
+		       .power_val = ADV7343_SVIDEO_POWER_VALUE},
+	 .services_set = VID_ENC_SLICED_VBI_WSS_PAL |
+	 VID_ENC_SLICED_VBI_CGMS_NTSC | VID_ENC_SLICED_VBI_CC_NTSC,
+	 .num_services = 0}
+};
+
+static struct adv7343_service_data_reg
+    adv7343_services_regs[ADV7343_VBI_NUM_SERVICES] = {
+	{
+	 .service_set = VID_ENC_SLICED_VBI_CC_NTSC,
+	 .field = {
+		   {
+		    .addr = {ADV7343_SD_CLOSE_CAPTION_ODD0,
+			     ADV7343_SD_CLOSE_CAPTION_ODD1}
+		    },
+		   {
+		    .addr = {ADV7343_SD_CLOSE_CAPTION_EVEN0,
+			     ADV7343_SD_CLOSE_CAPTION_EVEN1}
+		    }
+		   },
+	 .bytestowrite = 2},
+	{
+	 .service_set = VID_ENC_SLICED_VBI_WSS_PAL,
+	 .field = {
+		   {
+		    .addr = {ADV7343_SD_CGMS_WSS2,
+			     ADV7343_SD_CGMS_WSS1}
+		    },
+		   {
+		    .addr = {ADV7343_SD_CGMS_WSS2,
+			     ADV7343_SD_CGMS_WSS1}
+		    }
+		   },
+	 .bytestowrite = 2}
+};
+
+static struct adv7343_service_reg adv7343_sliced_reg[ADV7343_VBI_NUM_SERVICES] = {
+
+	{
+	 .service = VID_ENC_SLICED_VBI_WSS_PAL,
+	 .reg = ADV7343_SD_CGMS_WSS0,
+	 .reg_val = &reg12,
+	 .enable_val = SD_WSS_EN,
+	 .disable_val = SD_WSS_DI,
+	 .std = &adv7343_composite_standards[1]},
+	{
+	 .service = VID_ENC_SLICED_VBI_CC_NTSC,
+	 .reg = ADV7343_SD_MODE_REG3,
+	 .reg_val = &reg13,
+	 .enable_val = SD_CLOSE_CAPTION_BOTH,
+	 .disable_val = SD_CLOSE_CAPTION_DI,
+	 .std = &adv7343_composite_standards[0]},
+	{
+	 .service = VID_ENC_SLICED_VBI_CGMS_NTSC,
+	 .reg = ADV7343_SD_CGMS_WSS0,
+	 .reg_val = &reg12,
+	 .enable_val = SD_CGMS_EN,
+	 .disable_val = SD_CGMS_DI,
+	 .std = &adv7343_composite_standards[0]}
+};
+
+static struct adv7343_channel adv7343_channel_info[ADV7343_NUM_CHANNELS] = {
+	{
+	 .current_output = ADV7343_COMPOSITE_ID,
+	 .mode_info = &adv7343_composite_standards[0],
+	 .i2c_dev = {
+		     .i2c_addr = (0x54 >> 1),
+		     .i2c_registration = 0},
+	 .enc_device = NULL}
+};
+
+/* Global variables */
+static struct device *adv7343_i2c_dev[ADV7343_NUM_CHANNELS];
+
+/* Global structures variables */
+static struct vid_enc_param_ops params_ops = {
+	.setparams = adv7343_set_params,
+	.getparams = adv7343_get_params
+};
+
+static struct vid_enc_control_ops controls_ops = {
+	.setcontrol = adv7343_setcontrol,
+	.getcontrol = adv7343_getcontrol
+};
+
+static struct vid_enc_output_ops outputs_ops = {
+	.count = ADV7343_MAX_NO_OUTPUTS,
+	.enumoutput = adv7343_enumoutput,
+	.setoutput = adv7343_setoutput,
+	.getoutput = adv7343_getoutput
+};
+
+static struct vid_enc_mode_ops standards_ops = {
+	.setmode = adv7343_setstd,
+	.getmode = adv7343_getstd,
+};
+
+static struct vid_encoder_device adv7343_dev[ADV7343_NUM_CHANNELS] = {
+	{
+	 .name = "ADV7343",
+	 .channel_id = 0,
+	 .capabilities = 0,
+	 .initialize = adv7343_initialize,
+	 .mode_ops = &standards_ops,
+	 .ctrl_ops = &controls_ops,
+	 .output_ops = &outputs_ops,
+	 .params_ops = &params_ops,
+	 .deinitialize = adv7343_deinitialize,
+	 .misc_ops = NULL,
+	 .write_vbi_data = adv7343_write_vbi_data,
+	 .enable_vbi = NULL,
+	 .enable_hbi = NULL,
+	 .set_vbi_services = adv7343_set_vbi_services,
+	 .get_sliced_cap = adv7343_get_sliced_cap,
+	 .start_display = adv7343_start_display,
+	 .stop_display = adv7343_stop_display}
+};
+
+/* This function is called by the vpif driver to initialize ADV7343 driver.
+ * It initializes all registers of adv7343 with the default values
+ */
+static int adv7343_initialize(struct vid_encoder_device *enc, int flag)
+{
+	int err = 0;
+	int ch_id;
+	struct i2c_client *ch_client;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	ch_client = &adv7343_channel_info[ch_id].i2c_dev.client;
+	if (adv7343_channel_info[ch_id].i2c_dev.i2c_registration & 0x01) {
+		printk(KERN_ERR "adv7343 driver is already initialized..\n");
+		return err;
+	}
+
+	/* Register ADV7343 I2C client */
+	err = i2c_add_driver(&adv7343_channel_info[ch_id].i2c_dev.driver);
+	if (err) {
+		printk(KERN_ERR "Failed to register ADV7343 I2C client.\n");
+		return -EINVAL;
+	}
+	adv7343_channel_info[ch_id].i2c_dev.i2c_registration |= 1;
+	adv7343_channel_info[ch_id].enc_device = enc;
+	if (VID_ENC_I2C_BIND_FLAG == flag) {
+		return err;
+	}
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "ADV7343 driver registered\n");
+
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SOFT_RESET,
+				     ADV7343_SOFT_RESET_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_POWER_MODE_REG,
+				     ADV7343_POWER_MODE_REG_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_MODE_SELECT_REG,
+				     ADV7343_MODE_SELECT_REG_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_MODE_REG0,
+				     ADV7343_MODE_REG0_DEFAULT);
+
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_DAC1_OUTPUT_LEVEL,
+				     ADV7343_DAC1_OUTPUT_LEVEL_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_DAC2_OUTPUT_LEVEL,
+				     ADV7343_DAC2_OUTPUT_LEVEL_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG1,
+				     ADV7343_HD_MODE_REG1_DEFAULT);
+
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG2,
+				     ADV7343_HD_MODE_REG2_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG3,
+				     ADV7343_HD_MODE_REG3_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG4,
+				     ADV7343_HD_MODE_REG4_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG5,
+				     ADV7343_HD_MODE_REG5_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG6,
+				     ADV7343_HD_MODE_REG6_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_HD_MODE_REG7,
+				     ADV7343_HD_MODE_REG7_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG1,
+				     ADV7343_SD_MODE_REG1_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG2,
+				     ADV7343_SD_MODE_REG2_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG3,
+				     ADV7343_SD_MODE_REG3_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG4,
+				     ADV7343_SD_MODE_REG4_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG5,
+				     ADV7343_SD_MODE_REG5_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG6,
+				     ADV7343_SD_MODE_REG6_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG7,
+				     ADV7343_SD_MODE_REG7_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_MODE_REG8,
+				     ADV7343_SD_MODE_REG8_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_TIMING_REG0,
+				     ADV7343_SD_TIMING_REG0_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_TIMING_REG0,
+				     ADV7343_SD_TIMING_REG0_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_HUE_REG,
+				     ADV7343_SD_HUE_REG_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_CGMS_WSS0,
+				     ADV7343_SD_CGMS_WSS0_DEFAULT);
+	err |= adv7343_i2c_write_reg(ch_client,
+				     ADV7343_SD_BRIGHTNESS_WSS,
+				     ADV7343_SD_BRIGHTNESS_WSS_DEFAULT);
+
+	if (err < 0) {
+		err = -EINVAL;
+		adv7343_deinitialize(enc);
+		return err;
+	} else {
+		adv7343_channel_info[ch_id].current_output = 0;
+		adv7343_channel_info[ch_id].mode_info =
+		    &adv7343_composite_standards[0];
+		/* Configure for default video standard */
+		/* call set standard */
+		err |=
+		    adv7343_setoutput(adv7343_configuration[ch_id].
+				      output[0].output_name, enc);
+		err |=
+		    adv7343_setstd(adv7343_configuration[ch_id].output[0].
+				   def_std, enc);
+		if (err < 0) {
+			err = -EINVAL;
+			adv7343_deinitialize(enc);
+			return err;
+		}
+	}
+	adv7343_channel_info[ch_id].i2c_dev.i2c_registration |= 2;
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_initialize>\n");
+	return err;
+}
+
+static int adv7343_deinitialize(struct vid_encoder_device *enc)
+{
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "ADV7343 ch \
+			deinitialization called\n");
+
+	if (adv7343_channel_info[ch_id].i2c_dev.i2c_registration & 0x01) {
+		i2c_del_driver(&adv7343_channel_info[ch_id].i2c_dev.driver);
+		adv7343_channel_info[ch_id].i2c_dev.client.adapter = NULL;
+		adv7343_channel_info[ch_id].i2c_dev.i2c_registration &= ~(0x01);
+		adv7343_channel_info[ch_id].enc_device = NULL;
+	}
+	return 0;
+}
+
+int adv7343_start_display(struct vid_encoder_device *enc)
+{
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "ADV7343 ch \
+		start display called\n");
+
+	try_module_get(THIS_MODULE);
+	return 0;
+}
+
+int adv7343_stop_display(struct vid_encoder_device *enc)
+{
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "ADV7343 ch \
+			start display called\n");
+
+	module_put(THIS_MODULE);
+	return 0;
+}
+
+static int adv7343_set_vbi_services(struct vid_enc_sliced_vbi_service
+				    *services, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	unsigned char val1 = 0;
+	int i;
+	u8 num_services = 0;
+
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "adv7343_set_vbi_services\n");
+
+	if (NULL == services) {
+		dev_err(adv7343_i2c_dev[ch_id], "NULL pointer.\n");
+		return -EINVAL;
+	}
+	if ((services->service_set |
+	     adv7343_configuration[ch_id].services_set) !=
+	    adv7343_configuration[ch_id].services_set) {
+		dev_err(adv7343_i2c_dev[ch_id], "Invalid service\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < ADV7343_VBI_NUM_SERVICES; i++) {
+		if ((services->service_set & adv7343_sliced_reg[i].service)
+		    && (0 !=
+			strcmp(adv7343_sliced_reg[i].std->name,
+			       adv7343_channel_info[ch_id].mode_info->name))) {
+			dev_err(adv7343_i2c_dev[ch_id],
+				"Standard doesn't " "support this service\n");
+			return -EINVAL;
+		}
+		val1 = *adv7343_sliced_reg[i].reg_val;
+
+		if (services->service_set & adv7343_sliced_reg[i].service) {
+			val1 |= adv7343_sliced_reg[i].enable_val;
+			num_services++;
+		} else {
+			val1 &= adv7343_sliced_reg[i].disable_val;
+		}
+
+		err |=
+		    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].
+					  i2c_dev.client,
+					  adv7343_sliced_reg[i].reg, val1);
+		*adv7343_sliced_reg[i].reg_val = val1;
+	}
+	adv7343_configuration[ch_id].num_services = num_services;
+	adv7343_channel_info[ch_id].services_set = services->service_set;
+	return (err < 0) ? err : num_services;
+}
+
+/* This function is used to write the vbi data to the encoder device */
+static int adv7343_write_vbi_data(struct vid_enc_sliced_vbi_data *data,
+				  struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	int i = 0, j, k;
+	unsigned char val1 = 0, val2;
+	u8 num_services;
+
+	if (NULL == enc) {
+		printk(KERN_ERR "adv7343_write_vbi_data:NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "Start of adv7343_write_vbi_data..\n");
+	if (NULL == data) {
+		dev_err(adv7343_i2c_dev[ch_id], "adv7343_write_vbi_data:"
+			"NULL pointer.\n");
+		return -EINVAL;
+	}
+	num_services = adv7343_configuration[ch_id].num_services;
+	for (i = 0; i < num_services; i++) {
+		if (0 == data[i].service_id)
+			continue;
+		if ((data[i].service_id | adv7343_channel_info[ch_id].
+		     services_set) !=
+		    adv7343_channel_info[ch_id].services_set) {
+			printk(KERN_ERR "%d Service Id = %x\n", i,
+			       data[i].service_id);
+			dev_err(adv7343_i2c_dev[ch_id], "Invalid Service\n");
+			return -EINVAL;
+		}
+		for (j = 0; j < ADV7343_VBI_NUM_SERVICES; j++) {
+			if (!(adv7343_services_regs[j].service_set &
+			      data[i].service_id))
+				if (data[i].service_id !=
+				    VID_ENC_SLICED_VBI_CGMS_NTSC)
+					continue;
+			if (data[i].service_id & VID_ENC_SLICED_VBI_CGMS_NTSC) {
+				err |=
+				    adv7343_i2c_write_reg
+				    (&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_CGMS_WSS2,
+				     data[i].data[0]);
+
+				err |=
+				    adv7343_i2c_write_reg
+				    (&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_CGMS_WSS1,
+				     data[i].data[1]);
+
+				val1 = *adv7343_sliced_reg[2].reg_val;
+				val2 = data[i].data[2] & 0x0F;
+				val1 |= val2;
+				err |=
+				    adv7343_i2c_write_reg
+				    (&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_CGMS_WSS0, val1);
+				if (err < 0) {
+					dev_err(adv7343_i2c_dev[ch_id],
+						"adv7343_write_vbi_data failed\n");
+					return err;
+				}
+			} else {
+
+				for (k = 0; k <
+				     adv7343_services_regs[j].bytestowrite;
+				     k++) {
+					err |=
+					    adv7343_i2c_write_reg
+					    (&adv7343_channel_info[ch_id].
+					     i2c_dev.client,
+					     adv7343_services_regs[j].
+					     field[data[i].field].addr[k],
+					     data[i].data[0 + k]);
+					if (err < 0) {
+						dev_err(adv7343_i2c_dev
+							[ch_id],
+							"adv7343_write_vbi_data"
+							"failed\n");
+						return err;
+					}
+				}
+			}
+		}
+	}
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_write_vbi_data>\n");
+	return err;
+}
+
+/* This function is used to set the value of the control like brightness,
+   hue */
+static int adv7343_setcontrol(enum vid_enc_ctrl_id ctrl,
+			      unsigned char val, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int value;
+	int output_idx;
+	int ch_id, i = 0;
+	struct adv7343_control_info *control = NULL;
+	int no_of_controls;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_setcontrol>\n");
+	output_idx = adv7343_channel_info[ch_id].current_output;
+
+	value = val;
+	if ((strcmp(adv7343_channel_info[ch_id].mode_info->name,
+		    VID_ENC_STD_NTSC) == 0) ||
+	    (strcmp(adv7343_channel_info[ch_id].mode_info->name,
+		    VID_ENC_STD_PAL) == 0)) {
+		no_of_controls = 3;
+	} else {
+		no_of_controls
+		    = adv7343_configuration[ch_id].output[output_idx].
+		    no_of_controls;
+	}
+
+	for (i = 0; i < no_of_controls; i++) {
+		control = &adv7343_configuration[ch_id].output[output_idx].
+		    controls[i];
+		if (control->id == ctrl) {
+			break;
+		}
+	}
+	if (i == no_of_controls) {
+		return -EINVAL;
+	}
+	if ((control->minimum > value)
+	    || (control->maximum < value)) {
+		return -EINVAL;
+	}
+	if (VID_ENC_CTRL_GAIN == ctrl) {
+		if ((value > POSITIVE_GAIN_MAX)
+		    && (value < NEGATIVE_GAIN_MIN)) {
+			return -EINVAL;
+		} else {
+			err |= adv7343_i2c_write_reg(&adv7343_channel_info
+						     [ch_id].i2c_dev.
+						     client,
+						     ADV7343_DAC2_OUTPUT_LEVEL,
+						     value);
+		}
+	}
+
+	err = adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				    client, control->register_address, value);
+
+	if (err < 0) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"ADV7343 set control fails...\n");
+		return err;
+	}
+	control->value = value;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_setcontrol>\n");
+	return err;
+}
+
+/* This function is used to get the value of the control */
+static int adv7343_getcontrol(enum vid_enc_ctrl_id ctrl,
+			      unsigned char *val,
+			      struct vid_encoder_device *enc)
+{
+	int err = 0, i;
+	int ch_id;
+	struct adv7343_control_info *control = NULL;
+	int output_idx;
+	int no_of_controls;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "Starting getctrl of adv7343...\n");
+	output_idx = adv7343_channel_info[ch_id].current_output;
+
+	/* check for null pointer */
+	if (val == NULL) {
+		dev_err(adv7343_i2c_dev[ch_id], "NULL pointer\n");
+		return -EINVAL;
+	}
+	if ((strcmp(adv7343_channel_info[ch_id].mode_info->name,
+		    VID_ENC_STD_NTSC) == 0) ||
+	    (strcmp(adv7343_channel_info[ch_id].mode_info->name,
+		    VID_ENC_STD_PAL) == 0)) {
+		no_of_controls = 3;
+	} else {
+		no_of_controls
+		    = adv7343_configuration[ch_id].output[output_idx].
+		    no_of_controls;
+	}
+
+	for (i = 0; i < no_of_controls; i++) {
+		control =
+		    &adv7343_configuration[ch_id].output[output_idx].
+		    controls[i];
+		if (control->id == ctrl) {
+			break;
+		}
+	}
+	if (i == no_of_controls) {
+		dev_err(adv7343_i2c_dev[ch_id], "Invalid id...\n");
+		return -EINVAL;
+	}
+
+	*val = control->value;
+
+	if (err < 0) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"ADV7343 get control fails...\n");
+		return err;
+	}
+	if (VID_ENC_CTRL_BRIGHTNESS == ctrl) {
+		(*val) &= SD_BRIGHTNESS_MASK;
+	}
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_getcontrol>\n");
+	return err;
+}
+
+/* following function is used to set ths7303 */
+static int ths7303_setvalue(struct vid_enc_mode_info *mode)
+{
+	int err = 0;
+	u8 val[2];
+	u8 val1;
+	u16 ths7303_i2c_addr = 0x2C;
+
+	if (NULL == mode) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	if ((strcmp(mode->name, VID_ENC_STD_NTSC) == 0) ||
+	    (strcmp(mode->name, VID_ENC_STD_PAL) == 0))
+		val1 = 0x02;
+	else if ((strcmp(mode->name, VID_ENC_STD_480P_60) == 0) ||
+		 (strcmp(mode->name, VID_ENC_STD_576P_50) == 0))
+		val1 = 0x4A;
+	else
+		val1 = 0x92;
+
+	val[0] = 0x01;
+	val[1] = val1;
+	err = davinci_i2c_write(2, val, ths7303_i2c_addr);
+	val[0] = 0x02;
+	val[1] = val1;
+	err = davinci_i2c_write(2, val, ths7303_i2c_addr);
+	val[0] = 0x03;
+	val[1] = val1;
+	err = davinci_i2c_write(2, val, ths7303_i2c_addr);
+	if (err) {
+		printk(KERN_ERR "ths7303\n");
+	}
+	mdelay(100);
+	return err;
+}
+
+static int adv7343_setstd(struct vid_enc_mode_info *mode_info,
+			  struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	int i = 0;
+	struct vid_enc_mode_info *standard;
+	int output_idx;
+	unsigned char val1, val2;
+	u8 reg, val;
+	struct vid_enc_sliced_vbi_service services;
+
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "Start of adv7343_setstd..\n");
+	output_idx = adv7343_channel_info[ch_id].current_output;
+
+	if (mode_info == NULL) {
+		dev_err(adv7343_i2c_dev[ch_id], "NULL pointer.\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < adv7343_configuration[ch_id].output[output_idx].
+	     no_of_standard; i++) {
+		standard =
+		    &adv7343_configuration[ch_id].output[output_idx].
+		    standard[i];
+		if (strcmp(standard->name, mode_info->name) == 0) {
+			break;
+		}
+	}
+	if (i == adv7343_configuration[ch_id].output[output_idx].no_of_standard) {
+		dev_err(adv7343_i2c_dev[ch_id], "Invalid id...\n");
+		return -EINVAL;
+	}
+
+	/* Read Mode Select Register */
+	val1 = reg1;
+
+	val2 = *(adv7343_configuration[ch_id].
+		 output[output_idx].std_info[i].value);
+
+	if (err < 0) {
+		dev_err(adv7343_i2c_dev[ch_id], "Set standard failed\n");
+		return err;
+	}
+	val2 &=
+	    adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    standard_val2;
+	val2 |=
+	    adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    standard_val3;
+	err |=
+	    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				  client,
+				  adv7343_configuration[ch_id].
+				  output[output_idx].std_info[i].
+				  set_std_register, val2);
+	*(adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	  value) = val2;
+
+	val1 &= (~((u8) INPUT_MODE_MASK));
+
+	val1 |=
+	    adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    outputmode_val1;
+
+	/* Write val1 to Mode select register */
+
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_MODE_SELECT_REG, val1);
+	if (err < 0) {
+		dev_err(adv7343_i2c_dev[ch_id], "Set standard failed\n");
+		return err;
+	}
+	reg1 = val1;
+
+	/* Store the standard in global object of adv7343 */
+	adv7343_channel_info[ch_id].mode_info =
+	    &adv7343_configuration[ch_id].output[output_idx].standard[i];
+	ths7303_setvalue(adv7343_channel_info[ch_id].mode_info);
+
+	reg = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc0_reg;
+	val = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc0_val;
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_FSC_REG0,
+				     adv7343_configuration[ch_id].
+				     output[output_idx].std_info[i].fsc0_val);
+
+	reg = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc1_reg;
+	val = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc1_val;
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_FSC_REG1,
+				     adv7343_configuration[ch_id].
+				     output[output_idx].std_info[i].fsc1_val);
+
+	reg = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc2_reg;
+	val = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc2_val;
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_FSC_REG2,
+				     adv7343_configuration[ch_id].
+				     output[output_idx].std_info[i].fsc2_val);
+
+	reg = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc3_reg;
+	val = adv7343_configuration[ch_id].output[output_idx].std_info[i].
+	    fsc3_val;
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_FSC_REG3,
+				     adv7343_configuration[ch_id].
+				     output[output_idx].std_info[i].fsc3_val);
+	val1 = reg80;
+	if (0 == strcmp(mode_info->name, VID_ENC_STD_NTSC)) {
+		val1 &= 0x03;
+	} else if (0 == strcmp(mode_info->name, VID_ENC_STD_PAL)) {
+		val1 |= 0x04;
+	}
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_MODE_REG1, val1);
+	reg80 = val1;
+
+	/* disable all VBI sliced vbi services */
+	services.service_set = 0;
+	err |= adv7343_set_vbi_services(&services, enc);
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_setstd>\n");
+	return err;
+}
+
+/* Following function is used to get currently selected standard.*/
+static int adv7343_getstd(struct vid_enc_mode_info *mode_info,
+			  struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "Starting getstd function.\n");
+
+	if (mode_info == NULL) {
+		dev_err(adv7343_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	/* Read the video standard */
+	memcpy(mode_info, adv7343_channel_info[ch_id].mode_info,
+	       sizeof(struct vid_enc_mode_info));
+	dev_dbg(adv7343_i2c_dev[ch_id], "End of getstd function.\n");
+	return err;
+}
+
+static int adv7343_get_sliced_cap(struct vid_enc_sliced_vbi_service
+				  *service, struct vid_encoder_device *enc)
+{
+	int ch_id;
+	if (NULL == enc || NULL == service) {
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+
+	service->service_set = adv7343_configuration[ch_id].services_set;
+	return 0;
+}
+static int adv7343_enumoutput(int index, char *output,
+			      struct vid_encoder_device *enc)
+{
+	int err = 0, ch_id;
+	if (NULL == enc || NULL == output) {
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	if (index >= adv7343_configuration[ch_id].no_of_outputs) {
+		return -EINVAL;
+	}
+	strncpy(output,
+		adv7343_configuration[ch_id].output[index].output_name,
+		VID_ENC_NAME_MAX_CHARS);
+	return err;
+}
+
+/* Following function is used to set output format in ADV7343 device. The index
+   of the output format is  passed as the argument to this function. */
+static int adv7343_setoutput(char *output, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	unsigned char val1, val2;
+	int ch_id, i;
+	int index;
+
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "Start of set output function.\n");
+
+	/* check for null pointer */
+	if (output == NULL) {
+		dev_err(adv7343_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < adv7343_configuration[ch_id].no_of_outputs; i++) {
+		if (0 == strcmp(output,
+				adv7343_configuration[ch_id].output[i].
+				output_name))
+			break;
+	}
+	if (i == adv7343_configuration[ch_id].no_of_outputs)
+		return -EINVAL;
+	index = i;
+	/* Enable Appropriate DAC */
+	val1 = reg11;
+	val1 &= 0x03;
+	val1 |= adv7343_configuration[ch_id].output[index].power_val;
+	err = adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				    client, ADV7343_POWER_MODE_REG, val1);
+	reg11 = val1;
+	/* Enable YUV output mode in Mode Register 0 */
+
+	/* Read Mode register 0 */
+	val1 = reg0;
+
+	/* Enable YUV output */
+	val1 |= YUV_OUTPUT_SELECT;
+
+	/* write Mode register 0 */
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_MODE_REG0, val1);
+	reg0 = val1;
+
+	/* Read SD MODE REGISTER 2 */
+	val2 = reg2;
+
+	/* configure SD DAC Output 2 and SD DAC Output 1 bit to zero */
+	val2 &= (SD_DAC_1_DI & SD_DAC_2_DI);
+
+	/* write SD MODE REGISTER 2 */
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_MODE_REG2, val2);
+	if (err < 0) {
+		return err;
+	}
+	reg2 = val2;
+
+	/* Read HD MODE REGISTER 6 */
+	val2 = reg6;
+
+	/* configure ED/HD Color DAC Swap and ED/HD RGB Input Enable bit to
+	 * zero */
+	val2 &= (HD_RGB_INPUT_DI & HD_DAC_SWAP_DI);
+
+	/* write HD MODE REGISTER 6 */
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_HD_MODE_REG6, val2);
+	if (err < 0) {
+		return err;
+	}
+	reg6 = val2;
+
+	adv7343_channel_info[ch_id].current_output = index;
+
+	/* set default standard */
+	adv7343_channel_info[ch_id].mode_info
+	    = adv7343_configuration[ch_id].output[index].def_std;
+	err |= adv7343_setstd(adv7343_channel_info[ch_id].mode_info, enc);
+	if (err < 0) {
+		return err;
+	}
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_setoutput>\n");
+	return err;
+}
+
+/* Following function is used to get index of the output currently selected.*/
+static int adv7343_getoutput(char *output, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	int index;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "Start of get output function.\n");
+	/* check for null pointer */
+	if (output == NULL) {
+		dev_err(adv7343_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	index = adv7343_channel_info[ch_id].current_output;
+	strncpy(output, adv7343_configuration[ch_id].output[index].
+		output_name, VID_ENC_NAME_MAX_CHARS);
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_getoutput>\n");
+	return err;
+}
+
+/* This function is used to set parameters depending on the type */
+static int adv7343_set_params(void *p, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	adv7343_params params;
+
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_params>\n");
+	/* Check for null value */
+	if (!(adv7343_params *) p) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_hdparams:NULL pointer\n");
+		return -EINVAL;
+	}
+
+	if (copy_from_user(&params, (adv7343_params *) p, sizeof(params))) {
+		return -EFAULT;
+	}
+
+	if (ADV7343_SDPARAMS == params.type) {
+		/* If parameter type is SD parameters, call
+		 * adv7343_set_sdparams function to set SD parameters */
+		err = adv7343_set_sdparams(&(params.params.sd), enc);
+	} else if (ADV7343_HDPARAMS == params.type) {
+		/* If parameter type is HD parameters, call
+		 * adv7343_set_hdparams function to set HD parameters */
+		err = adv7343_set_hdparams(&(params.params.hd), enc);
+	} else {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_params:invalid type of parameter\n");
+		return -EINVAL;
+	}
+	adv7343_channel_info[ch_id].params = params;
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_params>\n");
+	return err;
+}
+
+/* This function is used to get parameters depending on the type */
+static int adv7343_get_params(void *p, struct vid_encoder_device *enc)
+{
+	int err = 0;
+	int ch_id;
+	adv7343_params *params = (adv7343_params *) p;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	ch_id = enc->channel_id;
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_get_params>\n");
+	/* Check for null value */
+	if (!params) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_get_params:NULL pointer\n");
+		return -EINVAL;
+	}
+
+	if (copy_to_user(params, &(adv7343_channel_info[ch_id].params),
+			 sizeof(*params))) {
+		return -EFAULT;
+	}
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_get_params>\n");
+	return err;
+}
+
+/* This function is used to set SD parameters */
+static int adv7343_set_sdparams(struct adv7343_sd_params *sd, void *enc)
+{
+	int err = 0;
+	unsigned char val1, val2, val3;
+	int ch_id;
+	struct i2c_client *ch_client;
+
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+	ch_client = &adv7343_channel_info[ch_id].i2c_dev.client;
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_sdparams>\n");
+	/* Check for null value */
+	if (!sd) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_sdparams:NULL pointer\n");
+		return -EINVAL;
+	}
+	/* Check for valid value */
+	if (!(ADV7343_VALID_FEATURE_VAL(sd->active_step_edge_scale))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_sdparams:invalid value of"
+			" active_step_edge_scale\n");
+		return -EINVAL;
+	}
+	if (!(ADV7343_VALID_FEATURE_VAL(sd->scale.en_scale))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_sdparams:invalid value of"
+			" scale.en_scale\n");
+		return -EINVAL;
+	}
+	/* Set Luma and chroma filter in SD Mode register 0 */
+	val1 = reg80;
+
+	/* Set PbPr color difference filter in SD Mode register 1 */
+	val3 = reg2;
+
+	val1 &= (~(SD_LUMA_FLTR_MASK << SD_LUMA_FLTR_SHIFT));
+	val1 |= ((sd->luma_filter & SD_LUMA_FLTR_MASK) << SD_LUMA_FLTR_SHIFT);
+
+	if (sd->chroma_filter != ADV7343_CHROMA_SSAF) {
+		val1 &= (~(SD_CHROMA_FLTR_MASK << SD_CHROMA_FLTR_SHIFT));
+		val1 |= ((sd->chroma_filter & SD_CHROMA_FLTR_MASK) <<
+			 SD_CHROMA_FLTR_SHIFT);
+		val3 &= SD_PBPR_SSAF_DI;
+	} else {
+		val3 |= SD_PBPR_SSAF_EN;
+	}
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_SD_MODE_REG1, val1);
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_SD_MODE_REG2, val3);
+	reg80 = val1;
+	reg2 = val3;
+
+	/* Call adv7343_set_ssafparams to set ssaf parameters */
+	err = adv7343_set_ssafparams(&sd->ssaf, enc);
+	if (err < 0)
+		return err;
+
+	/* Call adv7343_set_dnrparams to set dnr parameters */
+	err = adv7343_set_dnrparams(&sd->dnr, enc);
+	if (err < 0)
+		return err;
+
+	/* Set scalling parameters in ADV7343 SD Y,U,V Scale registers and
+	 * enable it on SD Mode register 4 */
+	val3 = reg3;
+	if (sd->scale.en_scale == ADV7343_ENABLE) {
+		/* Enable scaling in ADV7343 register */
+		val3 |= SD_PBPR_SCALE_EN;
+		val3 |= SD_Y_SCALE_EN;
+
+		val1 = 0;
+
+		sd->scale.y_scale &= SD_YPBPR_SCALE_MASK;
+		sd->scale.pb_scale &= SD_YPBPR_SCALE_MASK;
+		sd->scale.pr_scale &= SD_YPBPR_SCALE_MASK;
+
+		/* Write pr scale value in ADV Register */
+		val2 = (u8) ((sd->scale.pr_scale & SD_YPBPR_SCALE_HMASK) >>
+			     SD_YPBPR_SCALE_SHIFT);
+		val1 = (sd->scale.pr_scale & SD_YPBPR_SCALE_LMASK);
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_SD_CR_SCALE, val2);
+
+		/* Write pb scale value in ADV Register */
+		val2 = (u8) ((sd->scale.pb_scale & SD_YPBPR_SCALE_HMASK) >>
+			     SD_YPBPR_SCALE_SHIFT);
+		val1 <<= SD_YPBPR_SCALE_SHIFT;
+		val1 |= (sd->scale.pb_scale & SD_YPBPR_SCALE_LMASK);
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_SD_CB_SCALE, val2);
+
+		/* Write y scale value in ADV Register */
+		val2 = (u8) ((sd->scale.y_scale & SD_YPBPR_SCALE_HMASK) >>
+			     SD_YPBPR_SCALE_SHIFT);
+		val1 <<= SD_YPBPR_SCALE_SHIFT;
+		val1 |= sd->scale.y_scale & SD_YPBPR_SCALE_LMASK;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_SD_Y_SCALE, val2);
+
+		val2 = reg4;
+		val2 |= val1;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_SD_SCALE_LSB, val2);
+		reg4 = val2;
+	} else {
+		/* Disable scaling in ADV7343 register */
+		val3 &= SD_PBPR_SCALE_DI;
+		val3 &= SD_Y_SCALE_DI;
+	}
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_SD_MODE_REG6, val3);
+	reg3 = val3;
+
+	/* Enable active and step edge control in SD Mode register 1 if it is
+	   enabled in sd */
+	val1 = reg2;
+	if (sd->active_step_edge_scale == ADV7343_ENABLE) {
+		val1 |= SD_ACTIVE_EDGE_EN;
+	} else {
+		val1 &= SD_ACTIVE_EDGE_DI;
+	}
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_SD_MODE_REG2, val1);
+	reg2 = val1;
+
+	/* Call adv7343_set_gammaparams to set gamma correction parameters */
+	err = adv7343_set_gammaparams(&sd->gamma, ADV7343_SDPARAMS, enc);
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_sdparams>\n");
+	return err;
+}
+
+/* This function is used to set Gamma Correction parameters */
+static int adv7343_set_gammaparams(struct adv7343_gamma_params *params,
+				   enum adv7343_params_type type, void *enc)
+{
+	int err = 0, i;
+	unsigned char val1, reg = 0;
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_gammaparams>\n");
+	/* Check for null value */
+	if (!params) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_gammaparams:NULL pointer\n");
+		return -EINVAL;
+	}
+	/* Check for valid value */
+	if (!(ADV7343_VALID_FEATURE_VAL(params->en_gamma))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_gammaparams:invalid value"
+			" of en_gamma\n");
+		return -EINVAL;
+	}
+	/* Check for invalid curve */
+	if ((ADV7343_ENABLE == params->en_gamma)
+	    && (!(ADV7343_VALID_GAMMA_CURVE(params->curve)))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_gammaparams:invalid curve type\n");
+		return -EINVAL;
+	}
+
+	/* Write the gamma coefficient in */
+	if (ADV7343_SDPARAMS == type) {
+		val1 = reg5;
+	} else {
+		val1 = reg6;
+	}
+
+	/* If gamm enabled, enable gamma correction in SD Mode Register 5
+	 * or HD Mode register 6 */
+	if (params->en_gamma == ADV7343_ENABLE) {
+		if (ADV7343_SDPARAMS == type) {
+			val1 |= SD_GAMMA_EN;
+			/* Select gamm curve in the same register */
+			(params->curve == ADV7343_GAMMA_CURVE_B)
+			    ? (val1 |= SD_GAMMA_CURVE_B)
+			    : (val1 &= SD_GAMMA_CURVE_A);
+
+			/* Select base register for gamma coefficients as per
+			 * the curve selected */
+			(params->curve == ADV7343_GAMMA_CURVE_B)
+			    ? (reg = ADV7343_SD_GAMMA_B0)
+			    : (reg = ADV7343_SD_GAMMA_A0);
+
+		} else {
+			val1 |= HD_GAMMA_EN;
+
+			/* Select gamm curve in the same register */
+			(params->curve == ADV7343_GAMMA_CURVE_B)
+			    ? (val1 |= HD_GAMMA_CURVE_B)
+			    : (val1 &= HD_GAMMA_CURVE_A);
+
+			/* Select base register for gamma coefficients as per
+			 * the curve selected */
+			(params->curve == ADV7343_GAMMA_CURVE_B)
+			    ? (reg = ADV7343_HD_GAMMA_B0)
+			    : (reg = ADV7343_HD_GAMMA_A0);
+		}
+		/* Write the gamma coefficient in */
+		for (i = reg; i < reg + ADV7343_MAX_GAMMA_COEFFS; i++) {
+			err |=
+			    adv7343_i2c_write_reg(&adv7343_channel_info
+						  [ch_id].i2c_dev.client,
+						  i, params->coeff[i - reg]);
+		}
+	} else {
+		/* Disable the gamma curve */
+		if (ADV7343_SDPARAMS == type) {
+			val1 &= SD_GAMMA_DI;
+		} else {
+			val1 &= HD_GAMMA_DI;
+		}
+	}
+
+	/* Write the value to the register */
+	if (ADV7343_SDPARAMS == type) {
+		err |=
+		    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].
+					  i2c_dev.client,
+					  ADV7343_SD_MODE_REG7, val1);
+		reg5 = val1;
+	} else {
+		err |=
+		    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].
+					  i2c_dev.client,
+					  ADV7343_HD_MODE_REG6, val1);
+		reg6 = val1;
+	}
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_gammaparams>\n");
+	return err;
+}
+
+/* This function is used to set HD parameters */
+static int adv7343_set_hdparams(struct adv7343_hd_params *hd, void *enc)
+{
+	int err = 0;
+	unsigned char val;
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_hdparams>\n");
+	if (!hd) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_hdparams:NULL pointer\n");
+		return -EINVAL;
+	}
+	/* Check for valid value */
+	if (!ADV7343_VALID_FEATURE_VAL(hd->sinc_filter)) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_hdparams:invalid value"
+			" of sinc filter\n");
+		return -EINVAL;
+	}
+	if (!ADV7343_VALID_FEATURE_VAL(hd->ssaf_filter)) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_hdparams:invalid value"
+			" of ssaf filter\n");
+		return -EINVAL;
+	}
+
+	/* Set the HD filters in HD Mode register 4 */
+	val = reg7;
+
+	if (hd->sinc_filter == ADV7343_ENABLE) {
+		val |= HD_SYNC_FLTR_EN;
+	} else {
+		val &= HD_SYNC_FLTR_DI;
+	}
+
+	if (hd->ssaf_filter == ADV7343_ENABLE) {
+		val |= HD_CHROMA_SSAF_EN;
+	} else {
+		val &= HD_CHROMA_SSAF_DI;
+	}
+
+	err |=
+	    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				  client, ADV7343_HD_MODE_REG4, val);
+	reg7 = val;
+
+	/* Call adv7343_set_rgbparams function to set RGB params */
+	err = adv7343_set_rgbmatrix(&hd->rgb, enc);
+	if (err < 0)
+		return err;
+
+	/* Call adv7343_set_filterparams function to set filter params */
+	err = adv7343_set_filterparams(&hd->filt_params, enc);
+	if (err < 0)
+		return err;
+
+	/* Call adv7343_set_gammaparams function to set gamma correction
+	   parameters */
+	err = adv7343_set_gammaparams(&hd->gamma, ADV7343_HDPARAMS, enc);
+	if (err < 0)
+		return err;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_hdparams>\n");
+	return err;
+}
+
+/* This function is used to set DNR parameters */
+static int adv7343_set_dnrparams(struct adv7343_dnr_params *dnr, void *enc)
+{
+	int err = 0;
+	unsigned char val1, val2;
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_dnrparams>\n");
+	/* Check for null value */
+	if (!dnr) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_dnrparams:NULL pointer\n");
+		return -EINVAL;
+	}
+	/* Check for valid value */
+	if (!(ADV7343_VALID_FEATURE_VAL(dnr->en_dnr))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_dnrparams:invalid value" " of en_dnr\n");
+		return -EINVAL;
+	}
+	/* If DNR is disabled, disable it in ADV registers */
+
+	/* Read SD Mode Register 5 to enable/disable DNR */
+	val1 = reg5;
+
+	if (dnr->en_dnr == ADV7343_DISABLE) {
+
+		/* Disable DNR in SD Mode register 5 */
+		val1 &= SD_DNR_DI;
+
+		err |=
+		    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].
+					  i2c_dev.client,
+					  ADV7343_SD_MODE_REG7, val1);
+		reg5 = val1;
+		return err;
+	}
+
+	/* Check for invalid values */
+	if (dnr->data_gain > SD_DNR_GAIN_MAX
+	    || dnr->border_gain > SD_DNR_GAIN_MAX
+	    || dnr->threshold > SD_DNR_THRESHOLD_MAX) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_dnrparams:gain is out of bound\n");
+		return -EINVAL;
+	}
+	if (ADV7343_DNR_BLOCK_16 != dnr->block_size &&
+	    ADV7343_DNR_BLOCK_8 != dnr->block_size) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_dnrparams:invalid block size\n");
+		return -EINVAL;
+	}
+	if (ADV7343_BORDER_AREA_4 != dnr->area &&
+	    ADV7343_BORDER_AREA_4 != dnr->area) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_dnrparams:invalid border area\n");
+		return -EINVAL;
+	}
+	if (ADV7343_MODE_DNR_SHARPNESS != dnr->mode &&
+	    ADV7343_MODE_DNR != dnr->mode) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_dnrparams:invalid mode\n");
+		return -EINVAL;
+	}
+
+	/* Enable DNR in SD Mode register 5 */
+	val1 |= SD_DNR_EN;
+
+	err |= adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				     client, ADV7343_SD_MODE_REG7, val1);
+	reg5 = val1;
+
+	/* Write value of Data and Border gain in DNR 0 Register */
+	val1 = (dnr->data_gain & SD_DNR_DATA_GAIN_MASK);
+	val1 <<= SD_DNR_DATA_GAIN_SHIFT;
+	val1 |= (dnr->border_gain & SD_DNR_BORDER_GAIN_MASK);
+
+	err |=
+	    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				  client, ADV7343_SD_DNR0, val1);
+
+	val1 = dnr->threshold & SD_DNR_THRESHOLD_MASK;
+	if (ADV7343_DNR_BLOCK_16 == dnr->block_size) {
+		val1 |= SD_BLOCK_SIZE_16x16;
+	} else {
+		val1 &= SD_BLOCK_SIZE_8x8;
+	}
+
+	if (ADV7343_BORDER_AREA_4 == dnr->area) {
+		val1 |= SD_BORDER_AREA_4PIXELS;
+	} else {
+		val1 &= SD_BORDER_AREA_2PIXELS;
+	}
+
+	/* Write the value of border size, block size and threshold in DNR 1
+	   Register */
+	err |=
+	    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				  client, ADV7343_SD_DNR1, val1);
+
+	val1 = dnr->filt_select;
+
+	if (ADV7343_MODE_DNR_SHARPNESS == dnr->mode) {
+		val1 |= SD_DNR_SHARPNESS_MODE;
+	} else {
+		val1 &= SD_DNR_MODE;
+	}
+
+	val2 = (dnr->block_offset & SD_DNR_BLOCK_OFFSET_MASK);
+	val2 <<= SD_DNR_BLOCK_OFFSET_SHIFT;
+	val1 |= val2;
+	/* Write the value of block offset and DNR mode in DNR 2 register */
+	err |=
+	    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				  client, ADV7343_SD_DNR2, val1);
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_dnrparams>\n");
+	return err;
+}
+
+/* This function is used to set SSAF filter parameters */
+static int adv7343_set_ssafparams(struct adv7343_ssaf_params *ssaf, void *enc)
+{
+	int err = 0;
+	unsigned char val1;
+	int ch_id;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_ssafparams>\n");
+
+	/* Check for null value */
+	if (!ssaf) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_ssafparams:NULL pointer\n");
+		return -EINVAL;
+	}
+	/* Check for valid value */
+	if (!(ADV7343_VALID_FEATURE_VAL(ssaf->en_gain))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_ssafparams:invalid value" " of en_gain\n");
+		return -EINVAL;
+	}
+
+	/* Read SD Mode register 4 */
+	val1 = reg3;
+
+	/* If ssaf gain is enabled */
+	if (ssaf->en_gain == ADV7343_ENABLE) {
+		/* If gain value is out of bound return error */
+		if (ssaf->gain > SD_LUMA_SSAF_GAIN_MAX) {
+			dev_err(adv7343_i2c_dev[ch_id],
+				"adv7343_set_ssafparams:Invalid"
+				" value of gain\n");
+			return -EINVAL;
+		}
+
+		/* Enable SSAF Gain in SD Mode Register 4 */
+		val1 |= SD_LUMA_SSAF_GAIN_EN;
+
+		/* Write value of gain in SD LUMA SSAF register */
+		err |=
+		    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].
+					  i2c_dev.client,
+					  ADV7343_SD_LUMA_SSAF, ssaf->gain);
+	} else {
+		/* Disable ssaf gain */
+		/* Disable SSAF Gain in SD Mode Register 4 */
+		val1 &= SD_LUMA_SSAF_GAIN_DI;
+	}
+	err |=
+	    adv7343_i2c_write_reg(&adv7343_channel_info[ch_id].i2c_dev.
+				  client, ADV7343_SD_MODE_REG6, val1);
+	reg3 = val1;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_ssafparams>\n");
+	return err;
+}
+
+/* This function is used to set filter parameters for HD */
+static int adv7343_set_filterparams(struct adv7343_filter_params *filt,
+				    void *enc)
+{
+	int err = 0;
+	unsigned char val1;
+	int ch_id;
+	struct i2c_client *ch_client;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+	ch_client = &adv7343_channel_info[ch_id].i2c_dev.client;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_filterparams>\n");
+
+	/* Check for null value */
+	if (!filt) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_filterparams:NULL pointer\n");
+		return -EINVAL;
+	}
+
+	/* Check for valid value */
+	if (!(ADV7343_VALID_FEATURE_VAL(filt->en_filter))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_filterparams:invalid value of "
+			"en_filter\n");
+		return -EINVAL;
+	}
+	/* If filter is not enabled, return */
+	if (filt->en_filter == ADV7343_DISABLE) {
+		/* Disable both sharpness and adaptive filters */
+		val1 = reg9;
+
+		val1 &= HD_SHARPNESS_FLTR_DI;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG2, val1);
+		reg9 = val1;
+
+		val1 = reg6;
+
+		val1 &= HD_ADPT_FLTR_DI;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG6, val1);
+		reg6 = val1;
+
+		dev_dbg(adv7343_i2c_dev[ch_id], "adv7343_set_filterparams L\n");
+		return 0;
+	}
+
+	/* Switch on the value of mode */
+	switch (filt->mode) {
+		/* If the case is for mode sharpness */
+	case ADV7343_FILTER_MODE_SHARPNESS:
+		/* Read HD Mode Register 2 to enable sharpness filter */
+		val1 = reg9;
+		val1 |= HD_SHARPNESS_FLTR_EN;
+
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG2, val1);
+		reg9 = val1;
+
+		/* Disable adaptive filter in HD Mode Register 2 */
+		val1 = reg6;
+
+		val1 &= HD_ADPT_FLTR_DI;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG6, val1);
+		reg6 = val1;
+
+		/* Write the value of sharpness in HD Sharpness filter
+		 *  gain register */
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_SHARPNESS_FLTR_GAIN,
+					     filt->sharpness);
+		break;
+
+		/* If the case is for mode A */
+	case ADV7343_FILTER_MODE_A:
+		/* enable sharpness filter in HD Mode Register 2 */
+		val1 = reg9;
+
+		val1 |= HD_SHARPNESS_FLTR_EN;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG2, val1);
+		reg9 = val1;
+		/* Enable adaptive filter and mode A in HD Mode
+		 * Register 6 */
+		val1 = reg6;
+
+		val1 |= HD_ADPT_FLTR_EN;
+		val1 &= HD_ADPT_FLTR_MODEA;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG6, val1);
+		reg6 = val1;
+
+		/* Write the value of sharpness in HD Sharpness filter
+		 *  gain register */
+		val1 = (filt->sharpness & HD_SHARPNESS_FLTR_B_MASK)
+		    << HD_SHARPNESS_FLTR_B_SHIFT;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_SHARPNESS_FLTR_GAIN,
+					     val1);
+		filt->sharpness = val1;
+
+		/* Write the value of thresholds in HD thresholds
+		 * register */
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_THRLDA,
+					     filt->threshold_a);
+
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_THRLDB,
+					     filt->threshold_b);
+
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_THRLDC,
+					     filt->threshold_c);
+		filt->gain1_valb &= HD_ADPT_FLTR_GAIN_B_MASK;
+		filt->gain2_valb &= HD_ADPT_FLTR_GAIN_B_MASK;
+		filt->gain3_valb &= HD_ADPT_FLTR_GAIN_B_MASK;
+
+		/* Write value of filter gains in HD Gains registers */
+		val1 = (filt->gain1_valb & HD_ADPT_FLTR_GAIN_B_MASK);
+		val1 <<= HD_ADPT_FLTR_GAIN_B_SHIFT;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_GAIN1, val1);
+
+		val1 = (filt->gain2_valb & HD_ADPT_FLTR_GAIN_B_MASK);
+		val1 <<= HD_ADPT_FLTR_GAIN_B_SHIFT;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_GAIN2, val1);
+
+		val1 = (filt->gain3_valb & HD_ADPT_FLTR_GAIN_B_MASK);
+		val1 <<= HD_ADPT_FLTR_GAIN_B_SHIFT;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_GAIN3, val1);
+
+		break;
+
+		/* If the case is for mode B */
+	case ADV7343_FILTER_MODE_B:
+		/* enable sharpness filter in HD Mode Register 2 */
+		val1 = reg9;
+
+		val1 |= HD_SHARPNESS_FLTR_EN;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG2, val1);
+		reg9 = val1;
+
+		/* Enable adaptive filter and mode B in HD Mode
+		 * Register 6 */
+		val1 = reg6;
+		val1 |= HD_ADPT_FLTR_EN;
+		val1 |= HD_ADPT_FLTR_MODEB;
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_MODE_REG6, val1);
+		reg6 = val1;
+
+		/* Write the value of sharpness in HD Sharpness filter
+		 * gain register */
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_SHARPNESS_FLTR_GAIN,
+					     filt->sharpness);
+		filt->gain1_valb &= HD_ADPT_FLTR_GAIN_B_MASK;
+		filt->gain2_valb &= HD_ADPT_FLTR_GAIN_B_MASK;
+		filt->gain3_valb &= HD_ADPT_FLTR_GAIN_B_MASK;
+		filt->gain1_vala &= HD_ADPT_FLTR_GAIN_A_MASK;
+		filt->gain2_vala &= HD_ADPT_FLTR_GAIN_A_MASK;
+		filt->gain3_vala &= HD_ADPT_FLTR_GAIN_A_MASK;
+
+		/* Write the value of thresholds in HD thresholds
+		 * register */
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_THRLDA,
+					     filt->threshold_a);
+
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_THRLDB,
+					     filt->threshold_b);
+
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_THRLDC,
+					     filt->threshold_c);
+
+		/* Write value of filter gains in HD Gains registers */
+		val1 = (filt->gain1_valb & HD_ADPT_FLTR_GAIN_B_MASK);
+		val1 <<= HD_ADPT_FLTR_GAIN_B_SHIFT;
+		val1 |= (filt->gain1_vala & HD_ADPT_FLTR_GAIN_A_MASK);
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_GAIN1, val1);
+
+		val1 = (filt->gain2_valb & HD_ADPT_FLTR_GAIN_B_MASK);
+		val1 <<= HD_ADPT_FLTR_GAIN_B_SHIFT;
+		val1 |= (filt->gain2_vala & HD_ADPT_FLTR_GAIN_A_MASK);
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_GAIN2, val1);
+
+		val1 = (filt->gain3_valb & HD_ADPT_FLTR_GAIN_B_MASK);
+		val1 <<= HD_ADPT_FLTR_GAIN_B_SHIFT;
+		val1 |= (filt->gain3_vala & HD_ADPT_FLTR_GAIN_A_MASK);
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_HD_ADPT_FLTR_GAIN3, val1);
+		break;
+
+	default:
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_filterparams:invalid Mode\n");
+	}
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_filterparams>\n");
+	return err;
+}
+
+/* This function is used to set RGB matrix coeffiecients */
+static int adv7343_set_rgbmatrix(struct adv7343_rgb_matrix *rgb, void *enc)
+{
+	int err = 0;
+	unsigned char val1, val2;
+	int ch_id;
+	struct i2c_client *ch_client;
+	if (NULL == enc) {
+		printk(KERN_ERR "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct vid_encoder_device *)enc)->channel_id;
+	ch_client = &adv7343_channel_info[ch_id].i2c_dev.client;
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "<adv7343_set_rgbmatrix>\n");
+
+	/* Check for null value */
+	if (!rgb) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_rgbmatrix:NULL pointer\n");
+		return -EINVAL;
+	}
+
+	/* Check for valid value */
+	if (!(ADV7343_VALID_FEATURE_VAL(rgb->en_rgb_matrix))) {
+		dev_err(adv7343_i2c_dev[ch_id],
+			"adv7343_set_rgbmatrix:invalid value of "
+			"en_rgb_matrix\n");
+		return -EINVAL;
+	}
+	/* Disable RGB matrix in Mode Register 0 */
+	val1 = reg0;
+
+	/* If rgb matrix is not enabled, return */
+	if (rgb->en_rgb_matrix == ADV7343_DISABLE) {
+		val1 &= CSC_MATRIX_DI;
+
+		err |= adv7343_i2c_write_reg(ch_client,
+					     ADV7343_MODE_REG0, val1);
+		reg0 = val1;
+		dev_dbg(adv7343_i2c_dev[ch_id], "adv7343_set_rgbmatrix L\n");
+		return err;
+	}
+
+	/* Enable RGB matrix in Mode Register 0 */
+	val1 |= CSC_MATRIX_EN;
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_MODE_REG0, val1);
+	reg0 = val1;
+
+	rgb->gy &= CSC_MATRIX_MASK;
+	rgb->gu &= CSC_MATRIX_MASK;
+	rgb->gv &= CSC_MATRIX_MASK;
+	rgb->bu &= CSC_MATRIX_MASK;
+	rgb->rv &= CSC_MATRIX_MASK;
+
+	/* Write the value GY in RGB matrix 2 register */
+	val1 = (rgb->gy & CSC_LSB_MASK);
+	val2 = (u8) (rgb->gy >> CSC_SHIFT);
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX0, val1);
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX2, val2);
+
+	/* Write the value GU in RGB matrix 3 register */
+	val1 = (rgb->gu & CSC_LSB_MASK);
+	val2 = (rgb->gu >> CSC_SHIFT);
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX3, val2);
+
+	/* Write the value GR in RGB matrix 4 register */
+	val1 <<= CSC_SHIFT;
+	val1 |= (rgb->gv & CSC_LSB_MASK);
+	val2 = (rgb->gv >> CSC_SHIFT);
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX4, val2);
+
+	/* Write the value BU in RGB matrix 5 register */
+	val1 <<= CSC_SHIFT;
+	val1 |= (rgb->bu & CSC_LSB_MASK);
+	val2 = rgb->bu >> CSC_SHIFT;
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX5, val2);
+
+	/* Write the value RV in RGB matrix 6 register */
+	val1 <<= CSC_SHIFT;
+	val1 |= (rgb->rv & CSC_LSB_MASK);
+	val2 = rgb->rv >> CSC_SHIFT;
+
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX6, val2);
+	err |= adv7343_i2c_write_reg(ch_client, ADV7343_CSC_MATRIX1, val1);
+
+	dev_dbg(adv7343_i2c_dev[ch_id], "</adv7343_set_rgbmatrix>\n");
+	return err;
+}
+
+/*This function is used to write value into register using i2c client. */
+static int adv7343_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		dev_dbg(adv7343_i2c_dev[0], "adv7343 i2c WRITE start \n");
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = reg;
+		data[1] = val;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+	dev_dbg(adv7343_i2c_dev[0], "adv7343 i2c WRITE end \n");
+
+	return ((err < 0) ? err : 0);
+}
+
+/* This function is used to attach i2c client */
+static int adv7343_i2c_attach_client(struct i2c_client *client,
+				     struct i2c_driver *driver,
+				     struct i2c_adapter *adap, int addr)
+{
+	int err = 0;
+
+	if (client->adapter) {
+		err = -EBUSY;	/* our client is already attached */
+	} else {
+		client->addr = addr;
+		client->driver = driver;
+		client->adapter = adap;
+
+		err = i2c_attach_client(client);
+		if (err) {
+			client->adapter = NULL;
+		}
+	}
+	return err;
+}
+
+/* This function is used to detach i2c client */
+static int adv7343_i2c_detach_client(struct i2c_client *client)
+{
+	int err = 0;
+	if (!client->adapter) {
+		return -ENODEV;	/* our client isn't attached */
+	} else {
+		err = i2c_detach_client(client);
+		client->adapter = NULL;
+	}
+	return err;
+}
+
+static int adv7343_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	int err = 0;
+	adv7343_i2c_dev[0] = &(adap->dev);
+	dev_dbg(adv7343_i2c_dev[0], "ADV7343 i2c probe adapter called...\n");
+	/* Attach the client */
+	err = adv7343_i2c_attach_client(&adv7343_channel_info[0].i2c_dev.
+					client,
+					&adv7343_channel_info[0].i2c_dev.
+					driver, adap,
+					adv7343_channel_info[0].i2c_dev.
+					i2c_addr);
+	dev_dbg(adv7343_i2c_dev[0], "ADV7343 i2c probe adapter ends...\n");
+	return err;
+
+}
+
+/* This function used to initialize the i2c driver */
+static int adv7343_i2c_init(void)
+{
+	int err = 0;
+	int i = 0, j;
+	/* Take instance of driver */
+	struct i2c_driver *driver;
+
+	static char strings[ADV7343_NUM_CHANNELS][80] = {
+		"ADV7343 encoder I2C driver"
+	};
+
+	for (i = 0; i < ADV7343_NUM_CHANNELS; i++) {
+		driver = &adv7343_channel_info[i].i2c_dev.driver;
+		driver->driver.name = strings[i];
+		driver->id = I2C_DRIVERID_MISC;
+//		driver->flags = I2C_DF_NOTIFY;
+		if (0 == i) {
+			driver->attach_adapter = adv7343_i2c_probe_adapter;
+		}
+
+		driver->detach_client = adv7343_i2c_detach_client;
+		err |= vid_enc_register_encoder(&adv7343_dev[i]);
+		if (err < 0) {
+			for (j = i - 1; j > 0; j--) {
+				vid_enc_unregister_encoder(&adv7343_dev[j]);
+			}
+			return err;
+		}
+	}
+	return err;
+}
+
+/* Function used to cleanup i2c driver */
+static void adv7343_i2c_cleanup(void)
+{
+	int i;
+	for (i = 0; i < ADV7343_NUM_CHANNELS; i++) {
+		if (vid_enc_unregister_encoder(&adv7343_dev[i]) < 0)
+			return;
+		if (adv7343_channel_info[i].i2c_dev.i2c_registration & 0x01) {
+			i2c_del_driver(&adv7343_channel_info[i].i2c_dev.driver);
+			adv7343_channel_info[i].i2c_dev.client.adapter = NULL;
+			adv7343_channel_info[i].i2c_dev.i2c_registration = 0;
+		}
+	}
+}
+
+module_init(adv7343_i2c_init);
+module_exit(adv7343_i2c_cleanup);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/media/video/davinci/davincihd_capture.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/davincihd_capture.c
@@ -0,0 +1,3048 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* davincihd_vpfe.c */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+//#include <linux/videodev.h>
+#include <media/v4l2-dev.h>
+//#include <linux/videodev2.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/platform_device.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+
+#include <media/davinci/davincihd_capture.h>
+#include <media/davinci/vpif.h>
+#include <asm/arch/video_hdevm.h>
+
+static u32 device_type = -1;
+static u32 channel0_numbuffers = 3;
+static u32 channel1_numbuffers = 3;
+static u32 channel0_bufsize = 1920 * 1080 * 2;
+static u32 channel1_bufsize = 720 * 576 * 2;
+module_param(device_type, uint, S_IRUGO);
+module_param(channel0_numbuffers, uint, S_IRUGO);
+module_param(channel1_numbuffers, uint, S_IRUGO);
+module_param(channel0_bufsize, uint, S_IRUGO);
+module_param(channel1_bufsize, uint, S_IRUGO);
+
+static struct vpif_config_params config_params = {
+	.min_numbuffers = 3,
+	.numbuffers[0] = 3,
+	.numbuffers[1] = 3,
+	.min_bufsize[0] = 720 * 480 * 2,
+	.min_bufsize[1] = 720 * 480 * 2,
+	.channel_bufsize[0] = 1920 * 1080 * 2,
+	.channel_bufsize[1] = 720 * 576 * 2,
+	.default_device[0] = 0,
+	.default_device[1] = 0,
+	.max_device_type = 1,
+	.device_type = -1
+};
+
+static int vpif_nr[] = { 0, 1 };
+
+/* global variables */
+static struct vpif_device vpif_obj = { {NULL} };
+static struct workqueue_struct *vbi_workqueue;
+static struct work_struct vbi_work[VPIF_CAPTURE_NUM_CHANNELS];
+
+static struct device *vpif_dev = NULL;
+
+static struct v4l2_capability vpif_videocap = {
+	.driver = "vpif capture",
+	.card = "DaVinciHD EVM",
+	.bus_info = "Platform",
+	.version = VPIF_CAPTURE_VERSION_CODE,
+	.capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |
+	    V4L2_CAP_VBI_CAPTURE | V4L2_CAP_HBI_CAPTURE
+};
+
+static struct v4l2_vbi_format vpif_raw_vbi_formats[2] = {
+	{
+	 .sampling_rate = 29.97,
+	 .samples_per_line = VPIF_NTSC_VBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_NTSC_VBI_START_FIELD0,
+		   VPIF_NTSC_VBI_START_FIELD1},
+	 .count = {VPIF_NTSC_VBI_COUNT_FIELD0,
+		   VPIF_NTSC_VBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED},
+	{
+	 .sampling_rate = 25,
+	 .samples_per_line = VPIF_PAL_VBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_PAL_VBI_START_FIELD0,
+		   VPIF_PAL_VBI_START_FIELD1},
+	 .count = {VPIF_PAL_VBI_COUNT_FIELD0,
+		   VPIF_PAL_VBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED}
+};
+
+static struct v4l2_vbi_format vpif_raw_hbi_formats[2] = {
+	{
+	 .sampling_rate = 29.97,
+	 .samples_per_line = VPIF_NTSC_HBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_NTSC_HBI_START_FIELD0,
+		   VPIF_NTSC_HBI_START_FIELD1},
+	 .count = {VPIF_NTSC_HBI_COUNT_FIELD0,
+		   VPIF_NTSC_HBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED},
+	{
+	 .sampling_rate = 25,
+	 .samples_per_line = VPIF_PAL_HBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_PAL_HBI_START_FIELD0,
+		   VPIF_PAL_HBI_START_FIELD1},
+	 .count = {VPIF_PAL_HBI_COUNT_FIELD0,
+		   VPIF_PAL_HBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED}
+};
+
+static struct vpif_service_line vbi_service_lines[] = {
+	{V4L2_SLICED_CGMS_525, {20, 283}},
+	{V4L2_SLICED_CAPTION_525, {21, 284}},
+	{V4L2_SLICED_WSS_625, {23, 0}},
+};
+
+static void vbi_work_handler(unsigned long data)
+{
+	struct channel_obj *channel = (struct channel_obj *)data;
+	struct common_obj *common = &(channel->common[VPIF_VBI_INDEX]);
+	struct decoder_device *dec = channel->decoder[channel->current_decoder];
+	unsigned long addr = (unsigned long)common->curFrm->boff;
+
+	if (ISNULL(dec->read_vbi_data)) {
+		dev_err(vpif_dev, "tasklet handler : no read_vbi_data\n");
+		return;
+	}
+	addr = (unsigned long)phys_to_virt(addr);
+	down(&common->lock);
+	if (channel->field_id == 1) {
+		addr += sizeof(struct v4l2_sliced_vbi_data) *
+		    (channel->vbi.num_services);
+	}
+	dec->read_vbi_data((void *)addr, (void *)dec);
+	up(&common->lock);
+}
+
+/* vpif_alloc_buffer : Allocate memory for buffers
+ */
+static inline unsigned long vpif_alloc_buffer(unsigned int buf_size)
+{
+	void *mem = 0;
+	u32 size = PAGE_SIZE << (get_order(buf_size));
+
+	mem = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				       get_order(buf_size));
+	if (mem) {
+		unsigned long adr = (unsigned long)mem;
+		while (size > 0) {
+			SetPageReserved(virt_to_page(adr));
+			adr += PAGE_SIZE;
+			size -= PAGE_SIZE;
+		}
+	}
+	return (unsigned long)mem;
+}
+
+/* vpif_free_buffer :  Free memory for buffers
+ */
+static inline void vpif_free_buffer(unsigned long addr, unsigned int buf_size)
+{
+	unsigned int size, adr;
+
+	if (!addr)
+		return;
+	adr = addr;
+	size = PAGE_SIZE << (get_order(buf_size));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(addr, get_order(buf_size));
+}
+
+/*  vpif_uservirt_to_phys : This inline function is used to
+ *  convert user space virtual address to physical address.
+ */
+static inline u32 vpif_uservirt_to_phys(u32 virtp)
+{
+	unsigned long physp = 0;
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+	/* For kernel direct-mapped memory, take the easy way */
+	if (virtp >= PAGE_OFFSET) {
+		physp = virt_to_phys((void *)virtp);
+	} else if ((vma = find_vma(mm, virtp)) && (vma->vm_flags & VM_IO) &&
+		   (vma->vm_pgoff)) {
+		/* this will catch, kernel-allocated,
+		   mmaped-to-usermode addresses */
+		physp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);
+	} else {
+		/* otherwise, use get_user_pages() for general userland pages */
+		int res, nr_pages = 1;
+		struct page *pages;
+		down_read(&current->mm->mmap_sem);
+
+		res = get_user_pages(current, current->mm,
+				     virtp, nr_pages, 1, 0, &pages, NULL);
+		up_read(&current->mm->mmap_sem);
+
+		if (res == nr_pages) {
+			physp = __pa(page_address(&pages[0]) +
+				     (virtp & ~PAGE_MASK));
+		} else {
+			dev_err(vpif_dev, "get_user_pages failed\n");
+			return 0;
+		}
+	}
+	return physp;
+}
+
+/* buffer_prepare :  This is the callback function called from
+ * videobuf_qbuf() function the buffer is prepared and user space
+ * virtual address is converted into  physical address
+ */
+static int vpif_buffer_prepare(struct videobuf_queue *q,
+			       struct videobuf_buffer *vb,
+			       enum v4l2_field field)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common;
+	unsigned long addr;
+	int i, j, prevline = 0, num_services;
+	struct v4l2_sliced_vbi_data *vbidata;
+
+	dev_dbg(vpif_dev, "<vpif_buffer_prepare>\n");
+
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* If buffer is not initialized, initialize it */
+	if (STATE_NEEDS_INIT == vb->state) {
+		vb->width = common->width;
+		vb->height = common->height;
+		vb->size = vb->width * vb->height;
+		vb->field = field;
+	}
+	vb->state = STATE_PREPARED;
+	/* if user pointer memory mechanism is used, get the physical
+	 * address of the buffer
+	 */
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		if (0 == vb->baddr) {
+			dev_err(vpif_dev, "buffer address is 0\n");
+			return -EINVAL;
+		}
+		vb->boff = vpif_uservirt_to_phys(vb->baddr);
+		if (!ISALIGNED(vb->boff)) {
+			dev_err(vpif_dev, "buffer_prepare:offset is \
+					not aligned to 8 bytes\n");
+			return -EINVAL;
+		}
+	}
+	addr = vb->boff;
+	if (q->streaming && (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE != q->type)) {
+		if (!ISALIGNED((addr + common->ytop_off)) ||
+		    !ISALIGNED((addr + common->ybtm_off)) ||
+		    !ISALIGNED((addr + common->ctop_off)) ||
+		    !ISALIGNED((addr + common->cbtm_off))) {
+			dev_err(vpif_dev, "buffer_prepare:offset is \
+					not aligned to 8 bytes\n");
+			return -EINVAL;
+		}
+	}
+	if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE == q->type) {
+		num_services = channel->vbi.num_services;
+		vbidata = (struct v4l2_sliced_vbi_data *)phys_to_virt(vb->boff);
+		prevline = 0;
+		for (i = 0; i < num_services * 2; i++) {
+			if (0 == vbidata->id)
+				continue;
+			if (!(vbidata->id & common->fmt.fmt.sliced.service_set)) {
+				dev_err(vpif_dev, "Invalid services id\n");
+				return -EINVAL;
+			}
+			if ((vbidata->field != 0) && (vbidata->field != 1)) {
+				dev_err(vpif_dev, "Invalid field value\n");
+				return -EINVAL;
+			}
+			for (j = 0; j < VPIF_SLICED_MAX_SERVICES; j++) {
+				if (!(vbidata->id &
+				      vbi_service_lines[j].service_id))
+					continue;
+				if ((vbidata->field == 0) && (vbidata->line !=
+							      vbi_service_lines
+							      [j].
+							      service_line[0]))
+				{
+					dev_err(vpif_dev,
+						"Invalid field 0 line number\n");
+					return -EINVAL;
+				}
+				if ((vbidata->field == 1) && (vbidata->line !=
+							      vbi_service_lines
+							      [j].
+							      service_line[1]))
+				{
+					dev_err(vpif_dev,
+						"Invalid field 1 line number\n");
+					return -EINVAL;
+				}
+			}
+			if (prevline > vbidata->line) {
+				dev_err(vpif_dev, "line numbers are not in \
+						increasing order\n");
+				return -EINVAL;
+			}
+			prevline = vbidata->line;
+			vbidata++;
+		}
+	}
+
+	dev_dbg(vpif_dev, "</vpif_buffer_prepare>\n");
+	return 0;
+}
+
+/*  vpif_buffer_config : This function is responsible to
+ *  responsible for buffer's  physical address
+ */
+static void vpif_buffer_config(struct videobuf_queue *q, unsigned int count)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common;
+	int i;
+	dev_dbg(vpif_dev, "<vpif_buffer_config>\n");
+
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != common->memory) {
+		dev_dbg(vpif_dev, "End of buffer config\n");
+		return;
+	}
+	/* Convert kernel space virtual address to physical address */
+	for (i = 0; i < count; i++) {
+		q->bufs[i]->boff = virt_to_phys((u32 *) common->fbuffers[i]);
+		dev_dbg(vpif_dev, "buffer address: %x\n", q->bufs[i]->boff);
+	}
+	dev_dbg(vpif_dev, "</vpif_buffer_config>\n");
+}
+
+/* vpif_buffer_setup : This function allocates memory for
+ * the buffers
+ */
+static int vpif_buffer_setup(struct videobuf_queue *q, unsigned int *count,
+			     unsigned int *size)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common;
+	int i, startindex = 0;
+	dev_dbg(vpif_dev, "<vpif_buffer_setup>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != common->memory) {
+		dev_dbg(vpif_dev, "End of buffer setup\n");
+		return 0;
+	}
+
+	/* Calculate the size of the buffer */
+	if (V4L2_BUF_TYPE_VIDEO_CAPTURE == q->type) {
+		/* Calculate the size of the buffer */
+		*size = config_params.channel_bufsize[channel->channel_id];
+		startindex = config_params.numbuffers[channel->channel_id];
+
+	} else if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE == q->type) {
+		/* Get the size of the buffer */
+		*size = VPIF_SLICED_BUF_SIZE;
+	} else {
+		/* Calculate the size of the buffer */
+		*size = ((common->fmt.fmt.vbi.count[0]) +
+			 (common->fmt.fmt.vbi.count[1])) *
+		    (common->fmt.fmt.vbi.samples_per_line);
+	}
+
+	for (i = startindex; i < *count; i++) {
+		/* Allocate memory for the buffers */
+		common->fbuffers[i] = (u8 *) vpif_alloc_buffer(*size);
+		if (!common->fbuffers[i])
+			break;
+	}
+	/* Store number of buffers allocated in numbuffer member */
+	*count = common->numbuffers = i;
+	dev_dbg(vpif_dev, "</vpif_buffer_setup>\n");
+	return 0;
+}
+
+/* vpif_buffer_queue : This function adds the buffer to DMA queue
+ */
+static void vpif_buffer_queue(struct videobuf_queue *q,
+			      struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	dev_dbg(vpif_dev, "<vpif_buffer_queue>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* add the buffer to the DMA queue */
+	list_add_tail(&vb->queue, &common->dma_queue);
+	/* Change state of the buffer */
+	vb->state = STATE_QUEUED;
+	dev_dbg(vpif_dev, "</vpif_buffer_queue>\n");
+}
+
+/* vpif_buffer_release : This function is called from the videobuf
+ * layer to free memory allocated to  the buffers
+ */
+static void vpif_buffer_release(struct videobuf_queue *q,
+				struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	unsigned int buf_size = 0;
+	dev_dbg(vpif_dev, "<vpif_buffer_release>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	vb->state = STATE_NEEDS_INIT;
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != common->memory) {
+		dev_dbg(vpif_dev, "End of buffer release\n");
+		return;
+	}
+	/* Calculate the size of the buffer */
+	buf_size = config_params.channel_bufsize[channel->channel_id];
+
+	dev_dbg(vpif_dev, "</vpif_buffer_release>\n");
+}
+
+static struct videobuf_queue_ops video_qops = {
+	.buf_setup = vpif_buffer_setup,
+	.buf_prepare = vpif_buffer_prepare,
+	.buf_queue = vpif_buffer_queue,
+	.buf_release = vpif_buffer_release,
+	.buf_config = vpif_buffer_config,
+};
+
+static u8 channel_first_int[VPIF_NUMBER_OF_OBJECTS][2] = { {1, 1},
+{1, 1}, {1, 1}
+};
+
+/* vpif_channel_isr :It changes status of the captured buffer,
+ * takes next buffer from the queue  and sets its address in VPIF
+ * registers
+ */
+static irqreturn_t vpif_channel_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct timeval timevalue;
+	int fid = -1, i;
+	struct channel_obj *channel = NULL;
+	struct common_obj *common = NULL;
+	struct video_obj *vid_ch = NULL;
+	int channel_id = 0;
+	struct vpif_device *dev = &vpif_obj;
+	unsigned long addr = 0;
+	enum v4l2_field field;
+	dev_dbg(vpif_dev, "<vpif_channel_isr>\n");
+
+	channel_id = *(int *)(dev_id);
+	channel = dev->dev[channel_id];
+	vid_ch = &(channel->video);
+	do_gettimeofday(&timevalue);
+	field = channel->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.field;
+
+	for (i = 0; i < VPIF_NUMBER_OF_OBJECTS; i++) {
+		common = &(channel->common[i]);
+		/* If streaming is started in this channel */
+		if (0 == common->started)
+			continue;
+
+		/* Check the field format */
+		if (1 == vid_ch->std_info.frame_format) {
+			if (list_empty(&common->dma_queue))
+				continue;
+			/* Progressive mode */
+			if (!channel_first_int[i][channel_id]) {
+				/* Mark status of the curFrm to
+				 * done and unlock semaphore on it */
+				common->curFrm->ts = timevalue;
+				common->curFrm->state = STATE_DONE;
+				wake_up_interruptible(&common->curFrm->done);
+				/* Make curFrm pointing to nextFrm */
+				common->curFrm = common->nextFrm;
+			}
+			channel_first_int[i][channel_id] = 0;
+			/* Get the next buffer from buffer queue */
+			common->nextFrm =
+			    list_entry(common->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove that buffer from the buffer queue */
+			list_del(&common->nextFrm->queue);
+			/* Mark status of the buffer as active */
+			common->nextFrm->state = STATE_ACTIVE;
+			/* Set top and bottom field addresses in
+			   VPIF registers */
+			addr = common->nextFrm->boff;
+			if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
+			    == common->fmt.type) {
+				queue_work(vbi_workqueue,
+					   &vbi_work[channel->channel_id]);
+			} else {
+				common->set_addr(addr + common->ytop_off,
+						 addr + common->ybtm_off,
+						 addr + common->ctop_off,
+						 addr + common->cbtm_off);
+			}
+			channel_first_int[i][channel_id] = 0;
+		} else {
+			/* Interlaced mode */
+			/* If it is first interrupt, ignore it */
+			if (channel_first_int[i][channel_id]) {
+				channel_first_int[i][channel_id] = 0;
+				continue;
+			}
+			if (0 == i) {
+				channel->field_id ^= 1;
+				/* Get field id from VPIF registers */
+				fid = vpif_channel_getfid(channel->channel_id);
+				/* If field id does not match with stored
+				   field id */
+				if (fid != channel->field_id) {
+					/* Make them in sync */
+					if (0 == fid) {
+						channel->field_id = fid;
+					}
+					return IRQ_HANDLED;
+				}
+			}
+			/* device field id and local field id are
+			   in sync */
+			/* If this is even field */
+			if (0 == fid) {
+				if (common->curFrm == common->nextFrm) {
+					continue;
+				}
+				/* one frame is captured If next frame is
+				 * available, release curFrm and move on*/
+				/* Copy frame capture time */
+				common->curFrm->ts = timevalue;
+				/* Change status of the curFrm */
+				common->curFrm->state = STATE_DONE;
+				/* unlock semaphore on curFrm */
+				wake_up_interruptible(&common->curFrm->done);
+				/* Make curFrm pointing to
+				   nextFrm */
+				common->curFrm = common->nextFrm;
+				if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
+				    == common->fmt.type) {
+					queue_work(vbi_workqueue,
+						   &vbi_work[channel->
+							     channel_id]);
+				}
+			} else if (1 == fid) {	/* odd field */
+				if (list_empty(&common->dma_queue)
+				    || (common->curFrm != common->nextFrm)) {
+					continue;
+				}
+
+				/* one field is captured, configure
+				   the next frame if it is available
+				   otherwise hold on current frame
+				 */
+				/* Get next from the buffer
+				   queue */
+				common->nextFrm = list_entry(common->
+							     dma_queue.
+							     next, struct
+							     videobuf_buffer,
+							     queue);
+
+				/* Remove that from the
+				   buffer queue */
+				list_del(&common->nextFrm->queue);
+
+				/* Mark state of the frame
+				   to active */
+				common->nextFrm->state = STATE_ACTIVE;
+				addr = common->nextFrm->boff;
+
+				if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
+				    == common->fmt.type) {
+					queue_work(vbi_workqueue,
+						   &vbi_work[channel->
+							     channel_id]);
+				} else {
+					common->set_addr(addr +
+							 common->ytop_off,
+							 addr +
+							 common->ybtm_off,
+							 addr +
+							 common->ctop_off,
+							 addr +
+							 common->cbtm_off);
+				}
+			}
+		}
+	}
+	dev_dbg(vpif_dev, "</vpif_channel_isr>\n");
+	return IRQ_HANDLED;
+}
+
+static void vpif_get_std_info(struct channel_obj *ch)
+{
+	struct decoder_device *dec = ch->decoder[ch->current_decoder];
+	struct video_obj *vid_ch = &(ch->video);
+	struct v4l2_standard standard;
+	int index = 0, ret;
+
+	vid_ch->std_info.channel_id = ch->channel_id;
+
+	/* Get standard name from the decoder by enumerating standards */
+	do {
+		standard.index = index;
+
+		ret = dec->std_ops->enumstd(&standard, dec);
+		if (standard.id & vid_ch->std) {
+			strncpy(vid_ch->std_info.name, standard.name,
+				sizeof(vid_ch->std_info.name));
+			strncpy(ch->vpifparams.video_params.name,
+				standard.name, sizeof(vid_ch->std_info.name));
+			break;
+		}
+		index++;
+	} while (ret >= 0);
+
+	/* Get standard information from VPIF layer */
+	ret = vpif_get_mode_info(&vid_ch->std_info);
+	ch->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.width =
+	    ch->common[VPIF_VIDEO_INDEX].width = vid_ch->std_info.activepixels;
+	ch->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.height =
+	    ch->common[VPIF_VIDEO_INDEX].height = vid_ch->std_info.activelines;
+	ch->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.bytesperline =
+	    vid_ch->std_info.activepixels;
+	ch->vpifparams.video_params.hpitch = vid_ch->std_info.activepixels;
+	ch->vpifparams.video_params.storage_mode =
+	    vid_ch->std_info.frame_format;
+}
+
+/* vpif_calculate_offsets : This function calculates buffers offset
+ *  for Y and C in the top and bottom field
+ */
+static void vpif_calculate_offsets(struct channel_obj *channel)
+{
+	unsigned int hpitch, vpitch, sizeimage;
+	struct video_obj *vid_ch = &(channel->video);
+	struct vpif_params *vpifparams = &channel->vpifparams;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	enum v4l2_field field = common->fmt.fmt.pix.field;
+
+	dev_dbg(vpif_dev, "<vpif_calculate_offsets>\n");
+
+	if (V4L2_FIELD_ANY == field) {
+		if (vid_ch->std_info.frame_format)
+			vid_ch->buf_field = V4L2_FIELD_NONE;
+		else
+			vid_ch->buf_field = V4L2_FIELD_INTERLACED;
+	} else {
+		vid_ch->buf_field = common->fmt.fmt.pix.field;
+	}
+
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		sizeimage = common->fmt.fmt.pix.sizeimage;
+	} else {
+		sizeimage = config_params.channel_bufsize[channel->channel_id];
+	}
+	hpitch = common->fmt.fmt.pix.bytesperline;
+	vpitch = sizeimage / (hpitch * 2);
+
+	if ((V4L2_FIELD_NONE == vid_ch->buf_field) ||
+	    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {
+		/* Calculate offsets for Y top, Y Bottom, C top and C Bottom */
+		common->ytop_off = 0;
+		common->ybtm_off = hpitch;
+		common->ctop_off = sizeimage / 2;
+		common->cbtm_off = sizeimage / 2 + hpitch;
+	} else if (V4L2_FIELD_SEQ_TB == vid_ch->buf_field) {
+		/* Calculate offsets for Y top, Y Bottom, C top and C Bottom */
+		common->ytop_off = 0;
+		common->ybtm_off = sizeimage / 4;
+		common->ctop_off = sizeimage / 2;
+		common->cbtm_off = common->ctop_off + sizeimage / 4;
+	} else if (V4L2_FIELD_SEQ_BT == vid_ch->buf_field) {
+		/* Calculate offsets for Y top, Y Bottom, C top and C Bottom */
+		common->ybtm_off = 0;
+		common->ytop_off = sizeimage / 4;
+		common->cbtm_off = sizeimage / 2;
+		common->ctop_off = common->cbtm_off + sizeimage / 4;
+	}
+	if ((V4L2_FIELD_NONE == vid_ch->buf_field) ||
+	    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {
+		vpifparams->video_params.storage_mode = 1;
+	} else {
+		vpifparams->video_params.storage_mode = 0;
+	}
+
+	if (1 == vid_ch->std_info.frame_format) {
+		vpifparams->video_params.hpitch =
+		    common->fmt.fmt.pix.bytesperline;
+	} else {
+		if ((field == V4L2_FIELD_ANY)
+		    || (field == V4L2_FIELD_INTERLACED))
+			vpifparams->video_params.hpitch =
+			    common->fmt.fmt.pix.bytesperline * 2;
+		else
+			vpifparams->video_params.hpitch =
+			    common->fmt.fmt.pix.bytesperline;
+	}
+
+	strncpy(channel->vpifparams.video_params.name, vid_ch->std_info.name,
+		sizeof(channel->vpifparams.video_params.name));
+	dev_dbg(vpif_dev, "</vpif_calculate_offsets>\n");
+}
+
+static void vpif_calculate_offsets_vbi(struct channel_obj *channel, u8 index)
+{
+	struct common_obj *common = &(channel->common[index]);
+	dev_dbg(vpif_dev, "<vpif_calculate_offsets_vbi>\n");
+	common->ytop_off = 0;
+	common->ctop_off = 0;
+	common->ybtm_off = (common->fmt.fmt.vbi.count[0]) *
+	    (common->fmt.fmt.vbi.samples_per_line);
+	common->cbtm_off = 0;
+	dev_dbg(vpif_dev, "</vpif_calculate_offsets_vbi>\n");
+}
+
+static void vpif_config_format(struct channel_obj *channel)
+{
+	struct decoder_device *dec = channel->decoder[channel->current_decoder];
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	common->fmt.fmt.pix.field = V4L2_FIELD_ANY;
+
+	if (config_params.numbuffers[channel->channel_id] == 0)
+		common->memory = V4L2_MEMORY_USERPTR;
+	else
+		common->memory = V4L2_MEMORY_MMAP;
+
+	common->fmt.fmt.pix.sizeimage
+	    = config_params.channel_bufsize[channel->channel_id];
+
+	if (dec->if_type & INTERFACE_TYPE_RAW)
+		common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+	else
+		common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422UVP;
+	common->fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	channel->common[VPIF_VBI_INDEX].fmt.type =
+	    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE;
+	channel->common[VPIF_VBI_INDEX].fmt.fmt.sliced.service_set = 0;
+	channel->common[VPIF_VBI_INDEX].memory = V4L2_MEMORY_MMAP;
+	channel->common[VPIF_HBI_INDEX].fmt.type = V4L2_BUF_TYPE_HBI_CAPTURE;
+	channel->common[VPIF_HBI_INDEX].memory = V4L2_MEMORY_MMAP;
+}
+
+static void vpif_config_std(struct channel_obj *channel)
+{
+	int ret;
+	struct decoder_device *dec = channel->decoder[channel->current_decoder];
+	struct video_obj *vid_ch = &(channel->video);
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	/* Detect the standard from the devide */
+	ret = dec->std_ops->getstd(&vid_ch->std, dec);
+	if (ret)
+		return;
+
+	vpif_get_std_info(channel);
+
+	/* Reset the pitch */
+	common->fmt.fmt.pix.bytesperline = common->fmt.fmt.pix.width;
+
+	/* Change the pixel format as per the new decoder */
+	if (dec->if_type & INTERFACE_TYPE_RAW)
+		common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_SBGGR8;
+	else
+		common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422UVP;
+}
+
+static int vpif_check_format(struct channel_obj *channel,
+			     struct v4l2_pix_format *pixfmt)
+{
+	struct decoder_device *dec = channel->decoder[channel->current_decoder];
+	struct video_obj *vid_ch = &(channel->video);
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	u32 sizeimage, hpitch, vpitch;
+	enum v4l2_field field = pixfmt->field;
+
+	if ((dec->if_type & INTERFACE_TYPE_RAW)
+	    && (pixfmt->pixelformat != V4L2_PIX_FMT_SBGGR8)) {
+		dev_err(vpif_dev, "invalid frame format\n");
+		return -EINVAL;
+	} else if (pixfmt->pixelformat != V4L2_PIX_FMT_YUV422UVP) {
+		dev_err(vpif_dev, "invalid frame format\n");
+		return -EINVAL;
+	}
+	if (!(VPIF_VALID_FIELD(field))) {
+		dev_err(vpif_dev, "invalid field format\n");
+		return -EINVAL;
+	}
+	if (pixfmt->bytesperline <= 0) {
+		dev_err(vpif_dev, "invalid pitch\n");
+		return -EINVAL;
+	}
+
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		sizeimage = pixfmt->sizeimage;
+	} else {
+		sizeimage = config_params.channel_bufsize[channel->channel_id];
+	}
+	hpitch = pixfmt->bytesperline;
+	vpitch = sizeimage / (hpitch * 2);
+	/* Check for valid value of pitch */
+	if ((hpitch < vid_ch->std_info.activepixels) ||
+	    (vpitch < vid_ch->std_info.activelines)) {
+		dev_err(vpif_dev, "Invalid pitch\n");
+		return -EINVAL;
+	}
+	/* Check for 8 byte alignment */
+	if (!(ISALIGNED(hpitch))) {
+		dev_err(vpif_dev, "invalid pitch alignment\n");
+		return -EINVAL;
+	}
+	pixfmt->width = common->fmt.fmt.pix.width;
+	pixfmt->height = common->fmt.fmt.pix.height;
+	return 0;
+}
+
+static int vpif_convert_index(struct channel_obj *channel, int *index,
+			      int *dec_index)
+{
+	int i, suminput = 0;
+	struct decoder_device *dec;
+	*dec_index = 0;
+	for (i = 0; i < channel->numdecoders; i++) {
+		dec = channel->decoder[i];
+		suminput += dec->input_ops->count;
+		if ((*index) < suminput) {
+			*dec_index = i;
+			suminput -= dec->input_ops->count;
+			break;
+		}
+	}
+	*index -= suminput;
+	if (i == channel->numdecoders)
+		return -EINVAL;
+
+	return 0;
+}
+
+static void vpif_config_addr(struct channel_obj *channel, int muxmode,
+			     enum v4l2_buf_type buftype)
+{
+	struct common_obj *common;
+	int buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE
+			      == buftype) ? VPIF_VIDEO_INDEX : VPIF_VBI_INDEX;
+	common = &(channel->common[buf_type_index]);
+	if (VPIF_CHANNEL1_VIDEO == channel->channel_id) {
+		if (0 == buf_type_index)
+			common->set_addr = ch1_set_videobuf_addr;
+		else if (1 == buf_type_index)
+			common->set_addr = ch1_set_vbi_addr;
+		else
+			common->set_addr = ch1_set_hbi_addr;
+	} else {
+		if (0 == buf_type_index) {
+			if (2 == muxmode) {
+				common->set_addr =
+				    ch0_set_videobuf_addr_yc_nmux;
+			} else {
+				common->set_addr = ch0_set_videobuf_addr;
+			}
+		} else if (1 == buf_type_index) {
+			common->set_addr = ch0_set_vbi_addr;
+		} else {
+			common->set_addr = ch0_set_hbi_addr;
+		}
+	}
+}
+
+static int vpif_try_raw_format(struct channel_obj *channel,
+			       struct v4l2_vbi_format *fmt, u8 index)
+{
+	struct video_obj *vid_ch = &(channel->video);
+	struct v4l2_vbi_format *raw_vbi;
+	if (V4L2_STD_525_60 == vid_ch->std) {
+		raw_vbi = (1 == index) ? &(vpif_raw_vbi_formats[0]) :
+		    &(vpif_raw_hbi_formats[0]);
+	} else {
+		raw_vbi = (1 == index) ? &(vpif_raw_vbi_formats[1]) :
+		    &(vpif_raw_hbi_formats[1]);
+	}
+
+	if ((fmt->sampling_rate != raw_vbi->sampling_rate) ||
+	    (fmt->samples_per_line != raw_vbi->samples_per_line) ||
+	    (fmt->start[0] != raw_vbi->start[0]) ||
+	    (fmt->count[0] != raw_vbi->count[0]) ||
+	    (fmt->start[1] != raw_vbi->start[1]) ||
+	    (fmt->count[1] != raw_vbi->count[1]) ||
+	    (fmt->flags != raw_vbi->flags)) {
+		dev_err(vpif_dev, "invalid parameters\n");
+		*fmt = *raw_vbi;
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*  vpfe_doioctl : This function will provide different V4L2 commands.
+ * This function can be used to configure driver or get status of
+ * driver as per command passed  by application
+ */
+static int vpif_doioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct vpif_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct video_obj *vid_ch = &(channel->video);
+	unsigned int index = 0, i = 0;
+	unsigned long addr, flags;
+	struct decoder_device *dec = channel->decoder[channel->current_decoder];
+	dev_dbg(vpif_dev, "<vpif_doioctl>\n");
+
+	if ((VPIF_CHANNEL0_VIDEO == channel->channel_id)
+	    || (VPIF_CHANNEL1_VIDEO == channel->channel_id)) {
+		switch (cmd) {
+		case VIDIOC_G_INPUT:
+		case VIDIOC_S_STD:
+		case VIDIOC_S_INPUT:
+		case VIDIOC_S_FMT:
+		case VIDIOC_REQBUFS:
+		case VPIF_S_VPIF_PARAMS:
+		case VPIF_CMD_S_DECODER_PARAMS:
+			if (!fh->initialized) {
+				dev_dbg(vpif_dev, "channel busy\n");
+				return -EBUSY;
+			}
+		}
+	}
+	/* Check for the priority */
+	if ((VPIF_CHANNEL0_VIDEO == channel->channel_id)
+	    || (VPIF_CHANNEL1_VIDEO == channel->channel_id)) {
+		switch (cmd) {
+		case VIDIOC_S_STD:
+		case VIDIOC_S_INPUT:
+		case VIDIOC_S_FMT:
+			ret = v4l2_prio_check(&channel->prio, &fh->prio);
+			if (0 != ret)
+				return ret;
+			fh->initialized = 1;
+			break;
+		}
+	}
+
+	/* Check for null value of parameter */
+	if (ISNULL((void *)arg)) {
+		dev_err(vpif_dev, "Null pointer\n");
+		return -EINVAL;
+	}
+	/* Switch on the command value */
+	switch (cmd) {
+		/* If the case is for querying capabilities */
+	case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *cap =
+			    (struct v4l2_capability *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_QUERYCAP\n");
+			memset(cap, 0, sizeof(*cap));
+			if ((VPIF_CHANNEL0_VIDEO == channel->channel_id)
+			    || (VPIF_CHANNEL1_VIDEO == channel->channel_id)) {
+				*cap = vpif_videocap;
+				cap->capabilities |= dec->capabilities;
+			} else {
+				ret = -EINVAL;
+			}
+			break;
+		}
+
+		/* If the case is for enumerating inputs */
+	case VIDIOC_ENUMINPUT:
+		{
+			int index, index1;
+			struct v4l2_input *input = (struct v4l2_input *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_ENUMINPUT\n");
+
+			index = index1 = input->index;
+			/* Map the index to the index of the decoder */
+			ret = vpif_convert_index(channel, &index, &i);
+			if (ret)
+				break;
+			input->index = index;
+			/* Call enuminput of the new decoder */
+			ret = channel->decoder[i]->input_ops->
+			    enuminput(input, channel->decoder[i]);
+			input->index = index1;
+			break;
+		}
+
+		/* If the case is for getting input */
+	case VIDIOC_G_INPUT:
+		{
+			int i, j;
+			int temp_input_idx = 0;
+			struct decoder_device *cur_dec;
+			int sumindex = 0;
+			int found = 0;
+			int result_input_idx = -1;
+			int first_input_idx = -1;
+			int default_mt9t001_decoder = 0;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			struct video_obj *vid_ch = &(channel->video);
+
+			dev_dbg(vpif_dev, "VIDIOC_G_INPUT\n");
+			down_interruptible(&common->lock);
+
+			if (0 == strcmp(channel->
+					decoder[channel->default_decoder]->name,
+					"MT9T001")) {
+				default_mt9t001_decoder = 1;
+			}
+			if (0 != strcmp(dec->name, "MT9T001")) {
+				/* De-Initialize the current decoder */
+				dec->deinitialize(dec);
+			}
+			for (i = 0; i < channel->numdecoders; i++) {
+				cur_dec = channel->decoder[i];
+				if (ISNULL(cur_dec->input_ops)
+				    || ISNULL(cur_dec->input_ops->getinput)
+				    || ISNULL(cur_dec->deinitialize)
+				    || ISNULL(cur_dec->initialize)) {
+					sumindex += cur_dec->input_ops->count;
+					continue;
+				}
+				if (0 != strcmp(cur_dec->name, "MT9T001")) {
+					cur_dec->initialize(cur_dec,
+							    DECODER_I2C_BIND_FLAG);
+				}
+				if ((0 == strcmp(cur_dec->name, "MT9T001")) &&
+				    (!default_mt9t001_decoder)) {
+					sumindex += cur_dec->input_ops->count;
+					continue;
+				}
+
+				/* for decoder, call getinput for each index */
+				for (j = 0; j < cur_dec->input_ops->count; j++) {
+					if (0 != strcmp(cur_dec->name,
+							"MT9T001")) {
+						ret =
+						    cur_dec->input_ops->
+						    getinput(&j, cur_dec);
+					} else {
+						ret = 0;
+					}
+					if (ret)
+						continue;
+					if (0 == found) {
+						first_input_idx = sumindex + j;
+						found = 1;
+					}
+					if (temp_input_idx == vid_ch->input_idx) {
+						result_input_idx = sumindex + j;
+						vid_ch->input_idx++;
+						found = 2;
+						break;
+					}
+					temp_input_idx++;
+				}
+				if (0 != strcmp(cur_dec->name, "MT9T001")) {
+					cur_dec->deinitialize(cur_dec);
+				}
+				if (2 == found)
+					break;
+				sumindex += cur_dec->input_ops->count;
+			}
+			if (0 == found) {
+				up(&common->lock);
+				return -EINVAL;
+			}
+
+			if (1 == found) {
+				vid_ch->input_idx = 1;
+				result_input_idx = first_input_idx;
+			}
+			*(int *)arg = result_input_idx;
+			/* Map the index to the index of the decoder */
+			ret = vpif_convert_index(channel,
+						 &result_input_idx, &i);
+			if (ret) {
+				up(&common->lock);
+				break;
+			}
+			/* Initialize the new decoder */
+			dec = channel->decoder[i];
+			channel->current_decoder = i;
+			if (0 != strcmp(dec->name, "MT9T001")) {
+				dec->initialize(dec, DECODER_I2C_BIND_FLAG);
+			}
+			/* Set the standard in the decoder */
+			ret = dec->input_ops->setinput(&result_input_idx, dec);
+			vpif_config_std(channel);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for setting input */
+	case VIDIOC_S_INPUT:
+		{
+			int index = *(int *)arg;
+			int index1 = index;
+			int default_mt9t001_decoder = 0;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			dev_dbg(vpif_dev, "VIDIOC_S_INPUT\n");
+			/* If streaming is started return device busy
+			 * error */
+			down_interruptible(&common->lock);
+			if (common->started) {
+				dev_err(vpif_dev, "Streaming is on\n");
+				ret = -EBUSY;
+				up(&common->lock);
+				break;
+			}
+			if (0 == strcmp(channel->
+					decoder[channel->default_decoder]->name,
+					"MT9T001")) {
+				default_mt9t001_decoder = 1;
+			}
+
+			if (ISNULL(dec->input_ops)
+			    || ISNULL(dec->input_ops->setinput) ||
+			    ISNULL(dec->deinitialize)
+			    || ISNULL(dec->initialize)) {
+				dev_err(vpif_dev, "vpif_doioctl:No setinput\n");
+				up(&common->lock);
+				return -EINVAL;
+			}
+
+			/* Map the index to the index of the decoder */
+			ret = vpif_convert_index(channel, &index, &i);
+
+			if (ret) {
+				up(&common->lock);
+				break;
+			}
+			dec = channel->decoder[channel->current_decoder];
+			/* if default is not mt9t001 and request comes
+			 * to set
+			 * it, raise an error */
+			if ((0 == strcmp(channel->decoder[i]->name, "MT9T001"))
+			    && (!default_mt9t001_decoder)) {
+				up(&common->lock);
+				return -EINVAL;
+			}
+			channel->current_decoder = i;
+			/* Deinitialize the previous decoder */
+			dec->deinitialize(dec);
+
+			/* Initialize the new decoder */
+			dec = channel->decoder[i];
+			dec->initialize(dec, DECODER_FULL_INIT_FLAG);
+
+			/* Set the standard in the decoder */
+			ret = dec->input_ops->setinput(&index, dec);
+			*(int *)arg = index1;
+			vpif_config_std(channel);
+			up(&common->lock);
+
+			break;
+		}
+		/* If the case is for enumerating standards */
+	case VIDIOC_ENUMSTD:
+		{
+			struct v4l2_standard *std = (struct v4l2_standard *)arg;
+			struct video_obj *vid_ch = &(channel->video);
+			int index = std->index, dec_idx;
+			dev_dbg(vpif_dev, "VIDIOC_ENUMSTD\n");
+			/* Call enumstd function of decoder device */
+			if (ISNULL(dec->std_ops)
+			    || ISNULL(dec->std_ops->enumstd)) {
+				dev_err(vpif_dev, "vpif_doioctl:No enumstd\n");
+				return -EINVAL;
+			}
+			if (index >= vid_ch->count_std) {
+				dev_err(vpif_dev, "Invalid index\n");
+				return -EINVAL;
+			}
+			dec_idx = vid_ch->std_tbl[index].dec_idx;
+			dec = channel->decoder[dec_idx];
+			std->index = vid_ch->std_tbl[index].std_idx;
+			ret = dec->std_ops->enumstd(std, dec);
+			std->index = index;
+			break;
+		}
+
+		/* If the case is for querying standards */
+	case VIDIOC_QUERYSTD:
+		{
+			v4l2_std_id *std = (v4l2_std_id *) arg;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			struct video_obj *vid_ch = &(channel->video);
+			dev_dbg(vpif_dev, "VIDIOC_QUERYSTD\n");
+			if (ISNULL(dec->std_ops)
+			    || ISNULL(dec->std_ops->querystd)) {
+				dev_err(vpif_dev, "vpif_doioctl:No querystd\n");
+				return -EINVAL;
+			}
+			down_interruptible(&common->lock);
+			/* Call querystd function of decoder device */
+			ret = dec->std_ops->querystd(std, dec);
+
+			if (!ret) {
+				/* Get the information about
+				 * the standard from the decoder */
+				vid_ch->std = *std;
+				vpif_get_std_info(channel);
+			}
+
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for getting standard */
+	case VIDIOC_G_STD:
+		{
+			v4l2_std_id *std = (v4l2_std_id *) arg;
+			dev_dbg(vpif_dev, "VIDIOC_G_STD\n");
+			if (ISNULL(dec->std_ops)
+			    || ISNULL(dec->std_ops->getstd)) {
+				dev_err(vpif_dev, "vpif_doioctl:No getstd\n");
+				return -EINVAL;
+			}
+			/* Call getstd function of decoder device */
+			ret = dec->std_ops->getstd(std, dec);
+			break;
+		}
+
+		/* If the case is for setting standard */
+	case VIDIOC_S_STD:
+		{
+			v4l2_std_id std = *(v4l2_std_id *) arg;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			dev_dbg(vpif_dev, "VIDIOC_S_STD\n");
+
+			/* If streaming is started, return device
+			   busy error */
+			if (common->started) {
+				dev_err(vpif_dev, "streaming is started\n");
+				return -EBUSY;
+			}
+			if (ISNULL(dec->std_ops)
+			    || ISNULL(dec->std_ops->setstd)) {
+				dev_err(vpif_dev, "vpif_doioctl:No setstd\n");
+				return -EINVAL;
+			}
+			/* Call decoder driver function to set the
+			   standard */
+			down_interruptible(&common->lock);
+			ret = dec->std_ops->setstd(&std, dec);
+
+			/* If it returns error, return error */
+			if (ret < 0) {
+				up(&common->lock);
+				return ret;
+			}
+			/* Get the information about the standard from
+			 * the decoder */
+			vid_ch->std = std;
+			vpif_get_std_info(channel);
+
+			if ((vid_ch->std_info.activelines *
+			     vid_ch->std_info.activepixels * 2)
+			    > config_params.channel_bufsize[channel->
+							    channel_id]) {
+				dev_err(vpif_dev,
+					"invalid std for this size\n");
+				up(&common->lock);
+				return -EINVAL;
+			}
+
+			up(&common->lock);
+			break;
+		}
+		/* If the case is for enumerating formats */
+	case VIDIOC_ENUM_FMT:
+		{
+			struct v4l2_fmtdesc *fmt = (struct v4l2_fmtdesc *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_ENUM_FMT\n");
+			if (fmt->index != 0) {
+				dev_err(vpif_dev, "Invalid format index\n");
+				return -EINVAL;
+			}
+			/* Fill in the information about format */
+			index = fmt->index;
+			memset(fmt, 0, sizeof(*fmt));
+			fmt->index = index;
+			if (dec->if_type & INTERFACE_TYPE_RAW) {
+				fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+				strcpy(fmt->description,
+				       "Raw Mode -Bayer Pattern GrRBGb");
+				fmt->pixelformat = V4L2_PIX_FMT_SBGGR8;
+			} else {
+				fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+				strcpy(fmt->description,
+				       "YCbCr4:2:2 YC Planar");
+				fmt->pixelformat = V4L2_PIX_FMT_YUV422UVP;
+			}
+			break;
+		}
+		/* If the case is for getting formats */
+	case VIDIOC_G_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			struct common_obj *common = NULL;
+			common = (fmt->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+			    &(channel->common[VPIF_VIDEO_INDEX]) :
+			    ((fmt->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+			     &(channel->common[VPIF_HBI_INDEX]) :
+			     &(channel->common[VPIF_VBI_INDEX]));
+
+			dev_dbg(vpif_dev, "VIDIOC_G_FMT\n");
+
+			if (common->fmt.type != fmt->type) {
+				ret = -EINVAL;
+				break;
+			}
+			/* If buffer type is not video output */
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE != fmt->type) {
+				if (vid_ch->std_info.vbi_supported == 0) {
+					return -EINVAL;
+				}
+			}
+			/* Fill in the information about
+			 * format */
+			down_interruptible(&(common->lock));
+			*fmt = common->fmt;
+			up(&(common->lock));
+			break;
+		}
+
+		/* If the case is for setting formats */
+	case VIDIOC_S_FMT:
+		{
+			struct common_obj *common = NULL;
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			u8 index;
+			dev_dbg(vpif_dev, "VIDIOC_S_FMT\n");
+			common = (fmt->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+			    &(channel->common[VPIF_VIDEO_INDEX]) :
+			    ((fmt->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+			     &(channel->common[VPIF_HBI_INDEX]) :
+			     &(channel->common[VPIF_VBI_INDEX]));
+
+			/* If streaming is started, return error */
+			if (common->started) {
+				dev_err(vpif_dev, "Streaming is started\n");
+				return -EBUSY;
+			}
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Check for valid field format */
+				ret = vpif_check_format(channel, pixfmt);
+
+				if (ret) {
+					return ret;
+				}
+
+				/* store the pixel format in the channel
+				 * object */
+				common->fmt.fmt.pix = *pixfmt;
+			} else {
+				if (vid_ch->std_info.vbi_supported == 0) {
+					dev_err(vpif_dev, "standard \
+						 doesn't support\n");
+					return -EINVAL;
+				}
+				if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
+				    == fmt->type) {
+					if (ISNULL(dec->fmt_ops) ||
+					    ISNULL(dec->fmt_ops->setformat)) {
+						dev_err(vpif_dev,
+							"vpif_doioctl:\
+							No setformat \
+								\n");
+						return -EINVAL;
+					}
+					ret = dec->fmt_ops->setformat(fmt, dec);
+					if (ret >= 0) {
+						common->width =
+						    fmt->fmt.sliced.io_size;
+						common->height = 1;
+						channel->vbi.num_services = ret;
+					}
+				} else if ((V4L2_BUF_TYPE_VBI_CAPTURE
+					    == fmt->type) ||
+					   (V4L2_BUF_TYPE_HBI_CAPTURE
+					    == fmt->type)) {
+					index = (V4L2_BUF_TYPE_VBI_CAPTURE ==
+						 fmt->type) ? VPIF_VBI_INDEX :
+					    VPIF_HBI_INDEX;
+					ret = vpif_try_raw_format
+					    (channel, &(fmt->fmt.vbi), index);
+					if (ret) {
+						return ret;
+					}
+					ret = dec->fmt_ops->setformat(fmt, dec);
+					if (ret) {
+						return ret;
+					}
+					common->width =
+					    fmt->fmt.vbi.samples_per_line;
+					common->height =
+					    fmt->fmt.vbi.count[0] +
+					    fmt->fmt.vbi.count[1];
+				} else {
+					dev_err(vpif_dev, "invalid \
+							type\n");
+					ret = -EINVAL;
+				}
+			}
+			if (ret < 0)
+				return ret;
+
+			/* store the pixel format in the channel
+			 * object */
+			down_interruptible(&common->lock);
+			common->fmt = *fmt;
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for trying formats */
+	case VIDIOC_TRY_FMT:
+		{
+			struct common_obj *common = NULL;
+			struct v4l2_format *fmt;
+			u8 index;
+			dev_dbg(vpif_dev, "VIDIOC_TRY_FMT\n");
+			fmt = (struct v4l2_format *)arg;
+
+			common = (fmt->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) ?
+			    &(channel->common[VPIF_VIDEO_INDEX]) :
+			    ((fmt->type == V4L2_BUF_TYPE_HBI_CAPTURE) ?
+			     &(channel->common[VPIF_HBI_INDEX]) :
+			     &(channel->common[VPIF_VBI_INDEX]));
+
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Check for valid field format */
+				ret = vpif_check_format(channel, pixfmt);
+				if (ret) {
+					*pixfmt = common->fmt.fmt.pix;
+					pixfmt->sizeimage =
+					    pixfmt->width * pixfmt->height * 2;
+				}
+			} else {
+				if (vid_ch->std_info.vbi_supported == 0) {
+					dev_err(vpif_dev, "standard doesn't \
+							support\n");
+					return -EINVAL;
+				}
+				if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE
+				    == fmt->type) {
+					if (ISNULL(dec->fmt_ops)
+					    || ISNULL(dec->fmt_ops->tryformat)) {
+						dev_err(vpif_dev,
+							"vpif_doioctl:\
+							No tryformat\
+							\n");
+						return -EINVAL;
+					}
+					ret = dec->fmt_ops->tryformat(fmt, dec);
+				} else if ((V4L2_BUF_TYPE_VBI_CAPTURE
+					    == fmt->type) ||
+					   (V4L2_BUF_TYPE_HBI_CAPTURE
+					    == fmt->type)) {
+					index = (V4L2_BUF_TYPE_VBI_CAPTURE ==
+						 fmt->type) ? VPIF_VBI_INDEX :
+					    VPIF_HBI_INDEX;
+					ret = vpif_try_raw_format
+					    (channel, &(fmt->fmt.vbi), index);
+				} else {
+					dev_err(vpif_dev, "invalid type\n");
+					ret = -EINVAL;
+				}
+			}
+			break;
+		}
+
+		/* If the case is for querying controls */
+	case VIDIOC_QUERYCTRL:
+		{
+			struct v4l2_queryctrl *queryctrl =
+			    (struct v4l2_queryctrl *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_QUERYCTRL\n");
+			if (ISNULL(dec->ctrl_ops)
+			    || ISNULL(dec->ctrl_ops->queryctrl)) {
+				dev_err(vpif_dev,
+					"vpif_doioctl:No queryctrl\n");
+				return -EINVAL;
+			}
+			/* Call queryctrl function of decoder device */
+			ret = dec->ctrl_ops->queryctrl(queryctrl, dec);
+			break;
+		}
+
+		/* If the case is for getting controls value */
+	case VIDIOC_G_CTRL:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			struct v4l2_control *ctrl = (struct v4l2_control *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_G_CTRL\n");
+			if (ISNULL(dec->ctrl_ops)
+			    || ISNULL(dec->ctrl_ops->getcontrol)) {
+				dev_err(vpif_dev,
+					"vpif_doioctl:No getcontrol\n");
+				return -EINVAL;
+			}
+			/* Call getcontrol function of decoder device */
+			down_interruptible(&common->lock);
+			ret = dec->ctrl_ops->getcontrol(ctrl, dec);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for getting controls value */
+	case VIDIOC_S_CTRL:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			struct v4l2_control *ctrl = (struct v4l2_control *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_S_CTRL\n");
+			if (ISNULL(dec->ctrl_ops)
+			    || ISNULL(dec->ctrl_ops->setcontrol)) {
+				dev_err(vpif_dev,
+					"vpif_doioctl:No setcontrol\n");
+				return -EINVAL;
+			}
+			/* Call setcontrol function of decoder device */
+			down_interruptible(&common->lock);
+			ret = dec->ctrl_ops->setcontrol(ctrl, dec);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for getting decoder parameters */
+	case VPIF_CMD_G_DECODER_PARAMS:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			dev_dbg(vpif_dev, "VPIF_CMD_G_DECODER_PARAMS\n");
+			if (ISNULL(dec->params_ops)
+			    || ISNULL(dec->params_ops->getparams)) {
+				dev_err(vpif_dev, "vpif_doioctl:No \
+							getdeviceparams\n");
+				return -EINVAL;
+			}
+			/* Call getparams function of decoder device */
+			down_interruptible(&common->lock);
+			ret = dec->params_ops->getparams((void *)arg, dec);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for setting decoder parameters */
+	case VPIF_CMD_S_DECODER_PARAMS:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			dev_dbg(vpif_dev, "VPIF_CMD_S_DECODER_PARAMS\n");
+			/* If channel is already started, return
+			 * error */
+			if (common->started) {
+				dev_err(vpif_dev, "streaming is started\n");
+				return -EBUSY;
+			}
+			if (ISNULL(dec->params_ops)
+			    || ISNULL(dec->params_ops->setparams)) {
+				dev_err(vpif_dev, "vpif_doioctl:No \
+							setdeviceparams\n");
+				return -EINVAL;
+			}
+			/* Call getparams function of decoder device */
+			down_interruptible(&common->lock);
+			ret = dec->params_ops->setparams((void *)arg, dec);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for requesting buffer allocation */
+	case VIDIOC_REQBUFS:
+		{
+			struct common_obj *common = NULL;
+			struct v4l2_requestbuffers *reqbuf;
+			enum v4l2_field field;
+			int buf_type_index;
+			reqbuf = (struct v4l2_requestbuffers *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_REQBUFS\n");
+			if ((V4L2_BUF_TYPE_VIDEO_CAPTURE != reqbuf->type) &&
+			    (V4L2_BUF_TYPE_VBI_CAPTURE != reqbuf->type) &&
+			    (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE != reqbuf->type)
+			    && (V4L2_BUF_TYPE_HBI_CAPTURE != reqbuf->type))
+				return -EINVAL;
+			buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE
+					  == reqbuf->type) ? VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_CAPTURE == reqbuf->type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[buf_type_index]);
+
+			if (common->fmt.type != reqbuf->type) {
+				ret = -EINVAL;
+				break;
+			}
+			if ((V4L2_BUF_TYPE_SLICED_VBI_CAPTURE == reqbuf->type)
+			    && (V4L2_MEMORY_MMAP != reqbuf->memory)) {
+				ret = -EINVAL;
+				break;
+			}
+
+			/* If io users of the channel is not zero,
+			   return error */
+			if (0 != common->io_usrs) {
+				ret = -EBUSY;
+				break;
+			}
+
+			down_interruptible(&common->lock);
+			if ((common->fmt.fmt.pix.field != V4L2_FIELD_ANY) &&
+			    (V4L2_BUF_TYPE_VIDEO_CAPTURE == reqbuf->type))
+				field = common->fmt.fmt.pix.field;
+			else
+				field = V4L2_FIELD_INTERLACED;
+			/* Initialize videobuf queue as per the
+			   buffer type */
+			videobuf_queue_init(&common->buffer_queue,
+					    &video_qops, NULL,
+					    &common->irqlock,
+					    reqbuf->type,
+					    field,
+					    sizeof(struct videobuf_buffer), fh);
+			/* Set buffer to Linear buffer */
+			videobuf_set_buftype(&common->buffer_queue,
+					     VIDEOBUF_BUF_LINEAR);
+			/* Set io allowed member of file handle to
+			 * TRUE */
+			fh->io_allowed[buf_type_index] = 1;
+			/* Increment io usrs member of channel object
+			   to 1 */
+			common->io_usrs = 1;
+			/* Store type of memory requested in channel
+			 * object */
+			common->memory = reqbuf->memory;
+			/* Initialize buffer queue */
+			INIT_LIST_HEAD(&common->dma_queue);
+			/* Allocate buffers */
+			ret = videobuf_reqbufs(&common->buffer_queue, reqbuf);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for en-queing buffer in the buffer
+		 * queue */
+	case VIDIOC_QBUF:
+		{
+			struct common_obj *common = NULL;
+			struct v4l2_buffer tbuf = *(struct v4l2_buffer *)arg;
+			struct videobuf_buffer *buf1;
+			int buf_type_index;
+			dev_dbg(vpif_dev, "VIDIOC_QBUF\n");
+			buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE
+					  == (tbuf.type)) ?
+			    VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_CAPTURE == tbuf.type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[buf_type_index]);
+
+			/* If this file handle is not allowed to do IO,
+			   return error */
+			if (!fh->io_allowed[buf_type_index]) {
+				dev_err(vpif_dev, "fh->io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+
+			if (!(list_empty(&common->dma_queue)) ||
+			    (common->curFrm != common->nextFrm) ||
+			    !(common->started) ||
+			    (common->started && (0 == channel->field_id))) {
+				ret = videobuf_qbuf
+				    (&common->buffer_queue,
+				     (struct v4l2_buffer *)
+				     arg);
+				break;
+			}
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE != common->fmt.type) {
+				ret = videobuf_qbuf
+				    (&common->buffer_queue,
+				     (struct v4l2_buffer *)
+				     arg);
+				break;
+			}
+			/* bufferqueue is empty store buffer address
+			 * in VPIF registers */
+			mutex_lock(&common->buffer_queue.lock);
+			tbuf = *(struct v4l2_buffer *)arg;
+			buf1 = common->buffer_queue.bufs[tbuf.index];
+			if (buf1->memory != tbuf.memory) {
+				dev_err(vpif_dev, "invalid buffer" " type\n");
+				mutex_unlock(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+			if ((buf1->state == STATE_QUEUED) ||
+			    (buf1->state == STATE_ACTIVE)) {
+				dev_err(vpif_dev, "invalid state\n");
+				mutex_unlock(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+
+			switch (buf1->memory) {
+			case V4L2_MEMORY_MMAP:
+				if (buf1->baddr == 0) {
+					mutex_unlock(&common->buffer_queue.lock);
+					return -EINVAL;
+				}
+				break;
+			case V4L2_MEMORY_USERPTR:
+				if (tbuf.length < buf1->bsize) {
+					mutex_unlock(&common->buffer_queue.lock);
+					return -EINVAL;
+				}
+				if ((STATE_NEEDS_INIT != buf1->state)
+				    && (buf1->baddr != tbuf.m.userptr))
+					vpif_buffer_release(&common->
+							    buffer_queue, buf1);
+				buf1->baddr = tbuf.m.userptr;
+				break;
+			default:
+				mutex_unlock(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+			local_irq_save(flags);
+			ret =
+			    vpif_buffer_prepare(&common->buffer_queue,
+						buf1, common->buffer_queue.
+						field);
+			if (ret < 0) {
+				local_irq_restore(flags);
+				mutex_unlock(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+			buf1->state = STATE_ACTIVE;
+			addr = buf1->boff;
+			common->nextFrm = buf1;
+			common->set_addr((addr + common->ytop_off),
+					 (addr + common->ybtm_off),
+					 (addr + common->ctop_off),
+					 (addr + common->cbtm_off));
+			local_irq_restore(flags);
+			list_add_tail(&buf1->stream,
+				      &(common->buffer_queue.stream));
+			mutex_unlock(&common->buffer_queue.lock);
+			break;
+		}
+
+		/* If the case is for de-queing buffer from the
+		 * buffer queue */
+	case VIDIOC_DQBUF:
+		{
+			struct common_obj *common = NULL;
+			int buf_type_index = 0;
+			buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE ==
+					  ((struct v4l2_buffer *)arg)->type) ?
+			    VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_CAPTURE ==
+			      ((struct v4l2_buffer *)arg)->type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[buf_type_index]);
+
+			if (file->f_flags & O_NONBLOCK)
+				/* Call videobuf_dqbuf for non
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(&common->buffer_queue,
+						   (struct v4l2_buffer *)
+						   arg, 1);
+			else
+				/* Call videobuf_dqbuf for
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(&common->buffer_queue,
+						   (struct v4l2_buffer *)
+						   arg, 0);
+			break;
+		}
+
+		/* If the case is for querying information about
+		 *  buffer for memory mapping io */
+	case VIDIOC_QUERYBUF:
+		{
+			struct common_obj *common = NULL;
+			u8 buf_type_index = 0;
+			dev_dbg(vpif_dev, "VIDIOC_QUERYBUF\n");
+			buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE ==
+					  ((struct v4l2_buffer *)arg)->type) ?
+			    VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_CAPTURE ==
+			      ((struct v4l2_buffer *)arg)->type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[buf_type_index]);
+			if (((struct v4l2_buffer *)arg)->memory !=
+			    V4L2_MEMORY_MMAP) {
+				return -EINVAL;
+			}
+			/* Call videobuf_querybuf to get information */
+			ret = videobuf_querybuf(&common->buffer_queue,
+						(struct v4l2_buffer *)
+						arg);
+			break;
+		}
+
+		/* If the case is starting streaming */
+	case VIDIOC_STREAMON:
+		{
+			struct common_obj *common = NULL;
+			struct video_obj *vid_ch = NULL;
+			struct channel_obj *oth_ch
+			    = vpif_obj.dev[!channel->channel_id];
+			struct vpif_params *vpif;
+			enum v4l2_buf_type buftype
+			    = *(enum v4l2_buf_type *)(arg);
+			int buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE ==
+					      buftype) ?
+			    VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_CAPTURE ==
+			      buftype) ? VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			dev_dbg(vpif_dev, "VIDIOC_STREAMON\n");
+			common = &(channel->common[buf_type_index]);
+			vid_ch = &(channel->video);
+			vpif = &channel->vpifparams;
+			/* If file handle is not allowed IO,
+			 * return error */
+			if (!fh->io_allowed[buf_type_index]) {
+				dev_err(vpif_dev, "fh->io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			/* If Streaming is already started,
+			 * return error */
+			if (common->started) {
+				dev_err(vpif_dev, "channel->started\n");
+				ret = -EBUSY;
+				break;
+			}
+			if ((channel->channel_id == VPIF_CHANNEL0_VIDEO
+			     && oth_ch->common[VPIF_VIDEO_INDEX].started &&
+			     vid_ch->std_info.ycmux_mode == 0)
+			    || ((channel->channel_id == VPIF_CHANNEL1_VIDEO)
+				&& (2 == oth_ch->common[VPIF_VIDEO_INDEX].
+				    started))) {
+				dev_err(vpif_dev, "other channel is using\n");
+				ret = -EBUSY;
+				break;
+			}
+			if (VPIF_VIDEO_INDEX == buf_type_index) {
+				ret = vpif_check_format(channel,
+							&common->fmt.fmt.pix);
+				if (ret)
+					return ret;
+			} else {
+				if (!channel->common[VPIF_VIDEO_INDEX].started)
+					return -EINVAL;
+			}
+
+			/* Call videobuf_streamon to start streaming
+			   in videobuf */
+			ret = videobuf_streamon(&common->buffer_queue);
+			if (ret) {
+				dev_err(vpif_dev, "videobuf_streamon\n");
+				break;
+			}
+			down_interruptible(&common->lock);
+			/* If buffer queue is empty, return error */
+			if (list_empty(&common->dma_queue)) {
+				dev_err(vpif_dev, "buffer queue is empty\n");
+				ret = -EIO;
+				up(&common->lock);
+				break;
+			}
+			/* Get the next frame from the buffer queue */
+			common->nextFrm = common->curFrm =
+			    list_entry(common->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove buffer from the buffer queue */
+			list_del(&common->curFrm->queue);
+			/* Mark state of the current frame to active */
+			common->curFrm->state = STATE_ACTIVE;
+			/* Initialize field_id and started member */
+			channel->field_id = 0;
+			common->started = 1;
+
+			addr = common->curFrm->boff;
+
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE == buftype) {
+				/* Calculate the offset for Y and C data
+				   in the buffer */
+				vpif_calculate_offsets(channel);
+
+				if ((vid_ch->std_info.frame_format &&
+				     ((common->fmt.fmt.pix.field !=
+				       V4L2_FIELD_NONE) &&
+				      (common->fmt.fmt.pix.field !=
+				       V4L2_FIELD_ANY))) ||
+				    (!vid_ch->std_info.frame_format &&
+				     (common->fmt.fmt.pix.field ==
+				      V4L2_FIELD_NONE))) {
+					dev_err(vpif_dev, "conflict in field \
+							format and std \
+							format\n");
+					up(&common->lock);
+					return -EINVAL;
+				}
+				/* if single channel is needed */
+				if (vid_ch->std_info.ycmux_mode == 1) {
+					ret = set_vid_in_mode_for_tvp5147();
+				} else {
+					ret = set_vid_in_mode_for_tvp7002();
+				}
+				if (ret < 0) {
+					dev_err(vpif_dev,
+						"cann't set vid in bit\n");
+					up(&common->lock);
+					return ret;
+				}
+
+				/* Call vpif_set_params function to set
+				 * the parameters and addresses */
+				ret =
+				    vpif_set_video_params(vpif,
+							  channel->channel_id);
+				if (ret < 0) {
+					dev_err(vpif_dev,
+						"cann't set video params\n");
+					up(&common->lock);
+					return ret;
+				}
+				common->started = ret;
+				vpif_config_addr(channel, ret, buftype);
+
+				common->set_addr((addr + common->ytop_off),
+						 (addr + common->ybtm_off),
+						 (addr + common->ctop_off),
+						 (addr + common->cbtm_off));
+
+				/* Set interrupt for both the fields in
+				   VPIF Register enable channel in
+				   VPIF register */
+				if ((VPIF_CHANNEL0_VIDEO
+				     == channel->channel_id)) {
+					channel0_intr_assert();
+					channel0_intr_enable(1);
+					enable_channel0(1);
+				}
+				if ((VPIF_CHANNEL1_VIDEO == channel->channel_id)
+				    || (common->started == 2)) {
+					channel1_intr_assert();
+					channel1_intr_enable(1);
+					enable_channel1(1);
+				}
+				channel_first_int[VPIF_VIDEO_INDEX]
+				    [channel->channel_id] = 1;
+			} else if (V4L2_BUF_TYPE_VBI_CAPTURE == buftype ||
+				   V4L2_BUF_TYPE_HBI_CAPTURE == buftype) {
+				u8 index = 0;
+				/* Calculate the offset for vbi data
+				   in the buffer */
+				if (V4L2_BUF_TYPE_VBI_CAPTURE == buftype)
+					index = VPIF_VBI_INDEX;
+				else
+					index = VPIF_HBI_INDEX;
+
+				vpif_calculate_offsets_vbi(channel, index);
+
+				vpif_config_addr(channel, 0, buftype);
+				common->set_addr((addr + common->ytop_off),
+						 (addr + common->ybtm_off),
+						 (addr + common->ctop_off),
+						 (addr + common->cbtm_off));
+				enable_raw_feature(channel->channel_id, index);
+				channel_first_int[index]
+				    [channel->channel_id] = 1;
+			} else {
+				queue_work(vbi_workqueue,
+					   &vbi_work[channel->channel_id]);
+				channel_first_int[VPIF_VBI_INDEX]
+				    [channel->channel_id] = 1;
+			}
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for stopping streaming */
+	case VIDIOC_STREAMOFF:
+		{
+			struct common_obj *common = NULL;
+			int buf_type_index;
+			enum v4l2_buf_type buftype
+			    = *(enum v4l2_buf_type *)(arg);
+			buf_type_index = (V4L2_BUF_TYPE_VIDEO_CAPTURE ==
+					  buftype) ?
+			    VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_CAPTURE ==
+			      buftype) ? VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[buf_type_index]);
+			dev_dbg(vpif_dev, "VIDIOC_STREAMOFF\n");
+			/* If io is allowed for this file handle,
+			   return error */
+			if (!fh->io_allowed[buf_type_index]) {
+				dev_err(vpif_dev, "fh->io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			/* If streaming is not started, return error */
+			if (!common->started) {
+				dev_err(vpif_dev, "channel->started\n");
+				ret = -EINVAL;
+				break;
+			}
+			down_interruptible(&common->lock);
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE == buftype) {
+				/* disable channel */
+				if (VPIF_CHANNEL0_VIDEO == channel->channel_id) {
+					enable_channel0(0);
+					channel0_intr_enable(0);
+				} else {
+					enable_channel1(0);
+					channel1_intr_enable(0);
+				}
+			} else if (buftype == V4L2_BUF_TYPE_VBI_CAPTURE) {
+				disable_raw_feature(channel->channel_id,
+						    VPIF_VBI_INDEX);
+			} else if (buftype == V4L2_BUF_TYPE_HBI_CAPTURE) {
+				disable_raw_feature(channel->channel_id,
+						    VPIF_HBI_INDEX);
+			}
+			common->started = 0;
+			up(&common->lock);
+			ret = videobuf_streamoff(&common->buffer_queue);
+			break;
+		}
+
+		/* If the case is for setting VPIF parameters */
+	case VPIF_S_VPIF_PARAMS:
+		{
+			struct video_obj *vid_ch = NULL;
+			struct common_obj *common = NULL;
+			struct vpif_params *params = (struct vpif_params *)arg;
+			common = &(channel->common[VPIF_VIDEO_INDEX]);
+			vid_ch = &(channel->video);
+			dev_dbg(vpif_dev, "VPIF_S_VPIF_PARAMS\n");
+			/* If streaming is not started, return error */
+			if (common->started) {
+				ret = -EINVAL;
+				break;
+			}
+			down_interruptible(&common->lock);
+			channel->vpifparams = *params;
+			strncpy(channel->video.std_info.name,
+				params->video_params.name,
+				sizeof(channel->video.std_info.name));
+			common->fmt.fmt.pix.bytesperline =
+			    params->video_params.hpitch;
+			ret = vpif_get_mode_info(&vid_ch->std_info);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for getting VPIF Parameters */
+	case VPIF_G_VPIF_PARAMS:
+		{
+			struct vpif_params *params = (struct vpif_params *)arg;
+			struct common_obj *common = NULL;
+			dev_dbg(vpif_dev, "VPIF_G_VPIF_PARAMS\n");
+			common = &(channel->common[VPIF_VIDEO_INDEX]);
+			down_interruptible(&common->lock);
+			memcpy(params, &channel->vpifparams, sizeof(*params));
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for getting TVP5146 parameters */
+	case VPFE_CMD_CONFIG_TVP5146:
+		{
+			dev_err(vpif_dev, "Device is not supported\n");
+			return -ENODEV;
+			break;
+		}
+
+		/* If the case is for setting mt9t001 parameters */
+	case VPFE_S_MT9T001_PARAMS:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			if (VPIF_CHANNEL1_VIDEO == channel->channel_id)
+				return -EINVAL;
+			if (0 != strcmp(dec->name, "MT9T001"))
+				return -ENODEV;
+			if (ISNULL(dec->params_ops->setparams)) {
+				dev_err(vpif_dev,
+					"vpif_doioctl:No setparams\n");
+				return -EINVAL;
+			}
+			down_interruptible(&common->lock);
+			ret = dec->params_ops->setparams((void *)arg, dec);
+			up(&common->lock);
+		}
+		break;
+
+		/* If the case is for setting mt9t001 parameters */
+	case VPFE_G_MT9T001_PARAMS:
+		{
+			struct common_obj *common;
+			common = &(channel->common[VPIF_VIDEO_INDEX]);
+			if (VPIF_CHANNEL1_VIDEO == channel->channel_id)
+				return -EINVAL;
+			if (0 != strcmp(dec->name, "MT9T001"))
+				return -ENODEV;
+			if (ISNULL(dec->params_ops->getparams)) {
+				dev_err(vpif_dev,
+					"vpif_doioctl:No getparams\n");
+				return -EINVAL;
+			}
+			down_interruptible(&common->lock);
+			ret = dec->params_ops->getparams((void *)arg, dec);
+			up(&common->lock);
+		}
+		break;
+	case VIDIOC_S_PRIORITY:
+		{
+			enum v4l2_priority *p = (enum v4l2_priority *)arg;
+			ret = v4l2_prio_change(&channel->prio, &fh->prio, *p);
+			break;
+		}
+	case VIDIOC_G_PRIORITY:
+		{
+			enum v4l2_priority *p = (enum v4l2_priority *)arg;
+			*p = v4l2_prio_max(&channel->prio);
+			break;
+		}
+		/* If the case is for getting sliced vbi capabilites */
+	case VIDIOC_G_SLICED_VBI_CAP:
+		{
+			if (ISNULL(dec->get_sliced_vbi_cap)) {
+				dev_err(vpif_dev,
+					"vpif_doioctl:No get sliced vbi cap\n");
+				return -EINVAL;
+			}
+			/* Call get sliced capability function
+			   of encoder device */
+			dec->get_sliced_vbi_cap
+			    ((struct v4l2_sliced_vbi_cap *)arg, dec);
+			break;
+		}
+		/* If the case if for getting cropping parameters */
+	case VIDIOC_CROPCAP:
+		{
+			struct v4l2_cropcap *crop = (struct v4l2_cropcap *)arg;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			if (V4L2_BUF_TYPE_VIDEO_CAPTURE != crop->type)
+				return -EINVAL;
+			crop->bounds.left = crop->bounds.top = 0;
+			crop->defrect.left = crop->defrect.top = 0;
+			crop->defrect.height = crop->bounds.height =
+			    common->height;
+			crop->defrect.width = crop->bounds.width =
+			    common->width;
+			break;
+		}
+	default:
+		dev_err(vpif_dev, "Invalid command\n");
+
+		return -EINVAL;
+	}
+
+	dev_dbg(vpif_dev, "End of vpif_doioctl\n");
+	return ret;
+}
+
+/* vpfe_ioctl : Calls vpif_doioctl function
+ */
+static int vpif_ioctl(struct inode *inode, struct file *file,
+		      unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	char sbuf[128];
+	void *mbuf = NULL;
+	void *parg = NULL;
+
+	dev_dbg(vpif_dev, "Start of vpif ioctl\n");
+	if (ISDECODERCMD(cmd)) {
+		ret = vpif_doioctl(inode, file, cmd, arg);
+		if (ret == -ENOIOCTLCMD)
+			ret = -EINVAL;
+		goto out;
+	}
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		parg = NULL;
+		break;
+	case _IOC_READ:
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+			parg = sbuf;
+		} else {
+			/* too big to allocate from stack */
+			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+			if (NULL == mbuf)
+				return -ENOMEM;
+			parg = mbuf;
+		}
+
+		ret = -EFAULT;
+		if (_IOC_DIR(cmd) & _IOC_WRITE)
+			if (copy_from_user(parg, (void __user *)arg,
+					   _IOC_SIZE(cmd)))
+				goto out;
+		break;
+	}
+
+	/* call driver */
+	ret = vpif_doioctl(inode, file, cmd, (unsigned long)parg);
+	if (ret == -ENOIOCTLCMD)
+		ret = -EINVAL;
+
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+			ret = -EFAULT;
+		break;
+	}
+out:
+	if (mbuf)
+		kfree(mbuf);
+
+	dev_dbg(vpif_dev, "End of vpif ioctl\n");
+	return ret;
+}
+
+/*  vpfe_mmap : It is used to map kernel space buffers
+ *  into user spaces
+ */
+static int vpif_mmap(struct file *filep, struct vm_area_struct *vma)
+{
+	/* Get the channel object and file handle object */
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = &(channel->common[VPIF_VBI_INDEX]);
+	int err = 0, i, found = 0;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	dev_dbg(vpif_dev, "Start of vpif mmap\n");
+	for (i = 0; (i < common->numbuffers) && (0 == found); i++) {
+		if (common->buffer_queue.bufs[i]->boff == offset)
+			found = 1;
+	}
+	if (0 == found) {
+		common = &(channel->common[VPIF_HBI_INDEX]);
+		for (i = 0; (i < common->numbuffers) && (0 == found); i++) {
+			if (common->buffer_queue.bufs[i]->boff == offset)
+				found = 1;
+		}
+	}
+	if (0 == found)
+		common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	err = videobuf_mmap_mapper(&common->buffer_queue, vma);
+	dev_dbg(vpif_dev, "End of vpif mmap\n");
+	return err;
+}
+
+/* vpif_poll: It is used for select/poll system call
+ */
+static unsigned int vpif_poll(struct file *filep, poll_table * wait)
+{
+	int err = 0;
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	dev_dbg(vpif_dev, "<vpif_poll>");
+
+	if (common->started)
+		err = videobuf_poll_stream(filep, &common->buffer_queue, wait);
+
+	common = &(channel->common[VPIF_VBI_INDEX]);
+	if (common->started)
+		err |= videobuf_poll_stream(filep, &common->buffer_queue, wait);
+
+	dev_dbg(vpif_dev, "</vpif_poll>");
+	return err;
+}
+
+/* vpif_open : It creates object of file handle structure and
+ * stores it in private_data  member of filepointer
+ */
+static int vpif_open(struct inode *inode, struct file *filep)
+{
+	int minor = iminor(inode);
+	int found = -1;
+	int i = 0;
+	struct channel_obj *channel = NULL;
+	struct decoder_device *dec = NULL;
+	struct video_obj *vid_ch = NULL;
+	struct common_obj *common = NULL;
+	struct vpif_fh *fh = NULL;
+	u8 name[20];
+
+	dev_dbg(vpif_dev, "<vpif open>\n");
+
+	/* Check for valid minor number */
+	for (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[i];
+		vid_ch = &(channel->video);
+		common = &(channel->common[VPIF_VIDEO_INDEX]);
+		if (minor == channel->video_dev->minor) {
+			found = i;
+			break;
+		}
+	}
+	/* If not found, return error no device */
+	if (0 > found) {
+		dev_err(vpif_dev, "device not found\n");
+		return -ENODEV;
+	}
+	channel->current_decoder = 0;
+	/* Select the decoder as per the device_type argument */
+	if (config_params.device_type >= 0) {
+		if (config_params.device_type == 0)
+			strncpy(name, "TVP5147", sizeof(name));
+		else
+			strncpy(name, "MT9T001", sizeof(name));
+		for (i = 0; i < channel->numdecoders; i++) {
+			if (0 == strncmp(channel->decoder[i]->name, name,
+					 sizeof(name))) {
+				channel->current_decoder = i;
+				break;
+			}
+		}
+	}
+	channel->default_decoder = channel->current_decoder;
+	vid_ch->input_idx = 0;
+	/* Check if decoder registered for default device */
+	dec = channel->decoder[channel->current_decoder];
+	if (ISNULL(dec)) {
+		dev_err(vpif_dev, "No decoder registered\n");
+		return -ENXIO;
+	}
+	if (ISNULL(dec->std_ops) || ISNULL(dec->std_ops->getstd)) {
+		dev_err(vpif_dev, "No standard functions in decoder\n");
+		return -EINVAL;
+	}
+	/* Allocate memory for the file handle object */
+	fh = kmalloc(sizeof(struct vpif_fh), GFP_KERNEL);
+	if (ISNULL(fh)) {
+		dev_err(vpif_dev,
+			"unable to allocate memory for file handle object\n");
+		return -ENOMEM;
+	}
+	/* store pointer to fh in private_data member of filep */
+	filep->private_data = fh;
+	fh->channel = channel;
+	fh->initialized = 0;
+	/* If decoder is not initialized. initialize it */
+	if (!channel->initialized) {
+		fh->initialized = 1;
+		/* Initialize decoder by calling initialize function */
+		dec->initialize(dec, DECODER_FULL_INIT_FLAG);
+		channel->initialized = 1;
+		/* Increment usage counter */
+		memset(&(channel->vpifparams), 0, sizeof(struct vpif_params));
+
+		/* Get the default standard and info about standard */
+		dec->std_ops->getstd(&vid_ch->std, dec);
+		vpif_get_std_info(channel);
+		common->fmt.fmt.pix.bytesperline = common->fmt.fmt.pix.width;
+		/* Configure the default format information */
+		vpif_config_format(channel);
+	}
+	/* Increment channel usrs counter */
+	channel->usrs++;
+	/* Set io_allowed member to false */
+	fh->io_allowed[VPIF_VIDEO_INDEX] =
+	    fh->io_allowed[VPIF_VBI_INDEX] = fh->io_allowed[VPIF_HBI_INDEX] = 0;
+	/* Initialize priority of this instance to default priority */
+	fh->prio = V4L2_PRIORITY_UNSET;
+	v4l2_prio_open(&channel->prio, &fh->prio);
+
+	dev_dbg(vpif_dev, "</vpif_open>\n");
+	return 0;
+}
+
+static void vpif_free_vbibuffers(struct channel_obj *channel, u8 index)
+{
+	struct common_obj *common = NULL;
+	u32 bufsize, i;
+	common = &(channel->common[index]);
+	if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE == common->buffer_queue.type)
+		bufsize = VPIF_SLICED_BUF_SIZE;
+	else {
+		/* Calculate the size of the buffer */
+		bufsize = ((common->fmt.fmt.vbi.count[0]) +
+			   (common->fmt.fmt.vbi.count[1])) *
+		    (common->fmt.fmt.vbi.samples_per_line);
+	}
+	for (i = 0; i < common->numbuffers; i++) {
+		if (common->fbuffers[i]) {
+			vpif_free_buffer((unsigned long)common->
+					 fbuffers[i], bufsize);
+		}
+	}
+	common->numbuffers = 0;
+}
+static void vpif_free_allbuffers(struct channel_obj *channel)
+{
+	int i;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	u32 start = config_params.numbuffers[channel->channel_id];
+	u32 end = common->numbuffers;
+	u32 bufsize = config_params.channel_bufsize[channel->channel_id];
+	for (i = start; i < end; i++) {
+		if (common->fbuffers[i]) {
+			vpif_free_buffer((unsigned long)common->
+					 fbuffers[i], bufsize);
+		}
+		common->fbuffers[i] = 0;
+	}
+}
+
+/* vpif_release : This function deletes buffer queue, frees the
+ * buffers and the vpfe file  handle
+ */
+static int vpif_release(struct inode *inode, struct file *filep)
+{
+	struct common_obj *common = NULL;
+	/* Get the channel object and file handle object */
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct decoder_device *dec = channel->decoder[channel->current_decoder];
+	int i;
+
+	dev_dbg(vpif_dev, "<vpif_release>\n");
+	common = &(channel->common[VPIF_VIDEO_INDEX]);
+	/* If this is doing IO and other channels are not closed */
+	if ((channel->usrs != 1) && fh->io_allowed[VPIF_VIDEO_INDEX]) {
+		dev_err(vpif_dev, "Close other instances\n");
+		return -EAGAIN;
+	}
+	/* Get the lock on channel object */
+	down_interruptible(&common->lock);
+	/* if this instance is doing IO */
+	if (fh->io_allowed[VPIF_VIDEO_INDEX]) {
+		/* Reset io_usrs member of channel object */
+		common->io_usrs = 0;
+		/* Disable channel/vbi as per its device type and channel id */
+		if (VPIF_CHANNEL0_VIDEO == channel->channel_id) {
+			enable_channel0(0);
+			channel0_intr_enable(0);
+		}
+		if ((VPIF_CHANNEL1_VIDEO == channel->channel_id) ||
+		    (2 == common->started)) {
+			enable_channel1(0);
+			channel1_intr_enable(0);
+		}
+		common->started = 0;
+		/* Free buffers allocated */
+		videobuf_queue_cancel(&common->buffer_queue);
+		vpif_free_allbuffers(channel);
+		common->numbuffers =
+		    config_params.numbuffers[channel->channel_id];
+	}
+	/* unlock semaphore on channel object */
+	up(&common->lock);
+
+	for (i = VPIF_VBI_INDEX; i <= VPIF_HBI_INDEX; i++) {
+		common = &(channel->common[i]);
+		/* If this is doing IO and other channels are not closed */
+		if ((channel->usrs != 1) && fh->io_allowed[i]) {
+			dev_err(vpif_dev, "Close other instances\n");
+			return -EAGAIN;
+		}
+		/* Get the lock on channel object */
+		down_interruptible(&common->lock);
+
+		/* if this instance is doing IO */
+		if (fh->io_allowed[i]) {
+			/* Reset io_usrs member of channel object */
+			common->io_usrs = 0;
+			/* Disable channel/vbi as per its device type and
+			   channel id */
+			disable_raw_feature(channel->channel_id, i);
+			common->started = 0;
+			/* Free buffers allocated */
+			videobuf_queue_cancel(&common->buffer_queue);
+			vpif_free_vbibuffers(channel, i);
+			common->numbuffers = 0;
+		}
+		/* unlock semaphore on channel object */
+		up(&common->lock);
+	}
+
+	/* Decrement channel usrs counter */
+	channel->usrs--;
+	/* Close the priority */
+	v4l2_prio_close(&channel->prio, &fh->prio);
+	/* If this file handle has initialize decoder device, reset it */
+	if (fh->initialized) {
+		dec->deinitialize(dec);
+		channel->initialized = 0;
+	}
+	filep->private_data = NULL;
+	/* Free memory allocated to file handle object */
+	if (!ISNULL(fh))
+		kfree(fh);
+
+	dev_dbg(vpif_dev, "</vpif_release>\n");
+	return 0;
+}
+
+static void vpif_platform_release(struct device
+				  *device)
+{
+	/* This is called when the reference count goes to zero. */
+}
+
+static struct file_operations vpif_fops = {
+	.owner = THIS_MODULE,
+	.open = vpif_open,
+	.release = vpif_release,
+	.ioctl = vpif_ioctl,
+	.mmap = vpif_mmap,
+	.poll = vpif_poll
+};
+static struct video_device vpif_video_template = {
+	.name = "vpif",
+	.type = VID_TYPE_CAPTURE,
+	.hardware = 0,
+	.fops = &vpif_fops,.minor = -1,
+};
+
+/* vpif_probe : This function creates device entries by register
+ * itself to the V4L2 driver and initializes fields of each
+ * channel objects */
+static __init int vpif_probe(struct device *device)
+{
+	struct common_obj *common = NULL;
+	int i, j = 0, k, err = 0, index = 0;
+	struct video_device *vfd = NULL;
+	struct channel_obj *channel = NULL;
+	struct video_obj *vid_ch = NULL;
+	vpif_dev = device;
+
+	for (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[i];
+		/* Allocate memory for video device */
+		vfd = video_device_alloc();
+		if (ISNULL(vfd)) {
+			for (j = 0; j < i; j++) {
+				video_device_release(vpif_obj.dev[j]->
+						     video_dev);
+			}
+			return -ENOMEM;
+		}
+
+		/* Initialize field of video device */
+		*vfd = vpif_video_template;
+		vfd->dev = device;
+		vfd->release = video_device_release;
+		snprintf(vfd->name, sizeof(vfd->name),
+			 "DaVinciHD_VPIFCapture_DRIVER_V%d.%d.%d",
+			 (VPIF_CAPTURE_VERSION_CODE >> 16) & 0xff,
+			 (VPIF_CAPTURE_VERSION_CODE >> 8) & 0xff,
+			 (VPIF_CAPTURE_VERSION_CODE) & 0xff);
+		/* Set video_dev to the video device */
+		channel->video_dev = vfd;
+	}
+
+	for (j = 0; j < VPIF_CAPTURE_MAX_DEVICES; j++) {
+		channel = vpif_obj.dev[j];
+		channel->usrs = 0;
+		for (k = VPIF_VIDEO_INDEX; k <= VPIF_HBI_INDEX; k++) {
+			common = &(channel->common[k]);
+			common->io_usrs = 0;
+			common->started = 0;
+			spin_lock_init(&common->irqlock);
+			init_MUTEX(&common->lock);
+			common->numbuffers = 0;
+			common->set_addr = NULL;
+			common->ytop_off = common->ybtm_off = 0;
+			common->ctop_off = common->cbtm_off = 0;
+			common->curFrm = common->nextFrm = NULL;
+			memset(&common->fmt, 0, sizeof(struct v4l2_format));
+		}
+		channel->video.std = 0;
+		channel->initialized = 0;
+		channel->channel_id = j;
+
+		common = &(channel->common[VPIF_VIDEO_INDEX]);
+		vid_ch = &(channel->video);
+		/* Initialize field of the channel objects */
+		channel->usrs = common->io_usrs = vid_ch->std = 0;
+		common->started = channel->initialized = 0;
+		channel->channel_id = j;
+		common->numbuffers =
+		    config_params.numbuffers[channel->channel_id];
+
+		channel->numdecoders = 0;
+		channel->current_decoder = 0;
+		for (index = 0; index < VPIF_CAPTURE_NUM_DECODERS; index++) {
+			channel->decoder[index] = NULL;
+		}
+
+		memset(&(channel->vpifparams), 0, sizeof(struct vpif_params));
+		/* Initialize prio member of channel object */
+		v4l2_prio_init(&channel->prio);
+
+		/* Set the tasklet handler in the tasklet struct */
+		channel->vbi.vbi_tasklet.func = vbi_work_handler;
+		/* Set Timer counter */
+		channel->vbi.timer_counter = VPIF_TIMER_COUNT;
+		/* Initialize the work structure */
+		INIT_WORK(&vbi_work[channel->channel_id],
+			  (void (*)(void *))vbi_work_handler, (void *)channel);
+		/* register video device */
+		dev_dbg(vpif_dev, "trying to register vpif device.\n");
+		dev_dbg(vpif_dev, "channel=%x,channel->video_dev=%x\n",
+			(int)channel, (int)&channel->video_dev);
+		channel->common[VPIF_VIDEO_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		channel->common[VPIF_VBI_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_SLICED_VBI_CAPTURE;
+		channel->common[VPIF_HBI_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_HBI_CAPTURE;
+		err = video_register_device(channel->video_dev,
+					    VFL_TYPE_GRABBER, vpif_nr[j]);
+		if (err)
+			goto probe_out;
+	}
+	return 0;
+
+probe_out:
+	for (k = 0; k < j; k++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[k];
+		/* Unregister video device */
+		video_unregister_device(channel->video_dev);
+		/* Release video device */
+		video_device_release(channel->video_dev);
+		channel->video_dev = NULL;
+	}
+	dev_dbg(vpif_dev, "</vpif_probe>\n");
+	return err;
+}
+
+/*  vpif_remove : It un-register channels from V4L2 driver
+ */
+static int vpif_remove(struct device *device)
+{
+	int i;
+	struct channel_obj *channel;
+	dev_dbg(vpif_dev, "<vpif_remove>\n");
+	/* un-register device */
+	for (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[i];
+		/* Unregister video device */
+		video_unregister_device(channel->video_dev);
+		channel->video_dev = NULL;
+	}
+	dev_dbg(vpif_dev, "</vpif_remove>\n");
+	return 0;
+}
+
+static struct device_driver vpif_driver = {
+	.name = "vpif capture",
+	.bus = &platform_bus_type,
+	.probe = vpif_probe,
+	.remove = vpif_remove,
+};
+static struct platform_device _vpif_device = {
+	.name = "vpif capture",
+	.id = 1,
+	.dev = {
+		.release = vpif_platform_release,
+		}
+};
+
+/* vpif_init : This function registers device and driver to
+ * the kernel, requests irq handler and allocates memory
+ * for channel objects
+ */
+static __init int vpif_init(void)
+{
+	int free_irq_no_index;
+	int err = 0, i, j;
+	int free_channel_objects_index;
+	int free_buffer_channel_index;
+	int free_buffer_index;
+	u8 *addr;
+	u32 size;
+
+	/* Default number of buffers should be 3 */
+	if ((channel0_numbuffers > 0) &&
+	    (channel0_numbuffers < config_params.min_numbuffers))
+		channel0_numbuffers = config_params.min_numbuffers;
+	if ((channel1_numbuffers > 0) &&
+	    (channel1_numbuffers < config_params.min_numbuffers))
+		channel1_numbuffers = config_params.min_numbuffers;
+
+	/* Set buffer size to min buffers size if invalid buffer size is
+	 * given */
+	if (channel0_bufsize < config_params.min_bufsize[VPIF_CHANNEL0_VIDEO])
+		channel0_bufsize =
+		    config_params.min_bufsize[VPIF_CHANNEL0_VIDEO];
+	if (channel1_bufsize < config_params.min_bufsize[VPIF_CHANNEL1_VIDEO])
+		channel1_bufsize =
+		    config_params.min_bufsize[VPIF_CHANNEL1_VIDEO];
+
+	config_params.numbuffers[VPIF_CHANNEL0_VIDEO] = channel0_numbuffers;
+	config_params.numbuffers[VPIF_CHANNEL1_VIDEO] = channel1_numbuffers;
+	if (channel0_numbuffers) {
+		config_params.channel_bufsize[VPIF_CHANNEL0_VIDEO]
+		    = channel0_bufsize;
+	}
+	if (channel1_numbuffers) {
+		config_params.channel_bufsize[VPIF_CHANNEL1_VIDEO]
+		    = channel1_bufsize;
+	}
+
+	/* Check the correct value of device_type */
+	if ((device_type > config_params.max_device_type) || (device_type < 0)) {
+		config_params.device_type = 0;
+	} else {
+		config_params.device_type = device_type;
+	}
+	/* Allocate memory for six channel objects */
+	for (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {
+		vpif_obj.dev[i] =
+		    kmalloc(sizeof(struct channel_obj), GFP_KERNEL);
+		/* If memory allocation fails, return error */
+		if (!vpif_obj.dev[i]) {
+			free_channel_objects_index = i;
+			goto vpif_init_free_channel_objects;
+			err = -ENOMEM;
+		}
+	}
+	free_channel_objects_index = VPIF_CAPTURE_MAX_DEVICES;
+
+	/* Allocate memory for buffers */
+	for (i = 0; i < VPIF_CAPTURE_NUM_CHANNELS; i++) {
+		size = config_params.channel_bufsize[i];
+		for (j = 0; j < config_params.numbuffers[i]; j++) {
+			addr = (u8 *) vpif_alloc_buffer(size);
+			if (!addr) {
+				free_buffer_channel_index = i;
+				free_buffer_index = j;
+				err = -ENOMEM;
+				goto vpif_init_free_buffers;
+			}
+			vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].fbuffers[j] =
+			    addr;
+		}
+	}
+	free_buffer_channel_index = VPIF_CAPTURE_NUM_CHANNELS;
+	free_buffer_index = config_params.numbuffers[i - 1];
+
+	/* Create the workqueue */
+	vbi_workqueue = create_singlethread_workqueue("vbi");
+	if (!vbi_workqueue) {
+		err = -ENOMEM;
+		goto vpif_init_free_buffers;
+	}
+
+	/* Register driver to the kernel */
+	err = driver_register(&vpif_driver);
+	if (0 != err) {
+		goto vpif_init_free_buffers;
+	}
+	/* register device as a platform device to the kernel */
+	err = platform_device_register(&_vpif_device);
+	if (0 != err) {
+		goto vpif_init_unregister_vpif_driver;
+	}
+	for (j = 0; j < VPIF_CAPTURE_NUM_CHANNELS; j++) {
+		err =
+		    request_irq(vpif_get_irq_number(j),
+				vpif_channel_isr, SA_INTERRUPT,
+				"DaVinciHD_Capture",
+				(void *)(&(vpif_obj.dev[j]->channel_id)));
+		if (0 != err) {
+			if (j == 0) {
+				goto vpif_init_unregister_vpif_device;
+			} else {
+				free_irq_no_index = j;
+				goto vpif_init_free_irq;
+			}
+		}
+	}
+	free_irq_no_index = VPIF_CAPTURE_NUM_CHANNELS;
+
+	/* Set the pinmux settings */
+	set_vpif_pinmux();
+
+	return 0;
+
+vpif_init_free_irq:
+	for (j = 0; j < free_irq_no_index; j++) {
+		free_irq(vpif_get_irq_number(j),
+			 (void *)(&(vpif_obj.dev[j]->channel_id)));
+	}
+vpif_init_unregister_vpif_device:
+	platform_device_unregister(&_vpif_device);
+
+vpif_init_unregister_vpif_driver:
+	driver_unregister(&vpif_driver);
+
+vpif_init_free_buffers:
+	for (i = 0; i < free_buffer_channel_index; i++) {
+		for (j = 0; j < config_params.numbuffers[i]; j++) {
+			addr = vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+			    fbuffers[j];
+			if (addr) {
+				vpif_free_buffer((unsigned long)addr,
+						 config_params.
+						 channel_bufsize[i]
+				    );
+				vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+				    fbuffers[j] = NULL;
+			}
+		}
+	}
+	for (j = 0; j < free_buffer_index; j++) {
+		addr =
+		    vpif_obj.dev[free_buffer_channel_index]->
+		    common[VPIF_VIDEO_INDEX].fbuffers[j];
+		if (addr) {
+			vpif_free_buffer((unsigned long)addr,
+					 config_params.channel_bufsize[i]);
+			vpif_obj.dev[free_buffer_channel_index]->
+			    common[VPIF_VIDEO_INDEX].fbuffers[j]
+			    = NULL;
+		}
+	}
+
+vpif_init_free_channel_objects:
+	for (j = 0; j < free_channel_objects_index; j++) {
+		if (vpif_obj.dev[i]) {
+			kfree(vpif_obj.dev[j]);
+			vpif_obj.dev[i] = NULL;
+		}
+	}
+	return err;
+}
+
+/* vpif_cleanup : This function un-registers device and driver
+ * to the kernel, frees requested irq handler and de-allocates memory
+ * allocated for channel objects.
+ */
+static void vpif_cleanup(void)
+{
+	int i = 0, j = 0;
+	u32 addr;
+
+	for (i = 0; i < VPIF_CAPTURE_NUM_CHANNELS; i++) {
+		free_irq(vpif_get_irq_number(i),
+			 (void *)(&(vpif_obj.dev[i]->channel_id)));
+	}
+	/* Flush and destroy the workqueue */
+	flush_workqueue(vbi_workqueue);
+	destroy_workqueue(vbi_workqueue);
+
+	platform_device_unregister(&_vpif_device);
+	driver_unregister(&vpif_driver);
+	for (i = 0; i < VPIF_CAPTURE_NUM_CHANNELS; i++) {
+		for (j = 0; j < config_params.numbuffers[i]; j++) {
+			addr = (u32) vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+			    fbuffers[j];
+			if (addr) {
+				vpif_free_buffer(addr,
+						 config_params.
+						 channel_bufsize[i]);
+				vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+				    fbuffers[j] = NULL;
+			}
+		}
+	}
+	for (i = 0; i < VPIF_CAPTURE_MAX_DEVICES; i++) {
+		if (vpif_obj.dev[i]) {
+			kfree(vpif_obj.dev[i]);
+			vpif_obj.dev[i] = NULL;
+		}
+	}
+}
+
+/* vpif_enum_std : Function to enumerate all the standards in
+ * all the registered decoders
+ */
+static int vpif_enum_std(struct channel_obj *channel)
+{
+	int i, j, index;
+	struct video_obj *vid_ch = NULL;
+	struct v4l2_standard standard;
+	struct decoder_device *dec;
+	v4l2_std_id all_std = 0;
+	int ret = 0;
+	vid_ch = &(channel->video);
+	vid_ch->count_std = 0;
+
+	/* For all the registered encoders */
+	for (i = 0; i < channel->numdecoders; i++) {
+		dec = channel->decoder[i];
+		/* Do the enumstd */
+		for (j = 0; j < dec->std_ops->count; j++) {
+			standard.index = j;
+			ret = dec->std_ops->enumstd(&standard, dec);
+			if (ret)
+				return ret;
+
+			/* If the standard is already added,
+			 * do not add it to the table */
+			if (all_std & standard.id)
+				continue;
+			/* Store the standard information in the table */
+			index = vid_ch->count_std;
+			vid_ch->std_tbl[index].dec_idx = i;
+			vid_ch->std_tbl[index].std_idx = j;
+			vid_ch->std_tbl[index].std = standard.id;
+			vid_ch->count_std++;
+			all_std |= standard.id;
+		}
+	}
+	return 0;
+}
+
+/* vpif_register_decoder : This function will be called by the decoder
+ * driver to register its functionalities to vpif driver
+ */
+int vpif_register_decoder(struct decoder_device
+			  *decoder)
+{
+	struct channel_obj *channel = vpif_obj.dev[decoder->channel_id];
+	int err = -EINVAL;
+
+	dev_dbg(vpif_dev, "<vpif_register_decoder>\n");
+	if (ISNULL(channel)) {
+		return err;
+	}
+	if (channel->numdecoders < VPIF_CAPTURE_NUM_DECODERS) {
+		channel->decoder[channel->numdecoders++] = decoder;
+		err = vpif_enum_std(channel);
+		return err;
+	}
+	dev_dbg(vpif_dev, "</vpif_register_decoder>\n");
+	return err;
+}
+
+/* vpif_unregister_decoder : This function will be called by the decoder
+ * driver to un-register its functionalities to vpif driver
+ */
+int vpif_unregister_decoder(struct decoder_device
+			    *decoder)
+{
+	int i, j = 0, err = 0;
+	struct channel_obj *channel = vpif_obj.dev[decoder->channel_id];
+	dev_dbg(vpif_dev, "<vpif_unregister_decoder>\n");
+
+	for (i = 0; i < channel->numdecoders; i++) {
+		if (decoder == channel->decoder[i]) {
+			if (channel->decoder[channel->current_decoder] ==
+			    decoder && channel->initialized)
+				return -EBUSY;
+			channel->decoder[i] = NULL;
+			for (j = i; j < channel->numdecoders - 1; j++)
+				channel->decoder[j] = channel->decoder[j + 1];
+			channel->numdecoders--;
+			err = vpif_enum_std(channel);
+			break;
+		}
+	}
+	dev_dbg(vpif_dev, "</vpif_unregister_decoder>\n");
+	return err;
+}
+
+EXPORT_SYMBOL(vpif_register_decoder);
+EXPORT_SYMBOL(vpif_unregister_decoder);
+MODULE_LICENSE("GPL");
+/* Function for module initialization and cleanup */
+module_init(vpif_init);
+module_exit(vpif_cleanup);
Index: linux-2.6.18/drivers/media/video/davinci/davincihd_display.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/davincihd_display.c
@@ -0,0 +1,2545 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* davincihd_display.c */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/platform_device.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+
+#include <media/davinci/davincihd_display.h>
+#include <media/davinci/vpif.h>
+#include <asm/arch/video_hdevm.h>
+#include <asm/arch/i2c-client.h>
+#include <media/davinci/davinci_enc.h>
+
+static u32 channel2_numbuffers = 3;
+static u32 channel3_numbuffers = 3;
+static u32 channel2_bufsize = 1920 * 1080 * 2;
+static u32 channel3_bufsize = 720 * 576 * 2;
+
+module_param(channel2_numbuffers, uint, S_IRUGO);
+module_param(channel3_numbuffers, uint, S_IRUGO);
+module_param(channel2_bufsize, uint, S_IRUGO);
+module_param(channel3_bufsize, uint, S_IRUGO);
+
+static struct vpif_config_params config_params = {
+	.min_numbuffers = 3,
+	.numbuffers[0] = 3,
+	.numbuffers[1] = 3,
+	.min_bufsize[0] = 720 * 480 * 2,
+	.min_bufsize[1] = 720 * 480 * 2,
+	.channel_bufsize[0] = 1920 * 1080 * 2,
+	.channel_bufsize[1] = 720 * 576 * 2,
+};
+
+static int vpif_nr[] = { 2, 3, };
+
+/* global variables */
+static struct vpif_device vpif_obj = { {NULL} };
+static struct workqueue_struct *vbi_workqueue;
+static struct work_struct vbi_work[VPIF_DISPLAY_NUM_CHANNELS];
+
+static struct device *vpif_dev = NULL;
+
+static struct v4l2_capability vpif_videocap = {
+	.driver = "vpif display",
+	.card = "DaVinciHD EVM",
+	.bus_info = "Platform",
+	.version = VPIF_DISPLAY_VERSION_CODE,
+	.capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING |
+	    V4L2_CAP_VBI_OUTPUT | V4L2_CAP_HBI_OUTPUT |
+	    V4L2_CAP_SLICED_VBI_OUTPUT
+};
+
+static struct v4l2_vbi_format vpif_raw_vbi_formats[2] = {
+	{
+	 .sampling_rate = 29.97,
+	 .samples_per_line = VPIF_NTSC_VBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_NTSC_VBI_START_FIELD0,
+		   VPIF_NTSC_VBI_START_FIELD1},
+	 .count = {VPIF_NTSC_VBI_COUNT_FIELD0,
+		   VPIF_NTSC_VBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED},
+	{
+	 .sampling_rate = 25,
+	 .samples_per_line = VPIF_PAL_VBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_PAL_VBI_START_FIELD0,
+		   VPIF_PAL_VBI_START_FIELD1},
+	 .count = {VPIF_PAL_VBI_COUNT_FIELD0,
+		   VPIF_PAL_VBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED}
+};
+static struct v4l2_vbi_format vpif_raw_hbi_formats[2] = {
+	{
+	 .sampling_rate = 29.97,
+	 .samples_per_line = VPIF_NTSC_HBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_NTSC_HBI_START_FIELD0,
+		   VPIF_NTSC_HBI_START_FIELD1},
+	 .count = {VPIF_NTSC_HBI_COUNT_FIELD0,
+		   VPIF_NTSC_HBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED},
+	{
+	 .sampling_rate = 25,
+	 .samples_per_line = VPIF_PAL_HBI_SAMPLES_PER_LINE,
+	 .sample_format = V4L2_PIX_FMT_GREY,
+	 .start = {VPIF_PAL_HBI_START_FIELD0,
+		   VPIF_PAL_HBI_START_FIELD1},
+	 .count = {VPIF_PAL_HBI_COUNT_FIELD0,
+		   VPIF_PAL_HBI_COUNT_FIELD1},
+	 .flags = V4L2_VBI_INTERLACED}
+};
+
+static struct vpif_service_line vbi_service_lines[] = {
+	{V4L2_SLICED_CGMS_525, {20, 283}, VID_ENC_SLICED_VBI_CGMS_NTSC, 3},
+	{V4L2_SLICED_CAPTION_525, {21, 284}, VID_ENC_SLICED_VBI_CC_NTSC,
+	 2},
+	{V4L2_SLICED_WSS_625, {23, 0}, VID_ENC_SLICED_VBI_WSS_PAL, 2},
+};
+
+static void vbi_work_handler(unsigned long data1)
+{
+	int i, j;
+	struct channel_obj *channel = (struct channel_obj *)data1;
+	struct common_obj *common = &(channel->common[VPIF_VBI_INDEX]);
+	struct v4l2_sliced_vbi_data *addr = (struct v4l2_sliced_vbi_data *)
+	    common->curFrm->boff;
+	struct vid_enc_sliced_vbi_data data[2];
+	addr = (struct v4l2_sliced_vbi_data *)
+	    phys_to_virt((unsigned long)addr);
+	down(&common->lock);
+	if (channel->field_id == 1)
+		addr += channel->vbi.num_services;
+	for (i = 0; i < channel->vbi.num_services; i++) {
+		data[i].service_id = 0;
+		data[i].field = 0;
+		for (j = 0; j < 3; j++) {
+			if ((addr + i)->id & vbi_service_lines[j].service_id) {
+				data[i].service_id =
+				    vbi_service_lines[j].enc_service_id;
+				data[i].field = addr->field;
+				memcpy(data[i].data, (addr + i)->data,
+				       vbi_service_lines[j].bytestowrite);
+			}
+		}
+	}
+	davinci_enc_write_sliced_vbi_data(channel->channel_id, data);
+	up(&common->lock);
+}
+
+/*
+ * vpif_alloc_buffer: Allocate memory for buffers */
+static inline unsigned long vpif_alloc_buffer(unsigned int buf_size)
+{
+	void *mem = 0;
+	u32 size = PAGE_SIZE << (get_order(buf_size));
+
+	mem = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				       get_order(buf_size));
+	if (mem) {
+		unsigned long adr = (unsigned long)mem;
+		while (size > 0) {
+			SetPageReserved(virt_to_page(adr));
+			adr += PAGE_SIZE;
+			size -= PAGE_SIZE;
+		}
+	}
+	return (unsigned long)mem;
+}
+
+/*
+ *vpif_free_buffer : Free memory for buffers */
+static inline void vpif_free_buffer(unsigned long addr, unsigned int buf_size)
+{
+	unsigned int size, adr;
+
+	if (!addr)
+		return;
+	adr = addr;
+	size = PAGE_SIZE << (get_order(buf_size));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(addr, get_order(buf_size));
+}
+
+/*
+ * vpif_uservirt_to_phys: This inline function is used to convert user
+ * space virtual address to physical address.
+ */
+static inline u32 vpif_uservirt_to_phys(u32 virtp)
+{
+	unsigned long physp = 0;
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+
+	/* For kernel direct-mapped memory, take the easy way */
+	if (virtp >= PAGE_OFFSET) {
+		physp = virt_to_phys((void *)virtp);
+	} else if ((vma = find_vma(mm, virtp)) && (vma->vm_flags & VM_IO)
+		   && (vma->vm_pgoff)) {
+		/* this will catch, kernel-allocated,
+		   mmaped-to-usermode addresses */
+		physp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);
+	} else {
+		/* otherwise, use get_user_pages() for general userland pages */
+		int res, nr_pages = 1;
+		struct page *pages;
+		down_read(&current->mm->mmap_sem);
+
+		res = get_user_pages(current, current->mm,
+				     virtp, nr_pages, 1, 0, &pages, NULL);
+		up_read(&current->mm->mmap_sem);
+
+		if (res == nr_pages) {
+			physp = __pa(page_address(&pages[0]) +
+				     (virtp & ~PAGE_MASK));
+		} else {
+			dev_err(vpif_dev, "get_user_pages failed\n");
+			return 0;
+		}
+	}
+
+	return physp;
+}
+
+/*
+ * buffer_prepare: This is the callback function called from videobuf_qbuf()
+ * function the buffer is prepared and user space virtual address is converted
+* into physical address */
+static int vpif_buffer_prepare(struct videobuf_queue *q,
+			       struct videobuf_buffer *vb,
+			       enum v4l2_field field)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	unsigned long addr;
+	int i, j, prevline = 0, num_services;
+	struct v4l2_sliced_vbi_data *vbidata;
+	struct common_obj *common = NULL;
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_OUTPUT) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	dev_dbg(vpif_dev, "<vpif_buffer_prepare>\n");
+
+	/* If buffer is not initialized, initialize it */
+	if (STATE_NEEDS_INIT == vb->state) {
+		vb->width = common->width;
+		vb->height = common->height;
+		vb->size = vb->width * vb->height;
+		vb->field = field;
+	}
+	vb->state = STATE_PREPARED;
+	/* if user pointer memory mechanism is used, get the physical
+	 * address of the buffer
+	 */
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		if (0 == vb->baddr) {
+			dev_err(vpif_dev, "buffer_address is 0\n");
+			return -EINVAL;
+		}
+		vb->boff = vpif_uservirt_to_phys(vb->baddr);
+		if (!ISALIGNED(vb->boff)) {
+			dev_err(vpif_dev, "buffer_prepare:offset is \
+					not aligned to 8 bytes\n");
+			return -EINVAL;
+		}
+	}
+	addr = vb->boff;
+	if (q->streaming && (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT != q->type)) {
+		if (!ISALIGNED((addr + common->ytop_off)) ||
+		    !ISALIGNED((addr + common->ybtm_off)) ||
+		    !ISALIGNED((addr + common->ctop_off)) ||
+		    !ISALIGNED((addr + common->cbtm_off))) {
+			dev_err(vpif_dev, "buffer_prepare:offset is \
+					not aligned to 8 bytes\n");
+			return -EINVAL;
+		}
+	}
+	if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT == q->type) {
+		num_services = channel->vbi.num_services;
+		vbidata = (struct v4l2_sliced_vbi_data *)phys_to_virt(vb->boff);
+		prevline = 0;
+		for (i = 0; i < num_services * 2; i++) {
+			if (0 == vbidata->id)
+				continue;
+			if (!(vbidata->id & common->fmt.fmt.sliced.service_set)) {
+				dev_err(vpif_dev, "Invalid service\n");
+				return -EINVAL;
+			}
+			if (vbidata->field != 0 && vbidata->field != 1) {
+				dev_err(vpif_dev, "Invalid field\n");
+				return -EINVAL;
+			}
+			for (j = 0; j < VPIF_SLICED_MAX_SERVICES; j++) {
+				if (!(vbidata->id &
+				      vbi_service_lines[j].service_id))
+					continue;
+				if ((vbidata->field == 0)
+				    && (vbidata->line !=
+					vbi_service_lines[j].service_line[0])) {
+					dev_err(vpif_dev,
+						"Invalid field0line\n");
+					return -EINVAL;
+				}
+				if ((vbidata->field == 1)
+				    && (vbidata->line !=
+					vbi_service_lines[j].service_line[1])) {
+					dev_err(vpif_dev,
+						"Invalid field0line\n");
+					return -EINVAL;
+				}
+			}
+			if (prevline > vbidata->line) {
+				dev_err(vpif_dev,
+					"Lines are not in increasing order\n");
+				return -EINVAL;
+			}
+			prevline = vbidata->line;
+			vbidata++;
+		}
+	}
+	dev_dbg(vpif_dev, "</vpif_buffer_prepare>\n");
+	return 0;
+}
+
+/*
+ * vpif_buffer_config: This function is responsible to responsible for
+ * buffer's physical address */
+static void vpif_buffer_config(struct videobuf_queue *q, unsigned int count)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	int i;
+	dev_dbg(vpif_dev, "<vpif_buffer_config>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_OUTPUT) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != common->memory) {
+		dev_dbg(vpif_dev, "End of buffer config\n");
+		return;
+	}
+	/* Convert kernel space virtual address to physical address */
+	for (i = 0; i < count; i++) {
+		q->bufs[i]->boff = virt_to_phys((void *)common->fbuffers[i]);
+		dev_dbg(vpif_dev, "buffer address: %x\n", q->bufs[i]->boff);
+	}
+	dev_dbg(vpif_dev, "</vpif_buffer_config>\n");
+}
+
+/*
+ * vpif_buffer_setup: This function allocates memory for the buffers */
+static int vpif_buffer_setup(struct videobuf_queue *q, unsigned int *count,
+			     unsigned int *size)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	int i;
+	int startindex = 0;
+	dev_dbg(vpif_dev, "<vpif_buffer_setup>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_OUTPUT) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != common->memory) {
+		dev_dbg(vpif_dev, "End of buffer setup\n");
+		return 0;
+	}
+
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT == q->type) {
+		/* Calculate the size of the buffer */
+		*size = config_params.channel_bufsize[channel->channel_id];
+		startindex = config_params.numbuffers[channel->channel_id];
+	} else if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT == q->type) {
+		/* Get the size of the buffer */
+		*size = VPIF_SLICED_BUF_SIZE;
+	} else {
+		/* Calculate the size of the buffer */
+		*size = ((common->fmt.fmt.vbi.count[0]) +
+			 (common->fmt.fmt.vbi.count[1])) *
+		    (common->fmt.fmt.vbi.samples_per_line);
+	}
+
+	for (i = startindex; i < *count; i++) {
+		/* Allocate memory for the buffers */
+		common->fbuffers[i] = (u8 *) vpif_alloc_buffer(*size);
+		if (!common->fbuffers[i])
+			break;
+	}
+	/* Store number of buffers allocated in numbuffer member */
+	*count = common->numbuffers = i;
+	dev_dbg(vpif_dev, "</vpif_buffer_setup>\n");
+	return 0;
+}
+
+/*
+ * vpif_buffer_queue: This function adds the buffer to DMA queue  */
+static void vpif_buffer_queue(struct videobuf_queue *q,
+			      struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	dev_dbg(vpif_dev, "<vpif_buffer_queue>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_OUTPUT) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	/* add the buffer to the DMA queue */
+	list_add_tail(&vb->queue, &common->dma_queue);
+	/* Change state of the buffer */
+	vb->state = STATE_QUEUED;
+	dev_dbg(vpif_dev, "</vpif_buffer_queue>\n");
+}
+
+/*
+ * vpif_buffer_release: This function is called from the videobuf layer to
+ * free memory allocated to the buffers */
+static void vpif_buffer_release(struct videobuf_queue *q,
+				struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and channel object */
+	struct vpif_fh *fh = q->priv_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = NULL;
+	unsigned int buf_size = 0;
+	int endindex = 0;
+	dev_dbg(vpif_dev, "<vpif_buffer_release>\n");
+	common = (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) ?
+	    &(channel->common[VPIF_VIDEO_INDEX]) :
+	    ((q->type == V4L2_BUF_TYPE_HBI_OUTPUT) ?
+	     &(channel->common[VPIF_HBI_INDEX]) :
+	     &(channel->common[VPIF_VBI_INDEX]));
+
+	vb->state = STATE_NEEDS_INIT;
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != common->memory) {
+		dev_dbg(vpif_dev, "End of buffer release\n");
+		return;
+	}
+	if (V4L2_BUF_TYPE_VIDEO_OUTPUT == q->type) {
+		/* Calculate the size of the buffer */
+		buf_size = config_params.channel_bufsize[channel->channel_id];
+		endindex = config_params.numbuffers[channel->channel_id];
+
+	} else if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT == q->type) {
+		/* Get the size of the buffer */
+		buf_size = VPIF_SLICED_BUF_SIZE;
+	} else {
+		/* Calculate the size of the buffer */
+		buf_size = ((common->fmt.fmt.vbi.count[0]) +
+			    (common->fmt.fmt.vbi.count[1])) *
+		    (common->fmt.fmt.vbi.samples_per_line);
+	}
+
+	dev_dbg(vpif_dev, "</vpif_buffer_release>\n");
+}
+
+static struct videobuf_queue_ops video_qops = {
+	.buf_setup = vpif_buffer_setup,
+	.buf_prepare = vpif_buffer_prepare,
+	.buf_queue = vpif_buffer_queue,
+	.buf_release = vpif_buffer_release,
+	.buf_config = vpif_buffer_config,
+};
+
+static u8 channel_first_int[VPIF_NUMOBJECTS][2] = { {1, 1}, {1, 1}, {1, 1} };
+
+/* vpif_channel_isr: It changes status of the displayed buffer, takes next
+ * buffer from the queue and sets its address in VPIF registers */
+static irqreturn_t vpif_channel_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct timeval timevalue;
+	int fid = -1, i;
+	struct vpif_device *dev = &vpif_obj;
+	int channel_id = 0;
+	unsigned long addr = 0;
+	struct channel_obj *channel = NULL;
+	struct common_obj *common = NULL;
+	struct video_obj *vid_ch = NULL;
+	enum v4l2_field field;
+	dev_dbg(vpif_dev, "<vpif_channel_isr>\n");
+
+	channel_id = *(int *)(dev_id);
+	channel = dev->dev[channel_id];
+	vid_ch = &(channel->video);
+
+	do_gettimeofday(&timevalue);
+	field = channel->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.field;
+	for (i = 0; i < VPIF_NUMOBJECTS; i++) {
+		common = &(channel->common[i]);
+		/* If streaming is started in this channel */
+		if (0 == common->started)
+			continue;
+
+		/* Check the field format */
+		if (1 == vid_ch->std_info.frame_format) {
+			if (list_empty(&common->dma_queue))
+				continue;
+			/* Progressive mode */
+			if (!channel_first_int[i][channel_id]) {
+				/* Mark status of the curFrm to
+				 * done and unlock semaphore on it */
+				common->curFrm->ts = timevalue;
+				common->curFrm->state = STATE_DONE;
+				wake_up_interruptible(&common->curFrm->done);
+				/* Make curFrm pointing to nextFrm */
+				common->curFrm = common->nextFrm;
+			}
+			channel_first_int[i][channel_id] = 0;
+
+			/* Get the next buffer from buffer queue */
+			common->nextFrm =
+			    list_entry(common->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove that buffer from the buffer queue */
+			list_del(&common->nextFrm->queue);
+			/* Mark status of the buffer as active */
+			common->nextFrm->state = STATE_ACTIVE;
+			/* Set top and bottom field addresses in
+			   VPIF registers */
+
+			addr = common->nextFrm->boff;
+
+			if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT == common->fmt.type) {
+				queue_work(vbi_workqueue,
+					   &vbi_work[channel->channel_id]);
+			} else {
+				common->set_addr(addr + common->ytop_off,
+						 addr + common->ybtm_off,
+						 addr + common->ctop_off,
+						 addr + common->cbtm_off);
+			}
+		} else {
+			/* Interlaced mode */
+			/* If it is first interrupt, ignore it */
+			if (channel_first_int[i][channel_id]) {
+				channel_first_int[i][channel_id] = 0;
+				continue;
+			}
+			if (0 == i) {
+				channel->field_id ^= 1;
+				/* Get field id from VPIF registers */
+				fid =
+				    vpif_channel_getfid(channel->
+							channel_id + 2);
+				/* If field id does not match with stored
+				   field id */
+				if (fid != channel->field_id) {
+					/* Make them in sync */
+					if (0 == fid) {
+						channel->field_id = fid;
+					}
+					return IRQ_HANDLED;
+				}
+			}
+			/* device field id and local field id are
+			   in sync */
+			/* If this is even field */
+			if (0 == fid) {
+				if (common->curFrm == common->nextFrm) {
+					continue;
+				}
+				/* one frame is displayed If next frame is
+				 *  available, release curFrm and move on*/
+
+				/* Copy frame display time */
+				common->curFrm->ts = timevalue;
+				/* Change status of the curFrm */
+				common->curFrm->state = STATE_DONE;
+				/* unlock semaphore on curFrm */
+				wake_up_interruptible(&common->curFrm->done);
+				/* Make curFrm pointing to
+				   nextFrm */
+				common->curFrm = common->nextFrm;
+				if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT
+				    == common->fmt.type) {
+					queue_work(vbi_workqueue,
+						   &vbi_work[channel->
+							     channel_id]);
+				}
+			} else if (1 == fid) {	/* odd field */
+				if (list_empty(&common->dma_queue)
+				    || (common->curFrm != common->nextFrm)) {
+					continue;
+				}
+
+				/* one field is displayed configure
+				   the next frame if it is available
+				   otherwise hold on current frame
+				 */
+				/* Get next from the buffer
+				   queue */
+				common->nextFrm = list_entry(common->
+							     dma_queue.
+							     next, struct
+							     videobuf_buffer,
+							     queue);
+
+				/* Remove that from the
+				   buffer queue */
+				list_del(&common->nextFrm->queue);
+
+				/* Mark state of the frame
+				   to active */
+				common->nextFrm->state = STATE_ACTIVE;
+				addr = common->nextFrm->boff;
+
+				if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT
+				    == common->fmt.type) {
+					queue_work(vbi_workqueue,
+						   &vbi_work[channel->
+							     channel_id]);
+				} else {
+					common->set_addr(addr +
+							 common->ytop_off,
+							 addr +
+							 common->ybtm_off,
+							 addr +
+							 common->ctop_off,
+							 addr +
+							 common->cbtm_off);
+				}
+
+			}
+		}
+	}
+	dev_dbg(vpif_dev, "</vpif_channel_isr>\n");
+	return IRQ_HANDLED;
+}
+
+static void vpif_get_std_info(struct channel_obj *ch)
+{
+	struct video_obj *vid_ch = &(ch->video);
+	struct common_obj *common = &(ch->common[VPIF_VIDEO_INDEX]);
+	int ret;
+
+	vid_ch->std_info.channel_id = ch->channel_id + 2;
+
+	/* Get standard name from the encoder by enumerating standards */
+	strncpy(vid_ch->std_info.name, vid_ch->mode_info.name,
+		sizeof(vid_ch->std_info.name));
+
+	/* Get standard information from VPIF layer */
+	ret = vpif_get_mode_info(&vid_ch->std_info);
+	common->fmt.fmt.pix.width = vid_ch->std_info.activepixels;
+	common->fmt.fmt.pix.height = vid_ch->std_info.activelines;
+
+	/* Set height and width paramateres */
+	ch->common[VPIF_VIDEO_INDEX].height = vid_ch->std_info.activelines;
+	ch->common[VPIF_VIDEO_INDEX].width = vid_ch->std_info.activepixels;
+}
+
+/*
+ * vpif_calculate_offsets: This function calculates buffers offset for Y and C
+ * in the top and bottom field */
+static void vpif_calculate_offsets(struct channel_obj *channel)
+{
+	unsigned int hpitch, vpitch, sizeimage;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	struct video_obj *vid_ch = &(channel->video);
+	struct vpif_params *vpifparams = &channel->vpifparams;
+	enum v4l2_field field = common->fmt.fmt.pix.field;
+
+	dev_dbg(vpif_dev, "<vpif_calculate_offsets>\n");
+
+	if (V4L2_FIELD_ANY == common->fmt.fmt.pix.field) {
+		if (vid_ch->std_info.frame_format)
+			vid_ch->buf_field = V4L2_FIELD_NONE;
+		else
+			vid_ch->buf_field = V4L2_FIELD_INTERLACED;
+	} else {
+		vid_ch->buf_field = common->fmt.fmt.pix.field;
+	}
+
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		sizeimage = common->fmt.fmt.pix.sizeimage;
+	} else {
+		sizeimage = config_params.channel_bufsize[channel->channel_id];
+	}
+
+	hpitch = common->fmt.fmt.pix.bytesperline;
+	vpitch = sizeimage / (hpitch * 2);
+
+	if ((V4L2_FIELD_NONE == vid_ch->buf_field) ||
+	    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {
+		/* Calculate offsets for Y top, Y Bottom, C top and C Bottom */
+		common->ytop_off = 0;
+		common->ybtm_off = hpitch;
+		common->ctop_off = sizeimage / 2;
+		common->cbtm_off = sizeimage / 2 + hpitch;
+	} else if (V4L2_FIELD_SEQ_TB == vid_ch->buf_field) {
+		/* Calculate offsets for Y top, Y Bottom, C top and C Bottom */
+		common->ytop_off = 0;
+		common->ybtm_off = sizeimage / 4;
+		common->ctop_off = sizeimage / 2;
+		common->cbtm_off = common->ctop_off + sizeimage / 4;
+	} else if (V4L2_FIELD_SEQ_BT == vid_ch->buf_field) {
+		/* Calculate offsets for Y top, Y Bottom, C top and C Bottom */
+		common->ybtm_off = 0;
+		common->ytop_off = sizeimage / 4;
+		common->cbtm_off = sizeimage / 2;
+		common->ctop_off = common->cbtm_off + sizeimage / 4;
+	}
+	if ((V4L2_FIELD_NONE == vid_ch->buf_field) ||
+	    (V4L2_FIELD_INTERLACED == vid_ch->buf_field)) {
+		vpifparams->video_params.storage_mode = 1;
+	} else {
+		vpifparams->video_params.storage_mode = 0;
+	}
+
+	if (vid_ch->std_info.frame_format == 1) {
+		vpifparams->video_params.hpitch =
+		    common->fmt.fmt.pix.bytesperline;
+	} else {
+		if ((field == V4L2_FIELD_ANY)
+		    || (field == V4L2_FIELD_INTERLACED))
+			vpifparams->video_params.hpitch =
+			    common->fmt.fmt.pix.bytesperline * 2;
+		else
+			vpifparams->video_params.hpitch =
+			    common->fmt.fmt.pix.bytesperline;
+	}
+	strncpy(channel->vpifparams.video_params.name,
+		vid_ch->std_info.name,
+		sizeof(channel->vpifparams.video_params.name));
+	dev_dbg(vpif_dev, "</vpif_calculate_offsets>\n");
+}
+
+static void vpif_calculate_offsets_vbi(struct channel_obj *channel, u8 index)
+{
+	struct common_obj *common = &(channel->common[index]);
+	dev_dbg(vpif_dev, "<vpif_calculate_offsets_vbi>\n");
+
+	common->ytop_off = 0;
+	common->ctop_off = 0;
+	common->ybtm_off = (common->fmt.fmt.vbi.count[0]) *
+	    (common->fmt.fmt.vbi.samples_per_line);
+	common->cbtm_off = 0;
+
+	dev_dbg(vpif_dev, "</vpif_calculate_offsets_vbi>\n");
+}
+static void vpif_config_format(struct channel_obj *channel)
+{
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	common->fmt.fmt.pix.field = V4L2_FIELD_ANY;
+
+	if (config_params.numbuffers[channel->channel_id] == 0)
+		common->memory = V4L2_MEMORY_USERPTR;
+	else
+		common->memory = V4L2_MEMORY_MMAP;
+
+	common->fmt.fmt.pix.sizeimage
+	    = config_params.channel_bufsize[channel->channel_id];
+
+	common->fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUV422UVP;
+	common->fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	channel->common[VPIF_VBI_INDEX].fmt.type =
+	    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT;
+	channel->common[VPIF_VBI_INDEX].fmt.fmt.sliced.service_set = 0;
+	channel->common[VPIF_VBI_INDEX].memory = V4L2_MEMORY_MMAP;
+
+	channel->common[VPIF_HBI_INDEX].fmt.type = V4L2_BUF_TYPE_HBI_OUTPUT;
+	channel->common[VPIF_HBI_INDEX].memory = V4L2_MEMORY_MMAP;
+}
+
+static int vpif_check_format(struct channel_obj *channel,
+			     struct v4l2_pix_format *pixfmt)
+{
+	u32 sizeimage, hpitch, vpitch;
+	enum v4l2_field field = pixfmt->field;
+	struct video_obj *vid_ch = &(channel->video);
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	dev_dbg(vpif_dev, "<vpif_check_format>\n");
+
+	if (pixfmt->pixelformat != V4L2_PIX_FMT_YUV422UVP) {
+		dev_err(vpif_dev, "invalid frame format\n");
+		return -EINVAL;
+	}
+	if (!(VPIF_VALID_FIELD(field))) {
+		dev_err(vpif_dev, "invalid field format\n");
+		return -EINVAL;
+	}
+	if (pixfmt->bytesperline <= 0) {
+		dev_err(vpif_dev, "invalid pitch\n");
+		return -EINVAL;
+	}
+
+	if (V4L2_MEMORY_USERPTR == common->memory) {
+		sizeimage = pixfmt->sizeimage;
+	} else {
+		sizeimage = config_params.channel_bufsize[channel->channel_id];
+	}
+
+	davinci_enc_get_mode(channel->channel_id, &channel->video.mode_info);
+	vpif_get_std_info(channel);
+
+	hpitch = pixfmt->bytesperline;
+	vpitch = sizeimage / (hpitch * 2);
+
+	/* Check for valid value of pitch */
+	if ((hpitch < vid_ch->std_info.activepixels) ||
+	    (vpitch < vid_ch->std_info.activelines)) {
+		dev_err(vpif_dev, "Invalid pitch\n");
+		return -EINVAL;
+	}
+	/* Check for 8 byte alignment */
+	if (!(ISALIGNED(hpitch))) {
+		dev_err(vpif_dev, "invalid pitch alignment\n");
+		return -EINVAL;
+	}
+	pixfmt->width = common->fmt.fmt.pix.width;
+	pixfmt->height = common->fmt.fmt.pix.height;
+
+	dev_dbg(vpif_dev, "</vpif_check_format>\n");
+	return 0;
+}
+
+static void vpif_config_addr(struct channel_obj *channel, int muxmode)
+{
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	dev_dbg(vpif_dev, "<vpif_config_addr>");
+	if (VPIF_CHANNEL3_VIDEO == channel->channel_id) {
+		common->set_addr = ch3_set_videobuf_addr;
+	} else {
+		if (2 == muxmode) {
+			common->set_addr = ch2_set_videobuf_addr_yc_nmux;
+		} else {
+			common->set_addr = ch2_set_videobuf_addr;
+		}
+	}
+	dev_dbg(vpif_dev, "</vpif_config_addr>");
+}
+
+static void vpif_config_addr_vbi(struct channel_obj *channel,
+				 int channel_id, u8 index)
+{
+	struct common_obj *common = &(channel->common[index]);
+	dev_dbg(vpif_dev, "<vpif_config_addr_vbi>");
+	if (VPIF_CHANNEL3_VIDEO == channel_id) {
+		common->set_addr = ch3_set_vbi_addr;
+	} else {
+		common->set_addr = ch2_set_vbi_addr;
+	}
+	dev_dbg(vpif_dev, "</vpif_config_addr_vbi>");
+}
+
+static int vpif_try_raw_format(struct channel_obj *channel,
+			       struct v4l2_vbi_format *fmt, u8 index)
+{
+	struct video_obj *vid_ch = &(channel->video);
+	struct v4l2_vbi_format *raw_vbi;
+	if (0 == strcmp(vid_ch->mode_info.name, "NTSC")) {
+		raw_vbi = (1 == index) ? &(vpif_raw_vbi_formats[0]) :
+		    &(vpif_raw_hbi_formats[0]);
+	} else {
+		raw_vbi = (1 == index) ? &(vpif_raw_vbi_formats[1]) :
+		    &(vpif_raw_hbi_formats[1]);
+	}
+
+	if ((fmt->sampling_rate != raw_vbi->sampling_rate) ||
+	    (fmt->samples_per_line != raw_vbi->samples_per_line) ||
+	    (fmt->start[0] != raw_vbi->start[0]) ||
+	    (fmt->count[0] != raw_vbi->count[0]) ||
+	    (fmt->start[1] != raw_vbi->start[1]) ||
+	    (fmt->count[1] != raw_vbi->count[1]) ||
+	    (fmt->flags != raw_vbi->flags)) {
+		dev_err(vpif_dev, "invalid parameters\n");
+		*fmt = *raw_vbi;
+		return -EINVAL;
+	}
+	return 0;
+}
+int vpif_try_sliced_vbi(struct v4l2_format *fmt,
+			struct vid_enc_sliced_vbi_service *service)
+{
+	u16 serv = 0;
+	if (service->service_set & VID_ENC_SLICED_VBI_CGMS_NTSC)
+		serv |= V4L2_SLICED_CGMS_525;
+	if (service->service_set & VID_ENC_SLICED_VBI_CC_NTSC)
+		serv |= V4L2_SLICED_CAPTION_525;
+	if (service->service_set & VID_ENC_SLICED_VBI_WSS_PAL)
+		serv |= V4L2_SLICED_WSS_625;
+	if (fmt->fmt.sliced.service_set & (~serv)) {
+		fmt->fmt.sliced.service_set = serv;
+		return -EINVAL;
+	}
+	return 0;
+}
+int vpif_convert_vbi_services(struct v4l2_format *fmt,
+			      struct vid_enc_sliced_vbi_service *service)
+{
+	service->service_set = 0;
+	if (fmt->fmt.sliced.service_set & V4L2_SLICED_CGMS_525)
+		service->service_set |= VID_ENC_SLICED_VBI_CGMS_NTSC;
+	if (fmt->fmt.sliced.service_set & V4L2_SLICED_CAPTION_525)
+		service->service_set |= VID_ENC_SLICED_VBI_CC_NTSC;
+	if (fmt->fmt.sliced.service_set & V4L2_SLICED_WSS_625)
+		service->service_set |= VID_ENC_SLICED_VBI_WSS_PAL;
+	if (0 == service->service_set && 0 != fmt->fmt.sliced.service_set)
+		return -EINVAL;
+	return 0;
+}
+
+/*
+ * vpif_doioctl: This function will provide different V4L2 commands.This
+ * function can be used to configure driver or get status of driver as per
+ * command passed by application */
+static int vpif_doioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct vpif_fh *fh = file->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct video_obj *vid_ch = &(channel->video);
+	unsigned int index = 0;
+	unsigned long addr = 0, flags;
+	dev_dbg(vpif_dev, "<vpif_doioctl>\n");
+
+	/* This file handle has not initialized the channel,
+	   It is not allowed to do settings */
+	if ((VPIF_CHANNEL2_VIDEO == channel->channel_id)
+	    || (VPIF_CHANNEL3_VIDEO == channel->channel_id)) {
+		switch (cmd) {
+		case VIDIOC_S_FMT:
+		case VIDIOC_REQBUFS:
+		case VPIF_S_VPIF_PARAMS:
+		case VPIF_CMD_S_ENCODER_PARAMS:
+			if (!fh->initialized) {
+				dev_err(vpif_dev, "Channel Busy\n");
+				return -EBUSY;
+			}
+		}
+	}
+	/* Check for the priority */
+	if ((VPIF_CHANNEL2_VIDEO == channel->channel_id)
+	    || (VPIF_CHANNEL3_VIDEO == channel->channel_id)) {
+		switch (cmd) {
+		case VIDIOC_S_FMT:
+			ret = v4l2_prio_check(&channel->prio, &fh->prio);
+			if (0 != ret)
+				return ret;
+			fh->initialized = 1;
+			break;
+		}
+	}
+	/* Check for null value of parameter */
+	if (ISNULL((void *)arg)) {
+		dev_err(vpif_dev, "Null pointer\n");
+		return -EINVAL;
+	}
+	/* Switch on the command value */
+	switch (cmd) {
+		/* If the case is for querying capabilities */
+	case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *cap =
+			    (struct v4l2_capability *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_QUERYCAP\n");
+			memset(cap, 0, sizeof(*cap));
+			if ((VPIF_CHANNEL2_VIDEO == channel->channel_id)
+			    || (VPIF_CHANNEL3_VIDEO == channel->channel_id)) {
+				*cap = vpif_videocap;
+			} else {
+				ret = -EINVAL;
+			}
+			break;
+		}
+
+		/* If the case is for enumerating formats */
+	case VIDIOC_ENUM_FMT:
+		{
+			struct v4l2_fmtdesc *fmt = (struct v4l2_fmtdesc *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_ENUM_FMT\n");
+			if (fmt->index != 0) {
+				dev_err(vpif_dev, "Invalid format index\n");
+				return -EINVAL;
+			}
+			/* Fill in the information about format */
+			index = fmt->index;
+			memset(fmt, 0, sizeof(*fmt));
+			fmt->index = index;
+			fmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+			strcpy(fmt->description, "YCbCr4:2:2 YC Planar");
+			fmt->pixelformat = V4L2_PIX_FMT_YUV422UVP;
+			break;
+		}
+
+		/* If the case is for getting formats */
+	case VIDIOC_G_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			struct common_obj *common = NULL;
+			common =
+			    (fmt->type ==
+			     V4L2_BUF_TYPE_VIDEO_OUTPUT) ? &(channel->
+							     common
+							     [VPIF_VIDEO_INDEX])
+			    : ((fmt->type ==
+				V4L2_BUF_TYPE_HBI_OUTPUT) ? &(channel->
+							      common
+							      [VPIF_HBI_INDEX])
+			       : &(channel->common[VPIF_VBI_INDEX]));
+
+			dev_dbg(vpif_dev, "VIDIOC_G_FMT\n");
+
+			/* Check the validity of the buffer type */
+			if (common->fmt.type != fmt->type) {
+				ret = -EINVAL;
+				break;
+			}
+			/* If buffer type is not video output */
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT != fmt->type) {
+				if (vid_ch->std_info.vbi_supported == 0)
+					return -EINVAL;
+			}
+			/* Fill in the information about
+			 * format */
+			down_interruptible(&common->lock);
+			ret = davinci_enc_get_mode(channel->channel_id,
+						   &channel->video.mode_info);
+			if (ret < 0)
+				return ret;
+
+			vpif_get_std_info(channel);
+			*fmt = common->fmt;
+			up(&(common->lock));
+			dev_dbg(vpif_dev, "SUCCESS.\n");
+			break;
+		}
+
+		/* If the case is for setting formats */
+	case VIDIOC_S_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			struct common_obj *common = NULL;
+			common =
+			    (fmt->type ==
+			     V4L2_BUF_TYPE_VIDEO_OUTPUT) ? &(channel->
+							     common
+							     [VPIF_VIDEO_INDEX])
+			    : ((fmt->type ==
+				V4L2_BUF_TYPE_HBI_OUTPUT) ? &(channel->
+							      common
+							      [VPIF_HBI_INDEX])
+			       : &(channel->common[VPIF_VBI_INDEX]));
+
+			dev_dbg(vpif_dev, "VIDIOC_S_FMT\n");
+
+			/* If streaming is started, return error */
+			if (common->started) {
+				dev_err(vpif_dev, "Streaming is started\n");
+				return -EBUSY;
+			}
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Check for valid field format */
+				ret = vpif_check_format(channel, pixfmt);
+
+				if (ret) {
+					return ret;
+				}
+
+				/* store the pixel format in the channel
+				 * object */
+				common->fmt.fmt.pix = *pixfmt;
+				dev_dbg(vpif_dev, "Success.\n");
+			} else {
+				if (vid_ch->std_info.vbi_supported == 0) {
+					dev_err
+					    (vpif_dev,
+					     "standard doesn't support\n");
+					return -EINVAL;
+				}
+
+				if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT
+				    == fmt->type) {
+					struct vid_enc_sliced_vbi_service
+					    service;
+					ret =
+					    vpif_convert_vbi_services(fmt,
+								      &service);
+					if (ret < 0)
+						return ret;
+					ret =
+					    davinci_enc_enable_sliced_vbi
+					    (channel->channel_id, &service);
+					if (ret >= 0) {
+						common->height = 1;
+						common->width =
+						    VPIF_SLICED_BUF_SIZE;
+						channel->vbi.num_services = ret;
+					}
+				} else if ((V4L2_BUF_TYPE_VBI_OUTPUT
+					    == fmt->type) ||
+					   (V4L2_BUF_TYPE_HBI_OUTPUT ==
+					    fmt->type)) {
+					index =
+					    (V4L2_BUF_TYPE_VBI_OUTPUT ==
+					     fmt->
+					     type) ? VPIF_VBI_INDEX :
+					    VPIF_HBI_INDEX;
+					ret =
+					    vpif_try_raw_format(channel,
+								&(fmt->fmt.
+								  vbi), index);
+					if (ret < 0)
+						return ret;
+					if (V4L2_BUF_TYPE_VBI_OUTPUT
+					    == fmt->type)
+						ret =
+						    davinci_enc_enable_vbi
+						    (channel->channel_id, 1);
+					else
+						ret =
+						    davinci_enc_enable_hbi
+						    (channel->channel_id, 1);
+					if (ret < 0)
+						return ret;
+					common->height =
+					    common->fmt.fmt.vbi.count[0] +
+					    common->fmt.fmt.vbi.count[1];
+					common->width = common->fmt.
+					    fmt.vbi.samples_per_line;
+				} else {
+					dev_err(vpif_dev, "invalid type\n");
+					ret = -EINVAL;
+				}
+			}
+			if (ret < 0)
+				return ret;
+
+			/* store the format in the channel
+			 * object */
+			down_interruptible(&common->lock);
+			common->fmt = *fmt;
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for trying formats */
+	case VIDIOC_TRY_FMT:
+		{
+			struct v4l2_format *fmt = NULL;
+			struct common_obj *common = NULL;
+			fmt = (struct v4l2_format *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_TRY_FMT\n");
+			common =
+			    (fmt->type ==
+			     V4L2_BUF_TYPE_VIDEO_OUTPUT) ? &(channel->
+							     common
+							     [VPIF_VIDEO_INDEX])
+			    : ((fmt->type ==
+				V4L2_BUF_TYPE_HBI_OUTPUT) ? &(channel->
+							      common
+							      [VPIF_HBI_INDEX])
+			       : &(channel->common[VPIF_VBI_INDEX]));
+
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Check for valid field format */
+				ret = vpif_check_format(channel, pixfmt);
+				if (ret) {
+					*pixfmt = common->fmt.fmt.pix;
+					pixfmt->sizeimage =
+					    pixfmt->width * pixfmt->height * 2;
+				}
+			} else {
+				if (vid_ch->std_info.vbi_supported == 0) {
+					dev_err(vpif_dev,
+						"standard doesn't support\n");
+					return -EINVAL;
+				}
+				if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT
+				    == fmt->type) {
+					struct vid_enc_sliced_vbi_service
+					    service;
+					ret =
+					    davinci_enc_get_sliced_cap
+					    (channel->channel_id, &service);
+					if (ret < 0)
+						return ret;
+					ret = vpif_try_sliced_vbi(fmt,
+								  &service);
+				} else if ((V4L2_BUF_TYPE_VBI_OUTPUT
+					    == fmt->type) ||
+					   (V4L2_BUF_TYPE_HBI_OUTPUT ==
+					    fmt->type)) {
+					index =
+					    (V4L2_BUF_TYPE_VBI_OUTPUT ==
+					     fmt->
+					     type) ? VPIF_VBI_INDEX :
+					    VPIF_HBI_INDEX;
+					ret |=
+					    vpif_try_raw_format(channel,
+								&(fmt->fmt.
+								  vbi), index);
+				} else {
+					dev_err(vpif_dev, "invalid type\n");
+					ret = -EINVAL;
+				}
+			}
+			if (ret < 0)
+				return ret;
+			break;
+		}
+
+		/* If the case is for getting encoder parameters */
+	case VPIF_CMD_G_ENCODER_PARAMS:
+		{
+			dev_dbg(vpif_dev, "VPIF_CMD_G_ENCODER_PARAMS\n");
+			ret = davinci_enc_getparams(channel->channel_id,
+						    (void *)arg);
+			break;
+		}
+
+		/* If the case is for setting encoder parameters */
+	case VPIF_CMD_S_ENCODER_PARAMS:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			dev_dbg(vpif_dev, "VPIF_CMD_S_ENCODER_PARAMS\n");
+			down_interruptible(&common->lock);
+			/* If channel is already started, return
+			 * error */
+			if (common->started) {
+				dev_err(vpif_dev, "streaming is started\n");
+				up(&common->lock);
+				return -EBUSY;
+			}
+			ret = davinci_enc_setparams(channel->channel_id,
+						    (void *)arg);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for requesting buffer allocation */
+	case VIDIOC_REQBUFS:
+		{
+			struct v4l2_requestbuffers *reqbuf =
+			    (struct v4l2_requestbuffers *)arg;
+			enum v4l2_field field;
+			u8 index = 0;
+			struct common_obj *common = NULL;
+			reqbuf = (struct v4l2_requestbuffers *)arg;
+			dev_dbg(vpif_dev, "VIDIOC_REQBUFS\n");
+
+			if ((V4L2_BUF_TYPE_VIDEO_OUTPUT != reqbuf->type) &&
+			    (V4L2_BUF_TYPE_VBI_OUTPUT != reqbuf->type) &&
+			    (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT != reqbuf->type)
+			    && (V4L2_BUF_TYPE_HBI_OUTPUT != reqbuf->type))
+				return -EINVAL;
+			index = (V4L2_BUF_TYPE_VIDEO_OUTPUT
+				 == reqbuf->type) ? VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_OUTPUT == reqbuf->type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[index]);
+
+			/* Check the validity of the buffer type */
+			if (common->fmt.type != reqbuf->type) {
+				ret = -EINVAL;
+				break;
+			}
+			/* Only mmap is supported for sliced VBI */
+			if ((V4L2_BUF_TYPE_SLICED_VBI_OUTPUT == reqbuf->type)
+			    && (V4L2_MEMORY_MMAP != reqbuf->memory)) {
+				ret = -EINVAL;
+				break;
+			}
+			/* If io users of the channel is not zero,
+			   return error */
+			if (0 != common->io_usrs) {
+				ret = -EBUSY;
+				break;
+			}
+			down_interruptible(&common->lock);
+			if (reqbuf->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				if (common->fmt.fmt.pix.field == V4L2_FIELD_ANY)
+					field = V4L2_FIELD_INTERLACED;
+				else
+					field = common->fmt.fmt.pix.field;
+			} else {
+				field = V4L2_VBI_INTERLACED;
+			}
+			/* Initialize videobuf queue as per the
+			   buffer type */
+			videobuf_queue_init(&common->buffer_queue,
+					    &video_qops, NULL,
+					    &common->irqlock,
+					    reqbuf->type,
+					    field,
+					    sizeof(struct videobuf_buffer), fh);
+			/* Set buffer to Linear buffer */
+			videobuf_set_buftype(&common->buffer_queue,
+					     VIDEOBUF_BUF_LINEAR);
+			/* Set io allowed member of file handle to
+			 * TRUE */
+			fh->io_allowed[index] = 1;
+			/* Increment io usrs member of channel object
+			   to 1 */
+			common->io_usrs = 1;
+			/* Store type of memory requested in channel
+			   object */
+			common->memory = reqbuf->memory;
+			/* Initialize buffer queue */
+			INIT_LIST_HEAD(&common->dma_queue);
+			/* Allocate buffers */
+			ret = videobuf_reqbufs(&common->buffer_queue, reqbuf);
+			up(&common->lock);
+			break;
+		}
+
+		/* If the case is for en-queing buffer in the buffer
+		 * queue */
+	case VIDIOC_QBUF:
+		{
+			struct v4l2_buffer tbuf = *(struct v4l2_buffer *)arg;
+			u8 index = 0;
+			struct common_obj *common = NULL;
+			struct videobuf_buffer *buf1;
+			dev_dbg(vpif_dev, "VIDIOC_QBUF\n");
+			index = (V4L2_BUF_TYPE_VIDEO_OUTPUT
+				 == tbuf.type) ? VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_OUTPUT == tbuf.type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[index]);
+
+			/* Check the validity of the buffer type */
+			if (common->fmt.type != tbuf.type) {
+				ret = -EINVAL;
+				break;
+			}
+			/* If this file handle is not allowed to do IO,
+			   return error */
+			if (!fh->io_allowed[index]) {
+				dev_err(vpif_dev, "fh->io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			if (!(list_empty(&common->dma_queue)) ||
+			    (common->curFrm != common->nextFrm) ||
+			    !(common->started) ||
+			    (common->started && (0 == channel->field_id))) {
+				ret =
+				    videobuf_qbuf(&common->buffer_queue,
+						  (struct v4l2_buffer *)
+						  arg);
+				break;
+			}
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT != common->fmt.type) {
+				ret = videobuf_qbuf(&common->buffer_queue,
+						    (struct v4l2_buffer *)
+						    arg);
+				break;
+			}
+			/* bufferqueue is empty store buffer address
+			 *  in VPIF registers */
+			mutex_lock(&common->buffer_queue.lock);
+			tbuf = *(struct v4l2_buffer *)arg;
+			buf1 = common->buffer_queue.bufs[tbuf.index];
+			if (buf1->memory != tbuf.memory) {
+				dev_err(vpif_dev, "invalid buffer" " type\n");
+				mutex_unlock(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+			if ((buf1->state == STATE_QUEUED) ||
+			    (buf1->state == STATE_ACTIVE)) {
+				dev_err(vpif_dev, "invalid state\n");
+				mutex_unlock(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+
+			switch (buf1->memory) {
+			case V4L2_MEMORY_MMAP:
+				if (buf1->baddr == 0) {
+					mutex_unlock(&common->buffer_queue.lock);
+					return -EINVAL;
+				}
+				break;
+			case V4L2_MEMORY_USERPTR:
+				if (tbuf.length < buf1->bsize) {
+					mutex_unlock(&common->buffer_queue.lock);
+					return -EINVAL;
+				}
+				if ((STATE_NEEDS_INIT != buf1->state)
+				    && (buf1->baddr != tbuf.m.userptr))
+					vpif_buffer_release(&common->
+							    buffer_queue, buf1);
+				buf1->baddr = tbuf.m.userptr;
+				break;
+			default:
+				mutex_unlock(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+			local_irq_save(flags);
+			ret =
+			    vpif_buffer_prepare(&common->buffer_queue,
+						buf1,
+						common->buffer_queue.field);
+			if (ret < 0) {
+				local_irq_restore(flags);
+				mutex_unlock(&common->buffer_queue.lock);
+				return -EINVAL;
+			}
+			buf1->state = STATE_ACTIVE;
+			addr = buf1->boff;
+			common->nextFrm = buf1;
+			if (tbuf.type != V4L2_BUF_TYPE_SLICED_VBI_OUTPUT) {
+				common->set_addr((addr + common->ytop_off),
+						 (addr + common->ybtm_off),
+						 (addr + common->ctop_off),
+						 (addr + common->cbtm_off));
+			}
+			local_irq_restore(flags);
+			list_add_tail(&buf1->stream,
+				      &(common->buffer_queue.stream));
+			mutex_unlock(&common->buffer_queue.lock);
+			break;
+
+		}
+
+		/* If the case is for de-queing buffer from the
+		 * buffer queue */
+	case VIDIOC_DQBUF:
+		{
+			u8 index = 0;
+			struct common_obj *common = NULL;
+			dev_dbg(vpif_dev, "VIDIOC_DQBUF\n");
+			index = (V4L2_BUF_TYPE_VIDEO_OUTPUT ==
+				 ((struct v4l2_buffer *)arg)->type) ?
+			    VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_OUTPUT ==
+			      ((struct v4l2_buffer *)arg)->type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[index]);
+
+			if (file->f_flags & O_NONBLOCK)
+				/* Call videobuf_dqbuf for non
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(&common->buffer_queue,
+						   (struct v4l2_buffer *)
+						   arg, 1);
+			else
+				/* Call videobuf_dqbuf for
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(&common->buffer_queue,
+						   (struct v4l2_buffer *)
+						   arg, 0);
+			break;
+		}
+
+		/* If the case is for querying information about
+		 *  buffer for memory mapping io */
+	case VIDIOC_QUERYBUF:
+		{
+			struct v4l2_buffer tbuf = *(struct v4l2_buffer *)arg;
+			u8 index = 0;
+			struct common_obj *common = NULL;
+			dev_dbg(vpif_dev, "VIDIOC_QUERYBUF\n");
+			index = (V4L2_BUF_TYPE_VIDEO_OUTPUT
+				 == tbuf.type) ? VPIF_VIDEO_INDEX :
+			    ((V4L2_BUF_TYPE_HBI_OUTPUT == tbuf.type) ?
+			     VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			common = &(channel->common[index]);
+			/* Check the validity of the buffer type */
+			if (common->fmt.type != tbuf.type) {
+				ret = -EINVAL;
+				break;
+			}
+
+			if (tbuf.memory != V4L2_MEMORY_MMAP)
+				return -EINVAL;
+			/* Call videobuf_querybuf to get information */
+			ret = videobuf_querybuf(&common->buffer_queue,
+						(struct v4l2_buffer *)
+						arg);
+			break;
+		}
+
+		/* If the case is starting streaming */
+	case VIDIOC_STREAMON:
+		{
+			enum v4l2_buf_type buftype = *(enum v4l2_buf_type *)arg;
+			u8 index =
+			    (V4L2_BUF_TYPE_VIDEO_OUTPUT ==
+			     buftype) ? (VPIF_VIDEO_INDEX)
+			    : ((V4L2_BUF_TYPE_HBI_OUTPUT ==
+				buftype) ? VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			struct common_obj *common = &(channel->common[index]);
+			struct channel_obj *oth_ch =
+			    vpif_obj.dev[!channel->channel_id];
+			struct vpif_params *vpif = &channel->vpifparams;
+			dev_dbg(vpif_dev, "VIDIOC_STREAMON\n");
+			/* If file handle is not allowed IO,
+			 * return error */
+
+			if (!fh->io_allowed[index]) {
+				dev_err(vpif_dev, "fh->io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			/* If Streaming is already started,
+			 * return error */
+			if (common->started) {
+				dev_err(vpif_dev, "channel->started\n");
+				ret = -EBUSY;
+				break;
+			}
+			if ((channel->channel_id == VPIF_CHANNEL2_VIDEO
+			     && oth_ch->common[VPIF_VIDEO_INDEX].started &&
+			     channel->video.std_info.ycmux_mode == 0)
+			    || ((channel->channel_id == VPIF_CHANNEL3_VIDEO)
+				&& (2 == oth_ch->common[VPIF_VIDEO_INDEX].
+				    started))) {
+				dev_err(vpif_dev, "other channel is using\n");
+				ret = -EBUSY;
+				break;
+			}
+			if (index == VPIF_VIDEO_INDEX) {
+				ret = vpif_check_format
+				    (channel, &(common->fmt.fmt.pix));
+				if (ret < 0) {
+					return ret;
+				}
+			} else {
+				if (!channel->common[VPIF_VIDEO_INDEX].started)
+					return -EINVAL;
+			}
+
+			/* Call videobuf_streamon to start streaming
+			   in videobuf */
+			ret = videobuf_streamon(&common->buffer_queue);
+			if (ret < 0) {
+				dev_err(vpif_dev, "videobuf_streamon\n");
+				break;
+			}
+			down_interruptible(&common->lock);
+			/* If buffer queue is empty, return error */
+			if (list_empty(&common->dma_queue)) {
+				dev_err(vpif_dev, "buffer queue is empty\n");
+				ret = -EIO;
+				up(&common->lock);
+				break;
+			}
+			/* Get the next frame from the buffer queue */
+			common->nextFrm = common->curFrm =
+			    list_entry(common->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove buffer from the buffer queue */
+			list_del(&common->curFrm->queue);
+			/* Mark state of the current frame to active */
+			common->curFrm->state = STATE_ACTIVE;
+			/* Initialize field_id and started member */
+			channel->field_id = 0;
+			common->started = 1;
+
+			if (buftype == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				addr = common->curFrm->boff;
+				/* Calculate the offset for Y and C data
+				   in the buffer */
+				vpif_calculate_offsets(channel);
+
+				if ((vid_ch->std_info.frame_format &&
+				     ((common->fmt.fmt.pix.field !=
+				       V4L2_FIELD_NONE)
+				      && (common->fmt.fmt.pix.field !=
+					  V4L2_FIELD_ANY)))
+				    || (!vid_ch->std_info.frame_format
+					&& (common->fmt.fmt.pix.field ==
+					    V4L2_FIELD_NONE))) {
+					dev_err(vpif_dev,
+						"conflict in field format \
+							and std format\n");
+					up(&common->lock);
+					return -EINVAL;
+				}
+				/* if single channel is needed */
+				if (vid_ch->std_info.ycmux_mode == 1) {
+					ret = set_vid_out_mode_for_sd();
+				} else {
+					ret = set_vid_out_mode_for_hd();
+				}
+				if (ret < 0) {
+					dev_err(vpif_dev,
+						"cann't set vid out bit\n");
+					up(&common->lock);
+					return ret;
+				}
+				/* Set clock settings */
+				ret = set_vid_clock(vid_ch->std_info.hd_sd);
+
+				/* Call vpif_set_params function to set
+				 * the parameters and addresses */
+				ret = vpif_set_video_params(vpif,
+							    channel->
+							    channel_id + 2);
+				if (ret < 0) {
+					up(&common->lock);
+					return ret;
+				}
+				common->started = ret;
+				vpif_config_addr(channel, ret);
+
+				common->set_addr((addr + common->ytop_off),
+						 (addr + common->ybtm_off),
+						 (addr + common->ctop_off),
+						 (addr + common->cbtm_off));
+				/* Set interrupt for both the fields in
+				   VPIF Register enable channel in
+				   VPIF register */
+				if (VPIF_CHANNEL2_VIDEO == channel->channel_id) {
+					channel2_intr_assert();
+					channel2_intr_enable(1);
+					enable_channel2(1);
+				}
+				if ((VPIF_CHANNEL3_VIDEO == channel->channel_id)
+				    || (common->started == 2)) {
+					channel3_intr_assert();
+					channel3_intr_enable(1);
+					enable_channel3(1);
+				}
+				channel_first_int[VPIF_VIDEO_INDEX]
+				    [channel->channel_id] = 1;
+			} else if ((V4L2_BUF_TYPE_VBI_OUTPUT == buftype)
+				   || (V4L2_BUF_TYPE_HBI_OUTPUT == buftype)) {
+				if (V4L2_BUF_TYPE_VBI_OUTPUT == buftype)
+					index = VPIF_VBI_INDEX;
+				else
+					index = VPIF_HBI_INDEX;
+				/* Calculate the offset for vbi data
+				   in the buffer */
+				vpif_calculate_offsets_vbi(channel, index);
+
+				/* Call vpif_set_params function to set
+				 * the parameters and addresses */
+				ret = vpif_set_vbi_display_params
+				    (&channel->vpifparams.params.
+				     vbi_params, channel->channel_id);
+				if (ret < 0) {
+					up(&(common->lock));
+					return ret;
+				}
+				vpif_config_addr_vbi(channel,
+						     channel->channel_id,
+						     index);
+
+				common->set_addr((addr + common->ytop_off),
+						 (addr + common->ybtm_off),
+						 (addr + common->ctop_off),
+						 (addr + common->cbtm_off));
+				if (VPIF_CHANNEL2_VIDEO == channel->channel_id)
+					channel2_raw_enable(1, index);
+
+				if (VPIF_CHANNEL3_VIDEO == channel->channel_id)
+					channel3_raw_enable(1, index);
+
+				channel_first_int[index][channel->channel_id]
+				    = 1;
+			} else {
+				queue_work(vbi_workqueue,
+					   &vbi_work[channel->channel_id]);
+				channel_first_int
+				    [VPIF_VBI_INDEX][channel->channel_id]
+				    = 1;
+			}
+			up(&(common->lock));
+			break;
+		}
+
+		/* If the case is for stopping streaming */
+	case VIDIOC_STREAMOFF:
+		{
+			enum v4l2_buf_type buftype = *(enum v4l2_buf_type *)arg;
+			u8 index =
+			    (V4L2_BUF_TYPE_VIDEO_OUTPUT ==
+			     buftype) ? (VPIF_VIDEO_INDEX)
+			    : ((V4L2_BUF_TYPE_HBI_OUTPUT ==
+				buftype) ? VPIF_HBI_INDEX : VPIF_VBI_INDEX);
+			struct common_obj *common = &(channel->common[index]);
+			dev_dbg(vpif_dev, "VIDIOC_STREAMOFF\n");
+			/* If io is allowed for this file handle,
+			   return error */
+			if (!fh->io_allowed[index]) {
+				dev_err(vpif_dev, "fh->io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			/* If streaming is not started, return error */
+			if (!common->started) {
+				dev_err(vpif_dev, "channel->started\n");
+				ret = -EINVAL;
+				break;
+			}
+			down_interruptible(&common->lock);
+			if (buftype == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				/* disable channel */
+				if (VPIF_CHANNEL2_VIDEO == channel->channel_id) {
+					enable_channel2(0);
+					channel2_intr_enable(0);
+				}
+				if ((VPIF_CHANNEL3_VIDEO ==
+				     channel->channel_id) ||
+				    (2 == common->started)) {
+					enable_channel3(0);
+					channel3_intr_enable(0);
+				}
+			} else if (buftype == V4L2_BUF_TYPE_VBI_OUTPUT) {
+				/* disable raw vbi channel */
+				if (VPIF_CHANNEL2_VIDEO == channel->channel_id) {
+					channel2_raw_enable(0, index);
+				} else {
+					channel3_raw_enable(0, index);
+				}
+			} else {
+				/* disabel sliced vbi channel */
+				struct vid_enc_sliced_vbi_service services;
+				services.service_set = 0;
+				ret =
+				    davinci_enc_enable_sliced_vbi(channel->
+								  channel_id,
+								  &services);
+			}
+			common->started = 0;
+			up(&common->lock);
+			ret = videobuf_streamoff(&common->buffer_queue);
+			break;
+		}
+
+		/* If the case is for setting VPIF parameters */
+	case VPIF_S_VPIF_PARAMS:
+		{
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			struct vpif_params *params = (struct vpif_params *)arg;
+			dev_dbg(vpif_dev, "VPIF_S_PARAMS\n");
+			/* If streaming is not started, return error */
+			if (common->started) {
+				ret = -EBUSY;
+				break;
+			}
+			down_interruptible(&common->lock);
+			channel->vpifparams = *params;
+			up(&common->lock);
+			common = &(channel->common[VPIF_VBI_INDEX]);
+			break;
+		}
+
+		/* If the case is for getting VPIF Parameters */
+	case VPIF_G_VPIF_PARAMS:
+		{
+			struct vpif_params *params = (struct vpif_params *)arg;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			dev_dbg(vpif_dev, "VPIF_G_PARAMS\n");
+			down_interruptible(&common->lock);
+			*params = channel->vpifparams;
+			up(&common->lock);
+			common = &(channel->common[VPIF_VBI_INDEX]);
+			break;
+		}
+	case VIDIOC_S_PRIORITY:
+		{
+			enum v4l2_priority *p = (enum v4l2_priority *)arg;
+			ret = v4l2_prio_change(&channel->prio, &fh->prio, *p);
+			break;
+		}
+	case VIDIOC_G_PRIORITY:
+		{
+			enum v4l2_priority *p = (enum v4l2_priority *)arg;
+			*p = v4l2_prio_max(&channel->prio);
+			break;
+		}
+		/* If the case is for getting sliced vbi capabilites */
+	case VIDIOC_G_SLICED_VBI_CAP:
+		{
+			struct vid_enc_sliced_vbi_service service;
+			struct v4l2_sliced_vbi_cap *cap =
+			    (struct v4l2_sliced_vbi_cap *)arg;
+			ret =
+			    davinci_enc_get_sliced_cap(channel->channel_id,
+						       &service);
+			cap->service_set = 0;
+			if (service.service_set & VID_ENC_SLICED_VBI_CGMS_NTSC)
+				cap->service_set |= V4L2_SLICED_CGMS_525;
+			if (service.service_set & VID_ENC_SLICED_VBI_CC_NTSC)
+				cap->service_set |= V4L2_SLICED_CAPTION_525;
+			if (service.service_set & VID_ENC_SLICED_VBI_WSS_PAL)
+				cap->service_set |= V4L2_SLICED_WSS_625;
+			break;
+		}
+		/* If the case if for getting cropping parameters */
+	case VIDIOC_CROPCAP:
+		{
+			struct v4l2_cropcap *crop = (struct v4l2_cropcap *)arg;
+			struct common_obj *common =
+			    &(channel->common[VPIF_VIDEO_INDEX]);
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT != crop->type)
+				return -EINVAL;
+			crop->bounds.left = crop->bounds.top = 0;
+			crop->defrect.left = crop->defrect.top = 0;
+			crop->defrect.height = crop->bounds.height =
+			    common->height;
+			crop->defrect.width = crop->bounds.width =
+			    common->width;
+			break;
+		}
+	default:
+		dev_dbg(vpif_dev, "Invalid command\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(vpif_dev, "<vpif_doioctl>\n");
+	return ret;
+}
+
+/*
+ * vpif_ioctl: Calls vpif_doioctl function */
+static int vpif_ioctl(struct inode *inode, struct file *file,
+		      unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	char sbuf[128];
+	void *mbuf = NULL;
+	void *parg = NULL;
+
+	dev_dbg(vpif_dev, "Start of vpif ioctl\n");
+
+	if (ISENCODERCMD(cmd)) {
+		ret = vpif_doioctl(inode, file, cmd, (unsigned long)arg);
+		if (ret == -ENOIOCTLCMD)
+			ret = -EINVAL;
+		goto out;
+	}
+
+	/*  Copy arguments into temp kernel buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_NONE:
+		parg = NULL;
+		break;
+	case _IOC_READ:
+	case _IOC_WRITE:
+	case (_IOC_WRITE | _IOC_READ):
+		if (_IOC_SIZE(cmd) <= sizeof(sbuf)) {
+			parg = sbuf;
+		} else {
+			/* too big to allocate from stack */
+			mbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);
+			if (NULL == mbuf)
+				return -ENOMEM;
+			parg = mbuf;
+		}
+
+		ret = -EFAULT;
+		if (_IOC_DIR(cmd) & _IOC_WRITE)
+			if (copy_from_user(parg, (void __user *)arg,
+					   _IOC_SIZE(cmd)))
+				goto out;
+		break;
+	}
+
+	/* call driver */
+	ret = vpif_doioctl(inode, file, cmd, (unsigned long)parg);
+	if (ret == -ENOIOCTLCMD)
+		ret = -EINVAL;
+
+	/*  Copy results into user buffer  */
+	switch (_IOC_DIR(cmd)) {
+	case _IOC_READ:
+	case (_IOC_WRITE | _IOC_READ):
+		if (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))
+			ret = -EFAULT;
+		break;
+	}
+out:
+	if (mbuf)
+		kfree(mbuf);
+
+	dev_dbg(vpif_dev, "</vpif_ioctl>\n");
+	return ret;
+}
+
+/*
+ * vpif_mmap: It is used to map kernel space buffers into user spaces */
+static int vpif_mmap(struct file *filep, struct vm_area_struct *vma)
+{
+	/* Get the channel object and file handle object */
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = &(channel->common[VPIF_VBI_INDEX]);
+	int err = 0, i, found = 0;
+	unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+	dev_dbg(vpif_dev, "<vpif_mmap>\n");
+	for (i = 0; (i < common->numbuffers) && (0 == found); i++) {
+		if (common->buffer_queue.bufs[i]->boff == offset)
+			found = 1;
+	}
+	if (found == 0) {
+		common = &(channel->common[VPIF_HBI_INDEX]);
+		for (i = 0; (i < common->numbuffers) && (0 == found); i++) {
+			if (common->buffer_queue.bufs[i]->boff == offset)
+				found = 1;
+		}
+	}
+	if (0 == found)
+		common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	err = videobuf_mmap_mapper(&common->buffer_queue, vma);
+	dev_dbg(vpif_dev, "</vpif_mmap>\n");
+	return err;
+}
+
+/* vpif_poll: It is used for select/poll system call
+ */
+static unsigned int vpif_poll(struct file *filep, poll_table * wait)
+{
+	int err = 0;
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+
+	dev_dbg(vpif_dev, "<vpif_poll>");
+
+	if (common->started)
+		err = videobuf_poll_stream(filep, &common->buffer_queue, wait);
+
+	common = &(channel->common[VPIF_VBI_INDEX]);
+	if (common->started)
+		err |= videobuf_poll_stream(filep, &common->buffer_queue, wait);
+
+	if (err & POLLIN) {
+		err &= (~POLLIN);
+		err |= POLLOUT;
+	}
+	if (err & POLLRDNORM) {
+		err &= (~POLLRDNORM);
+		err |= POLLWRNORM;
+	}
+
+	dev_dbg(vpif_dev, "</vpif_poll>");
+	return err;
+}
+
+/*
+ * vpif_open: It creates object of file handle structure and stores it in
+ * private_data member of filepointer */
+static int vpif_open(struct inode *inode, struct file *filep)
+{
+	int minor = iminor(inode);
+	int found = -1;
+	int i = 0, err = 0;
+	struct channel_obj *channel;
+	struct vpif_fh *fh = NULL;
+
+	dev_dbg(vpif_dev, "<vpif open>\n");
+
+	/* Check for valid minor number */
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[i];
+		if (minor == channel->video_dev->minor) {
+			found = i;
+			break;
+		}
+	}
+	/* If not found, return error no device */
+	if (0 > found) {
+		dev_err(vpif_dev, "device not found\n");
+		return -ENODEV;
+	}
+	/* Allocate memory for the file handle object */
+	fh = kmalloc(sizeof(struct vpif_fh), GFP_KERNEL);
+	if (ISNULL(fh)) {
+		dev_err(vpif_dev,
+			"unable to allocate memory for file handle object\n");
+		return -ENOMEM;
+	}
+	/* store pointer to fh in private_data member of filep */
+	filep->private_data = fh;
+	fh->channel = channel;
+	fh->initialized = 0;
+	/* If encoder is not initialized. initialize it */
+	if (!channel->initialized) {
+		fh->initialized = 1;
+		channel->initialized = 1;
+		/* increment module usage counter */
+		/* Get the default standard and info about standard */
+		err = davinci_enc_get_mode(channel->channel_id,
+					   &channel->video.mode_info);
+		if (err < 0)
+			goto vpif_open_out;
+
+		vpif_get_std_info(channel);
+		channel->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.
+		    bytesperline =
+		    channel->common[VPIF_VIDEO_INDEX].fmt.fmt.pix.width;
+		/* Configure the default format information */
+		vpif_config_format(channel);
+		memset(&(channel->vpifparams), 0, sizeof(struct vpif_params));
+	}
+vpif_open_out:
+	if (err < 0) {
+		if (fh->initialized) {
+			channel->initialized = 0;
+		}
+		filep->private_data = NULL;
+		fh->initialized = 0;
+		/* Free memory allocated to file handle object */
+		if (!ISNULL(fh))
+			kfree(fh);
+		return err;
+	}
+	/* Increment channel usrs counter */
+	channel->usrs++;
+	/* Set io_allowed[VPIF_VIDEO_INDEX] member to false */
+	fh->io_allowed[VPIF_VIDEO_INDEX] = 0;
+	/* Set io_allowed[VPIF_VBI_INDEX] member to false */
+	fh->io_allowed[VPIF_VBI_INDEX] = 0;
+	fh->io_allowed[VPIF_HBI_INDEX] = 0;
+
+	/* Initialize priority of this instance to default priority */
+	fh->prio = V4L2_PRIORITY_UNSET;
+
+	v4l2_prio_open(&channel->prio, &fh->prio);
+
+	dev_dbg(vpif_dev, "</vpif_open>\n");
+	return err;
+}
+
+static void vpif_free_vbibuffers(struct channel_obj *channel, u8 index)
+{
+	struct common_obj *common = NULL;
+	u32 bufsize, i;
+	common = &(channel->common[index]);
+	if (V4L2_BUF_TYPE_SLICED_VBI_OUTPUT == common->buffer_queue.type) {
+		bufsize = VPIF_SLICED_BUF_SIZE;
+	} else {
+		/* Calculate the size of the buffer */
+		bufsize = ((common->fmt.fmt.vbi.count[0]) +
+			   (common->fmt.fmt.vbi.count[1])) *
+		    (common->fmt.fmt.vbi.samples_per_line);
+	}
+	for (i = 0; i < common->numbuffers; i++) {
+		if (common->fbuffers[i]) {
+			vpif_free_buffer((unsigned long)common->
+					 fbuffers[i], bufsize);
+		}
+		common->fbuffers[i] = 0;
+	}
+	common->numbuffers = 0;
+}
+
+static void vpif_free_allbuffers(struct channel_obj *channel)
+{
+	int i;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	u32 start = config_params.numbuffers[channel->channel_id];
+	u32 end = common->numbuffers;
+	u32 bufsize = config_params.channel_bufsize[channel->channel_id];
+	for (i = start; i < end; i++) {
+		if (common->fbuffers[i]) {
+			vpif_free_buffer((unsigned long)common->
+					 fbuffers[i], bufsize);
+		}
+		common->fbuffers[i] = 0;
+	}
+}
+
+/*
+ * vpif_release: This function deletes buffer queue, frees the buffers and
+ * the vpif file handle */
+static int vpif_release(struct inode *inode, struct file *filep)
+{
+	/* Get the channel object and file handle object */
+	struct vpif_fh *fh = filep->private_data;
+	struct channel_obj *channel = fh->channel;
+	struct common_obj *common = &(channel->common[VPIF_VIDEO_INDEX]);
+	int i;
+
+	dev_dbg(vpif_dev, "<vpif_release>\n");
+	/* If this is doing IO and other channels are not closed */
+	if ((channel->usrs != 1) && fh->io_allowed[VPIF_VIDEO_INDEX]) {
+		dev_err(vpif_dev, "Close other instances\n");
+		return -EAGAIN;
+	}
+	/* Get the lock on channel object */
+	down_interruptible(&common->lock);
+	/* if this instance is doing IO */
+	if (fh->io_allowed[VPIF_VIDEO_INDEX]) {
+		/* Reset io_usrs member of channel object */
+		common->io_usrs = 0;
+		/* Disable channel/vbi as per its device type
+		   and channel id */
+		if (VPIF_CHANNEL2_VIDEO == channel->channel_id) {
+			enable_channel2(0);
+			channel2_intr_enable(0);
+		}
+		if ((VPIF_CHANNEL3_VIDEO == channel->channel_id) ||
+		    (2 == common->started)) {
+			enable_channel3(0);
+			channel3_intr_enable(0);
+		}
+		common->started = 0;
+		/* Free buffers allocated */
+		videobuf_queue_cancel(&common->buffer_queue);
+		vpif_free_allbuffers(channel);
+		common->numbuffers =
+		    config_params.numbuffers[channel->channel_id];
+
+	}
+	/* unlock semaphore on channel object */
+	up(&common->lock);
+
+	for (i = VPIF_VBI_INDEX; i <= VPIF_HBI_INDEX; i++) {
+		down_interruptible(&(channel->common[i].lock));
+		if (fh->io_allowed[i]) {
+			/* Reset io_usrs member of channel object */
+			channel->common[i].io_usrs = 0;
+			/* Disable channel/vbi as per its device type
+			   and channel id */
+			if (VPIF_CHANNEL2_VIDEO == channel->channel_id) {
+				channel2_raw_enable(0, i);
+			} else {
+				channel3_raw_enable(0, i);
+			}
+			channel->common[i].started = 0;
+			/* Free buffers allocated */
+			videobuf_queue_cancel
+			    (&channel->common[VPIF_VBI_INDEX].buffer_queue);
+			vpif_free_vbibuffers(channel, i);
+			common->numbuffers = 0;
+		}
+		up(&(channel->common[i].lock));
+	}
+	/* Decrement channel usrs counter */
+	channel->usrs--;
+	/* If this file handle has initialize encoder device, reset it */
+	if (fh->initialized) {
+		channel->initialized = 0;
+	}
+	/* Close the priority */
+	v4l2_prio_close(&channel->prio, &fh->prio);
+	filep->private_data = NULL;
+	fh->initialized = 0;
+	/* Free memory allocated to file handle object */
+	if (!ISNULL(fh))
+		kfree(fh);
+	dev_dbg(vpif_dev, "</vpif_release>\n");
+	return 0;
+}
+
+static void vpif_platform_release(struct device
+				  *device)
+{
+	/* This is called when the reference count goes to zero */
+}
+
+static struct file_operations vpif_fops = {
+	.owner = THIS_MODULE,
+	.open = vpif_open,
+	.release = vpif_release,
+	.ioctl = vpif_ioctl,
+	.mmap = vpif_mmap,
+	.poll = vpif_poll
+};
+static struct video_device vpif_video_template = {
+	.name = "vpif",
+	.type = VID_TYPE_CAPTURE,
+	.hardware = 0,
+	.fops = &vpif_fops,
+	.minor = -1
+};
+
+/*
+ * vpif_probe: This function creates device entries by register itself to the
+ * V4L2 driver and initializes fields of each channel objects */
+static __init int vpif_probe(struct device *device)
+{
+	int i, j = 0, k, err = 0;
+	struct video_device *vfd = NULL;
+	struct channel_obj *channel = NULL;
+	struct common_obj *common = NULL;
+	vpif_dev = device;
+	dev_dbg(vpif_dev, "<vpif_probe>\n");
+
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[i];
+		/* Allocate memory for video device */
+		vfd = video_device_alloc();
+		if (ISNULL(vfd)) {
+			for (j = 0; j < i; j++) {
+				video_device_release
+				    (vpif_obj.dev[j]->video_dev);
+			}
+			return -ENOMEM;
+		}
+
+		/* Initialize field of video device */
+		*vfd = vpif_video_template;
+		vfd->dev = device;
+		vfd->release = video_device_release;
+		snprintf(vfd->name, sizeof(vfd->name),
+			 "DaVinciHD_VPIFDisplay_DRIVER_V%d.%d.%d",
+			 (VPIF_DISPLAY_VERSION_CODE >> 16)
+			 & 0xff,
+			 (VPIF_DISPLAY_VERSION_CODE >> 8) &
+			 0xff, (VPIF_DISPLAY_VERSION_CODE) & 0xff);
+		/* Set video_dev to the video device */
+		channel->video_dev = vfd;
+	}
+
+	for (j = 0; j < VPIF_DISPLAY_MAX_DEVICES; j++) {
+		channel = vpif_obj.dev[j];
+		/* Initialize field of the channel objects */
+		channel->usrs = 0;
+		for (k = 0; k < VPIF_NUMOBJECTS; k++) {
+			channel->common[k].numbuffers = 0;
+			common = &(channel->common[k]);
+			common->io_usrs = 0;
+			common->started = 0;
+			spin_lock_init(&common->irqlock);
+			init_MUTEX(&common->lock);
+			common->numbuffers = 0;
+			common->set_addr = NULL;
+			common->ytop_off = common->ybtm_off = 0;
+			common->ctop_off = common->cbtm_off = 0;
+			common->curFrm = common->nextFrm = NULL;
+			memset(&common->fmt, 0, sizeof(struct v4l2_format));
+
+		}
+		channel->initialized = 0;
+		channel->channel_id = j;
+		if (j < 2)
+			channel->common[VPIF_VIDEO_INDEX].numbuffers =
+			    config_params.numbuffers[channel->channel_id];
+		else
+			channel->common[VPIF_VIDEO_INDEX].numbuffers = 0;
+
+		memset(&(channel->vpifparams), 0, sizeof(struct vpif_params));
+
+		/* Initialize prio member of channel object */
+		v4l2_prio_init(&channel->prio);
+
+		/* Initialize the work structure */
+		INIT_WORK(&vbi_work[channel->channel_id],
+			  (void (*)(void *))vbi_work_handler, (void *)channel);
+
+		channel->common[VPIF_VIDEO_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_VIDEO_OUTPUT;
+		channel->common[VPIF_VBI_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_SLICED_VBI_OUTPUT;
+		channel->common[VPIF_HBI_INDEX].fmt.type =
+		    V4L2_BUF_TYPE_HBI_OUTPUT;
+		/* register video device */
+		dev_dbg(vpif_dev, "trying to register vpif device.\n");
+		dev_dbg(vpif_dev,
+			"channel=%x,channel->video_dev=%x\n",
+			(int)channel, (int)&channel->video_dev);
+
+		err =
+		    video_register_device(channel->
+					  video_dev,
+					  VFL_TYPE_GRABBER, vpif_nr[j]);
+		if (err < 0)
+			goto probe_out;
+	}
+	return 0;
+
+probe_out:
+	for (k = 0; k < j; k++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[k];
+		/* Unregister video device */
+		video_unregister_device(channel->video_dev);
+		/* Release video device */
+		video_device_release(channel->video_dev);
+		channel->video_dev = NULL;
+	}
+	dev_dbg(vpif_dev, "</vpif_probe>\n");
+	return err;
+}
+
+/*
+ * vpif_remove: It un-register channels from V4L2 driver */
+static int vpif_remove(struct device *device)
+{
+	int i;
+	struct channel_obj *channel;
+	dev_dbg(vpif_dev, "<vpif_remove>\n");
+	/* un-register device */
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the channel object */
+		channel = vpif_obj.dev[i];
+		/* Unregister video device */
+		video_unregister_device(channel->video_dev);
+
+		channel->video_dev = NULL;
+	}
+	dev_dbg(vpif_dev, "</vpif_remove>\n");
+	return 0;
+}
+
+static struct device_driver vpif_driver = {
+	.name = "vpif display",
+	.bus = &platform_bus_type,
+	.probe = vpif_probe,
+	.remove = vpif_remove,
+};
+static struct platform_device _vpif_device = {
+	.name = "vpif display",
+	.id = 1,
+	.dev = {
+		.release = vpif_platform_release,
+		}
+};
+
+/*
+ * vpif_init: This function registers device and driver to the kernel,
+* requests irq handler and allocates memory for channel objects */
+static __init int vpif_init(void)
+{
+	int err = 0, i, j;
+	int free_channel_objects_index;
+	int free_irq_no_index;
+	int free_buffer_channel_index;
+	int free_buffer_index;
+	u32 addr;
+	int size;
+
+	/* Default number of buffers should be 3 */
+	if ((channel2_numbuffers > 0) &&
+	    (channel2_numbuffers < config_params.min_numbuffers))
+		channel2_numbuffers = config_params.min_numbuffers;
+	if ((channel3_numbuffers > 0) &&
+	    (channel3_numbuffers < config_params.min_numbuffers))
+		channel3_numbuffers = config_params.min_numbuffers;
+
+	/* Set buffer size to min buffers size if invalid buffer size is
+	 * given */
+	if (channel2_bufsize < config_params.min_bufsize[VPIF_CHANNEL2_VIDEO])
+		channel2_bufsize =
+		    config_params.min_bufsize[VPIF_CHANNEL2_VIDEO];
+	if (channel3_bufsize < config_params.min_bufsize[VPIF_CHANNEL3_VIDEO])
+		channel3_bufsize =
+		    config_params.min_bufsize[VPIF_CHANNEL3_VIDEO];
+
+	config_params.numbuffers[VPIF_CHANNEL2_VIDEO] = channel2_numbuffers;
+
+	if (channel2_numbuffers) {
+		config_params.channel_bufsize[VPIF_CHANNEL2_VIDEO]
+		    = channel2_bufsize;
+	}
+	config_params.numbuffers[VPIF_CHANNEL3_VIDEO] = channel3_numbuffers;
+
+	if (channel3_numbuffers) {
+		config_params.channel_bufsize[VPIF_CHANNEL3_VIDEO]
+		    = channel3_bufsize;
+	}
+
+	/* Allocate memory for six channel objects */
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+		vpif_obj.dev[i] =
+		    kmalloc(sizeof(struct channel_obj), GFP_KERNEL);
+		/* If memory allocation fails, return error */
+		if (!vpif_obj.dev[i]) {
+			free_channel_objects_index = i;
+			err = -ENOMEM;
+			goto vpif_init_free_channel_objects;
+		}
+	}
+	free_channel_objects_index = VPIF_DISPLAY_MAX_DEVICES;
+
+	/* Allocate memory for buffers */
+	for (i = 0; i < VPIF_DISPLAY_NUM_CHANNELS; i++) {
+		size = config_params.channel_bufsize[i];
+		for (j = 0; j < config_params.numbuffers[i]; j++) {
+			addr = vpif_alloc_buffer(size);
+			if (!addr) {
+				free_buffer_channel_index = i;
+				free_buffer_index = j;
+				err = -ENOMEM;
+				goto vpif_init_free_buffers;
+			}
+			vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+			    fbuffers[j] = (u8 *) addr;
+		}
+	}
+	free_buffer_channel_index = VPIF_DISPLAY_NUM_CHANNELS;
+	free_buffer_index = config_params.numbuffers[i - 1];
+
+	/* Create the workqueue */
+	vbi_workqueue = create_singlethread_workqueue("vbi");
+	if (!vbi_workqueue) {
+		err = -ENOMEM;
+		goto vpif_init_free_buffers;
+	}
+
+	/* Register driver to the kernel */
+	err = driver_register(&vpif_driver);
+	if (0 != err) {
+		goto vpif_init_free_buffers;
+	}
+	/* register device as a platform device to the kernel */
+	err = platform_device_register(&_vpif_device);
+	if (0 != err) {
+		goto vpif_init_unregister_vpif_driver;
+	}
+	for (j = 0; j < VPIF_DISPLAY_NUM_CHANNELS; j++) {
+		err =
+		    request_irq(vpif_get_irq_number(j + 2),
+				vpif_channel_isr,
+				SA_INTERRUPT, "DaVinciHD_Display",
+				(void *)(&(vpif_obj.dev[j]->channel_id)));
+		if (0 != err) {
+			free_irq_no_index = j;
+			goto vpif_init_free_irq;
+
+		}
+	}
+	free_irq_no_index = VPIF_DISPLAY_NUM_CHANNELS;
+
+	/* Set pinmux settings */
+	set_vpif_pinmux();
+
+	return 0;
+vpif_init_free_irq:
+	for (j = 0; j < free_irq_no_index; j++) {
+		free_irq(vpif_get_irq_number(j + 2),
+			 (void *)(&(vpif_obj.dev[j]->channel_id)));
+	}
+	platform_device_unregister(&_vpif_device);
+
+vpif_init_unregister_vpif_driver:
+	driver_unregister(&vpif_driver);
+
+vpif_init_free_buffers:
+	for (i = 0; i < free_buffer_channel_index; i++) {
+		for (j = 0; j < config_params.numbuffers[i]; j++) {
+			addr = (unsigned long)vpif_obj.dev[i]->
+			    common[VPIF_VIDEO_INDEX].fbuffers[j];
+			if (addr) {
+				vpif_free_buffer(addr,
+						 config_params.
+						 channel_bufsize[i]);
+				vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+				    fbuffers[j] = 0;
+			}
+		}
+	}
+	for (j = 0; j < free_buffer_index; j++) {
+		addr = (unsigned long)vpif_obj.
+		    dev[free_buffer_channel_index]->
+		    common[VPIF_VIDEO_INDEX].fbuffers[j];
+		if (addr) {
+			vpif_free_buffer(addr,
+					 config_params.channel_bufsize[i]);
+			vpif_obj.dev[free_buffer_channel_index]->
+			    common[VPIF_VIDEO_INDEX].fbuffers[j] = 0;
+		}
+
+	}
+
+vpif_init_free_channel_objects:
+	for (j = 0; j < free_channel_objects_index; j++) {
+		if (vpif_obj.dev[i]) {
+			kfree(vpif_obj.dev[j]);
+			vpif_obj.dev[i] = NULL;
+		}
+	}
+	return err;
+}
+
+/* vpif_cleanup: This function un-registers device and driver to the kernel,
+ * frees requested irq handler and de-allocates memory allocated for channel
+ * objects.
+ * */
+static void vpif_cleanup(void)
+{
+	int i = 0, j = 0;
+	u32 addr;
+
+	for (i = 0; i < VPIF_DISPLAY_NUM_CHANNELS; i++) {
+		free_irq(vpif_get_irq_number(i + 2),
+			 (void *)(&(vpif_obj.dev[i]->channel_id)));
+	}
+	/* Flush and destroy the workqueue */
+	flush_workqueue(vbi_workqueue);
+	destroy_workqueue(vbi_workqueue);
+
+	platform_device_unregister(&_vpif_device);
+	driver_unregister(&vpif_driver);
+	for (i = 0; i < VPIF_DISPLAY_NUM_CHANNELS; i++) {
+		for (j = 0; j < config_params.numbuffers[i]; j++) {
+			addr = (unsigned long)vpif_obj.dev[i]->
+			    common[VPIF_VIDEO_INDEX].fbuffers[j];
+			if (addr) {
+				vpif_free_buffer(addr,
+						 config_params.
+						 channel_bufsize[i]);
+				vpif_obj.dev[i]->common[VPIF_VIDEO_INDEX].
+				    fbuffers[j] = 0;
+			}
+		}
+	}
+	for (i = 0; i < VPIF_DISPLAY_MAX_DEVICES; i++) {
+		if (vpif_obj.dev[i]) {
+			kfree(vpif_obj.dev[i]);
+			vpif_obj.dev[i] = NULL;
+		}
+	}
+}
+
+MODULE_LICENSE("GPL");
+/* Function for module initialization and cleanup */
+module_init(vpif_init);
+module_exit(vpif_cleanup);
Index: linux-2.6.18/drivers/media/video/davinci/davincihd_platform.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/davincihd_platform.c
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/davinci_platform.h>
+
+/* Function: davinci_enc_set_mode_platform
+ * @channel: channel number, starting index 0.
+ * @mgr: encoder device structure
+ * Returns: None
+ *
+ * Description:
+ *   This function does platform specific settings for the current mode.
+ *
+ */
+struct enc_config davinci_enc_default[DAVINCI_ENC_MAX_CHANNELS] = {
+	{VID_ENC_OUTPUT_COMPOSITE,
+	 VID_ENC_STD_NTSC}
+};
+EXPORT_SYMBOL(davinci_enc_default);
+
+char *davinci_outputs[] = {
+	VID_ENC_OUTPUT_COMPOSITE,
+	VID_ENC_OUTPUT_COMPOSITE1,
+	VID_ENC_OUTPUT_SVIDEO,
+	VID_ENC_OUTPUT_SVIDEO1,
+	VID_ENC_OUTPUT_COMPONENT,
+	VID_ENC_OUTPUT_COMPONENT1,
+	VID_ENC_OUTPUT_LCD,
+	VID_ENC_OUTPUT_LCD1,
+	""
+};
+EXPORT_SYMBOL(davinci_outputs);
+
+char *davinci_modes[] = {
+	VID_ENC_STD_NTSC,
+	VID_ENC_STD_NTSC_RGB,
+	VID_ENC_STD_PAL,
+	VID_ENC_STD_PAL_RGB,
+	VID_ENC_STD_720P_25,
+	VID_ENC_STD_720P_30,
+	VID_ENC_STD_720P_50,
+	VID_ENC_STD_720P_60,
+	VID_ENC_STD_1080I_25,
+	VID_ENC_STD_1080I_30,
+	VID_ENC_STD_1080P_24,
+	VID_ENC_STD_1080P_25,
+	VID_ENC_STD_1080P_30,
+	VID_ENC_STD_1080P_50,
+	VID_ENC_STD_1080P_60,
+	VID_ENC_STD_480P_60,
+	VID_ENC_STD_576P_50,
+	VID_ENC_STD_640x480,
+	VID_ENC_STD_640x400,
+	VID_ENC_STD_640x350,
+	""
+};
+EXPORT_SYMBOL(davinci_modes);
+
+void davinci_enc_set_mode_platform(int channel, struct vid_enc_device_mgr *mgr)
+{
+}
+EXPORT_SYMBOL(davinci_enc_set_mode_platform);
+
+/*
+ * davinci_enc_set_display_timing
+ */
+/* This function sets the display timing from the fb_info structure*/
+void davinci_enc_set_display_timing(struct vid_enc_mode_info *mode)
+{
+};
+EXPORT_SYMBOL(davinci_enc_set_display_timing);
+
Index: linux-2.6.18/drivers/media/video/davinci/tvp5147.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/tvp5147.c
@@ -0,0 +1,1654 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* tvp5147.c */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <media/davinci/tvp5147.h>
+#include <asm/arch/video_hdevm.h>
+#include <asm/uaccess.h>
+
+/* Prototypes */
+static int tvp5147_initialize(void *dec, int flag);
+static int tvp5147_deinitialize(void *dec);
+static int tvp5147_setcontrol(struct v4l2_control *ctrl, void *dec);
+static int tvp5147_getcontrol(struct v4l2_control *ctrl, void *dec);
+static int tvp5147_querycontrol(struct v4l2_queryctrl *queryctrl, void *dec);
+static int tvp5147_setstd(v4l2_std_id * id, void *dec);
+static int tvp5147_getstd(v4l2_std_id * id, void *dec);
+static int tvp5147_enumstd(struct v4l2_standard *std, void *dec);
+static int tvp5147_querystd(v4l2_std_id * id, void *dec);
+static int tvp5147_setinput(int *index, void *dec);
+static int tvp5147_getinput(int *index, void *dec);
+static int tvp5147_enuminput(struct v4l2_input *input, void *dec);
+static int tvp5147_setformat(struct v4l2_format *fmt, void *dec);
+static int tvp5147_tryformat(struct v4l2_format *fmt, void *dec);
+static int tvp5147_getformat(struct v4l2_format *fmt, void *dec);
+static int tvp5147_setparams(void *params, void *dec);
+static int tvp5147_getparams(void *params, void *dec);
+static int tvp5147_i2c_read_reg(struct i2c_client *client, u8 reg, u8 *val);
+static int tvp5147_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val);
+static int tvp5147_i2c_attach_client(struct i2c_client *client,
+				     struct i2c_driver *driver,
+				     struct i2c_adapter *adap, int addr);
+static int tvp5147_i2c_detach_client(struct i2c_client *client);
+static int tvp5147A_i2c_probe_adapter(struct i2c_adapter *adap);
+static int tvp5147B_i2c_probe_adapter(struct i2c_adapter *adap);
+static int tvp5147_i2c_init(void);
+static void tvp5147_i2c_cleanup(void);
+static int tvp5147_get_sliced_vbi_cap(struct v4l2_sliced_vbi_cap *cap,
+				      void *dec);
+static int tvp5147_read_vbi_data(struct v4l2_sliced_vbi_data *data, void *dec);
+
+static struct v4l2_standard tvp5147_standards[TVP5147_MAX_NO_STANDARDS] = {
+	{
+	 .index = 0,
+	 .id = V4L2_STD_525_60,
+	 .name = "NTSC",
+	 .frameperiod = {1001, 30000},
+	 .framelines = 525},
+	{
+	 .index = 1,
+	 .id = V4L2_STD_625_50,
+	 .name = "PAL",
+	 .frameperiod = {1, 25},
+	 .framelines = 625},
+	{
+	 .index = 2,
+	 .id = VPFE_STD_AUTO,
+	 .name = "auto detect",
+	 .frameperiod = {1, 1},
+	 .framelines = 1},
+	{
+	 .index = 3,
+	 .id = VPFE_STD_525_60_SQP,
+	 .name = "NTSC-SQP",
+	 .frameperiod = {1001, 30000},
+	 .framelines = 525},
+	{
+	 .index = 4,
+	 .id = VPFE_STD_625_50_SQP,
+	 .name = "PAL-SQP",
+	 .frameperiod = {1, 25},
+	 .framelines = 625},
+	{
+	 .index = 5,
+	 .id = VPFE_STD_AUTO_SQP,
+	 .name = "auto detect sqp pixel",
+	 .frameperiod = {1, 1},
+	 .framelines = 1}
+};
+
+static tvp5147_mode
+    tvp5147_modes[TVP5147_MAX_NO_STANDARDS][TVP5147_MAX_NO_MODES] = {
+	{TVP5147_MODE_NTSC, TVP5147_MODE_NTSC_443, 0xFF},
+	{TVP5147_MODE_PAL, TVP5147_MODE_PAL_M, TVP5147_MODE_PAL_CN},
+	{TVP5147_MODE_AUTO, 0xFF, 0xFF},
+	{TVP5147_MODE_NTSC_SQP, TVP5147_MODE_NTSC_443_SQP, 0xFF},
+	{TVP5147_MODE_PAL_SQP, TVP5147_MODE_PAL_M_SQP,
+	 TVP5147_MODE_PAL_CN_SQP},
+	{TVP5147_MODE_AUTO_SQP, 0xFF, 0xFF}
+};
+
+static struct tvp5147_control_info
+    tvp5147_control_information[TVP5147_MAX_NO_CONTROLS]
+    = {
+	{
+	 .register_address = TVP5147_BRIGHTNESS,
+	 .query_control = {
+			   .id = V4L2_CID_BRIGHTNESS,
+			   .name = "BRIGHTNESS",
+			   .type = V4L2_CTRL_TYPE_INTEGER,
+			   .minimum = 0,
+			   .maximum = 255,
+			   .step = 1,
+			   .default_value = 128}
+	 },
+	{
+	 .register_address = TVP5147_CONTRAST,
+	 .query_control = {
+			   .id = V4L2_CID_CONTRAST,
+			   .name = "CONTRAST",
+			   .type = V4L2_CTRL_TYPE_INTEGER,
+			   .minimum = 0,
+			   .maximum = 255,
+			   .step = 1,
+			   .default_value = 128}
+
+	 },
+	{
+	 .register_address = TVP5147_SATURATION,
+	 .query_control = {
+			   .id = V4L2_CID_SATURATION,
+			   .name = "SATURATION",
+			   .type = V4L2_CTRL_TYPE_INTEGER,
+			   .minimum = 0,
+			   .maximum = 255,
+			   .step = 1,
+			   .default_value = 128}
+	 },
+	{
+	 .register_address = TVP5147_HUE,
+	 .query_control = {
+			   .id = V4L2_CID_HUE,
+			   .name = "HUE",
+			   .type = V4L2_CTRL_TYPE_INTEGER,
+			   .minimum = -128,
+			   .maximum = 127,
+			   .step = 1,
+			   .default_value = 0}
+	 },
+	{
+	 .register_address = TVP5147_AFE_GAIN_CTRL,
+	 .query_control = {
+			   .id = V4L2_CID_AUTOGAIN,
+			   .name = "Automatic Gain Control",
+			   .type = V4L2_CTRL_TYPE_BOOLEAN,
+			   .minimum = 0,
+			   .maximum = 1,
+			   .step = 1,
+			   .default_value = 1}
+	 }
+};
+
+static struct tvp5147_config tvp5147_configuration[TVP5147_NUM_CHANNELS] = {
+	{
+	 .no_of_inputs = TVP5147_MAX_NO_INPUTS,
+	 .input[0] = {
+		      .input_type = TVP5147_COMPOSITE_INPUT,
+		      .lock_mask = 0x0E,
+		      .input_info = {
+				     .index = 0,
+				     .name = "COMPOSITE",
+				     .type = V4L2_INPUT_TYPE_CAMERA,
+				     .std = V4L2_STD_TVP5147_ALL},
+		      .no_of_standard = TVP5147_MAX_NO_STANDARDS,
+		      .standard = (struct v4l2_standard *)tvp5147_standards,
+		      .def_std = VPFE_STD_AUTO,
+		      .mode = (tvp5147_mode(*)[]) & tvp5147_modes,
+		      .no_of_controls = TVP5147_MAX_NO_CONTROLS,
+		      .controls = (struct tvp5147_control_info *)
+		      &tvp5147_control_information},
+	 .sliced_cap = {
+			.service_set = (V4L2_SLICED_CAPTION_525 |
+					V4L2_SLICED_WSS_625 |
+					V4L2_SLICED_CGMS_525),
+			},
+	 .num_services = 0},
+	{
+	 .no_of_inputs = TVP5147_MAX_NO_INPUTS,
+	 .input[0] = {
+		      .input_type = TVP5147_SVIDEO_INPUT,
+		      .lock_mask = 0x06,
+		      .input_info = {
+				     .index = 0,
+				     .name = "SVIDEO",
+				     .type = V4L2_INPUT_TYPE_CAMERA,
+				     .std = V4L2_STD_TVP5147_ALL},
+		      .no_of_standard = TVP5147_MAX_NO_STANDARDS,
+		      .standard = (struct v4l2_standard *)tvp5147_standards,
+		      .def_std = VPFE_STD_AUTO,
+		      .mode = (tvp5147_mode(*)[]) & tvp5147_modes,
+		      .no_of_controls = TVP5147_MAX_NO_CONTROLS,
+		      .controls = (struct tvp5147_control_info *)
+		      &tvp5147_control_information},
+	 .sliced_cap = {.service_set = (V4L2_SLICED_CAPTION_525 |
+					V4L2_SLICED_WSS_625 |
+					V4L2_SLICED_CGMS_525),
+			},
+	 .num_services = 0}
+};
+
+static struct tvp5147_service_data_reg tvp5147_services_regs
+    [TVP5147_VBI_NUM_SERVICES] = {
+	{
+	 .service = V4L2_SLICED_WSS_625,
+	 .field[0].addr = {0x20, 0x05, 0x80},
+	 .field[1].addr = {0x24, 0x05, 0x80},
+	 .bytestoread = 2},
+	{
+	 .service = V4L2_SLICED_CAPTION_525,
+	 .field[0].addr = {0x1C, 0x05, 0x80},
+	 .field[1].addr = {0x1E, 0x05, 0x80},
+	 .bytestoread = 2},
+	{
+	 .service = V4L2_SLICED_CGMS_525,
+	 .field[0].addr = {0x20, 0x05, 0x80},
+	 .field[1].addr = {0x24, 0x05, 0x80},
+	 .bytestoread = 3},
+};
+
+static struct tvp5147_sliced_reg tvp5147_sliced_regs[TVP5147_VBI_NUM_SERVICES] = {
+	{
+	 .service = V4L2_SLICED_CAPTION_525,
+	 .std = V4L2_STD_525_60,
+	 .line_addr_value = 0x15,
+	 .line_start = 19,
+	 .line_end = 23,
+	 .field[0] = {
+		      .fifo_line_addr = {0x00, 0x06, 0x80},
+		      .fifo_mode_value = 0x01},
+	 .field[1] = {
+		      .fifo_line_addr = {0x02, 0x06, 0x80},
+		      .fifo_mode_value = 0x09},
+	 .service_line = {{21, 21}, {21, 284} }
+	 },
+	{
+	 .service = V4L2_SLICED_WSS_625,
+	 .std = V4L2_STD_625_50,
+	 .line_addr_value = 0x17,
+	 .line_start = 21,
+	 .line_end = 25,
+	 .field[0] = {
+		      .fifo_line_addr = {0x04, 0x06, 0x80},
+		      .fifo_mode_value = 0x02},
+	 .field[1] = {
+		      .fifo_line_addr = {0x04, 0x06, 0x80},
+		      .fifo_mode_value = 0x02},
+	 .service_line = {{23, 23}, {0, 0} }
+	 },
+	{
+	 .service = V4L2_SLICED_CGMS_525,
+	 .std = V4L2_STD_525_60,
+	 .line_addr_value = 0x14,
+	 .line_start = 18,
+	 .line_end = 22,
+	 .field[0] = {
+		      .fifo_line_addr = {0x08, 0x06, 0x80},
+		      .fifo_mode_value = 0x02},
+	 .field[1] = {
+		      .fifo_line_addr = {0x06, 0x06, 0x80},
+		      .fifo_mode_value = 0x02},
+	 .service_line = {{20, 20}, {20, 283} }
+	 }
+};
+
+static struct tvp5147_channel tvp5147_channel_info[TVP5147_NUM_CHANNELS] = {
+	{
+	 .params.inputidx = 0,
+	 .params.std = VPFE_STD_AUTO,
+	 .i2c_dev = {
+		     .i2c_addr = (0xBA >> 1),
+		     .i2c_registration = 0},
+	 .dec_device = NULL},
+	{
+	 .params.inputidx = 0,
+	 .params.std = VPFE_STD_AUTO,
+	 .i2c_dev = {
+		     .i2c_addr = (0xB8 >> 1),
+		     .i2c_registration = 0},
+	 .dec_device = NULL}
+};
+
+/* Global variables */
+static struct param_ops params_ops = {
+	.setparams = tvp5147_setparams,
+	.getparams = tvp5147_getparams
+};
+static struct control_ops controls_ops = {
+	.count = TVP5147_MAX_NO_CONTROLS,
+	.queryctrl = tvp5147_querycontrol,
+	.setcontrol = tvp5147_setcontrol,
+	.getcontrol = tvp5147_getcontrol
+};
+
+static struct input_ops inputs_ops = {
+	.count = TVP5147_MAX_NO_INPUTS,
+	.enuminput = tvp5147_enuminput,
+	.setinput = tvp5147_setinput,
+	.getinput = tvp5147_getinput
+};
+static struct standard_ops standards_ops = {
+	.count = TVP5147_MAX_NO_STANDARDS,
+	.setstd = tvp5147_setstd,
+	.getstd = tvp5147_getstd,
+	.enumstd = tvp5147_enumstd,
+	.querystd = tvp5147_querystd,
+};
+static struct format_ops formats_ops = {
+	.count = 0,
+	.enumformat = NULL,
+	.setformat = tvp5147_setformat,
+	.getformat = tvp5147_getformat,
+	.tryformat = tvp5147_tryformat,
+};
+
+static struct device *tvp5147_i2c_dev[TVP5147_NUM_CHANNELS];
+static struct decoder_device dec_dev[TVP5147_NUM_CHANNELS] = {
+	{
+	 .name = "TVP5147",
+	 .if_type = INTERFACE_TYPE_BT656,
+	 .channel_id = 0,
+	 .capabilities = V4L2_CAP_SLICED_VBI_CAPTURE | V4L2_CAP_VBI_CAPTURE,
+	 .initialize = tvp5147_initialize,
+	 .std_ops = &standards_ops,
+	 .ctrl_ops = &controls_ops,
+	 .input_ops = &inputs_ops,
+	 .fmt_ops = &formats_ops,
+	 .params_ops = &params_ops,
+	 .deinitialize = tvp5147_deinitialize,
+	 .get_sliced_vbi_cap = tvp5147_get_sliced_vbi_cap,
+	 .read_vbi_data = tvp5147_read_vbi_data},
+	{
+	 .name = "TVP5147",
+	 .if_type = INTERFACE_TYPE_BT656,
+	 .channel_id = 1,
+	 .capabilities = V4L2_CAP_SLICED_VBI_CAPTURE | V4L2_CAP_VBI_CAPTURE,
+	 .initialize = tvp5147_initialize,
+	 .std_ops = &standards_ops,
+	 .ctrl_ops = &controls_ops,
+	 .input_ops = &inputs_ops,
+	 .fmt_ops = &formats_ops,
+	 .params_ops = &params_ops,
+	 .deinitialize = tvp5147_deinitialize,
+	 .get_sliced_vbi_cap = tvp5147_get_sliced_vbi_cap,
+	 .read_vbi_data = tvp5147_read_vbi_data}
+};
+
+static u8 tvp5147_after_reset_reg[][2] = {
+	{0xE8, 0x02},
+	{0xE9, 0x00},
+	{0xEA, 0x80},
+	{0xE0, 0x01},
+	{0xE8, 0x60},
+	{0xE9, 0x00},
+	{0xEA, 0xB0},
+	{0xE0, 0x01},
+	{0xE8, 0x16},
+	{0xE9, 0x00},
+	{0xEA, 0xA0},
+	{0xE0, 0x16},
+	{0xE8, 0x60},
+	{0xE9, 0x00},
+	{0xEA, 0xB0},
+	{0xE0, 0x00}
+};
+
+/* tvp5147_init :
+ * This function called by vpif driver to initialize the decoder with default
+ * values
+ */
+static int tvp5147_initialize(void *dec, int flag)
+{
+	int err = 0, i;
+	int ch_id;
+	int index;
+	struct i2c_client *i2c_client;
+	v4l2_std_id std;
+	if (NULL == dec) {
+		printk("dec:NULL pointer");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	if (tvp5147_channel_info[ch_id].i2c_dev.i2c_registration & 0x01) {
+		printk("tvp5147 driver is already initialized..\n");
+		return  -EINVAL;
+	}
+	i2c_client = &tvp5147_channel_info[ch_id].i2c_dev.client;
+
+	/* Register tvp5147 I2C client */
+	err = i2c_add_driver(&tvp5147_channel_info[ch_id].i2c_dev.driver);
+	if (err) {
+		printk("Failed to register TVP5147 I2C client.\n");
+		return -EINVAL;
+	}
+	try_module_get(THIS_MODULE);
+	tvp5147_channel_info[ch_id].i2c_dev.i2c_registration |= 1;
+	tvp5147_channel_info[ch_id].dec_device = (struct decoder_device *)dec;
+	if (DECODER_I2C_BIND_FLAG == flag) {
+		/* check that decoder is set with default values once or not,
+		 * if yes return, if not continue */
+		if (tvp5147_channel_info[ch_id].i2c_dev.i2c_registration & 0x02)
+			return err;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id) {
+		err = set_cpld_for_tvp5147();
+		if (err) {
+		    printk("Failed to set cpld bit.\n");
+		    return -EINVAL;
+		}
+	}
+
+	dev_dbg(tvp5147_i2c_dev[ch_id],
+		"Starting default settings tvp5147..\n");
+
+	/* Reset TVP5147 */
+	err = tvp5147_i2c_write_reg(i2c_client, TVP5147_OPERATION_MODE,
+				     TVP5147_OPERATION_MODE_RESET);
+
+	/*Put _tvp5147 in normal power mode */
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OPERATION_MODE,
+				     TVP5147_OPERATION_MODE_DEFAULT);
+
+	for (i = 0; i < 16; i++) {
+		err |= tvp5147_i2c_write_reg(i2c_client,
+					     tvp5147_after_reset_reg[i][0],
+					     tvp5147_after_reset_reg[i]
+					     [1]);
+	}
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_AFE_GAIN_CTRL,
+				     TVP5147_AFE_GAIN_CTRL_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_COLOR_KILLER,
+				     TVP5147_COLOR_KILLER_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_LUMA_CONTROL1,
+				     TVP5147_LUMA_CONTROL1_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_LUMA_CONTROL2,
+				     TVP5147_LUMA_CONTROL2_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_LUMA_CONTROL3,
+				     TVP5147_LUMA_CONTROL3_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_BRIGHTNESS,
+				     TVP5147_BRIGHTNESS_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_CONTRAST,
+				     TVP5147_CONTRAST_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_SATURATION,
+				     TVP5147_SATURATION_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_HUE,
+				     TVP5147_HUE_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_CHROMA_CONTROL1,
+				     TVP5147_CHROMA_CONTROL1_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_CHROMA_CONTROL2,
+				     TVP5147_CHROMA_CONTROL2_DEFAULT);
+
+	/* Configuration for 8-bit BT656 mode */
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OUTPUT5,
+				     TVP5147_OUTPUT5_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OUTPUT6,
+				     TVP5147_OUTPUT6_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OUTPUT1,
+				     TVP5147_OUTPUT1_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OUTPUT2,
+				     TVP5147_OUTPUT2_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OUTPUT3,
+				     TVP5147_OUTPUT3_DEFAULT);
+	err |= tvp5147_i2c_write_reg(i2c_client, TVP5147_OUTPUT4,
+				     TVP5147_OUTPUT4_DEFAULT);
+
+	/* Call setinput for setting default input */
+	index = 0;
+	err |= tvp5147_setinput(&index, dec);
+	if (err < 0) {
+		err = -EINVAL;
+		tvp5147_deinitialize(dec);
+		return err;
+	}
+
+	/* call set standard to set default standard */
+	std = tvp5147_configuration[ch_id].input[index].def_std;
+	err |= tvp5147_setstd(&std, dec);
+	err = tvp5147_querystd(&std, dec);
+	if (err < 0) {
+		err = -EINVAL;
+		tvp5147_deinitialize(dec);
+		return err;
+	}
+	tvp5147_channel_info[ch_id].i2c_dev.i2c_registration |= 0x2;
+	return err;
+}
+static int tvp5147_deinitialize(void *dec)
+{
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Tvp5147 ch deinitialization"
+		" called\n");
+	if (tvp5147_channel_info[ch_id].i2c_dev.i2c_registration & 0x01) {
+		i2c_del_driver(&tvp5147_channel_info[ch_id].i2c_dev.driver);
+		module_put(THIS_MODULE);
+		tvp5147_channel_info[ch_id].i2c_dev.client.adapter = NULL;
+		tvp5147_channel_info[ch_id].i2c_dev.i2c_registration &= ~(0x01);
+		tvp5147_channel_info[ch_id].dec_device = NULL;
+	}
+	return 0;
+}
+
+/* tvp5147_setcontrol :
+ * Function to set the control parameters
+ */
+static int tvp5147_setcontrol(struct v4l2_control *ctrl, void *dec)
+{
+	int err = 0;
+	int value;
+	int ch_id;
+	int i = 0;
+	int input_idx;
+	struct tvp5147_control_info *control = NULL;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id) {
+		err = set_cpld_for_tvp5147();
+		if (err) {
+			printk("Failed to set cpld bit.\n");
+			return -EINVAL;
+		}
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	input_idx = tvp5147_channel_info[ch_id].params.inputidx;
+
+	/* check for null pointer */
+	if (ctrl == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL pointer\n");
+		return -EINVAL;
+	}
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Starting setctrl...\n");
+	value = (__s32) ctrl->value;
+	for (i = 0; i < tvp5147_configuration[ch_id].input[input_idx].
+	     no_of_controls; i++) {
+		control = &tvp5147_configuration[ch_id].input[input_idx].
+		    controls[i];
+		if ((control->query_control).id == ctrl->id) {
+			break;
+		}
+	}
+	if (i == tvp5147_configuration[ch_id].input[input_idx].no_of_controls)
+		return -EINVAL;
+
+	if (V4L2_CID_AUTOGAIN == ctrl->id) {
+		if (value == 1) {
+			value = 0xF;
+		} else if (value == 0) {
+			value = 0xC;
+		} else {
+			return -EINVAL;
+		}
+	} else {
+		if (((control->query_control).minimum > value)
+		    || ((control->query_control).maximum < value)) {
+			return -EINVAL;
+		}
+	}
+	err = tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, control->register_address, value);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id],
+			"TVP5147 set control fails...\n");
+		return err;
+	}
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of setcontrol...\n");
+	return err;
+}
+
+/* tvp5147_getcontrol :
+ * Function to get the control parameters
+ */
+static int tvp5147_getcontrol(struct v4l2_control *ctrl, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	int i = 0;
+	struct tvp5147_control_info *control = NULL;
+	int input_idx;
+	u8 val;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id) {
+		err = set_cpld_for_tvp5147();
+		if (err) {
+			printk("Failed to set cpld bit.\n");
+			return -EINVAL;
+		}
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Starting getctrl of TVP5147...\n");
+	input_idx = tvp5147_channel_info[ch_id].params.inputidx;
+
+	/* check for null pointer */
+	if (ctrl == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL pointer\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < tvp5147_configuration[ch_id].input[input_idx].
+	     no_of_controls; i++) {
+		control = &tvp5147_configuration[ch_id].input[input_idx].
+		    controls[i];
+		if ((control->query_control).id == ctrl->id) {
+			break;
+		}
+	}
+	if (i == tvp5147_configuration[ch_id].input[input_idx].no_of_controls) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Invalid id...\n");
+		return -EINVAL;
+	}
+	err = tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				   client, control->register_address, &val);
+	ctrl->value = (int)val;
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id],
+			"TVP5147 get control fails...\n");
+		return err;
+	}
+	if (V4L2_CID_AUTOGAIN == ctrl->id) {
+		if ((ctrl->value & 0x3) == 3) {
+			ctrl->value = 1;
+		} else {
+			ctrl->value = 0;
+		}
+	}
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of tvp5147_getcontrol...\n");
+	return err;
+}
+
+/* This function is used to write the vbi data to the decoder device */
+static int tvp5147_read_vbi_data(struct v4l2_sliced_vbi_data *data, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	int i = 0, j, k;
+	unsigned char value;
+	u8 num_services;
+
+	if (NULL == dec) {
+		printk("tvp5147_write_vbi_data:NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "tvp5147_write_vbi_data:"
+		"Start of tvp5147_write_vbi_data..\n");
+	if (data == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_write_vbi_data:"
+			"NULL pointer.\n");
+		return -EINVAL;
+	}
+	num_services = tvp5147_configuration[ch_id].num_services;
+	for (i = 0; i < num_services; i++) {
+		if (0 == data[i].id)
+			continue;
+		if ((data[i].id | tvp5147_channel_info[ch_id].
+		     params.fmt.fmt.sliced.service_set) !=
+		    tvp5147_channel_info[ch_id].
+		    params.fmt.fmt.sliced.service_set) {
+			return -EINVAL;
+		}
+
+		for (j = 0; j < TVP5147_VBI_NUM_SERVICES; j++) {
+			if (!(tvp5147_services_regs[j].service & data[i].id))
+				continue;
+			for (k = 0; k < 3; k++)
+				tvp5147_i2c_write_reg(&tvp5147_channel_info
+						      [ch_id].i2c_dev.client,
+						      TVP5147_VBUS_ADDRESS_ACCESS0
+						      + k,
+						      tvp5147_services_regs[j].
+						      field[data[i].field].
+						      addr[k]);
+
+			for (k = 0; k <
+			     tvp5147_services_regs[j].bytestoread; k++) {
+				tvp5147_i2c_read_reg(&tvp5147_channel_info
+						     [ch_id].i2c_dev.client,
+						     TVP5147_VBUS_DATA_ACCESS_AUTO_INCR,
+						     &value);
+				data[i].data[k] = value;
+			}
+		}
+	}
+	dev_dbg(tvp5147_i2c_dev[ch_id], "</tvp5147_write_vbi_data>\n");
+	return err;
+}
+
+/* This function is used to get the sliced vbi services supported
+   by the decoder device */
+static int tvp5147_get_sliced_vbi_cap(struct v4l2_sliced_vbi_cap *cap,
+				      void *dec)
+{
+	int ch_id;
+
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Start of "
+		"tvp5147_get_sliced_vbi_cap\n");
+	if (cap == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id],
+			"tvp5147_get_sliced_vbi_cap:" "NULL pointer\n");
+		return -EINVAL;
+	}
+	*cap = tvp5147_configuration[ch_id].sliced_cap;
+	return 0;
+}
+
+/* tvp5147_querycontrol :
+ * Function to query control parameters
+ */
+static int tvp5147_querycontrol(struct v4l2_queryctrl *ctrl, void *dec)
+{
+	int err = 0;
+	int id;
+	int ch_id;
+	int i = 0;
+	struct tvp5147_control_info *control = NULL;
+	int input_idx;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Starting tvp5147_queryctrl...\n");
+	input_idx = tvp5147_channel_info[ch_id].params.inputidx;
+	if (ctrl == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL Pointer\n");
+		return -EINVAL;
+	}
+	id = ctrl->id;
+	memset(ctrl, 0, sizeof(struct v4l2_queryctrl));
+	ctrl->id = id;
+	for (i = 0; i < tvp5147_configuration[ch_id].input[input_idx].
+	     no_of_controls; i++) {
+		control = &tvp5147_configuration[ch_id].input[input_idx].
+		    controls[i];
+		if ((control->query_control).id == ctrl->id) {
+			break;
+		}
+	}
+	if (i == tvp5147_configuration[ch_id].input[input_idx].no_of_controls) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Invalid id...\n");
+		return -EINVAL;
+	}
+	memcpy(ctrl, &control->query_control, sizeof(struct v4l2_queryctrl));
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of tvp5147_querycontrol...\n");
+	return err;
+}
+
+static int tvp5147_raw_vbi_setformat(struct v4l2_vbi_format *fmt)
+{
+	/* TBD */
+    return 0;
+}
+
+static int tvp5147_sliced_vbi_setformat(struct v4l2_sliced_vbi_format *fmt,
+					void *dec)
+{
+	int ch_id, i, j, k, index;
+	u16 val;
+	u8 num_services = 0;
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	if ((fmt->service_set |
+	     tvp5147_configuration[ch_id].sliced_cap.service_set) !=
+	    tvp5147_configuration[ch_id].sliced_cap.service_set) {
+		dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_setformat:"
+			"Invalid service\n");
+		return -EINVAL;
+	}
+	memset(fmt->service_lines, 0, 2 * 24 * 2);
+	for (i = 0; i < TVP5147_VBI_NUM_SERVICES; i++) {
+		if ((fmt->service_set & tvp5147_sliced_regs[i].service) &&
+		    !(tvp5147_sliced_regs[i].std &
+		      tvp5147_channel_info[ch_id].params.std)) {
+			dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_setformat:"
+				"Invalid service for this standard\n");
+			return -EINVAL;
+		}
+
+		if (tvp5147_sliced_regs[i].std &
+		    tvp5147_channel_info[ch_id].params.std) {
+			for (j = 0; j < 2; j++) {
+				for (k = 0; k < 3; k++)
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VBUS_ADDRESS_ACCESS0 + k,
+					     tvp5147_sliced_regs[i].field[j].
+					     fifo_line_addr[k]);
+
+				if (fmt->service_set &
+				    tvp5147_sliced_regs[i].service) {
+					num_services++;
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VBUS_DATA_ACCESS_AUTO_INCR,
+					     tvp5147_sliced_regs[i].
+					     line_addr_value);
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VBUS_DATA_ACCESS_AUTO_INCR,
+					     tvp5147_sliced_regs[i].field[j].
+					     fifo_mode_value);
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VDP_LINE_START,
+					     tvp5147_sliced_regs[i].line_start);
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VDP_LINE_STOP,
+					     tvp5147_sliced_regs[i].line_end);
+					for (k = 0; k < 2; k++) {
+						index = tvp5147_sliced_regs[i].
+						    service_line[k].index;
+						val = tvp5147_sliced_regs[i].
+						    service_line[k].value;
+						fmt->service_lines[k][index] =
+						    val;
+					}
+				} else {
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VBUS_DATA_ACCESS_AUTO_INCR,
+					     TVP5147_LINE_ADDRESS_DEFAULT);
+					tvp5147_i2c_write_reg
+					    (&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_VBUS_DATA_ACCESS_AUTO_INCR,
+					     TVP5147_LINE_MODE_DEFAULT);
+				}
+			}
+		}
+	}
+	fmt->io_size = (TVP5147_SLICED_BUF_SIZE * num_services) / 2;
+	tvp5147_configuration[ch_id].num_services = num_services / 2;
+	return num_services / 2;
+}
+
+/*  tvp5147_setformat :
+ * This function is used to set sliced vbi services
+ */
+static int tvp5147_setformat(struct v4l2_format *fmtp, void *dec)
+{
+	int err = 0, ch_id;
+	struct v4l2_sliced_vbi_format fmta;
+	struct v4l2_vbi_format fmtb;
+	if (NULL == dec || NULL == fmtp) {
+		printk("tvp5147_setformat:NULL Pointer\n");
+		return -EINVAL;
+	}
+	if ((V4L2_BUF_TYPE_VIDEO_CAPTURE != fmtp->type) &&
+	    (V4L2_BUF_TYPE_VBI_CAPTURE != fmtp->type) &&
+	    (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE != fmtp->type))
+		return -EINVAL;
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+
+	if (V4L2_BUF_TYPE_SLICED_VBI_CAPTURE == fmtp->type) {
+		fmta = fmtp->fmt.sliced;
+		err = tvp5147_sliced_vbi_setformat(&fmta, dec);
+	} else {
+		fmtb = fmtp->fmt.vbi;
+		err = tvp5147_raw_vbi_setformat(&fmtb);
+	}
+
+	tvp5147_channel_info[ch_id].params.fmt = *fmtp;
+	dev_dbg(tvp5147_i2c_dev[ch_id],
+		"tvp5147_setformat:End of" " tvp5147_querycontrol...\n");
+	return err;
+}
+
+/* tvp5147_getformat:
+ * This function is used to set sliced vbi services
+ */
+static int tvp5147_getformat(struct v4l2_format *fmtp, void *dec)
+{
+	int err = 0;
+	int ch_id;
+
+	if (NULL == dec || NULL == fmtp) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "tvp5147_getformat:"
+		"Starting getformat function.\n");
+
+	/* Read sliced vbi format */
+	fmtp->fmt.sliced = tvp5147_channel_info[ch_id].params.fmt.fmt.sliced;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "tvp5147_getformat:"
+		"End of getformat function.\n");
+	return err;
+}
+
+/* tvp5147_tryformat:
+ * This function is used to set sliced vbi services
+ */
+static int tvp5147_tryformat(struct v4l2_format *fmtp, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	int i = 0;
+	struct v4l2_sliced_vbi_format *fmt;
+	int num_services = 0;
+
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "tvp5147_tryformat:"
+		"Start of tvp5147_tryformat..\n");
+	if (fmtp == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_tryformat:"
+			"NULL pointer\n");
+		return -EINVAL;
+	}
+	fmt = &(fmtp->fmt.sliced);
+	if ((fmt->service_set |
+	     tvp5147_configuration[ch_id].sliced_cap.service_set) !=
+	    tvp5147_configuration[ch_id].sliced_cap.service_set) {
+		fmt->service_set =
+		    tvp5147_configuration[ch_id].sliced_cap.service_set;
+		dev_err(tvp5147_i2c_dev[ch_id], "Invalid service\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < TVP5147_VBI_NUM_SERVICES; i++) {
+		if (((tvp5147_sliced_regs[i].service & fmt->service_set) ==
+		     tvp5147_sliced_regs[i].service) &&
+		    (tvp5147_channel_info[ch_id].params.std
+		     != tvp5147_sliced_regs[i].std)) {
+			dev_err(tvp5147_i2c_dev[ch_id],
+				"service not supported for the standard\n");
+			return -EINVAL;
+		}
+	}
+	num_services = 0;
+	for (i = 0; i < TVP5147_VBI_NUM_SERVICES; i++) {
+		if (tvp5147_sliced_regs[i].service & fmt->service_set)
+			num_services++;
+	}
+	fmt->io_size = num_services * TVP5147_SLICED_BUF_SIZE;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "</tvp5147_tryformat>\n");
+	return err;
+}
+
+/* tvp5147_setstd :
+ * This function is used to configure TVP5147 for video standard passed
+ * by application
+ */
+static int tvp5147_setstd(v4l2_std_id * id, void *dec)
+{
+	int err = 0;
+	unsigned char output1;
+	int ch_id;
+	int i = 0;
+	struct v4l2_standard *standard;
+	int input_idx;
+	struct v4l2_sliced_vbi_format fmt;
+
+	tvp5147_mode mode = TVP5147_MODE_INV;
+	v4l2_std_id std;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id) {
+		err = set_cpld_for_tvp5147();
+		if (err) {
+			printk("Failed to set cpld bit.\n");
+			return -EINVAL;
+		}
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Start of tvp5147_setstd..\n");
+	input_idx = tvp5147_channel_info[ch_id].params.inputidx;
+	if (id == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL pointer.\n");
+		return -EINVAL;
+	}
+	std = *id;
+	for (i = 0; i < tvp5147_configuration[ch_id].input[input_idx].
+	     no_of_standard; i++) {
+		standard = &(tvp5147_configuration[ch_id].input[input_idx].
+			     standard[i]);
+		if (standard->id & std) {
+			break;
+		}
+	}
+	if (i == tvp5147_configuration[ch_id].input[input_idx].no_of_standard) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Invalid id...\n");
+		return -EINVAL;
+	}
+	mode = tvp5147_configuration[ch_id].input[input_idx].mode[i][0];
+
+	/* for square pixel */
+	err |= tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_OUTPUT1, &output1);
+	if (err < 0) {
+		return err;
+	}
+	output1 |= ((mode & 0x8) << 4);
+	err |= tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				     client, TVP5147_OUTPUT1, output1);
+
+	/* setup the video standard */
+	err |= tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				     client, TVP5147_VIDEO_STD, (mode & 0x07));
+
+	/* if autoswitch mode, enable all modes for autoswitch */
+	if ((mode & 0x07) == TVP5147_MODE_AUTO) {
+		err |= tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].
+					     i2c_dev.client,
+					     TVP5147_AUTOSWT_MASK,
+					     TVP5147_AUTOSWITCH_MASK);
+	}
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Set standard failed\n");
+		return err;
+	}
+	tvp5147_channel_info[ch_id].params.std = *id;
+	if (*id == VPFE_STD_AUTO || *id == VPFE_STD_AUTO_SQP) {
+		err = tvp5147_querystd(id, dec);
+	}
+	/* disable all vbi services */
+	fmt.service_set = 0;
+	tvp5147_sliced_vbi_setformat(&fmt, dec);
+
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of tvp5147 set standard...\n");
+	return err;
+}
+
+/* tvp5147_getstd :
+ * Function to get the video standard
+ */
+static int tvp5147_getstd(v4l2_std_id * id, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Starting getstd function..\n");
+	if (id == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL Pointer\n");
+		return -EINVAL;
+	}
+	*id = tvp5147_channel_info[ch_id].params.std;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of tvp5147_getstd function\n");
+	return err;
+}
+
+/* tvp5147_enumstd :
+ * Function to enumerate standards supported
+ */
+static int tvp5147_enumstd(struct v4l2_standard *std, void *dec)
+{
+	int index, index1;
+	int err = 0;
+	int ch_id;
+	int input_idx, sumstd = 0;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	if (std == NULL) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	index = std->index;
+	index1 = index;
+	/* Check for valid value of index */
+	for (input_idx = 0;
+	     input_idx < tvp5147_configuration[ch_id].no_of_inputs;
+	     input_idx++) {
+		sumstd +=
+		    tvp5147_configuration[ch_id].input[input_idx].
+		    no_of_standard;
+		if (index < sumstd) {
+			sumstd -= tvp5147_configuration[ch_id].
+			    input[input_idx].no_of_standard;
+			break;
+		}
+	}
+	if (input_idx == tvp5147_configuration[ch_id].no_of_inputs)
+		return -EINVAL;
+	index -= sumstd;
+	memset(std, 0, sizeof(*std));
+	memcpy(std, &tvp5147_configuration[ch_id].input[input_idx].
+	       standard[index], sizeof(struct v4l2_standard));
+	std->index = index1;
+	return err;
+}
+
+/* tvp5147_querystd :
+ *
+ * Function to return standard detected by decoder
+ */
+static int tvp5147_querystd(v4l2_std_id * id, void *dec)
+{
+	int err = 0;
+
+	unsigned char std;
+	int ch_id;
+	unsigned char output1 = 0;
+	int i = 0, j = 0;
+	unsigned char lock_status = 0xFF;
+	int input_idx, flag = 1;
+	struct v4l2_sliced_vbi_format fmt;
+
+	tvp5147_mode mode;
+	u8 lock_mask;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id) {
+		err = set_cpld_for_tvp5147();
+		if (err) {
+			printk("Failed to set cpld bit.\n");
+			return -EINVAL;
+		}
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id],
+		"Start of tvp5147 standard detection.\n");
+	input_idx = tvp5147_channel_info[ch_id].params.inputidx;
+	if (id == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL Pointer\n");
+		return -EINVAL;
+	}
+	err = tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				   client, TVP5147_VIDEO_STD, &std);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Standard detection failed\n");
+		return err;
+	}
+
+	std &= 0x7;
+	if (std == TVP5147_MODE_AUTO) {
+
+		err |= tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].
+					    i2c_dev.client,
+					    TVP5147_VID_STD_STATUS, &std);
+	}
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Standard detection failed\n");
+		return err;
+	}
+
+	/* to keep standard without square pixel */
+	std &= 0x7;
+
+	/* for square pixel */
+	err |=
+	    tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				 client, TVP5147_OUTPUT1, &output1);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id],
+			"Setting square pixel failed.\n");
+		return err;
+	}
+	mode = std | ((output1 & 0x80) >> 4);	/* square pixel status */
+
+	/* check lock status */
+	err |= tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_STATUS1, &lock_status);
+	if (err < 0) {
+		return err;
+	}
+	err = -EAGAIN;
+	lock_mask = tvp5147_configuration[ch_id].input[input_idx].lock_mask;
+	if (lock_mask != (lock_status & lock_mask)) {
+		return err;
+	}
+	for (i = 0; i < tvp5147_configuration[ch_id].input[input_idx].
+	     no_of_standard; i++) {
+		for (j = 0; j < TVP5147_MAX_NO_MODES; j++) {
+			if (mode == tvp5147_configuration[ch_id].
+			    input[input_idx].mode[i][j]) {
+				flag = 0;
+				break;
+			}
+		}
+		if (!flag)
+			break;
+	}
+
+	if ((i == tvp5147_configuration[ch_id].input[input_idx].
+	     no_of_standard) && (TVP5147_MAX_NO_MODES == j)) {
+		dev_err(tvp5147_i2c_dev[ch_id],
+			"tvp5147_querystd:Invalid std\n");
+		return -EINVAL;
+	}
+	*id = tvp5147_configuration[ch_id].input[input_idx].standard[i].id;
+	tvp5147_channel_info[ch_id].params.std = *id;
+
+	/* disable all vbi services */
+	fmt.service_set = 0;
+	tvp5147_sliced_vbi_setformat(&fmt, dec);
+
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of detection...\n");
+	return 0;
+}
+
+/* tvp5147_setinput:
+ * Function to set the input
+ */
+static int tvp5147_setinput(int *index, void *dec)
+{
+	int err = 0;
+	unsigned char input_sel;
+	int ch_id;
+	u8 status;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id) {
+		err = set_cpld_for_tvp5147();
+		if (err) {
+			printk("Failed to set cpld bit.\n");
+			return -EINVAL;
+		}
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Start of set input function\n");
+
+	/* check for null pointer */
+	if (index == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL Pointer\n");
+		return -EINVAL;
+	}
+	if ((*index >= tvp5147_configuration[ch_id].no_of_inputs)
+	    || (*index < 0)) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Invalid Index.\n");
+		return -EINVAL;
+	}
+	input_sel = tvp5147_configuration[ch_id].input[*index].input_type;
+	err = tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_INPUT_SEL, input_sel);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "Set input failed\n");
+		return -EINVAL;
+	}
+	mdelay(500);
+	err = tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_CLEAR_LOST_LOCK, 0x01);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_getinput:error "
+			"writing  clear lost lock register\n");
+		return err;
+	}
+
+	/* wait here so that if lock is lost, it can be detected */
+	mdelay(500);
+	err |= tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_STATUS1, &status);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_getinput:error "
+			"reading status register\n");
+		return -EINVAL;
+	}
+	if (TVP5147_LOST_LOCK_MASK == (status & TVP5147_LOST_LOCK_MASK)) {
+		return -EINVAL;
+	}
+	tvp5147_channel_info[ch_id].params.inputidx = *index;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of set input function\n");
+	return err;
+}
+
+/* tvp5147_getinput :
+ * Function to get the input
+ */
+static int tvp5147_getinput(int *index, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	unsigned char input_sel;
+
+	unsigned char status;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (0 == ((struct decoder_device *)dec)->channel_id) {
+		err = set_cpld_for_tvp5147();
+		if (err) {
+			printk("Failed to set cpld bit.\n");
+			return -EINVAL;
+		}
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "Start of get input function.\n");
+
+	/* check for null pointer */
+	if (index == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL Pointer\n");
+		return -EINVAL;
+	}
+	input_sel = tvp5147_configuration[ch_id].input[0].input_type;
+	err = tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_INPUT_SEL, input_sel);
+	mdelay(500);
+	if (err < 0) {
+		return err;
+	}
+	err = tvp5147_i2c_write_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_CLEAR_LOST_LOCK, 0x01);
+	if (err < 0) {
+		return err;
+	}
+
+	/* wait here so that if lock is lost, it can be detected */
+	mdelay(500);
+	err |= tvp5147_i2c_read_reg(&tvp5147_channel_info[ch_id].i2c_dev.
+				    client, TVP5147_STATUS1, &status);
+	if (err < 0) {
+		dev_err(tvp5147_i2c_dev[ch_id], "tvp5147_getinput:error "
+			"reading status register\n");
+		return -EINVAL;
+	}
+	if (TVP5147_LOST_LOCK_MASK == (status & TVP5147_LOST_LOCK_MASK)) {
+		return -EINVAL;
+	}
+	*index = 0;
+
+	/* Store the input type in index */
+	tvp5147_channel_info[ch_id].params.inputidx = *index;
+	dev_dbg(tvp5147_i2c_dev[ch_id], "End of tvp5147_getinput.\n");
+	return 0;
+}
+
+/* tvp5147_enuminput :
+ * Function to enumerate the input
+ */
+static int tvp5147_enuminput(struct v4l2_input *input, void *dec)
+{
+	int err = 0;
+	int index = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+
+	/* check for null pointer */
+	if (input == NULL) {
+		dev_err(tvp5147_i2c_dev[ch_id], "NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	/* Only one input is available */
+	if (input->index >= tvp5147_configuration[ch_id].no_of_inputs) {
+		return -EINVAL;
+	}
+	index = input->index;
+	memset(input, 0, sizeof(*input));
+	input->index = index;
+	memcpy(input,
+	       &tvp5147_configuration[ch_id].input[index].input_info,
+	       sizeof(struct v4l2_input));
+	return err;
+}
+
+/* tvp5147_setparams :
+ * Function to set the parameters for tvp5147
+ */
+static int tvp5147_setparams(void *params, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	tvp5147_params tvp5147params;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	if (copy_from_user(&tvp5147params, (tvp5147_params *) params,
+			   sizeof(tvp5147params)))
+		return -EFAULT;
+
+	if (0 == ((struct decoder_device *)dec)->channel_id) {
+		err = set_cpld_for_tvp5147();
+		if (err) {
+			printk("Failed to set cpld bit.\n");
+			return -EINVAL;
+		}
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+
+	err |= tvp5147_setinput(&(tvp5147params.inputidx), dec);
+	if (err < 0) {
+		return err;
+	}
+	err |= tvp5147_setstd(&(tvp5147params.std), dec);
+	if (err < 0) {
+		return err;
+	}
+	err |= tvp5147_setformat(&(tvp5147params.fmt), dec);
+	if (err < 0) {
+		return err;
+	}
+	tvp5147_channel_info[ch_id].params = tvp5147params;
+	return err;
+}
+
+/*  tvp5147_getparams :
+ *  Function to get the parameters for tvp5147
+ */
+static int tvp5147_getparams(void *params, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	tvp5147_params *tvp5147params = (tvp5147_params *) params;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+
+	if (copy_to_user(tvp5147params, &(tvp5147_channel_info[ch_id].params),
+			 sizeof(*tvp5147params)))
+		return -EFAULT;
+
+	return err;
+}
+
+/* tvp5147_i2c_read_reg :This function is used to read value from
+ * register for i2c client.
+ */
+static int tvp5147_i2c_read_reg(struct i2c_client *client, u8 reg, u8 *val)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[1];
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 1;
+		msg->buf = data;
+		data[0] = reg;
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			msg->flags = I2C_M_RD;
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				*val = data[0];
+			}
+		}
+	}
+	return ((err < 0) ? err : 0);
+}
+
+/* tvp5147_i2c_write_reg :This function is used to write value into register
+ * for i2c client.
+ */
+static int tvp5147_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = reg;
+		data[1] = val;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+	return ((err < 0) ? err : 0);
+}
+
+/* tvp5147_i2c_attach_client : This function is used to attach i2c client
+ */
+static int tvp5147_i2c_attach_client(struct i2c_client *client,
+				     struct i2c_driver *driver,
+				     struct i2c_adapter *adap, int addr)
+{
+	int err = 0;
+	if (client->adapter) {
+		err = -EBUSY;	/* our client is already attached */
+	} else {
+		client->addr = addr;
+		client->driver = driver;
+		client->adapter = adap;
+		err = i2c_attach_client(client);
+		if (err) {
+			client->adapter = NULL;
+		}
+	}
+	return err;
+}
+
+/* tvp5147_i2c_detach_client:
+ * This function is used to detach i2c client
+ */
+static int tvp5147_i2c_detach_client(struct i2c_client *client)
+{
+	int err = 0;
+	if (!client->adapter) {
+		return -ENODEV;	/* our client isn't attached */
+	} else {
+		err = i2c_detach_client(client);
+		client->adapter = NULL;
+	}
+	return err;
+}
+
+/* tvp5147A_i2c_probe_adapter : This function is used to probe i2c adapter
+ */
+static int tvp5147A_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	int err = 0;
+	tvp5147_i2c_dev[0] = &(adap->dev);
+	dev_dbg(tvp5147_i2c_dev[0], "Tvp5147A i2c probe adapter called...\n");
+	err = tvp5147_i2c_attach_client(&tvp5147_channel_info[0].i2c_dev.
+					client,
+					&tvp5147_channel_info[0].i2c_dev.
+					driver, adap,
+					tvp5147_channel_info[0].i2c_dev.
+					i2c_addr);
+	dev_dbg(tvp5147_i2c_dev[0], "Tvp5147A i2c probe adapter ends...\n");
+	return err;
+}
+
+/* tvp5147B_i2c_probe_adapter: This function is used to probe i2c adapter
+ */
+static int tvp5147B_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	int err = 0;
+	tvp5147_i2c_dev[1] = &(adap->dev);
+	dev_dbg(tvp5147_i2c_dev[1], "Tvp5147B i2c probe adapter called...\n");
+	err = tvp5147_i2c_attach_client(&tvp5147_channel_info[1].i2c_dev.
+					client,
+					&tvp5147_channel_info[1].i2c_dev.
+					driver, adap,
+					tvp5147_channel_info[1].i2c_dev.
+					i2c_addr);
+	dev_dbg(tvp5147_i2c_dev[1], "Tvp5147B i2c probe adapter ends...\n");
+	return err;
+}
+
+/* tvp5147_i2c_init : This function is used initialize TVP5147 i2c client
+ */
+static int tvp5147_i2c_init(void)
+{
+	int err = 0;
+	int i = 0, j = 0;
+
+	/* Take instance of driver */
+	struct i2c_driver *driver;
+	static	char strings[TVP5147_NUM_CHANNELS][80] =
+	    { "TVP5147 channel0 Video Decoder I2C driver",
+		"TVP5147 channel1 Video Decoder I2C driver"
+	};
+	for (i = 0; i < TVP5147_NUM_CHANNELS; i++) {
+		driver = &tvp5147_channel_info[i].i2c_dev.driver;
+		driver->driver.name = strings[i];
+		driver->id = I2C_DRIVERID_MISC;
+		if (0 == i) {
+			driver->attach_adapter = tvp5147A_i2c_probe_adapter;
+		} else {
+			driver->attach_adapter = tvp5147B_i2c_probe_adapter;
+		}
+		driver->detach_client = tvp5147_i2c_detach_client;
+		err = vpif_register_decoder(&dec_dev[i]);
+		if (err < 0) {
+			for (j = i - 1; j > 0; j--) {
+				vpif_unregister_decoder(&dec_dev[j]);
+			}
+			return err;
+		}
+	}
+	return err;
+}
+
+/* tvp5147_i2c_cleanup : This function is used detach TVP5147 i2c client
+ */
+static void tvp5147_i2c_cleanup(void)
+{
+	int i;
+	for (i = 0; i < TVP5147_NUM_CHANNELS; i++) {
+		if (tvp5147_channel_info[i].i2c_dev.i2c_registration & 0x01) {
+			i2c_del_driver(&tvp5147_channel_info[i].i2c_dev.driver);
+			tvp5147_channel_info[i].i2c_dev.client.adapter = NULL;
+			tvp5147_channel_info[i].i2c_dev.i2c_registration = 0;
+		}
+		vpif_unregister_decoder(&dec_dev[i]);
+	}
+}
+
+module_init(tvp5147_i2c_init);
+module_exit(tvp5147_i2c_cleanup);
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/media/video/davinci/tvp7002.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/tvp7002.c
@@ -0,0 +1,1325 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* tvp7002.c */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <media/davinci/tvp7002.h>
+#include <asm/arch/i2c-client.h>
+#include <asm/arch/video_hdevm.h>
+#include <asm/uaccess.h>
+
+/* Function Prototypes */
+static int tvp7002_initialize(void *dec, int flag);
+static int tvp7002_deinitialize(void *dec);
+static int tvp7002_setcontrol(struct v4l2_control *ctrl, void *dec);
+static int tvp7002_getcontrol(struct v4l2_control *ctrl, void *dec);
+static int tvp7002_querycontrol(struct v4l2_queryctrl *ctrl, void *dec);
+static int tvp7002_setstd(v4l2_std_id * id, void *dec);
+static int tvp7002_getstd(v4l2_std_id * id, void *dec);
+static int tvp7002_querystd(v4l2_std_id * id, void *dec);
+static int tvp7002_enumstd(struct v4l2_standard *std, void *dec);
+static int tvp7002_setinput(int *index, void *dec);
+static int tvp7002_getinput(int *index, void *dec);
+static int tvp7002_enuminput(struct v4l2_input *input, void *dec);
+static int tvp7002_set_format_params(struct tvp7002_format_params
+				     *tvpformats, void *dec);
+static int tvp7002_setparams(void *params, void *dec);
+static int tvp7002_getparams(void *params, void *dec);
+static int tvp7002_i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val);
+static int tvp7002_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val);
+static int tvp7002_i2c_attach_client(struct i2c_client *client,
+				     struct i2c_driver *driver,
+				     struct i2c_adapter *adap, int addr);
+static int tvp7002_i2c_detach_client(struct i2c_client *client);
+static int tvp7002_i2c_probe_adapter(struct i2c_adapter *adap);
+static int tvp7002_i2c_init(void);
+static void tvp7002_i2c_cleanup(void);
+
+static int ths7353_setvalue(void);
+
+static struct v4l2_standard tvp7002_standards[TVP7002_MAX_NO_STANDARDS] = {
+	{
+	 .index = 0,
+	 .id = V4L2_STD_720P_60,
+	 .name = "720P-60",
+	 .frameperiod = {1, 60},
+	 .framelines = 720},
+	{
+	 .index = 1,
+	 .id = V4L2_STD_1080I_60,
+	 .name = "1080I-30",
+	 .frameperiod = {1, 30},
+	 .framelines = 1080},
+	{
+	 .index = 2,
+	 .id = V4L2_STD_1080I_50,
+	 .name = "1080I-25",
+	 .frameperiod = {1, 25},
+	 .framelines = 1080},
+	{
+	 .index = 3,
+	 .id = V4L2_STD_720P_50,
+	 .name = "720P-50",
+	 .frameperiod = {1, 50},
+	 .framelines = 720},
+	{
+	 .index = 4,
+	 .id = V4L2_STD_525P_60,
+	 .name = "480P-60",
+	 .frameperiod = {1, 60},
+	 .framelines = 525},
+	{
+	 .index = 5,
+	 .id = V4L2_STD_625P_50,
+	 .name = "576P-50",
+	 .frameperiod = {1, 50},
+	 .framelines = 625},
+};
+
+static struct tvp7002_format_params tvp7002_formats[TVP7002_MAX_NO_STANDARDS] = {
+	{
+	 .hpll_divider_msb = FEEDBACK_DIVIDER_MSB_720p,
+	 .hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_720p,
+	 .hpll_vco_control = VCO_CONTROL_720p,
+	 .hpll_cp_current = CP_CURRENT_720p,
+	 .hpll_phase_select = PHASE_SELECT_720p,
+	 .hpll_post_divider = POST_DIVIDER_720p,
+	 .hpll_control = HPLL_CONTROL_720p,
+	 .avid_start_msb = AVID_START_PIXEL_MSB_720p,
+	 .avid_start_lsb = AVID_START_PIXEL_LSB_720p,
+	 .avid_stop_lsb = AVID_STOP_PIXEL_LSB_720p,
+	 .avid_stop_msb = AVID_STOP_PIXEL_MSB_720p,
+	 .vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_720p,
+	 .vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_720p,
+	 .vblk_f0_duration = VBLK_F0_DURATION_720p,
+	 .vblk_f1_duration = VBLK_F1_DURATION_720p,
+	 .alc_placement = TVP7002_HD_ALC_PLACEMENT,
+	 .clamp_start = TVP7002_HD_CLAMP_START,
+	 .clamp_width = TVP7002_HD_CLAMP_WIDTH,
+	 .hpll_pre_coast = TVP7002_HD_PRE_COAST,
+	 .hpll_post_coast = TVP7002_HD_POST_COAST,
+	 .reserved = RESERVED_720p},
+	{
+	 .hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080i,
+	 .hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080i,
+	 .hpll_vco_control = VCO_CONTROL_1080i,
+	 .hpll_cp_current = CP_CURRENT_1080i,
+	 .hpll_phase_select = PHASE_SELECT_1080i,
+	 .hpll_post_divider = POST_DIVIDER_1080i,
+	 .hpll_control = HPLL_CONTROL_1080i,
+	 .avid_start_msb = AVID_START_PIXEL_MSB_1080i,
+	 .avid_start_lsb = AVID_START_PIXEL_LSB_1080i,
+	 .avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080i,
+	 .avid_stop_msb = AVID_STOP_PIXEL_MSB_1080i,
+	 .vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_1080i,
+	 .vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_1080i,
+	 .vblk_f0_duration = VBLK_F0_DURATION_1080i,
+	 .vblk_f1_duration = VBLK_F1_DURATION_1080i,
+	 .alc_placement = TVP7002_HD_ALC_PLACEMENT,
+	 .clamp_start = TVP7002_HD_CLAMP_START,
+	 .clamp_width = TVP7002_HD_CLAMP_WIDTH,
+	 .hpll_pre_coast = TVP7002_HD_PRE_COAST,
+	 .hpll_post_coast = TVP7002_HD_POST_COAST,
+	 .reserved = RESERVED_1080i},
+	{
+	 .hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080i_50,
+	 .hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080i_50,
+	 .hpll_vco_control = VCO_CONTROL_1080i_50,
+	 .hpll_cp_current = CP_CURRENT_1080i_50,
+	 .hpll_phase_select = PHASE_SELECT_1080i_50,
+	 .hpll_post_divider = POST_DIVIDER_1080i_50,
+	 .hpll_control = HPLL_CONTROL_1080i_50,
+	 .avid_start_msb = AVID_START_PIXEL_MSB_1080i_50,
+	 .avid_start_lsb = AVID_START_PIXEL_LSB_1080i_50,
+	 .avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080i_50,
+	 .avid_stop_msb = AVID_STOP_PIXEL_MSB_1080i_50,
+	 .vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_1080i_50,
+	 .vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_1080i_50,
+	 .vblk_f0_duration = VBLK_F0_DURATION_1080i_50,
+	 .vblk_f1_duration = VBLK_F1_DURATION_1080i_50,
+	 .alc_placement = TVP7002_HD_ALC_PLACEMENT,
+	 .clamp_start = TVP7002_HD_CLAMP_START,
+	 .clamp_width = TVP7002_HD_CLAMP_WIDTH,
+	 .hpll_pre_coast = TVP7002_HD_PRE_COAST,
+	 .hpll_post_coast = TVP7002_HD_POST_COAST,
+	 .reserved = RESERVED_1080i_50},
+	{
+	 .hpll_divider_msb = FEEDBACK_DIVIDER_MSB_720p_50,
+	 .hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_720p_50,
+	 .hpll_vco_control = VCO_CONTROL_720p_50,
+	 .hpll_cp_current = CP_CURRENT_720p_50,
+	 .hpll_phase_select = PHASE_SELECT_720p_50,
+	 .hpll_post_divider = POST_DIVIDER_720p_50,
+	 .hpll_control = HPLL_CONTROL_720p_50,
+	 .avid_start_msb = AVID_START_PIXEL_MSB_720p_50,
+	 .avid_start_lsb = AVID_START_PIXEL_LSB_720p_50,
+	 .avid_stop_lsb = AVID_STOP_PIXEL_LSB_720p_50,
+	 .avid_stop_msb = AVID_STOP_PIXEL_MSB_720p_50,
+	 .vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_720p_50,
+	 .vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_720p_50,
+	 .vblk_f0_duration = VBLK_F0_DURATION_720p_50,
+	 .vblk_f1_duration = VBLK_F1_DURATION_720p_50,
+	 .alc_placement = TVP7002_HD_ALC_PLACEMENT,
+	 .clamp_start = TVP7002_HD_CLAMP_START,
+	 .clamp_width = TVP7002_HD_CLAMP_WIDTH,
+	 .hpll_pre_coast = TVP7002_HD_PRE_COAST,
+	 .hpll_post_coast = TVP7002_HD_POST_COAST,
+	 .reserved = RESERVED_720p},
+	{
+	 .hpll_divider_msb = FEEDBACK_DIVIDER_MSB_480P,
+	 .hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_480P,
+	 .hpll_vco_control = VCO_CONTROL_480P,
+	 .hpll_cp_current = CP_CURRENT_480P,
+	 .hpll_phase_select = PHASE_SELECT_480P,
+	 .hpll_post_divider = POST_DIVIDER_480P,
+	 .hpll_control = HPLL_CONTROL_480P,
+	 .avid_start_msb = AVID_START_PIXEL_MSB_480P,
+	 .avid_start_lsb = AVID_START_PIXEL_LSB_480P,
+	 .avid_stop_lsb = AVID_STOP_PIXEL_LSB_480P,
+	 .avid_stop_msb = AVID_STOP_PIXEL_MSB_480P,
+	 .vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_480P,
+	 .vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_480P,
+	 .vblk_f0_duration = VBLK_F0_DURATION_480P,
+	 .vblk_f1_duration = VBLK_F1_DURATION_480P,
+	 .alc_placement = TVP7002_ED_ALC_PLACEMENT,
+	 .clamp_start = TVP7002_ED_CLAMP_START,
+	 .clamp_width = TVP7002_ED_CLAMP_WIDTH,
+	 .hpll_pre_coast = TVP7002_ED_PRE_COAST,
+	 .hpll_post_coast = TVP7002_ED_POST_COAST,
+	 .reserved = RESERVED_720p},
+	{
+	 .hpll_divider_msb = FEEDBACK_DIVIDER_MSB_576P,
+	 .hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_576P,
+	 .hpll_vco_control = VCO_CONTROL_576P,
+	 .hpll_cp_current = CP_CURRENT_576P,
+	 .hpll_phase_select = PHASE_SELECT_576P,
+	 .hpll_post_divider = POST_DIVIDER_576P,
+	 .hpll_control = HPLL_CONTROL_576P,
+	 .avid_start_msb = AVID_START_PIXEL_MSB_576P,
+	 .avid_start_lsb = AVID_START_PIXEL_LSB_576P,
+	 .avid_stop_lsb = AVID_STOP_PIXEL_LSB_576P,
+	 .avid_stop_msb = AVID_STOP_PIXEL_MSB_576P,
+	 .vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_576P,
+	 .vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_576P,
+	 .vblk_f0_duration = VBLK_F0_DURATION_576P,
+	 .vblk_f1_duration = VBLK_F1_DURATION_576P,
+	 .alc_placement = TVP7002_ED_ALC_PLACEMENT,
+	 .clamp_start = TVP7002_ED_CLAMP_START,
+	 .clamp_width = TVP7002_ED_CLAMP_WIDTH,
+	 .hpll_pre_coast = TVP7002_ED_PRE_COAST,
+	 .hpll_post_coast = TVP7002_ED_POST_COAST,
+	 .reserved = RESERVED_720p}
+};
+
+static struct tvp7002_config tvp7002_configuration[TVP7002_NUM_CHANNELS] = {
+	{
+	 .no_of_inputs = TVP7002_MAX_NO_INPUTS,
+	 .input[0] = {
+		      .input_type = TVP7002_HD_INPUT,
+		      .input_info = {
+				     .index = 0,
+				     .name = "COMPONENT",
+				     .type = V4L2_INPUT_TYPE_CAMERA,
+				     .std = V4L2_STD_TVP7002_ALL},
+		      .no_of_standard = TVP7002_MAX_NO_STANDARDS,
+		      .standard = (struct v4l2_standard *)&tvp7002_standards,
+		      .def_std = V4L2_STD_720P_60,
+		      .format =
+		      (struct tvp7002_format_params *)&tvp7002_formats,
+		      .no_of_controls = TVP7002_MAX_NO_CONTROLS,
+		      .controls = NULL},
+	 .def_params = {V4L2_STD_720P_60, 0, {1, 0xa, 0x6}, {0, 0, 0, 7, 7, 7},
+			{0x80, 0x80, 0x80, 0, 0, 0, 0x10, 0x10, 0x10}}
+	 }
+};
+
+static struct tvp7002_channel tvp7002_channel_info[TVP7002_NUM_CHANNELS] = {
+	{
+	 .params.inputidx = 0,
+	 .params.std = V4L2_STD_720P_60,
+	 .i2c_dev = {
+		     .i2c_addr = (0xBA >> 1),
+		     .i2c_registration = 0},
+	 .dec_device = NULL}
+};
+
+/* Global variables */
+static struct device *tvp7002_i2c_dev[TVP7002_NUM_CHANNELS];
+static struct param_ops params_ops = {
+	.setparams = tvp7002_setparams,
+	.getparams = tvp7002_getparams
+};
+static struct control_ops controls_ops = {
+	.count = TVP7002_MAX_NO_CONTROLS,
+	.queryctrl = tvp7002_querycontrol,
+	.setcontrol = tvp7002_setcontrol,
+	.getcontrol = tvp7002_getcontrol
+};
+static struct input_ops inputs_ops = {
+	.count = TVP7002_MAX_NO_INPUTS,
+	.enuminput = tvp7002_enuminput,
+	.setinput = tvp7002_setinput,
+	.getinput = tvp7002_getinput
+};
+static struct standard_ops standards_ops = {
+	.count = TVP7002_MAX_NO_STANDARDS,
+	.enumstd = tvp7002_enumstd,
+	.setstd = tvp7002_setstd,
+	.getstd = tvp7002_getstd,
+	.querystd = tvp7002_querystd,
+};
+static struct decoder_device tvp7002_dev[TVP7002_NUM_CHANNELS] = {
+	{
+	 .name = "TVP7002",
+	 .if_type = INTERFACE_TYPE_BT1120,
+	 .channel_id = 0,
+	 .capabilities = 0,
+	 .initialize = tvp7002_initialize,
+	 .std_ops = &standards_ops,
+	 .ctrl_ops = &controls_ops,
+	 .input_ops = &inputs_ops,
+	 .fmt_ops = NULL,
+	 .params_ops = &params_ops,
+	 .deinitialize = tvp7002_deinitialize}
+};
+
+/* tvp7002_initialize :
+ * This function will set the video format standard
+ */
+static int tvp7002_initialize(void *dec, int flag)
+{
+	int err = 0;
+	int ch_id;
+	v4l2_std_id std;
+	struct i2c_client *ch_client;
+	int index;
+	if (NULL == dec) {
+		printk("dec:NULL pointer");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	ch_client = &tvp7002_channel_info[ch_id].i2c_dev.client;
+	if (tvp7002_channel_info[ch_id].i2c_dev.i2c_registration & 0x01) {
+		printk("tvp7002 driver is already initialized..\n");
+		err = -EINVAL;
+		return err;
+	}
+
+	/* Register TVP7002 I2C client */
+	err = i2c_add_driver(&tvp7002_channel_info[ch_id].i2c_dev.driver);
+	if (err) {
+		printk("Failed to register TVP7002 I2C client.\n");
+		return -EINVAL;
+	}
+	try_module_get(THIS_MODULE);
+	tvp7002_channel_info[ch_id].i2c_dev.i2c_registration |= 1;
+	tvp7002_channel_info[ch_id].dec_device = (struct decoder_device *)dec;
+	if (DECODER_I2C_BIND_FLAG == flag) {
+		/* check that decoder is set with default values once or not,
+		 * if yes return, if not continue */
+		if (tvp7002_channel_info[ch_id].i2c_dev.i2c_registration & 0x02)
+			return err;
+
+	}
+
+	err |= set_cpld_for_tvp7002();
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Tvp7002 driver registered\n");
+	/*Configure the TVP7002 in default 720p 60 Hz standard for normal
+	   power up mode */
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_DIVIDER_MSB,
+				     TVP7002_HPLL_MSB_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_DIVIDER_LSB,
+				     TVP7002_HPLL_LSB_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_CONTROL,
+				     TVP7002_HPLL_CONTROL_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_PHASE_SELECT,
+				     TVP7002_HPLL_PHASE_SEL_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_CLAMP_START,
+				     TVP7002_CLAMP_START_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_CLAMP_WIDTH,
+				     TVP7002_CLAMP_WIDTH_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HSYNC_OUTPUT_WIDTH,
+				     TVP7002_HSYNC_OUTWIDTH_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_SYNC_CONTROL_1,
+				     TVP7002_SYNC_CONTROL1_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_CLAMP_CONTROL,
+				     TVP7002_HPLL_CLAMP_CTRL_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_SYNC_ON_GREEN_THLD,
+				     TVP7002_SYNC_GREEN_THLD_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_SYNC_SEPARATER_THLD,
+				  TVP7002_SYNC_SEP_THLD_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_PRE_COAST,
+				  TVP7002_HPLL_PRE_COAST_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_HPLL_POST_COAST,
+				  TVP7002_HPLL_POST_COAST_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_OUTPUT_FORMATTER,
+				  TVP7002_OUTPUT_FORMATTER_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_MISC_CONTROL_1,
+				  TVP7002_MISC_CONTROL1_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_MISC_CONTROL_3,
+				  TVP7002_MISC_CONTROL3_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_MISC_CONTROL_2,
+				  TVP7002_MISC_CONTROL2_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_INPUT_MUX_SELECT_1,
+				  TVP7002_INPUT_MUX_SELECT1_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_INPUT_MUX_SELECT_2,
+				  TVP7002_INPUT_MUX_SELECT2_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_HSOUT_OUTPUT_START,
+				     TVP7002_HSOUT_OUTPUT_START_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_MISC_CONTROL_4,
+				     TVP7002_MISC_CONTROL4_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_ALC_ENABLE,
+				     TVP7002_ALC_ENABLE_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_ALC_FILTER,
+				     TVP7002_ALC_FILTER_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_FINE_CLAMP_CONTROL,
+				     TVP7002_FINE_CLAMP_CONTROL_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_POWER_CONTROL,
+				     TVP7002_POWER_CONTROL_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_ADC_SETUP,
+				     TVP7002_ADC_SETUP_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client,
+				     TVP7002_COARSE_CLAMP_CONTROL,
+				     TVP7002_COARSE_CLAMP_CONTROL_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_SOG_CLAMP,
+				     TVP7002_SOG_CLAMP_DEFAULT);
+	err |= tvp7002_i2c_write_reg(ch_client, TVP7002_ALC_PLACEMENT,
+				     TVP7002_ALC_PLACEMENT_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client,
+				  TVP7002_VIDEO_BANDWIDTH_CONTROL,
+				  TVP7002_VIDEO_BANDWIDTH_CONTROL_DEFAULT);
+	err |=
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_AVID_START_PIXEL_HIGH,
+				  TVP7002_AVID_START_PIXEL_DEFAULT);
+
+	if (err < 0) {
+		err = -EINVAL;
+		tvp7002_deinitialize(dec);
+		return err;
+	} else {
+
+		memcpy(&tvp7002_channel_info[ch_id].params,
+		       &tvp7002_configuration[ch_id].def_params,
+		       sizeof(tvp7002_params));
+		/* Configure for default video standard */
+		/* call set standard */
+		index = tvp7002_channel_info[ch_id].params.inputidx;
+		std = tvp7002_configuration[ch_id].input[index].def_std;
+		err |= tvp7002_setstd(&std, dec);
+
+		if (err < 0) {
+			err = -EINVAL;
+			tvp7002_deinitialize(dec);
+			return err;
+		}
+	}
+	tvp7002_channel_info[ch_id].i2c_dev.i2c_registration |= 0x2;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of tvp7002_init.\n");
+	return err;
+}
+static int tvp7002_deinitialize(void *dec)
+{
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Tvp7002 ch deinitialization"
+		" called\n");
+	if (tvp7002_channel_info[ch_id].i2c_dev.i2c_registration & 0x01) {
+		i2c_del_driver(&tvp7002_channel_info[ch_id].i2c_dev.driver);
+		module_put(THIS_MODULE);
+		tvp7002_channel_info[ch_id].i2c_dev.client.adapter = NULL;
+		tvp7002_channel_info[ch_id].i2c_dev.i2c_registration &= ~(0x01);
+		tvp7002_channel_info[ch_id].dec_device = NULL;
+	}
+	return 0;
+}
+
+/* tvp7002_setcontrol : Function to set the control parameter
+ */
+static int tvp7002_setcontrol(struct v4l2_control *ctrl, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id],
+		"TVP7002 supports no control parameter to be set..\n");
+	err = -EINVAL;
+	return err;
+}
+
+/* tvp7002_getcontrol :
+ * Function to get the control parameter
+ */
+static int tvp7002_getcontrol(struct v4l2_control *ctrl, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id],
+		"TVP7002 supports no control parameters..\n");
+	err = -EINVAL;
+	return err;
+}
+
+/* tvp7002_querycontrol :
+ * Function to query control parameter
+ */
+static int tvp7002_querycontrol(struct v4l2_queryctrl *ctrl, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id],
+		"TVP7002 has no control parameters to return..\n");
+	err = -EINVAL;
+	return err;
+}
+
+/* following function is used to set THS7353 */
+static int ths7353_setvalue(void)
+{
+	int err = 0;
+	u8 val[2];
+	u16 ths7353_i2c_addr = 0x5C >> 1;
+	val[1] = 0x95;
+
+	val[0] = 0x01;
+	val[1] = 0x94;
+	err = davinci_i2c_write(2, val, ths7353_i2c_addr);
+	val[0] = 0x02;
+	val[1] = 0x95;
+	err |= davinci_i2c_write(2, val, ths7353_i2c_addr);
+	val[0] = 0x03;
+	val[1] = 0x94;
+	err |= davinci_i2c_write(2, val, ths7353_i2c_addr);
+	if (err) {
+		printk("THS7353\n");
+	}
+	return err;
+}
+
+/* tvp7002_setstd :
+ * Function to set the video standard
+ */
+static int tvp7002_setstd(v4l2_std_id * id, void *dec)
+{
+	int err = 0;
+	struct tvp7002_format_params *tvp7002formats;
+	int ch_id;
+	int i = 0;
+	struct v4l2_standard *standard;
+	int input_idx;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+
+	err |= set_cpld_for_tvp7002();
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Start of tvp7002_setstd..\n");
+	input_idx = tvp7002_channel_info[ch_id].params.inputidx;
+	if (id == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL pointer.\n");
+		return -EINVAL;
+	}
+	for (i = 0; i < tvp7002_configuration[ch_id].input[input_idx].
+	     no_of_standard; i++) {
+		standard = &tvp7002_configuration[ch_id].input[input_idx].
+		    standard[i];
+		if (standard->id & *id) {
+			break;
+		}
+	}
+	if (i == tvp7002_configuration[ch_id].input[input_idx].no_of_standard) {
+		dev_err(tvp7002_i2c_dev[ch_id], "Invalid id...\n");
+		return -EINVAL;
+	}
+
+	ths7353_setvalue();
+
+	tvp7002formats =
+	    &tvp7002_configuration[ch_id].input[input_idx].format[i];
+
+	err = tvp7002_set_format_params(tvp7002formats, dec);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "Set standard failed\n");
+		return err;
+	}
+
+	/* Lock the structure variable and assign std to the member
+	   variable */
+	tvp7002_channel_info[ch_id].params.std = *id;
+
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of tvp7002 set standard...\n");
+	return err;
+}
+
+/* tvp7002_getstd :
+ * Function to get the video standard
+ */
+static int tvp7002_getstd(v4l2_std_id * id, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Starting getstd function.\n");
+	if (id == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	/* Read the video standard */
+	*id = tvp7002_channel_info[ch_id].params.std;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of getstd function.\n");
+	return err;
+}
+
+/* tvp7002_querystd :
+ * Function to return standard detected by decoder
+ */
+static int tvp7002_querystd(v4l2_std_id * id, void *dec)
+{
+	int err = 0;
+	unsigned char val;
+	unsigned short val1;
+	int ch_id;
+	unsigned char val_t;
+	if (NULL == dec) {
+		printk("NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	err |= set_cpld_for_tvp7002();
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Starting querystd function...\n");
+	if (id == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	mdelay(100);
+	/* Query the standards */
+	err = tvp7002_i2c_read_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				   client,
+				   TVP7002_LINES_PER_FRAME_STATUS_LOW, &val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id],
+			"I2C read fails...Lines per frame low\n");
+		return err;
+	}
+	val1 = val;
+	err = tvp7002_i2c_read_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				   client,
+				   TVP7002_LINES_PER_FRAME_STATUS_HIGH, &val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id],
+			"I2C read fails...Lines per frame high\n");
+		return err;
+	}
+	val1 |= (val << LINES_PER_FRAME_MSB_SHIFT) & LINES_PER_FRAME_MSB_MASK;
+	val = (val & VIDEO_DETECTION_MASK) >> VIDEO_DETECTION_SHIFT;
+
+	err = tvp7002_i2c_read_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				   client,
+				   TVP7002_CLOCK_PER_LINE_STATUS_LSB, &val_t);
+
+	if ((INTERLACED_VIDEO == val)
+	    && (TVP7002_LINES_1080_60 == val1) && (val_t > 180 && val_t < 190)) {
+		*id = V4L2_STD_1080I_60;
+	} else if ((INTERLACED_VIDEO == val)
+		   && (TVP7002_LINES_1080_50 == val1)) {
+		*id = V4L2_STD_1080I_50;
+	} else if ((PROGRESSIVE_VIDEO == val)
+		   && (TVP7002_LINES_720 == val1) &&
+		   (val_t > 160 && val_t < 170)) {
+		*id = V4L2_STD_720P_50;
+	} else if ((PROGRESSIVE_VIDEO == val)
+		   && (TVP7002_LINES_720 == val1)) {
+		*id = V4L2_STD_720P_60;
+	} else if ((PROGRESSIVE_VIDEO == val)
+		   && (525 == val1)) {
+		*id = V4L2_STD_525P_60;
+	} else if ((PROGRESSIVE_VIDEO == val)
+		   && (625 == val1)) {
+		*id = V4L2_STD_625P_50;
+	} else {
+		return -EINVAL;
+	}
+
+	tvp7002_channel_info[ch_id].params.std = *id;
+	err = tvp7002_setstd(id, dec);
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of querystd function.\n");
+	return err;
+}
+
+/* tvp7002_enumstd : Function to enumerate standards supported
+ */
+static int tvp7002_enumstd(struct v4l2_standard *std, void *dec)
+{
+	int index, index1;
+	int err = 0;
+	int ch_id;
+	int input_idx, sumstd = 0;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	if (std == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	index = std->index;
+	index1 = index;
+	/* Check for valid value of index */
+	for (input_idx = 0;
+	     input_idx < tvp7002_configuration[ch_id].no_of_inputs;
+	     input_idx++) {
+		sumstd += tvp7002_configuration[ch_id].input[input_idx]
+		    .no_of_standard;
+		if (index < sumstd) {
+			sumstd -= tvp7002_configuration[ch_id]
+			    .input[input_idx].no_of_standard;
+			break;
+		}
+	}
+	if (input_idx == tvp7002_configuration[ch_id].no_of_inputs)
+		return -EINVAL;
+	index -= sumstd;
+
+	memset(std, 0, sizeof(*std));
+
+	memcpy(std, &tvp7002_configuration[ch_id].input[input_idx].
+	       standard[index], sizeof(struct v4l2_standard));
+	std->index = index1;
+	return err;
+}
+
+/* tvp7002_setinput :
+ * Function to set the input
+ */
+static int tvp7002_setinput(int *index, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Start of set input function.\n");
+
+	/* check for null pointer */
+	if (index == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	if ((*index >= tvp7002_configuration[ch_id].no_of_inputs)
+	    || (*index < 0)) {
+		return -EINVAL;
+	}
+	if (*index == 0) {	/* HD */
+		tvp7002_channel_info[ch_id].params.inputidx = *index;
+	} else {
+		dev_err(tvp7002_i2c_dev[ch_id], "Invalid index.\n");
+		return -EINVAL;
+	}
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of set input function.\n");
+	return err;
+}
+
+/* tvp7002_getinput : Function to get the input
+ */
+static int tvp7002_getinput(int *index, void *dec)
+{
+	int err = 0;
+	int ch_id;
+	v4l2_std_id id;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Start of get input function.\n");
+
+	/* check for null pointer */
+	if (index == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+	err |= tvp7002_querystd(&id, dec);
+	if (err < 0) {
+		return err;
+	}
+	*index = 0;
+	*index = tvp7002_channel_info[ch_id].params.inputidx;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of get input function.\n");
+	return err;
+}
+
+/* tvp7002_enuminput :
+ * Function to enumerate the input
+ */
+static int tvp7002_enuminput(struct v4l2_input *input, void *dec)
+{
+	int err = 0;
+	int index = 0;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer.\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+
+	/* check for null pointer */
+	if (input == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	/* Only one input is available */
+	if (input->index >= tvp7002_configuration[ch_id].no_of_inputs) {
+		return -EINVAL;
+	}
+	index = input->index;
+	memset(input, 0, sizeof(*input));
+	input->index = index;
+	memcpy(input,
+	       &tvp7002_configuration[ch_id].input[index].input_info,
+	       sizeof(struct v4l2_input));
+	return err;
+}
+
+/* tvp7002_set_format_params :
+ * Function to set the format parameters
+ */
+static int tvp7002_set_format_params(struct tvp7002_format_params
+				     *tvpformats, void *dec)
+{
+	int err = 0;
+	unsigned char val;
+	int ch_id;
+	if (NULL == dec) {
+		printk("NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	err |= set_cpld_for_tvp7002();
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id],
+		"Tvp7002 set format params started...\n");
+	if (tvpformats == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	/* Write the HPLL related registers */
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_HPLL_DIVIDER_MSB,
+				    tvpformats->hpll_divider_msb);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id],
+			"I2C write fails...Divider MSB\n");
+		return err;
+	}
+
+	val = ((tvpformats->
+		hpll_divider_lsb & HPLL_DIVIDER_LSB_MASK) <<
+	       HPLL_DIVIDER_LSB_SHIFT);
+	err =
+	    tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				  client, TVP7002_HPLL_DIVIDER_LSB, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id],
+			"I2C write fails...Divider LSB.\n");
+		return err;
+	}
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_HPLL_CONTROL,
+				    tvpformats->hpll_control);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_AVID_START_PIXEL_LOW,
+				    tvpformats->avid_start_lsb);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_AVID_START_PIXEL_HIGH,
+				    tvpformats->avid_start_msb);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_AVID_STOP_PIXEL_LOW,
+				    tvpformats->avid_stop_lsb);
+	err =
+	    tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				  client, TVP7002_AVID_STOP_PIXEL_HIGH,
+				  tvpformats->avid_stop_msb);
+	err =
+	    tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				  client, TVP7002_VBLK_FIELD0_START_OFFSET,
+				  tvpformats->vblk_start_f0_line_offset);
+	err =
+	    tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				  client, TVP7002_VBLK_FIELD1_START_OFFSET,
+				  tvpformats->vblk_start_f1_line_offset);
+	err =
+	    tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				  client, TVP7002_VBLK_FIELD0_DURATION,
+				  tvpformats->vblk_f0_duration);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_VBLK_FIELD1_DURATION,
+				    tvpformats->vblk_f1_duration);
+
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_ALC_PLACEMENT,
+				    tvpformats->alc_placement);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_CLAMP_START,
+				    tvpformats->clamp_start);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_CLAMP_WIDTH,
+				    tvpformats->clamp_width);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_HPLL_PRE_COAST,
+				    tvpformats->hpll_pre_coast);
+	err = tvp7002_i2c_write_reg(&tvp7002_channel_info[ch_id].i2c_dev.
+				    client, TVP7002_HPLL_POST_COAST,
+				    tvpformats->hpll_post_coast);
+
+	tvp7002_channel_info[ch_id].params.format = *tvpformats;
+
+	dev_dbg(tvp7002_i2c_dev[ch_id],
+		"End of tvp7002 set format params...\n");
+	return err;
+}
+
+/* tvp7002_setparams : This function will set parameters for tvp7002
+ */
+static int tvp7002_setparams(void *params, void *dec)
+{
+	int err = 0;
+	unsigned char val;
+	int ch_id;
+	struct i2c_client *ch_client;
+	tvp7002_params tvp7002params;
+
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	if (copy_from_user(&tvp7002params, (tvp7002_params *) params,
+			   sizeof(tvp7002params))) {
+		return -EFAULT;
+	}
+	err |= set_cpld_for_tvp7002();
+	if (err) {
+		printk("Failed to set cpld bit.\n");
+		return -EINVAL;
+	}
+
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	ch_client = &tvp7002_channel_info[ch_id].i2c_dev.client;
+	dev_dbg(tvp7002_i2c_dev[ch_id],
+		"Start of tvp7002 set params function.\n");
+
+	/* check for null pointer */
+	err |= tvp7002_setinput(&(tvp7002params.inputidx), dec);
+	if (err < 0) {
+		dev_dbg(tvp7002_i2c_dev[ch_id],
+			"Set format parameters failed.\n");
+		return err;
+	}
+	err |= tvp7002_setstd(&(tvp7002params.std), dec);
+	if (err < 0) {
+		dev_dbg(tvp7002_i2c_dev[ch_id],
+			"Set format parameters failed.\n");
+		return err;
+	}
+
+	/* set video format related parameters */
+	err = tvp7002_set_format_params(&tvp7002params.format, dec);
+	if (err < 0) {
+		dev_dbg(tvp7002_i2c_dev[ch_id],
+			"Set format parameters failed.\n");
+		return err;
+	}
+
+	/* Write the gain information */
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_BLUE_FINE_GAIN,
+				    tvp7002params.gain.blue_fine_gain);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_GREEN_FINE_GAIN,
+				    tvp7002params.gain.green_fine_gain);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_RED_FINE_GAIN,
+				    tvp7002params.gain.red_fine_gain);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+
+	/* Write coarse gain information */
+	val = 0;
+	val = tvp7002params.gain.blue_coarse_gain & BLUE_COARSE_GAIN_MASK;
+	tvp7002params.gain.blue_coarse_gain = val;
+
+	val |= ((tvp7002params.gain.green_coarse_gain &
+		 GREEN_COARSE_GAIN_MASK) << GREEN_COARSE_GAIN_SHIFT);
+	tvp7002params.gain.green_coarse_gain =
+	    tvp7002params.gain.green_coarse_gain & GREEN_COARSE_GAIN_MASK;
+
+	err = tvp7002_i2c_write_reg(ch_client,
+				    TVP7002_BLUE_GREEN_COARSE_GAIN, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+
+	val = tvp7002params.gain.red_coarse_gain & RED_COARSE_GAIN_MASK;
+	tvp7002params.gain.red_coarse_gain = val;
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_RED_COARSE_GAIN, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+
+	/*Write the offset value in register */
+	err = tvp7002_i2c_write_reg(ch_client,
+				    TVP7002_BLUE_FINE_OFFSETMSB,
+				    tvp7002params.offset.blue_fine_offset);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	err = tvp7002_i2c_write_reg(ch_client,
+				    TVP7002_GREEN_FINE_OFFSETMSB,
+				    tvp7002params.offset.green_fine_offset);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_RED_FINE_OFFSETMSB,
+				    tvp7002params.offset.red_fine_offset);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	val = 0;
+	val = tvp7002params.offset.blue_fine_offset_lsb & FINE_OFFSET_LSB_MASK;
+	tvp7002params.offset.blue_fine_offset_lsb = val;
+
+	val |= ((tvp7002params.
+		 offset.green_fine_offset_lsb & FINE_OFFSET_LSB_MASK) <<
+		FINE_OFFSET_LSB_SHIFT_GREEN);
+	tvp7002params.offset.green_fine_offset_lsb =
+	    (tvp7002params.offset.green_fine_offset_lsb & FINE_OFFSET_LSB_MASK);
+
+	val |= ((tvp7002params.
+		 offset.red_fine_offset_lsb & FINE_OFFSET_LSB_MASK) <<
+		FINE_OFFSET_LSB_SHIFT_RED);
+	tvp7002params.offset.red_fine_offset_lsb =
+	    (tvp7002params.offset.red_fine_offset_lsb & FINE_OFFSET_LSB_MASK);
+
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_FINE_OFFSET_LSBS, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	val = tvp7002params.offset.blue_coarse_offset & COARSE_OFFSET_MASK;
+	tvp7002params.offset.blue_coarse_offset = val;
+
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_BLUE_COARSE_OFFSET, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	val = tvp7002params.offset.green_coarse_offset & COARSE_OFFSET_MASK;
+	tvp7002params.offset.green_coarse_offset = val;
+
+	err =
+	    tvp7002_i2c_write_reg(ch_client, TVP7002_GREEN_COARSE_OFFSET, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	val = tvp7002params.offset.red_coarse_offset & COARSE_OFFSET_MASK;
+	tvp7002params.offset.red_coarse_offset = val;
+
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_RED_COARSE_OFFSET, val);
+	if (err < 0) {
+		dev_err(tvp7002_i2c_dev[ch_id], "I2C write fails...\n");
+		return err;
+	}
+	if (tvp7002params.alc.alc_enable) {
+		err =
+		    tvp7002_i2c_write_reg(ch_client, TVP7002_ALC_ENABLE, 0x80);
+	} else {
+		err =
+		    tvp7002_i2c_write_reg(ch_client, TVP7002_ALC_ENABLE, 0x00);
+	}
+	val = (tvp7002params.alc.vcoeff << TVP7002_ALC_VCOEFF_SHIFT) |
+	    (tvp7002params.alc.hcoeff);
+	err = tvp7002_i2c_write_reg(ch_client, TVP7002_ALC_FILTER, val);
+	if (err < 0)
+		return err;
+
+	tvp7002_channel_info[ch_id].params = tvp7002params;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of configTVP7002...\n");
+	return err;
+}
+
+/* tvp7002_getparams : This function will get parameters for tvp7002
+ */
+static int tvp7002_getparams(void *params, void *dec)
+{
+	int ch_id;
+	int err = 0;
+	tvp7002_params *tvp7002params = (tvp7002_params *) params;
+	if (NULL == dec) {
+		printk("NULL Pointer\n");
+		return -EINVAL;
+	}
+	ch_id = ((struct decoder_device *)dec)->channel_id;
+	dev_dbg(tvp7002_i2c_dev[ch_id], "Starting tvp7002_getparams\n");
+
+	/* check for null pointer */
+	if (tvp7002params == NULL) {
+		dev_err(tvp7002_i2c_dev[ch_id], "Null pointer\n");
+		return -EINVAL;
+	}
+	if (copy_to_user(tvp7002params, &(tvp7002_channel_info[ch_id].params),
+			 sizeof(*tvp7002params))) {
+		return -EFAULT;
+	}
+
+	dev_dbg(tvp7002_i2c_dev[ch_id], "End of getparamsTVP7002...\n");
+	return err;
+}
+
+/* tvp7002_i2c_read_reg :This function is used to read value from register
+ * for i2c client.
+ */
+static int tvp7002_i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[1];
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 1;
+		msg->buf = data;
+		data[0] = reg;
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			msg->flags = I2C_M_RD;
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				*val = data[0];
+			}
+		}
+	}
+
+	return ((err < 0) ? err : 0);
+}
+
+/* tvp7002_i2c_write_reg :This function is used to write value into register
+ * for i2c client.
+ */
+static int tvp7002_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = reg;
+		data[1] = val;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+
+	return ((err < 0) ? err : 0);
+}
+
+/* tvp7002_i2c_attach_client : This function is used to attach i2c client
+ */
+static int tvp7002_i2c_attach_client(struct i2c_client *client,
+				     struct i2c_driver *driver,
+				     struct i2c_adapter *adap, int addr)
+{
+	int err = 0;
+	if (client->adapter) {
+		err = -EBUSY;	/* our client is already attached */
+	} else {
+		client->addr = addr;
+		client->driver = driver;
+		client->adapter = adap;
+		err = i2c_attach_client(client);
+		if (err) {
+			client->adapter = NULL;
+		}
+	}
+	return err;
+}
+
+/* tvp7002_i2c_detach_client : This function is used to detach i2c client
+ */
+static int tvp7002_i2c_detach_client(struct i2c_client *client)
+{
+	int err = 0;
+	if (!client->adapter) {
+		return -ENODEV;	/* our client isn't attached */
+	} else {
+		err = i2c_detach_client(client);
+		client->adapter = NULL;
+	}
+	return err;
+}
+
+/* tvp7002_i2c_probe_adapter : This function is used to probe i2c adapter
+ */
+static int tvp7002_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	int err = 0;
+	tvp7002_i2c_dev[0] = &(adap->dev);
+	dev_dbg(tvp7002_i2c_dev[0], "Tvp7002 i2c probe adapter called...\n");
+
+	/* Attach the client */
+	err = tvp7002_i2c_attach_client(&tvp7002_channel_info[0].i2c_dev.
+					client,
+					&tvp7002_channel_info[0].i2c_dev.
+					driver, adap,
+					tvp7002_channel_info[0].i2c_dev.
+					i2c_addr);
+	dev_dbg(tvp7002_i2c_dev[0], "Tvp7002 i2c probe adapter ends...\n");
+	return err;
+}
+
+/* tvp7002_i2c_init : This function is used initialize tvp7002 i2c client
+ */
+static int tvp7002_i2c_init(void)
+{
+	int err = 0;
+	int i = 0, j = 0;
+
+	/* Take instance of driver */
+	struct i2c_driver *driver;
+	char strings[TVP7002_NUM_CHANNELS][80] =
+	    { "TVP channel0 Video Decoder I2C driver"
+	};
+	for (i = 0; i < TVP7002_NUM_CHANNELS; i++) {
+		driver = &tvp7002_channel_info[i].i2c_dev.driver;
+		driver->driver.name = strings[i];
+		driver->id = I2C_DRIVERID_MISC;
+		if (0 == i) {
+			driver->attach_adapter = tvp7002_i2c_probe_adapter;
+		}
+		driver->detach_client = tvp7002_i2c_detach_client;
+		err = vpif_register_decoder(&tvp7002_dev[i]);
+		if (err < 0) {
+			for (j = i - 1; j > 0; j--) {
+				vpif_unregister_decoder(&tvp7002_dev[j]);
+			}
+			return err;
+		}
+	}
+	return err;
+}
+
+/* tvp7002_i2c_cleanup : This function is used detach tvp7002 i2c client
+ */
+static void tvp7002_i2c_cleanup(void)
+{
+	int i;
+	for (i = 0; i < TVP7002_NUM_CHANNELS; i++) {
+		if (tvp7002_channel_info[i].i2c_dev.i2c_registration & 0x01) {
+			i2c_del_driver(&tvp7002_channel_info[i].i2c_dev.driver);
+			tvp7002_channel_info[i].i2c_dev.client.adapter = NULL;
+			tvp7002_channel_info[i].i2c_dev.i2c_registration = 0;
+		}
+		vpif_unregister_decoder(&tvp7002_dev[i]);
+	}
+}
+
+module_init(tvp7002_i2c_init);
+module_exit(tvp7002_i2c_cleanup);
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/media/video/davinci/vpif.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/vpif.c
@@ -0,0 +1,426 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* vpif.c */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <media/davinci/vpif.h>
+
+#define VPIF_CH0_MAX_MODES	(22)
+#define VPIF_CH1_MAX_MODES	2
+#define VPIF_CH2_MAX_MODES	15
+#define VPIF_CH3_MAX_MODES	2
+
+/* This structure is used to keep track of VPIF size register's offsets */
+struct vpif_registers {
+	u32 h_cfg, v_cfg_00, v_cfg_01, v_cfg_02, v_cfg, ch_ctrl;
+	u32 line_offset, vanc0_strt, vanc0_size, vanc1_strt;
+	u32 vanc1_size, width_mask, len_mask;
+	u8 max_modes;
+};
+
+static struct vpif_registers vpifregs[VPIF_NUM_CHANNELS] = {
+	/* Channel0 registers offsets */
+	{VPIF_CH0_H_CFG, VPIF_CH0_V_CFG_00, VPIF_CH0_V_CFG_01,
+	 VPIF_CH0_V_CFG_02, VPIF_CH0_V_CFG_03, VPIF_CH0_CTRL,
+	 VPIF_CH0_IMG_ADD_OFST, 0, 0, 0, 0, 0x1FFF, 0xFFF, VPIF_CH0_MAX_MODES},
+	/* Channel1 registers offsets */
+	{VPIF_CH1_H_CFG, VPIF_CH1_V_CFG_00, VPIF_CH1_V_CFG_01,
+	 VPIF_CH1_V_CFG_02, VPIF_CH1_V_CFG_03, VPIF_CH1_CTRL,
+	 VPIF_CH1_IMG_ADD_OFST, 0, 0, 0, 0, 0x1FFF, 0xFFF, VPIF_CH1_MAX_MODES},
+	/* Channel2 registers offsets */
+	{VPIF_CH2_H_CFG, VPIF_CH2_V_CFG_00, VPIF_CH2_V_CFG_01,
+	 VPIF_CH2_V_CFG_02, VPIF_CH2_V_CFG_03, VPIF_CH2_CTRL,
+	 VPIF_CH2_IMG_ADD_OFST, VPIF_CH2_VANC0_STRT, VPIF_CH2_VANC0_SIZE,
+	 VPIF_CH2_VANC1_STRT, VPIF_CH2_VANC1_SIZE, 0x7FF, 0x7FF,
+	 VPIF_CH2_MAX_MODES},
+	/* Channel3 registers offsets */
+	{VPIF_CH3_H_CFG, VPIF_CH3_V_CFG_00, VPIF_CH3_V_CFG_01,
+	 VPIF_CH3_V_CFG_02, VPIF_CH3_V_CFG_03, VPIF_CH3_CTRL,
+	 VPIF_CH3_IMG_ADD_OFST, VPIF_CH3_VANC0_STRT, VPIF_CH3_VANC0_SIZE,
+	 VPIF_CH3_VANC1_STRT, VPIF_CH3_VANC1_SIZE, 0x7FF, 0x7FF,
+	 VPIF_CH3_MAX_MODES}
+};
+
+int vpif_channel_getfid(u8 channel_id)
+{
+	return (((regr(vpifregs[channel_id].ch_ctrl) & VPIF_CH_FID_MASK) >>
+		 VPIF_CH_FID_SHIFT));
+}
+
+EXPORT_SYMBOL(vpif_channel_getfid);
+
+#define VPIF_SD_PARAMS \
+	{"NTSC", 720, 480, 30, 0, 1, 268, 1440, 1, 23, 263, 266, \
+	 286, 525, 525, 0, 1, 0}, \
+	{"PAL", 720, 576, 25, 0, 1, 280, 1440, 1, 23, 311, 313, \
+	 336, 624, 625, 0, 1, 0}
+
+#define VPIF_SD_16BIT_OUTPUT_PARAMS \
+        {"NTSC-16Bit", 720, 480, 30, 0, 1, 268, 1440, 1, 23, 263, 266, \
+	 286, 525, 525, 0, 0, 0}, \
+	{"PAL-16Bit", 720, 576, 25, 0, 1, 280, 1440, 1, 23, 311, 313, \
+	 336, 624, 625, 0, 0, 0}
+
+#define VPIF_HD_PARAMS	\
+	{"720P-60", 1280, 720, 60, 1, 0, 362, 1280, 1, 26, 746, 0, \
+	 0, 0, 750, 0, 0, 1}, \
+	{"1080I-30", 1920, 1080, 30, 0, 0, 272, 1920, 1, 21, 561, 564, \
+	 584, 1124, 1125, 0, 0, 1}, \
+	{"1080I-25", 1920, 1080, 25, 0, 0, 712, 1920, 1, 21, 561, 564, \
+	 584, 1124, 1125, 0, 0, 1}
+
+#define VPIF_720P_PARAMS \
+	{"720P-25", 1280, 720, 25, 1, 0, 2672, 1280, 1, 26, 746, 0, \
+	 0, 0, 750, 0, 0, 1}, \
+	{"720P-30", 1280, 720, 30, 1, 0, 2012, 1280, 1, 26, 746, 0, \
+	 0, 0, 750, 0, 0, 1}, \
+	{"720P-50", 1280, 720, 50, 1, 0, 692, 1280, 1, 26, 746, 0, \
+	 0, 0, 750, 0, 0, 1}
+
+#define VPIF_1080P_PARAMS  \
+	{"1080P-24", 1920, 1080, 24, 1, 0, 822, 1920, 1, 42, 1122, 0, \
+	 0, 0, 1125, 0, 0, 1}, \
+	{"1080P-25", 1920, 1080, 25, 1, 0, 712, 1920, 1, 42, 1122, 0, \
+	 0, 0, 1125, 0, 0, 1}, \
+	{"1080P-30", 1920, 1080, 30, 1, 0, 272, 1920, 1, 42, 1122, 0, \
+	 0, 0, 1125, 0, 0, 1},
+
+#define VPIF_ED_PARAMS	\
+	{"480P-60", 720, 480, 60, 1, 0, 130, 720, 1, 43, 525, \
+	 0, 0, 0, 525, 0, 0, 0}, \
+	{"576P-50", 720, 576, 50, 1, 0, 136, 720, 1, 45, 621, \
+	 0, 0, 0, 625, 0, 0, 0}
+
+#define VPIF_MT9T001_PARAMS \
+	{"VGA-30", 640, 480, 30, 1, 0, 2068, 1320, 1, 31, 522, 0, \
+	 0, 0, 490, 1, 0, 0}, \
+	{"VGA-60", 640, 480, 60, 1, 0, 1432, 1320, 1, 31, 522, 0, \
+	 0, 0, 490, 1, 0, 0}, \
+	{"SVGA-30", 800, 600, 30, 1, 0, 1432, 1640, 1, 31, 652, 0, \
+	 0, 0, 620, 1, 0, 0}, \
+	{"SVGA-60", 800, 600, 60, 1, 0, 780, 1640, 1, 31, 652, 0, \
+	 0, 0, 620, 1, 0, 0}, \
+	{"XGA", 1024, 768, 30, 1, 0, 938, 2080, 1, 283, 806, 0, \
+	 0, 0, 776, 1, 0, 0}, \
+	{"480P-MT-30", 720, 480, 30, 1, 0, 2090, 1472, 1, 350, 839, 0, \
+	 0, 0, 488, 1, 0, 0}, \
+	{"480P-MT-60", 720, 480, 60, 1, 0, 1494, 1472, 1, 50, 539, 0, \
+	 0, 0, 488, 1, 0, 0}, \
+	{"576P-MT-25", 720, 576, 25, 1, 0, 2238, 1472, 1, 450, 1035, 0, \
+	 0, 0, 584, 1, 0, 0}, \
+	{"576P-MT-50", 720, 576, 50, 1, 0, 1558, 1472, 1, 48, 663, 0, \
+	 0, 0, 584, 1, 0, 0}, \
+	{"720P-MT-24", 1280, 720, 24, 1, 0, 1338, 2600, 1, 282, 1013, 0, \
+	 0, 0, 730, 1, 0, 0}, \
+	{"720P-MT-30", 1280, 720, 30, 1, 0, 782, 2600, 1, 220, 951, 0, \
+	 0, 0, 730, 1, 0, 0}, \
+	{"1080P-MT-18", 1920, 1080, 18, 1, 0, 954, 3840, 1, 31, 1112, 0, \
+	 0, 0, 1080, 1, 0, 0}
+
+static struct vpif_channel_config_params ch0_params[VPIF_CH0_MAX_MODES] = {
+	VPIF_SD_PARAMS, VPIF_HD_PARAMS, VPIF_MT9T001_PARAMS, VPIF_720P_PARAMS,
+	VPIF_ED_PARAMS
+};
+
+static struct vpif_channel_config_params ch1_params[VPIF_CH1_MAX_MODES] = {
+	VPIF_SD_PARAMS
+};
+static struct vpif_channel_config_params ch2_params[VPIF_CH2_MAX_MODES] = {
+	VPIF_SD_PARAMS, VPIF_HD_PARAMS, VPIF_ED_PARAMS,
+	VPIF_SD_16BIT_OUTPUT_PARAMS, VPIF_720P_PARAMS, VPIF_1080P_PARAMS
+};
+
+static struct vpif_channel_config_params *vpif_config_params
+    [VPIF_NUM_CHANNELS] = {
+	ch0_params,
+	ch1_params,
+	ch2_params,
+	ch1_params
+};
+static u8 irq_vpif_channel[VPIF_NUM_CHANNELS] = { 0, 1, 2, 3 };
+int vpif_get_irq_number(int ch_id)
+{
+	return irq_vpif_channel[ch_id];
+}
+
+EXPORT_SYMBOL(vpif_get_irq_number);
+
+/* Function to set vpif parameters */
+static void vpif_set_mode_info(u8 index, u8 channel_id, u8 config_channel_id);
+
+/* vpif_set_mode_info: This function is used to set horizontal and
+ * vertical config parameters in VPIF registers */
+static void vpif_set_mode_info(u8 index, u8 channel_id, u8 config_channel_id)
+{
+	u32 value;
+
+	/* As per the standard in the channel, configure the values of L1, L3,
+	   L5, L7  L9, L11 in VPIF Register */
+	/* Write width of the image */
+	value = (vpif_config_params[config_channel_id][index].eav2sav &
+		 vpifregs[config_channel_id].width_mask);
+	value <<= VPIF_CH_LEN_SHIFT;
+	value |= (vpif_config_params[config_channel_id][index].sav2eav &
+		  vpifregs[config_channel_id].width_mask);
+
+	regw(value, vpifregs[channel_id].h_cfg);
+
+	/* Write the L1 and L3 parameters in VPIF register */
+	value = (vpif_config_params[config_channel_id][index].l1 &
+		 vpifregs[config_channel_id].len_mask);
+	value <<= VPIF_CH_LEN_SHIFT;
+	value |= (vpif_config_params[config_channel_id][index].l3 &
+		  vpifregs[config_channel_id].len_mask);
+
+	regw(value, vpifregs[channel_id].v_cfg_00);
+
+	/* Write the L5 and L6 parameters in VPIF register */
+	value = (vpif_config_params[config_channel_id][index].l5 &
+		 vpifregs[config_channel_id].len_mask);
+	value <<= VPIF_CH_LEN_SHIFT;
+	value |= (vpif_config_params[config_channel_id][index].l7 &
+		  vpifregs[config_channel_id].len_mask);
+
+	regw(value, vpifregs[channel_id].v_cfg_01);
+
+	/* Write the L9 and L11 parameters in VPIF register */
+	value = (vpif_config_params[config_channel_id][index].l9 &
+		 vpifregs[config_channel_id].len_mask);
+	value <<= VPIF_CH_LEN_SHIFT;
+	value |= (vpif_config_params[config_channel_id][index].l11 &
+		  vpifregs[config_channel_id].len_mask);
+
+	regw(value, vpifregs[channel_id].v_cfg_02);
+
+	/* Write the image height in VPIF register */
+	value = (vpif_config_params[config_channel_id][index].vsize &
+		 vpifregs[config_channel_id].len_mask);
+	regw(value, vpifregs[channel_id].v_cfg);
+}
+
+/* vpif_set_video_capture_params: This function is used to set video
+ * parameters in VPIF register. It sets size parameters, frame format
+ * and yc mux mode */
+int vpif_set_video_params(struct vpif_params *vpifparams, u8 channel_id)
+{
+	int index, found = -1, i;
+	u8 max_modes = vpifregs[channel_id].max_modes;
+	u32 value, ch_nip;
+	u8 start, end;
+
+	/* loop on the number of mode supported per channel */
+	for (index = 0; index < max_modes; index++) {
+
+		/* If the mode is found, set the parameter in VPIF register */
+		if (0 == strcmp(vpif_config_params[channel_id][index].name,
+				vpifparams->video_params.name)) {
+
+			found = 1;
+			/* Set the size parameteres in the VPIF registers */
+			vpif_set_mode_info(index, channel_id, channel_id);
+
+			if (!(vpif_config_params[channel_id][index].ycmux_mode)) {
+				vpif_set_mode_info(index,
+						   channel_id + 1, channel_id);
+				found = 2;
+			}
+			start = channel_id;
+			end = channel_id + found;
+
+			for (i = start; i < end; i++) {
+				value = regr(vpifregs[i].ch_ctrl);
+
+				if (channel_id < 2)
+					ch_nip = VPIF_CAPTURE_CH_NIP;
+				else
+					ch_nip = VPIF_DISPLAY_CH_NIP;
+
+				/* Set the frame format in the
+				 * control register */
+				if (vpif_config_params[channel_id][index].
+				    frm_fmt) {
+					/* Progressive Frame Format */
+					SETBIT(value, ch_nip);
+				} else {
+					/* Interlaced Frame Format */
+					RESETBIT(value, ch_nip);
+				}
+
+				/* Set YC mux mode in the control register */
+				if (vpif_config_params[channel_id][index].
+				    ycmux_mode) {
+					/* YC Mux mode */
+					SETBIT(value, VPIF_CH_YC_MUX_BIT);
+				} else {
+					/* YC Non Mux mode */
+					RESETBIT(value, VPIF_CH_YC_MUX_BIT);
+				}
+				/* Set field/frame mode in control register */
+				if (vpifparams->video_params.storage_mode) {
+					SETBIT(value,
+					       VPIF_CH_INPUT_FIELD_FRAME_BIT);
+				} else {
+					RESETBIT(value,
+						 VPIF_CH_INPUT_FIELD_FRAME_BIT);
+				}
+
+				/* Set raster scanning SDR Format */
+				RESETBIT(value, VPIF_CH_SDR_FMT_BIT);
+
+				/* Set the capture format */
+				if (vpif_config_params[channel_id][index].
+				    capture_format) {
+					SETBIT(value, VPIF_CH_DATA_MODE_BIT);
+				} else {
+					RESETBIT(value, VPIF_CH_DATA_MODE_BIT);
+				}
+
+				if (channel_id > 1) {
+					/* Set the Pixel enable bit */
+					SETBIT(value, VPIF_DISPLAY_PIX_EN_BIT);
+				} else {
+					/* Set the polarity of various pins */
+					if (vpif_config_params[channel_id]
+					    [index].capture_format) {
+						if (vpifparams->params.
+						    raw_params.fid_pol) {
+							SETBIT(value,
+							       VPIF_CH_FID_POLARITY_BIT);
+						} else {
+							RESETBIT(value,
+								 VPIF_CH_FID_POLARITY_BIT);
+						}
+						if (vpifparams->params.
+						    raw_params.vd_pol) {
+							SETBIT(value,
+							       VPIF_CH_V_VALID_POLARITY_BIT);
+						} else {
+							RESETBIT(value,
+								 VPIF_CH_V_VALID_POLARITY_BIT);
+						}
+						if (vpifparams->params.
+						    raw_params.hd_pol) {
+							SETBIT(value,
+							       VPIF_CH_H_VALID_POLARITY_BIT);
+						} else {
+							RESETBIT(value,
+								 VPIF_CH_H_VALID_POLARITY_BIT);
+						}
+						/* Set data width */
+						value &=
+						    ((~(unsigned int)(0x3)) <<
+						     VPIF_CH_DATA_WIDTH_BIT);
+						value |=
+						    ((vpifparams->params.
+						      raw_params.
+						      data_sz) <<
+						     VPIF_CH_DATA_WIDTH_BIT);
+					}
+				}
+				regw(value, vpifregs[i].ch_ctrl);
+
+				/* Write the pitch in the driver */
+				regw((vpifparams->video_params.hpitch),
+				     vpifregs[i].line_offset);
+			}
+			break;
+		}
+	}
+	regw(0x80, VPIF_REQ_SIZE);
+	regw(0x01, VPIF_EMULATION_CTRL);
+	return found;
+}
+
+EXPORT_SYMBOL(vpif_set_video_params);
+
+int vpif_set_vbi_display_params(struct vpif_vbi_params *vbiparams,
+				u8 channel_id)
+{
+	u32 value;
+
+	value = 0x3F8 & (vbiparams->hstart0);
+	value |= 0x3FFFFFF & ((vbiparams->vstart0) << 16);
+	regw(value, vpifregs[channel_id].vanc0_strt);
+
+	value = 0x3F8 & (vbiparams->hstart1);
+	value |= 0x3FFFFFF & ((vbiparams->vstart1) << 16);
+	regw(value, vpifregs[channel_id].vanc1_strt);
+
+	value = 0x3F8 & (vbiparams->hsize0);
+	value |= 0x3FFFFFF & ((vbiparams->vsize0) << 16);
+	regw(value, vpifregs[channel_id].vanc0_size);
+
+	value = 0x3F8 & (vbiparams->hsize1);
+	value |= 0x3FFFFFF & ((vbiparams->vsize1) << 16);
+	regw(value, vpifregs[channel_id].vanc1_size);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(vpif_set_vbi_display_params);
+
+int vpif_get_mode_info(struct vpif_stdinfo *std_info)
+{
+	int index, found = -1;
+	u8 channel_id;
+	u8 max_modes;
+
+	if (!std_info)
+		return found;
+
+	channel_id = std_info->channel_id;
+
+	if (channel_id != 0 && channel_id != 1 && channel_id != 2 &&
+	    channel_id != 3) {
+		return found;
+	}
+
+	max_modes = vpifregs[channel_id].max_modes;
+
+	/* loop on the number of mode supported per channel */
+	for (index = 0; index < max_modes; index++) {
+
+		/* If the mode is found, set the parameter in VPIF register */
+		if (0 == strcmp(vpif_config_params[channel_id][index].name,
+				std_info->name)) {
+			std_info->activelines =
+			    vpif_config_params[channel_id][index].height;
+			std_info->activepixels =
+			    vpif_config_params[channel_id][index].width;
+			std_info->fps =
+			    vpif_config_params[channel_id][index].fps;
+			std_info->frame_format =
+			    vpif_config_params[channel_id][index].frm_fmt;
+			std_info->ycmux_mode =
+			    vpif_config_params[channel_id][index].ycmux_mode;
+			std_info->vbi_supported = vpif_config_params
+			    [channel_id][index].vbi_supported;
+			std_info->hd_sd =
+			    vpif_config_params[channel_id][index].hd_sd;
+			found = 1;
+			break;
+		}
+	}
+	return found;
+}
+
+EXPORT_SYMBOL(vpif_get_mode_info);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/include/asm-arm/arch-davinci/video_hdevm.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/video_hdevm.h
@@ -0,0 +1,36 @@
+/*
+ *
+ * Copyright (C) 2007 Texas Instruments	Inc
+ *
+ * This	program	is free	software; you can redistribute it and/or modify
+ * it under the	terms of the GNU General Public	License	as published by
+ * the Free Software Foundation; either	version	2 of the License, or
+ * (at your option)any	later version.
+ *
+ * This	program	is distributed in the hope that	it will	be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not,write to the	Free Software
+ * Foundation, Inc., 59	Temple Place, Suite 330, Boston, MA  02111-1307	USA
+ */
+/* video_hdevm.c */
+#ifndef CPLD_FUNCTIONS_H
+#define CPLD_FUNCTIONS_H
+
+int set_cpld_for_tvp5147(void);
+
+int set_cpld_for_tvp7002(void);
+
+int set_vid_in_mode_for_tvp5147(void);
+
+int set_vid_in_mode_for_tvp7002(void);
+
+int set_vid_out_mode_for_sd(void);
+
+int set_vid_out_mode_for_hd(void);
+void set_vpif_pinmux(void);
+int set_vid_clock(int);
+#endif /* CPLD_FUNCTIONS_H */
Index: linux-2.6.18/include/media/davinci/davincihd_capture.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/davincihd_capture.h
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davincihd_capture.h */
+
+#ifndef DAVINCIHD_CAPTURE_H
+#define DAVINCIHD_CAPTURE_H
+
+#ifdef __KERNEL__
+
+/* Header files */
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <media/video-buf.h>
+#include <media/davinci/vid_decoder_if.h>
+#include <media/davinci/vpif.h>
+
+#define VPIF_CAPTURE_NUM_DECODERS        4
+
+/* Macros */
+#define VPIF_MAJOR_RELEASE              0
+#define VPIF_MINOR_RELEASE              0
+#define VPIF_BUILD                      1
+#define VPIF_CAPTURE_VERSION_CODE       ((VPIF_MAJOR_RELEASE<<16) | \
+	(VPIF_MINOR_RELEASE<<8)  | \
+	VPIF_BUILD)
+
+#define VPIF_VALID_FIELD(field)         (((V4L2_FIELD_ANY == field) || \
+	(V4L2_FIELD_NONE == field)) || \
+	(((V4L2_FIELD_INTERLACED == field) || \
+	(V4L2_FIELD_SEQ_TB == field)) || \
+	(V4L2_FIELD_SEQ_BT == field)))
+
+#define VPIF_VALID_BUFFER_TYPE(buftype)	{ \
+			(V4L2_BUF_TYPE_VIDEO_CAPTURE == buftype) || \
+			(V4L2_BUF_TYPE_VBI_CAPTURE == buftype) || \
+			(V4L2_BUF_TYPE_SLICED_VBI_CAPTURE == buftype) || \
+			(V4L2_BUF_TYPE_HBI_CAPTURE == buftype)}
+
+#define VPIF_CAPTURE_MAX_DEVICES	2
+#define VPIF_MAX_DECODER_STD		50
+#define VPIF_TIMER_COUNT		5
+#define VPIF_SLICED_BUF_SIZE		256
+#define VPIF_SLICED_MAX_SERVICES	3
+#define VPIF_HBI_INDEX			2
+#define VPIF_VBI_INDEX			1
+#define VPIF_VIDEO_INDEX		0
+
+#define VPIF_NUMBER_OF_OBJECTS		3
+
+/* Macros */
+#define ISNULL(p)       ((NULL) == (p))
+#define ISALIGNED(a)    (0 == (a%8))
+#define ISDECODERCMD(cmd)       ((VPIF_CMD_S_DECODER_PARAMS==cmd) || \
+                                        (VPIF_CMD_G_DECODER_PARAMS==cmd))
+/* enumerated data types */
+/* Enumerated data type to give id to each device per channel */
+enum vpif_channel_id {
+	VPIF_CHANNEL0_VIDEO = 0,	/* Channel0 Video */
+	VPIF_CHANNEL1_VIDEO,	/* Channel1 Video */
+};
+
+/* structures */
+/* Table to keep track of the standards supported in all the decoders */
+struct vpif_decoder_std_tbl {
+	u8 dec_idx;
+	u8 std_idx;
+	v4l2_std_id std;
+};
+
+struct video_obj {
+	v4l2_std_id std;	/* Currently selected or default
+				   standard */
+	enum v4l2_field buf_field;
+
+	u32 latest_only;	/* indicate whether to return
+				   most recent displayed frame
+				   only */
+	struct vpif_stdinfo std_info;	/*Keeps track of the information
+					   about the standard */
+	u32 input_idx;		/* This is to track the last
+				   input that is passed to
+				   application */
+	struct vpif_decoder_std_tbl std_tbl[VPIF_MAX_DECODER_STD];
+	int count_std;
+};
+
+struct vbi_obj {
+	u8 timer_counter;	/* Counter to synchronize
+				   access to the timer */
+	struct tasklet_struct vbi_tasklet;	/* An object of tasklets
+						   structure which is used
+						   for read  sliced vbi data
+						   from decoders */
+	u8 num_services;
+};
+
+struct common_obj {
+	/* Buffer specific parameters */
+	u8 *fbuffers[VIDEO_MAX_FRAME];	/* List of buffer pointers for
+					   storing frames */
+	u32 numbuffers;		/* number of buffers in fbuffers */
+	struct videobuf_buffer *curFrm;	/* Pointer pointing to current
+					   v4l2_buffer */
+	struct videobuf_buffer *nextFrm;	/* Pointer pointing to current
+						   v4l2_buffer */
+	enum v4l2_memory memory;	/* This field keeps track of type
+					   of buffer exchange mechanism
+					   user has selected */
+	struct v4l2_format fmt;	/* Used to store pixel format */
+
+	struct videobuf_queue buffer_queue;	/* Buffer queue used in
+						   video-buf */
+	struct list_head dma_queue;	/* Queue of filled frames */
+	spinlock_t irqlock;	/* Used in video-buf */
+
+	/* channel specifc parameters */
+	struct semaphore lock;	/* lock used to access this
+				   structure */
+	u32 io_usrs;		/* number of users performing
+				   IO */
+	u8 started;		/* Indicates whether streaming
+				   started */
+	void (*set_addr) (unsigned long, unsigned long, unsigned long, unsigned long);	/* Function pointer to set
+											   the addresses */
+	u32 ytop_off;		/* offset where Y top starts
+				   from the starting of the
+				   buffer */
+	u32 ybtm_off;		/* offset where Y bottom starts
+				   from the starting of the
+				   buffer */
+	u32 ctop_off;		/* offset where C top starts
+				   from the starting of the
+				   buffer */
+	u32 cbtm_off;		/* offset where C bottom starts
+				   from the starting of the
+				   buffer */
+	u32 width;		/* Indicates width of the image
+				   data or width of the vbi data */
+	u32 height;		/* Indicates height of the image
+				   data or height of the vbi data */
+};
+
+struct channel_obj {
+	/* V4l2 specific parameters */
+	struct video_device *video_dev;	/* Identifies video device for
+					   this channel */
+	struct v4l2_prio_state prio;	/* Used to keep track of state of
+					   the priority */
+	u32 usrs;		/* number of open instances of
+				   the channel */
+	u32 field_id;		/* Indicates id of the field
+				   which is being displayed */
+	u8 initialized;		/* flag to indicate whether
+				   decoder is initialized */
+
+	enum vpif_channel_id channel_id;	/* Identifies channel */
+
+	struct decoder_device *decoder[VPIF_CAPTURE_NUM_DECODERS];
+	/* pointer to decoder device
+	   structures for this channel */
+	u8 numdecoders;		/* indicates number of decoders
+				   registered to VPIF-V4L2 */
+	u8 current_decoder;	/* Index of the currently
+				   selected decoder */
+	u8 default_decoder;	/* Index of the defalut decoder,
+				   set as per boot args at
+				   channel creation time */
+	struct vpif_params vpifparams;
+	struct common_obj common[VPIF_NUMBER_OF_OBJECTS];
+	struct video_obj video;
+	struct vbi_obj vbi;
+};
+
+/* File handle structure */
+struct vpif_fh {
+	struct channel_obj *channel;	/* pointer to channel object for
+					   opened device */
+	u8 io_allowed[VPIF_NUMBER_OF_OBJECTS];	/* Indicates whether this
+						   file handle is doing IO */
+	enum v4l2_priority prio;	/* Used to keep track priority of
+					   this instance */
+	u8 initialized;		/* Used to indicate channel is
+				   initialize or not */
+};
+
+/* vpif device structure */
+struct vpif_device {
+	struct channel_obj *dev[VPIF_CAPTURE_NUM_CHANNELS];
+};
+
+struct vpif_config_params {
+	u8 min_numbuffers;
+	u8 numbuffers[VPIF_CAPTURE_NUM_CHANNELS];
+	s8 device_type;
+	u32 min_bufsize[VPIF_CAPTURE_NUM_CHANNELS];
+	u32 channel_bufsize[VPIF_CAPTURE_NUM_CHANNELS];
+	u8 default_device[VPIF_CAPTURE_NUM_CHANNELS];
+	u8 max_device_type;
+};
+/* Struct which keeps track of the line numbers for the sliced vbi service */
+struct vpif_service_line {
+	u16 service_id;
+	u16 service_line[2];
+};
+#endif				/* End of __KERNEL__ */
+
+/* IOCTLs */
+#define VPIF_S_VPIF_PARAMS   _IOW('V', BASE_VIDIOC_PRIVATE+1, \
+					struct vpif_params)
+#define VPIF_G_VPIF_PARAMS   _IOR('V', BASE_VIDIOC_PRIVATE+2, \
+					struct vpif_params)
+#define VPFE_S_MT9T001_PARAMS _IOW('V', BASE_VIDIOC_PRIVATE+3, \
+					void *)
+#define VPFE_G_MT9T001_PARAMS _IOR('V', BASE_VIDIOC_PRIVATE+4, \
+					void *)
+#define VPFE_CMD_CONFIG_TVP5146 _IOW('V',BASE_VIDIOC_PRIVATE + 5, \
+					void *)
+#define VPIF_CMD_G_DECODER_PARAMS _IOR('V',BASE_VIDIOC_PRIVATE+8, \
+					void *)
+#define VPIF_CMD_S_DECODER_PARAMS _IOW('V',BASE_VIDIOC_PRIVATE+9, \
+					void *)
+
+#endif				/* DAVINCIHD_CAPTURE_H */
Index: linux-2.6.18/include/media/davinci/davincihd_display.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/davincihd_display.h
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davincihd_display_new.h */
+
+#ifndef DAVINCIHD_DISPLAY_H
+#define DAVINCIHD_DISPLAY_H
+
+#ifdef __KERNEL__
+
+/* Header files */
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-dev.h>
+#include <media/video-buf.h>
+#include <media/davinci/vid_encoder_if.h>
+#include <media/davinci/vpif.h>
+#endif
+
+#ifdef __KERNEL__
+
+/* Macros */
+#define VPIF_MAJOR_RELEASE              0
+#define VPIF_MINOR_RELEASE              0
+#define VPIF_BUILD                      1
+#define VPIF_DISPLAY_VERSION_CODE       ((VPIF_MAJOR_RELEASE<<16) | \
+	(VPIF_MINOR_RELEASE<<8)  | \
+	VPIF_BUILD)
+
+#define VPIF_VALID_FIELD(field)         (((V4L2_FIELD_ANY == field) || \
+	(V4L2_FIELD_NONE == field)) || \
+	(((V4L2_FIELD_INTERLACED == field) || \
+	(V4L2_FIELD_SEQ_TB == field)) || \
+	(V4L2_FIELD_SEQ_BT == field)))
+
+#define VPIF_DISPLAY_MAX_DEVICES        2
+#define VPIF_SLICED_BUF_SIZE 	 	256
+#define VPIF_SLICED_MAX_SERVICES	3
+#define VPIF_VIDEO_INDEX                0
+#define VPIF_VBI_INDEX			1
+#define VPIF_HBI_INDEX			2
+
+#define VPIF_NUMOBJECTS			3
+
+/* Macros */
+#define ISNULL(p)       ((NULL) == (p))
+#define ISALIGNED(a)    (0 == (a%8))
+
+/* enumerated data types */
+/* Enumerated data type to give id to each device per channel */
+enum vpif_channel_id {
+	VPIF_CHANNEL2_VIDEO = 0,	/* Channel2 Video */
+	VPIF_CHANNEL3_VIDEO,	/* Channel3 Video */
+};
+
+/* structures */
+
+struct video_obj {
+	struct vid_enc_mode_info mode_info;
+	enum v4l2_field buf_field;
+
+	u32 latest_only;	/* indicate whether to return
+				   most recent displayed frame
+				   only */
+	struct vpif_stdinfo std_info;	/*Keeps track of the information
+					   about the standard */
+};
+
+struct vbi_obj {
+	struct vpif_vbi_params vbiparams;	/* Structure storing
+						   vpif parameters
+						   for the raw vbi data */
+	int num_services;
+};
+
+struct common_obj {
+	/* Buffer specific parameters */
+	u8 *fbuffers[VIDEO_MAX_FRAME];	/* List of buffer pointers for
+					   storing frames */
+	u32 numbuffers;		/* number of buffers in fbuffers */
+	struct videobuf_buffer *curFrm;	/* Pointer pointing to current
+					   videobuf_buffer */
+	struct videobuf_buffer *nextFrm;	/* Pointer pointing to current
+						   videobuf_buffer */
+	enum v4l2_memory memory;	/* This field keeps track of type
+					   of buffer exchange mechanism
+					   user has selected */
+	struct v4l2_format fmt;	/* Used to store the format */
+
+	struct videobuf_queue buffer_queue;	/* Buffer queue used in
+						   video-buf */
+	struct list_head dma_queue;	/* Queue of filled frames */
+	spinlock_t irqlock;	/* Used in video-buf */
+
+	/* channel specifc parameters */
+	struct semaphore lock;	/* lock used to access this
+				   structure */
+	u32 io_usrs;		/* number of users performing
+				   IO */
+	u8 started;		/* Indicates whether streaming
+				   started */
+
+	u32 ytop_off;		/* offset where Y top starts
+				   from the starting of the
+				   buffer */
+	u32 ybtm_off;		/* offset where Y bottom starts
+				   from the starting of the
+				   buffer */
+	u32 ctop_off;		/* offset where C top starts
+				   from the starting of the
+				   buffer */
+	u32 cbtm_off;		/* offset where C bottom starts
+				   from the starting of the
+				   buffer */
+	void (*set_addr) (unsigned long, unsigned long, unsigned long, unsigned long);	/* Function pointer to set
+											   the addresses */
+	u32 height;
+	u32 width;
+};
+
+struct channel_obj {
+	/* V4l2 specific parameters */
+	struct video_device *video_dev;	/* Identifies video device for
+					   this channel */
+	struct v4l2_prio_state prio;	/* Used to keep track of state of
+					   the priority */
+	u32 usrs;		/* number of open instances of
+				   the channel */
+	u32 field_id;		/* Indicates id of the field
+				   which is being displayed */
+	u8 initialized;		/* flag to indicate whether
+				   encoder is initialized */
+
+	enum vpif_channel_id channel_id;	/* Identifies channel */
+
+	struct vpif_params vpifparams;
+	struct common_obj common[VPIF_NUMOBJECTS];
+	struct video_obj video;
+	struct vbi_obj vbi;
+};
+
+/* File handle structure */
+struct vpif_fh {
+	struct channel_obj *channel;	/* pointer to channel object for
+					   opened device */
+	u8 io_allowed[VPIF_NUMOBJECTS];	/* Indicates whether this file handle
+					   is doing IO */
+	enum v4l2_priority prio;	/* Used to keep track priority of
+					   this instance */
+	u8 initialized;		/* Used to keep track of whether this
+				   file handle has initialized
+				   channel or not */
+};
+
+/* vpif device structure */
+struct vpif_device {
+	struct channel_obj *dev[VPIF_DISPLAY_NUM_CHANNELS];
+};
+
+struct vpif_config_params {
+	u8 min_numbuffers;
+	u8 numbuffers[VPIF_DISPLAY_NUM_CHANNELS];
+	u32 min_bufsize[VPIF_DISPLAY_NUM_CHANNELS];
+	u32 channel_bufsize[VPIF_DISPLAY_NUM_CHANNELS];
+};
+
+/* Struct which keeps track of the line numbers for the sliced vbi service */
+struct vpif_service_line {
+	u16 service_id;
+	u16 service_line[2];
+	u16 enc_service_id;
+	u8 bytestowrite;
+};
+
+#endif				/* End of __KERNEL__ */
+
+/* IOCTLs */
+
+#define VPIF_S_VPIF_PARAMS   _IOW('V', BASE_VIDIOC_PRIVATE+1, \
+					struct vpif_params)
+#define VPIF_G_VPIF_PARAMS   _IOR('V', BASE_VIDIOC_PRIVATE+2, \
+					struct vpif_params)
+
+#define VPIF_CMD_S_ENCODER_PARAMS _IOW('V',BASE_VIDIOC_PRIVATE+12, \
+					void *)
+#define VPIF_CMD_G_ENCODER_PARAMS _IOR('V',BASE_VIDIOC_PRIVATE+13, \
+					void *)
+
+#ifdef __KERNEL__
+#define ISENCODERCMD(cmd)	((VPIF_CMD_S_ENCODER_PARAMS==cmd) || \
+					(VPIF_CMD_G_ENCODER_PARAMS==cmd))
+#endif
+
+#endif				/* DAVINCIHD_DISPLAY_H */
Index: linux-2.6.18/include/media/davinci/tvp5147.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/tvp5147.h
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* tvp5147.h file */
+
+#ifndef TVP5147_H
+#define TVP5147_H
+
+#ifdef __KERNEL__
+
+/* Kernel Header files */
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <media/davinci/vid_decoder_if.h>
+
+#endif				/* __KERNEL__ */
+
+#define VPFE_STD_625_50_SQP ((v4l2_std_id)0x0000000100000000ULL)
+#define VPFE_STD_525_60_SQP ((v4l2_std_id)0x0000000200000000ULL)
+#define VPFE_STD_AUTO       ((v4l2_std_id)0x0000000400000000ULL)
+#define VPFE_STD_AUTO_SQP   ((v4l2_std_id)0x0000000800000000ULL)
+
+#define V4L2_STD_TVP5147_ALL         (V4L2_STD_525_60 | V4L2_STD_625_50 |\
+	VPFE_STD_AUTO | VPFE_STD_625_50_SQP |\
+	VPFE_STD_525_60_SQP | VPFE_STD_AUTO_SQP)
+
+typedef struct {
+	v4l2_std_id std;
+	int inputidx;
+	struct v4l2_format fmt;
+} tvp5147_params;
+
+#ifdef __KERNEL__
+
+#define TVP5147_NUM_CHANNELS                    2
+
+#define TVP5147_MAX_VBI_SERVICES		2	/* This gives maximum
+							   number of VBI service
+							   supported */
+
+typedef enum {
+	TVP5147_MODE_INV = -1,
+	TVP5147_MODE_AUTO = 0,	/* autoswitch mode (default)   */
+	TVP5147_MODE_NTSC = 1,	/* (M, J) NTSC      525-line   */
+	TVP5147_MODE_PAL = 2,	/* (B, D, G, H, I, N) PAL      */
+	TVP5147_MODE_PAL_M = 3,	/* (M) PAL          525-line   */
+	TVP5147_MODE_PAL_CN = 4,	/* (Combination-N) PAL         */
+	TVP5147_MODE_NTSC_443 = 5,	/* NTSC 4.43        525-line   */
+	TVP5147_MODE_SECAM = 6,	/* SECAM                       */
+	TVP5147_MODE_PAL_60 = 7,	/* PAL 60          525-line    */
+	TVP5147_MODE_AUTO_SQP = 8,	/* autoswitch mode (default)   */
+	TVP5147_MODE_NTSC_SQP = 9,	/* (M, J) NTSC      525-line   */
+	TVP5147_MODE_PAL_SQP = 0xA,	/* (B, D, G, H, I, N) PAL      */
+	TVP5147_MODE_PAL_M_SQP = 0xB,	/* (M) PAL          525-line   */
+	TVP5147_MODE_PAL_CN_SQP = 0xC,	/* (Combination-N) PAL         */
+	TVP5147_MODE_NTSC_443_SQP = 0xD,	/* NTSC 4.43 525-line          */
+	TVP5147_MODE_SECAM_SQP = 0xE,	/* SECAM                       */
+	TVP5147_MODE_PAL_60_SQP = 0xF,	/* PAL 60          525-line    */
+} tvp5147_mode;
+
+/* decoder standard related strctures */
+#define TVP5147_MAX_NO_INPUTS           (1)
+#define TVP5147_MAX_NO_STANDARDS        (6)
+#define TVP5147_MAX_NO_CONTROLS         (5)
+/* for AUTO mode, stdinfo structure will not be filled */
+#define TVP5147_STANDARD_INFO_SIZE      (TVP5147_MAX_NO_STANDARDS - 2)
+
+#define TVP5147_MAX_NO_MODES           (3)
+
+struct tvp5147_control_info {
+	int register_address;
+	struct v4l2_queryctrl query_control;
+};
+
+struct tvp5147_config {
+	int no_of_inputs;
+	struct {
+		int input_type;
+		u8 lock_mask;
+		struct v4l2_input input_info;
+		int no_of_standard;
+		struct v4l2_standard *standard;
+		v4l2_std_id def_std;
+		 tvp5147_mode(*mode)[TVP5147_MAX_NO_MODES];
+		int no_of_controls;
+		struct tvp5147_control_info *controls;
+	} input[TVP5147_MAX_NO_INPUTS];
+	struct v4l2_sliced_vbi_cap sliced_cap;
+	u8 num_services;
+};
+
+struct tvp5147_channel {
+	struct {
+		struct i2c_client client;
+		struct i2c_driver driver;
+		u32 i2c_addr;
+		int i2c_registration;
+	} i2c_dev;
+	struct decoder_device *dec_device;
+	tvp5147_params params;
+};
+
+struct tvp5147_service_data_reg {
+	u32 service;
+	struct {
+		u8 addr[3];
+	} field[2];
+	u8 bytestoread;
+};
+
+struct tvp5147_sliced_reg {
+	u32 service;
+	u8 line_addr_value;
+	u16 line_start, line_end;
+	struct {
+		u8 fifo_line_addr[3];
+		u8 fifo_mode_value;
+	} field[2];
+	v4l2_std_id std;
+	struct {
+		u8 index;
+		u16 value;
+	} service_line[2];
+};
+
+/* Defines for TVP5147 register address */
+
+#define TVP5147_INPUT_SEL                                       (0x00)
+#define TVP5147_AFE_GAIN_CTRL                                   (0x01)
+#define TVP5147_VIDEO_STD                                       (0x02)
+#define TVP5147_OPERATION_MODE                                  (0x03)
+#define TVP5147_AUTOSWT_MASK                                    (0x04)
+#define TVP5147_COLOR_KILLER                                    (0x05)
+#define TVP5147_LUMA_CONTROL1                                   (0x06)
+#define TVP5147_LUMA_CONTROL2                                   (0x07)
+#define TVP5147_LUMA_CONTROL3                                   (0x08)
+#define TVP5147_BRIGHTNESS                                      (0x09)
+#define TVP5147_CONTRAST                                        (0x0A)
+#define TVP5147_SATURATION                                      (0x0B)
+#define TVP5147_HUE                                             (0x0C)
+#define TVP5147_CHROMA_CONTROL1                                 (0x0D)
+#define TVP5147_CHROMA_CONTROL2                                 (0x0E)
+#define TVP5147_OUTPUT1                                         (0x33)
+#define TVP5147_OUTPUT2                                         (0x34)
+#define TVP5147_OUTPUT3                                         (0x35)
+#define TVP5147_OUTPUT4                                         (0x36)
+#define TVP5147_OUTPUT5                                         (0x37)
+#define TVP5147_OUTPUT6                                         (0x38)
+#define TVP5147_CLEAR_LOST_LOCK                                 (0x39)
+#define TVP5147_STATUS1                                         (0x3A)
+#define TVP5147_VID_STD_STATUS                                  (0x3F)
+#define TVP5147_FIFO_OUTPUT_CTRL				(0xC0)
+
+/* masks */
+
+#define TVP5147_LOST_LOCK_MASK                                  (0x10)
+/* mask to enable autoswitch for all standards*/
+
+#define TVP5147_AUTOSWITCH_MASK                                 (0x7F)
+#define TVP5147_COMPOSITE_INPUT                                 (0x05)
+#define TVP5147_SVIDEO_INPUT                                    (0x46)
+
+/* DEFAULTS */
+
+#define TVP5147_OPERATION_MODE_RESET				(0x1)
+#define TVP5147_OPERATION_MODE_DEFAULT                          (0x0)
+#define TVP5147_AFE_GAIN_CTRL_DEFAULT                           (0x0F)
+#define TVP5147_COLOR_KILLER_DEFAULT                            (0x10)
+#define TVP5147_LUMA_CONTROL1_DEFAULT                           (0x10)
+#define TVP5147_LUMA_CONTROL2_DEFAULT                           (0x00)
+#define TVP5147_LUMA_CONTROL3_DEFAULT                           (0x02)
+#define TVP5147_BRIGHTNESS_DEFAULT                              (0x80)
+#define TVP5147_CONTRAST_DEFAULT                                (0x80)
+#define TVP5147_SATURATION_DEFAULT                              (0x80)
+#define TVP5147_HUE_DEFAULT                                     (0x00)
+#define TVP5147_CHROMA_CONTROL1_DEFAULT                         (0x00)
+#define TVP5147_CHROMA_CONTROL2_DEFAULT                         (0x0E)
+#define TVP5147_OUTPUT1_DEFAULT					(0x40)
+#define TVP5147_OUTPUT2_DEFAULT					(0x11)
+#define TVP5147_OUTPUT3_DEFAULT					(0xFF)
+#define TVP5147_OUTPUT4_DEFAULT					(0xFF)
+#define TVP5147_OUTPUT5_DEFAULT					(0xFF)
+#define TVP5147_OUTPUT6_DEFAULT					(0xFF)
+#define TVP5147_FIFO_OUTPUT_CTRL_DEFAULT			(0x01)
+
+#define TVP5147_VBUS_ADDRESS_ACCESS0				(0xE8)
+#define TVP5147_VBUS_ADDRESS_ACCESS1				(0xE9)
+#define TVP5147_VBUS_ADDRESS_ACCESS2				(0xEA)
+#define TVP5147_VBUS_DATA_ACCESS				(0xE0)
+#define TVP5147_VBUS_DATA_ACCESS_AUTO_INCR			(0xE1)
+
+#define TVP5147_LINE_ADDRESS_START				(0x80)
+#define TVP5147_LINE_ADDRESS_MIDDLE				(0x06)
+#define TVP5147_LINE_ADDRESS_END				(0x00)
+
+#define TVP5147_LINE_ADDRESS_DEFAULT				(0x00)
+#define TVP5147_LINE_MODE_DEFAULT				(0xFF)
+
+#define TVP5147_VDP_LINE_START					(0xD6)
+#define TVP5147_VDP_LINE_STOP					(0xD7)
+
+#define TVP5147_VBI_NUM_SERVICES				(3)
+#define TVP5147_SLICED_BUF_SIZE					(128)
+
+#endif				/* __KERNEL__ */
+
+#endif				/* TVP5147_H */
Index: linux-2.6.18/include/media/davinci/tvp7002.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/tvp7002.h
@@ -0,0 +1,484 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* tvp7002.h file */
+#ifndef TVP7002_H
+#define TVP7002_H
+
+#ifdef __KERNEL__
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <media/davinci/vid_decoder_if.h>
+#endif				/* __KERNEL__ */
+
+#define V4L2_STD_TVP7002_ALL        (V4L2_STD_720P_60 | \
+					V4L2_STD_720P_50 | \
+					V4L2_STD_1080I_60 | \
+					V4L2_STD_1080I_50 | \
+					V4L2_STD_525P_60)
+
+/* enum */
+typedef enum {
+	TVP7002_MODE_480i_30FPS = 0,
+	TVP7002_MODE_576i_25FPS,
+	TVP7002_MODE_480p_30FPS,
+	TVP7002_MODE_576p_25FPS,
+	TVP7002_MODE_720p_30FPS,
+	TVP7002_MODE_1080i_30FPS,
+	TVP7002_MODE_1080p_30FPS,
+	TVP7002_MODE_1080i_25FPS
+} tvp7002_mode;
+
+typedef enum {
+	TVP7002_VCOEFF_1,
+	TVP7002_VCOEFF_2,
+	TVP7002_VCOEFF_4,
+	TVP7002_VCOEFF_8,
+	TVP7002_VCOEFF_16,
+	TVP7002_VCOEFF_32,
+	TVP7002_VCOEFF_64,
+	TVP7002_VCOEFF_128,
+	TVP7002_VCOEFF_256,
+	TVP7002_VCOEFF_512,
+	TVP7002_VCOEFF_1024
+} tvp7002_alc_vertical_coeff;
+
+typedef enum {
+	TVP7002_HCOEFF_2,
+	TVP7002_HCOEFF_4,
+	TVP7002_HCOEFF_8,
+	TVP7002_HCOEFF_16,
+	TVP7002_HCOEFF_32,
+	TVP7002_HCOEFF_64,
+	TVP7002_HCOEFF_128,
+	TVP7002_HCOEFF_256,
+	TVP7002_HCOEFF_512
+} tvp7002_alc_horizontal_coeff;
+
+typedef enum {
+	HPLL_POST_DIVIDE_1 = 0,
+	HPLL_POST_DIVIDE_2
+} tvp7002_post_divider;
+
+typedef enum {
+	VCO_GAIN_ULTRA_LOW = 0,
+	VCO_GAIN_LOW,
+	VCO_GAIN_MEDIUM,
+	VCO_GAIN_HIGH
+} tvp7002_vco_gain;
+
+typedef enum {
+	CP_CURRENT_SMALL,
+	CP_CURRENT_DEFAULT,
+	CP_CURRENT_LARGE
+} tvp7002_cp_current;
+
+/*structures*/
+
+struct alc_filter {
+	int alc_enable;
+	tvp7002_alc_vertical_coeff vcoeff;
+	tvp7002_alc_horizontal_coeff hcoeff;
+};
+
+struct tvp7002_format_params {
+	unsigned char hpll_divider_msb;
+	unsigned char hpll_divider_lsb;
+	tvp7002_vco_gain hpll_vco_control;
+	tvp7002_cp_current hpll_cp_current;
+	unsigned char hpll_phase_select;
+	tvp7002_post_divider hpll_post_divider;
+	unsigned char hpll_control;
+	unsigned char avid_start_msb;
+	unsigned char avid_start_lsb;
+	unsigned char avid_stop_msb;
+	unsigned char avid_stop_lsb;
+	unsigned char vblk_start_f0_line_offset;
+	unsigned char vblk_start_f1_line_offset;
+	unsigned char vblk_f0_duration;
+	unsigned char vblk_f1_duration;
+	unsigned char alc_placement;
+	unsigned char clamp_start, clamp_width;
+	unsigned char hpll_pre_coast;
+	unsigned char hpll_post_coast;
+	unsigned char reserved;
+};
+
+struct tvp7002_offset {
+	unsigned char blue_fine_offset;
+	unsigned char green_fine_offset;
+	unsigned char red_fine_offset;
+	unsigned char blue_fine_offset_lsb;
+	unsigned char green_fine_offset_lsb;
+	unsigned char red_fine_offset_lsb;
+	unsigned char blue_coarse_offset;
+	unsigned char green_coarse_offset;
+	unsigned char red_coarse_offset;
+};
+
+struct tvp7002_gain {
+	unsigned char blue_fine_gain;
+	unsigned char green_fine_gain;
+	unsigned char red_fine_gain;
+	unsigned char blue_coarse_gain;
+	unsigned char green_coarse_gain;
+	unsigned char red_coarse_gain;
+};
+
+typedef struct {
+	v4l2_std_id std;
+	int inputidx;
+	struct alc_filter alc;
+	struct tvp7002_gain gain;
+	struct tvp7002_offset offset;
+	struct tvp7002_format_params format;
+} tvp7002_params;
+
+#ifdef __KERNEL__
+
+#define TVP7002_NUM_CHANNELS                    1
+
+/* Macros */
+#define TVP7002_LINES_720       0x2EE
+#define TVP7002_LINES_1080_60   0x465
+#define TVP7002_LINES_1080_50   0x465
+#define TVP7002_CLOCKS_PER_LINE_1080_60 188
+#define TVP7002_CLOCKS_PER_LINE_1080_50 226
+
+#define INTERLACED_VIDEO                         (0)
+#define PROGRESSIVE_VIDEO                        (1)
+
+#define GENERATE_MASK(bits, pos) ((((0xFFFFFFFF) << (32-bits)) >> \
+		(32-bits)) << pos)
+
+/* Defines for input supported */
+#define TVP7002_HD (0)
+
+/* Macros for default register values */
+#define TVP7002_HPLL_MSB_DEFAULT                (0x67)
+#define TVP7002_HPLL_LSB_DEFAULT                (0x20)
+#define TVP7002_HPLL_CONTROL_DEFAULT            (0xA0)
+#define TVP7002_HPLL_PHASE_SEL_DEFAULT          (0x80)
+#define TVP7002_CLAMP_START_DEFAULT             (0x32)
+#define TVP7002_CLAMP_WIDTH_DEFAULT             (0x20)
+#define TVP7002_HSYNC_OUTWIDTH_DEFAULT          (0x60)
+#define TVP7002_BLUE_FINE_GAIN_DEFAULT          (0x00)
+#define TVP7002_GREEN_FINE_GAIN_DEFAULT         (0x00)
+#define TVP7002_RED_FINE_GAIN_DEFAULT           (0x00)
+#define TVP7002_BLUEF_OFFSETMSB_DEFAULT         (0x80)
+#define TVP7002_GREENF_OFFSETMSB_DEFAULT        (0x80)
+#define TVP7002_REDF_OFFSETMSB_DEFAULT          (0x80)
+#define TVP7002_SYNC_CONTROL1_DEFAULT           (0x20)
+#define TVP7002_HPLL_CLAMP_CTRL_DEFAULT         (0x2E)
+#define TVP7002_SYNC_GREEN_THLD_DEFAULT         (0x5D)
+#define TVP7002_SYNC_SEP_THLD_DEFAULT           (0x47)
+#define TVP7002_HPLL_PRE_COAST_DEFAULT          (0x00)
+#define TVP7002_HPLL_POST_COAST_DEFAULT         (0x00)
+#define TVP7002_OUTPUT_FORMATTER_DEFAULT        (0x47)
+#define TVP7002_MISC_CONTROL1_DEFAULT           (0x01)
+#define TVP7002_MISC_CONTROL2_DEFAULT           (0x00)
+#define TVP7002_MISC_CONTROL3_DEFAULT           (0x01)
+#define TVP7002_INPUT_MUX_SELECT1_DEFAULT       (0x00)
+#define TVP7002_INPUT_MUX_SELECT2_DEFAULT       (0x67)
+#define TVP7002_BLUE_GREEN_COARSE_GAIN_DEFAULT  (0x77)
+#define TVP7002_RED_COARSE_GAIN_DEFAULT         (0x07)
+#define TVP7002_FINE_OFFSET_LSBS_DEFAULT        (0x00)
+#define TVP7002_BLUE_COARSE_OFFSET_DEFUALT      (0x10)
+#define TVP7002_GREEN_COARSE_OFFSET_DEFAULT     (0x10)
+#define TVP7002_RED_COARSE_OFFSET_DEFAULT       (0x10)
+#define TVP7002_RED_COARSE_OFFSET_DEFAULT       (0x10)
+#define TVP7002_HSOUT_OUTPUT_START_DEFAULT      (0x08)
+#define TVP7002_MISC_CONTROL4_DEFAULT           (0x00)
+#define TVP7002_ALC_ENABLE_DEFAULT              (0x80)
+#define TVP7002_ALC_FILTER_DEFAULT              (0x53)
+#define TVP7002_FINE_CLAMP_CONTROL_DEFAULT      (0x07)
+#define TVP7002_POWER_CONTROL_DEFAULT           (0x00)
+#define TVP7002_ADC_SETUP_DEFAULT               (0x50)
+#define TVP7002_COARSE_CLAMP_CONTROL_DEFAULT    (0x00)
+#define TVP7002_SOG_CLAMP_DEFAULT               (0x80)
+#define TVP7002_ALC_PLACEMENT_DEFAULT           (0x5A)
+#define TVP7002_VSYNC_ALIGNMENT_DEFAULT         (0x10)
+#define TVP7002_SYNC_BYPASS_DEFAULT             (0x00)
+#define TVP7002_LINE_LENGTH_TOLERENCE_DEFAULT   (0x03)
+#define TVP7002_ADC_REF_SETUP_DEFAULT           (0x04)
+#define TVP7002_POWER_DOWN			(0x7F)
+#define TVP7002_VIDEO_BANDWIDTH_CONTROL_DEFAULT	(0x01)
+#define TVP7002_AVID_START_PIXEL_DEFAULT	(0x01)
+
+/* Macros for horizontal PLL */
+#define FEEDBACK_DIVIDER_MSB_720p               (0x67)
+#define FEEDBACK_DIVIDER_LSB_720p               (0x02)
+#define VCO_CONTROL_720p                        (0x02)
+#define CP_CURRENT_720p                         (0x04)
+#define PHASE_SELECT_720p                       (0x16)
+#define POST_DIVIDER_720p                       (0x0)
+#define HPLL_CONTROL_720p			(0xA0)
+#define AVID_START_PIXEL_LSB_720p		(0x47)
+#define AVID_START_PIXEL_MSB_720p		(0x01)
+#define AVID_STOP_PIXEL_LSB_720p		(0x4B)
+#define AVID_STOP_PIXEL_MSB_720p		(0x06)
+#define VBLK_F0_START_LINE_OFFSET_720p		(0x05)
+#define VBLK_F1_START_LINE_OFFSET_720p		(0x00)
+#define VBLK_F0_DURATION_720p			(0x2D)
+#define VBLK_F1_DURATION_720p			(0x00)
+#define RESERVED_720p				(0x03)
+
+#define FEEDBACK_DIVIDER_MSB_720p_50            (0x7B)
+#define FEEDBACK_DIVIDER_LSB_720p_50            (0x0C)
+#define VCO_CONTROL_720p_50                     (0x02)
+#define CP_CURRENT_720p_50                      (0x03)
+#define PHASE_SELECT_720p_50                    (0x16)
+#define POST_DIVIDER_720p_50                    (0x0)
+#define HPLL_CONTROL_720p_50			(0x98)
+#define AVID_START_PIXEL_LSB_720p_50		(0x47)
+#define AVID_START_PIXEL_MSB_720p_50		(0x01)
+#define AVID_STOP_PIXEL_LSB_720p_50		(0x4B)
+#define AVID_STOP_PIXEL_MSB_720p_50		(0x06)
+#define VBLK_F0_START_LINE_OFFSET_720p_50	(0x05)
+#define VBLK_F1_START_LINE_OFFSET_720p_50	(0x00)
+#define VBLK_F0_DURATION_720p_50		(0x2D)
+#define VBLK_F1_DURATION_720p_50		(0x00)
+#define RESERVED_720p				(0x03)
+
+#define FEEDBACK_DIVIDER_MSB_1080i              (0x89)
+#define FEEDBACK_DIVIDER_LSB_1080i              (0x08)
+#define VCO_CONTROL_1080i                       (0x02)
+#define CP_CURRENT_1080i                        (0x03)
+#define PHASE_SELECT_1080i                      (0x14)
+#define POST_DIVIDER_1080i                      (0x0)
+#define HPLL_CONTROL_1080i			(0x98)
+#define AVID_START_PIXEL_LSB_1080i		(0x06)
+#define AVID_START_PIXEL_MSB_1080i		(0x01)
+#define AVID_STOP_PIXEL_LSB_1080i		(0x8A)
+#define AVID_STOP_PIXEL_MSB_1080i		(0x08)
+#define VBLK_F0_START_LINE_OFFSET_1080i		(0x02)
+#define VBLK_F1_START_LINE_OFFSET_1080i		(0x02)
+#define VBLK_F0_DURATION_1080i			(0x16)
+#define VBLK_F1_DURATION_1080i			(0x17)
+#define RESERVED_1080i				(0x02)
+
+#define FEEDBACK_DIVIDER_MSB_1080i_50           (0xA5)
+#define FEEDBACK_DIVIDER_LSB_1080i_50           (0x00)
+#define VCO_CONTROL_1080i_50                    (0x02)
+#define CP_CURRENT_1080i_50                     (0x02)
+#define PHASE_SELECT_1080i_50                   (0x14)
+#define POST_DIVIDER_1080i_50                   (0x0)
+#define HPLL_CONTROL_1080i_50			(0x90)
+#define AVID_START_PIXEL_LSB_1080i_50		(0x06)
+#define AVID_START_PIXEL_MSB_1080i_50		(0x01)
+#define AVID_STOP_PIXEL_LSB_1080i_50		(0x8A)
+#define AVID_STOP_PIXEL_MSB_1080i_50		(0x08)
+#define VBLK_F0_START_LINE_OFFSET_1080i_50	(0x02)
+#define VBLK_F1_START_LINE_OFFSET_1080i_50	(0x02)
+#define VBLK_F0_DURATION_1080i_50		(0x16)
+#define VBLK_F1_DURATION_1080i_50		(0x17)
+#define RESERVED_1080i_50			(0x02)
+
+#define FEEDBACK_DIVIDER_MSB_480P		(0x35)
+#define FEEDBACK_DIVIDER_LSB_480P		(0x0A)
+#define VCO_CONTROL_480P			(0x02)
+#define CP_CURRENT_480P				(0x02)
+#define PHASE_SELECT_480P			(0x14)
+#define POST_DIVIDER_480P			(0x0)
+#define HPLL_CONTROL_480P			(0x18)
+#define AVID_START_PIXEL_LSB_480P		(0x91)
+#define AVID_START_PIXEL_MSB_480P		(0x00)
+#define AVID_STOP_PIXEL_LSB_480P		(0x0B)
+#define AVID_STOP_PIXEL_MSB_480P		(0x00)
+#define VBLK_F0_START_LINE_OFFSET_480P		(0x03)
+#define VBLK_F1_START_LINE_OFFSET_480P		(0x01)
+#define VBLK_F0_DURATION_480P			(0x13)
+#define VBLK_F1_DURATION_480P			(0x13)
+#define RESERVED_1080i_50                       (0x02)
+
+#define FEEDBACK_DIVIDER_MSB_576P               (0x36)
+#define FEEDBACK_DIVIDER_LSB_576P               (0x00)
+#define VCO_CONTROL_576P                        (0x02)
+#define CP_CURRENT_576P                         (0x02)
+#define PHASE_SELECT_576P                       (0x14)
+#define POST_DIVIDER_576P                       (0x0)
+#define HPLL_CONTROL_576P                       (0x18)
+#define AVID_START_PIXEL_LSB_576P               (0x9B)
+#define AVID_START_PIXEL_MSB_576P               (0x00)
+#define AVID_STOP_PIXEL_LSB_576P                (0x0F)
+#define AVID_STOP_PIXEL_MSB_576P                (0x00)
+#define VBLK_F0_START_LINE_OFFSET_576P          (0x00)
+#define VBLK_F1_START_LINE_OFFSET_576P          (0x00)
+#define VBLK_F0_DURATION_576P                   (0x2D)
+#define VBLK_F1_DURATION_576P                   (0x00)
+#define RESERVED_1080i_50                       (0x02)
+
+#define TVP7002_HD_ALC_PLACEMENT		(0x5A)
+#define TVP7002_ED_ALC_PLACEMENT		(0x18)
+
+#define TVP7002_HD_CLAMP_START			(0x32)
+#define TVP7002_ED_CLAMP_START			(0x06)
+
+#define TVP7002_HD_CLAMP_WIDTH			(0x20)
+#define TVP7002_ED_CLAMP_WIDTH			(0x10)
+
+#define TVP7002_HD_PRE_COAST			(0x0)
+#define TVP7002_ED_PRE_COAST			(0x03)
+
+#define TVP7002_HD_POST_COAST			(0x0)
+#define TVP7002_ED_POST_COAST			(0x0C)
+
+/* HPLL masks and shifts */
+#define HPLL_DIVIDER_LSB_MASK                   GENERATE_MASK(4, 0)
+#define HPLL_DIVIDER_LSB_SHIFT                  4
+#define VCO_CONTROL_MASK                        GENERATE_MASK(2, 0)
+#define CP_CURRENT_MASK                         GENERATE_MASK(3, 0)
+#define VCO_CONTROL_SHIFT                       6
+#define CP_CURRENT_SHIFT                        3
+#define PHASE_SELECT_MASK                       GENERATE_MASK(5, 0)
+#define PHASE_SELECT_SHIFT                      3
+
+#define POST_DIVIDER_MASK                       GENERATE_MASK(1, 0)
+
+#define LINES_PER_FRAME_MSB_MASK                GENERATE_MASK(4, 8)
+#define LINES_PER_FRAME_MSB_SHIFT               8
+
+#define VIDEO_DETECTION_MASK                    GENERATE_MASK(1, 5)
+#define VIDEO_DETECTION_SHIFT			5
+
+/* Gain and offset masks */
+
+#define BLUE_COARSE_GAIN_MASK                   GENERATE_MASK(4, 0)
+#define GREEN_COARSE_GAIN_MASK                  GENERATE_MASK(4, 0)
+#define RED_COARSE_GAIN_MASK                    GENERATE_MASK(4, 0)
+#define GREEN_COARSE_GAIN_SHIFT                 4
+
+#define FINE_OFFSET_LSB_MASK                    0x03
+
+#define FINE_OFFSET_LSB_SHIFT_GREEN             2
+#define FINE_OFFSET_LSB_SHIFT_RED               4
+
+#define COARSE_OFFSET_MASK                      GENERATE_MASK(6, 0)
+
+/* Defines for TVP7002 register address */
+#define TVP7002_HPLL_DIVIDER_MSB                (0x01)
+#define TVP7002_HPLL_DIVIDER_LSB                (0x02)
+#define TVP7002_HPLL_CONTROL                    (0x03)
+#define TVP7002_HPLL_PHASE_SELECT               (0x04)
+#define TVP7002_CLAMP_START                     (0x05)
+#define TVP7002_CLAMP_WIDTH                     (0x06)
+#define TVP7002_HSYNC_OUTPUT_WIDTH              (0x07)
+
+#define TVP7002_BLUE_FINE_GAIN                  (0x08)
+#define TVP7002_GREEN_FINE_GAIN                 (0x09)
+#define TVP7002_RED_FINE_GAIN                   (0x0A)
+#define TVP7002_BLUE_FINE_OFFSETMSB             (0x0B)
+#define TVP7002_GREEN_FINE_OFFSETMSB            (0x0C)
+#define TVP7002_RED_FINE_OFFSETMSB              (0x0D)
+
+#define TVP7002_SYNC_CONTROL_1                  (0x0E)
+#define TVP7002_HPLL_CLAMP_CONTROL              (0x0F)
+#define TVP7002_SYNC_ON_GREEN_THLD              (0x10)
+#define TVP7002_SYNC_SEPARATER_THLD             (0x11)
+#define TVP7002_HPLL_PRE_COAST                  (0x12)
+#define TVP7002_HPLL_POST_COAST                 (0x13)
+
+#define TVP7002_OUTPUT_FORMATTER                (0x15)
+#define TVP7002_MISC_CONTROL_1                  (0x16)
+#define TVP7002_MISC_CONTROL_2                  (0x17)
+#define TVP7002_MISC_CONTROL_3                  (0x18)
+#define TVP7002_INPUT_MUX_SELECT_1              (0x19)
+#define TVP7002_INPUT_MUX_SELECT_2              (0x1A)
+#define TVP7002_BLUE_GREEN_COARSE_GAIN          (0x1B)
+#define TVP7002_RED_COARSE_GAIN                 (0x1C)
+#define TVP7002_FINE_OFFSET_LSBS                (0x1D)
+#define TVP7002_BLUE_COARSE_OFFSET              (0x1E)
+#define TVP7002_GREEN_COARSE_OFFSET             (0x1F)
+#define TVP7002_RED_COARSE_OFFSET               (0x20)
+#define TVP7002_HSOUT_OUTPUT_START              (0x21)
+#define TVP7002_MISC_CONTROL_4                  (0x22)
+#define TVP7002_ALC_ENABLE                      (0x26)
+#define TVP7002_ALC_FILTER                      (0x28)
+#define TVP7002_FINE_CLAMP_CONTROL              (0x2A)
+#define TVP7002_POWER_CONTROL                   (0x2B)
+#define TVP7002_ADC_SETUP                       (0x2C)
+#define TVP7002_COARSE_CLAMP_CONTROL            (0x2D)
+#define TVP7002_SOG_CLAMP                       (0x2E)
+#define TVP7002_ALC_PLACEMENT                   (0x31)
+#define TVP7002_VSYNC_ALIGNMENT                 (0x35)
+#define TVP7002_SYNC_BYPASS                     (0x36)
+#define TVP7002_LINES_PER_FRAME_STATUS_LOW      (0x37)
+#define TVP7002_LINES_PER_FRAME_STATUS_HIGH     (0x38)
+#define TVP7002_CLOCK_PER_LINE_STATUS_LSB	(0x39)
+#define TVP7002_CLOCK_PER_LINE_STATUS_MSB	(0x3A)
+
+#define TVP7002_LINE_LENGTH_TOLERENCE           (0x3D)
+#define TVP7002_ADC_REF_SETUP                   (0x3E)
+#define TVP7002_VIDEO_BANDWIDTH_CONTROL		(0x3F)
+#define TVP7002_AVID_START_PIXEL_LOW            (0x40)
+#define TVP7002_AVID_START_PIXEL_HIGH           (0x41)
+#define TVP7002_AVID_STOP_PIXEL_LOW             (0x42)
+#define TVP7002_AVID_STOP_PIXEL_HIGH            (0x43)
+#define TVP7002_VBLK_FIELD0_START_OFFSET        (0x44)
+#define TVP7002_VBLK_FIELD1_START_OFFSET        (0x45)
+#define TVP7002_VBLK_FIELD0_DURATION            (0x46)
+#define TVP7002_VBLK_FIELD1_DURATION            (0x47)
+#define TVP7002_FBIT_FIELD0_START_OFFSET        (0x48)
+#define TVP7002_FBIT_FIELD1_START_OFFSET        (0x49)
+
+#define TVP7002_HD_INPUT                        (0x00)
+
+/* decoder standard related strctures */
+#define TVP7002_MAX_NO_INPUTS           (1)
+#define TVP7002_MAX_NO_STANDARDS        (4+1+1)
+#define TVP7002_MAX_NO_CONTROLS         (0)
+
+#define TVP7002_ALC_VCOEFF_SHIFT	(4)
+
+#define TVP7002_STANDARD_INFO_SIZE      (TVP7002_MAX_NO_STANDARDS)
+
+struct tvp7002_control_info {
+	int register_address;
+	struct v4l2_queryctrl query_control;
+};
+
+struct tvp7002_config {
+	int no_of_inputs;
+	struct {
+		int input_type;
+		struct v4l2_input input_info;
+		int no_of_standard;
+		struct v4l2_standard *standard;
+		v4l2_std_id def_std;
+		struct tvp7002_format_params *format;
+		int no_of_controls;
+		struct tvp7002_control_info *controls;
+	} input[TVP7002_MAX_NO_INPUTS];
+	tvp7002_params def_params;
+};
+
+struct tvp7002_channel {
+	struct {
+		struct i2c_client client;
+		struct i2c_driver driver;
+		u32 i2c_addr;
+		int i2c_registration;
+	} i2c_dev;
+	struct decoder_device *dec_device;
+	tvp7002_params params;
+};
+
+#endif				/* __KERNEL__ */
+
+#endif
Index: linux-2.6.18/include/media/davinci/vid_decoder_if.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/vid_decoder_if.h
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* vid_decoder_if.h */
+
+/* This file contains data structure which will be used as the interface
+ * between vpif and decoder */
+
+#ifndef VID_DECODER_IF_H
+#define VID_DECODER_IF_H
+
+#ifdef __KERNEL__
+
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+
+#define DECODER_MAX_NAME		(50)
+
+#define FRAME_FORMAT_PROGRESSIVE        (1)
+#define FRAME_FORMAT_INTERLACED         (0)
+
+#define DECODER_I2C_BIND_FLAG		(0)
+#define DECODER_FULL_INIT_FLAG		(1)
+
+typedef enum {
+	INTERFACE_TYPE_BT656 = 1,
+	INTERFACE_TYPE_BT1120 = 2,
+	INTERFACE_TYPE_RAW = 4
+} vid_capture_interface_type;
+
+/* structures */
+
+/* Parameters ops structure */
+struct param_ops {
+	int (*setparams) (void *params, void *dec);	/* Pointer to function
+							   to set parameters */
+	int (*getparams) (void *params, void *dec);	/* Pointer to function
+							   to get parameters */
+};
+
+/* standard ops structure */
+struct standard_ops {
+	int count;		/* Indicates number of standards
+				   supported */
+	int (*enumstd) (struct v4l2_standard *argp, void *dec);	/* Pointer to
+									   function to
+									   enumerate                                                                     standard */
+	int (*querystd) (v4l2_std_id *argp, void *dec);	/* Pointer to function
+								   to query standard */
+	int (*setstd) (v4l2_std_id *argp, void *dec);	/* Pointer to
+							   function to set
+							   standard */
+	int (*getstd) (v4l2_std_id *argp, void *dec);	/* Pointer to
+							   function to get
+							   standard */
+};
+
+/* format ops structure */
+struct format_ops {
+	int count;		/* Indicats number of formats
+				   supported */
+	int (*enumformat) (struct v4l2_fmtdesc *argp, void *dec);	/* Pointer
+									   to
+									   function
+									   to
+									   enumerate
+									   formats */
+	int (*tryformat) (struct v4l2_format *argp, void *dec);	/* Pointer to
+									   function
+									   to try
+									   format */
+	int (*setformat) (struct v4l2_format *argp, void *dec);	/* Pointer
+									   to function
+									   to set
+									   formats */
+	int (*getformat) (struct v4l2_format *argp, void *dec);	/* Pointer
+									   to function
+									   to get
+									   formats */
+};
+
+/* control ops structure */
+struct control_ops {
+	int count;		/* Indicats number of controls
+				   supported */
+	int (*queryctrl) (struct v4l2_queryctrl *argp, void *dec);	/* Pointer
+									   to
+									   function
+									   to
+									   enumerate
+									   controls */
+	int (*setcontrol) (struct v4l2_control *argp, void *dec);	/* Pointer
+									   to
+									   function
+									   to set
+									   controls */
+	int (*getcontrol) (struct v4l2_control *argp, void *dec);	/* Pointer
+									   to
+									   function
+									   to get
+									   controls */
+};
+
+/* input ops structure */
+struct input_ops {
+	int count;		/* Indicats number of
+				   inputs supported */
+	int (*enuminput) (struct v4l2_input *argp, void *dec);	/* Pointer to
+								   function to
+								   query
+								   inputs */
+	int (*setinput) (int *argp, void *dec);	/* Pointer to function
+						   to set inputs */
+	int (*getinput) (int *argp, void *dec);	/* Pointer to function
+						   to get inputs */
+};
+
+/* decoder device structure */
+struct decoder_device {
+	u8 name[DECODER_MAX_NAME];	/* Name of the
+					   decoder device */
+	vid_capture_interface_type if_type;	/* Decoder interface
+						   type i.e. BT656 */
+	int channel_id;		/* Id of the channel
+				   to which decoder
+				   is connected */
+	u32 capabilities;	/* decoder
+				   capabilities */
+	int (*initialize) (void *dec, int flag);	/* Pointer to
+							   initialize
+							   function to
+							   initialize
+							   decoder */
+	struct standard_ops *std_ops;	/* Set of functions
+					   pointers for
+					   standard related
+					   functions */
+	struct control_ops *ctrl_ops;	/* Set of functions
+					   pointers for
+					   control related
+					   functions */
+	struct input_ops *input_ops;	/* Set of functions
+					   pointers for input
+					   related
+					   functions */
+	struct format_ops *fmt_ops;	/* Set of functions
+					   pointers for
+					   format related
+					   functions */
+	struct param_ops *params_ops;	/* Set of functions
+					   pointers for
+					   device specific
+					   configs */
+	int (*deinitialize) (void *dec);	/* Pointer to
+						   deinitialize
+						   function */
+	int (*read_vbi_data) (struct v4l2_sliced_vbi_data *data, void *dec);
+	/* This function
+	   will be called
+	   whenever the
+	   sliced vbi data
+	   has to be get
+	   from the decoder */
+	int (*get_sliced_vbi_cap) (struct v4l2_sliced_vbi_cap *cap, void *dec);
+	/* This function
+	   will be called
+	   whenver all the
+	   sliced vbi
+	   services needs
+	   to be get from
+	   the decoder */
+
+};
+
+int vpif_register_decoder(struct decoder_device
+			  *decoder);	/* Function to register decoder to the
+					   VPIF-V4L2 layer */
+int vpif_unregister_decoder(struct decoder_device
+			    *decoder);	/* Function to un-register decoder
+					   to the
+					   VPIF-V4L2 layer */
+
+#endif				/* #ifdef __KERNEL__ */
+
+#endif				/* #ifdef VID_DECODER_IF_H */
Index: linux-2.6.18/include/media/davinci/vpif.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/vpif.h
@@ -0,0 +1,727 @@
+/*
+ *
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* vpif_capture.h */
+
+#ifndef VPIF_H
+#define VPIF_H
+
+#ifdef __KERNEL__
+
+/* Kernel Header files */
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+
+/* Registers Base Address */
+#define VPIF_IOBASE_ADDR                	IO_ADDRESS(0x01C12000)
+
+/* Maximum channel allowed */
+#define VPIF_NUM_CHANNELS               	4
+#define VPIF_CAPTURE_NUM_CHANNELS		2
+#define VPIF_DISPLAY_NUM_CHANNELS		2
+
+/* Macros to read/write registers */
+#define regr(reg)               inl((reg) + VPIF_IOBASE_ADDR)
+#define regw(value, reg)        outl(value, (reg) + VPIF_IOBASE_ADDR)
+
+
+/* Register Addresss */
+#define VPIF_PID                                (0x0000)
+#define VPIF_CH0_CTRL                           (0x0004)
+#define VPIF_CH1_CTRL                           (0x0008)
+#define VPIF_CH2_CTRL                           (0x000C)
+#define VPIF_CH3_CTRL                           (0x0010)
+
+#define VPIF_INTEN                              (0x0020)
+#define VPIF_INTEN_SET                          (0x0024)
+#define VPIF_INTEN_CLR                          (0x0028)
+#define VPIF_STATUS                             (0x002C)
+#define VPIF_STATUS_CLR                         (0x0030)
+#define VPIF_EMULATION_CTRL                     (0x0034)
+#define VPIF_REQ_SIZE                           (0x0038)
+
+#define VPIF_CH0_TOP_STRT_ADD_LUMA              (0x0040)
+#define VPIF_CH0_BTM_STRT_ADD_LUMA              (0x0044)
+#define VPIF_CH0_TOP_STRT_ADD_CHROMA            (0x0048)
+#define VPIF_CH0_BTM_STRT_ADD_CHROMA            (0x004c)
+#define VPIF_CH0_TOP_STRT_ADD_HANC              (0x0050)
+#define VPIF_CH0_BTM_STRT_ADD_HANC              (0x0054)
+#define VPIF_CH0_TOP_STRT_ADD_VANC              (0x0058)
+#define VPIF_CH0_BTM_STRT_ADD_VANC              (0x005c)
+#define VPIF_CH0_SP_CFG                         (0x0060)
+#define VPIF_CH0_IMG_ADD_OFST                   (0x0064)
+#define VPIF_CH0_HANC_ADD_OFST                  (0x0068)
+#define VPIF_CH0_H_CFG                          (0x006c)
+#define VPIF_CH0_V_CFG_00                       (0x0070)
+#define VPIF_CH0_V_CFG_01                       (0x0074)
+#define VPIF_CH0_V_CFG_02                       (0x0078)
+#define VPIF_CH0_V_CFG_03                       (0x007c)
+
+#define VPIF_CH1_TOP_STRT_ADD_LUMA              (0x0080)
+#define VPIF_CH1_BTM_STRT_ADD_LUMA              (0x0084)
+#define VPIF_CH1_TOP_STRT_ADD_CHROMA            (0x0088)
+#define VPIF_CH1_BTM_STRT_ADD_CHROMA            (0x008c)
+#define VPIF_CH1_TOP_STRT_ADD_HANC              (0x0090)
+#define VPIF_CH1_BTM_STRT_ADD_HANC              (0x0094)
+#define VPIF_CH1_TOP_STRT_ADD_VANC              (0x0098)
+#define VPIF_CH1_BTM_STRT_ADD_VANC              (0x009c)
+#define VPIF_CH1_SP_CFG                         (0x00a0)
+#define VPIF_CH1_IMG_ADD_OFST                   (0x00a4)
+#define VPIF_CH1_HANC_ADD_OFST                  (0x00a8)
+#define VPIF_CH1_H_CFG                          (0x00ac)
+#define VPIF_CH1_V_CFG_00                       (0x00b0)
+#define VPIF_CH1_V_CFG_01                       (0x00b4)
+#define VPIF_CH1_V_CFG_02                       (0x00b8)
+#define VPIF_CH1_V_CFG_03                       (0x00bc)
+
+#define VPIF_CH2_TOP_STRT_ADD_LUMA              (0x00c0)
+#define VPIF_CH2_BTM_STRT_ADD_LUMA              (0x00c4)
+#define VPIF_CH2_TOP_STRT_ADD_CHROMA            (0x00c8)
+#define VPIF_CH2_BTM_STRT_ADD_CHROMA            (0x00cc)
+#define VPIF_CH2_TOP_STRT_ADD_HANC		(0x00d0)
+#define VPIF_CH2_BTM_STRT_ADD_HANC              (0x00d4)
+#define VPIF_CH2_TOP_STRT_ADD_VANC              (0x00d8)
+#define VPIF_CH2_BTM_STRT_ADD_VANC              (0x00dc)
+#define VPIF_CH2_SP_CFG                         (0x00e0)
+#define VPIF_CH2_IMG_ADD_OFST                   (0x00e4)
+#define VPIF_CH2_HANC_ADD_OFST                  (0x00e8)
+#define VPIF_CH2_H_CFG                          (0x00ec)
+#define VPIF_CH2_V_CFG_00                       (0x00f0)
+#define VPIF_CH2_V_CFG_01                       (0x00f4)
+#define VPIF_CH2_V_CFG_02                       (0x00f8)
+#define VPIF_CH2_V_CFG_03                       (0x00fc)
+#define VPIF_CH2_HANC0_STRT                     (0x0100)
+#define VPIF_CH2_HANC0_SIZE                     (0x0104)
+#define VPIF_CH2_HANC1_STRT                     (0x0108)
+#define VPIF_CH2_HANC1_SIZE                     (0x010c)
+#define VPIF_CH2_VANC0_STRT                     (0x0110)
+#define VPIF_CH2_VANC0_SIZE                     (0x0114)
+#define VPIF_CH2_VANC1_STRT                     (0x0118)
+#define VPIF_CH2_VANC1_SIZE                     (0x011c)
+
+#define VPIF_CH3_TOP_STRT_ADD_LUMA              (0x0140)
+#define VPIF_CH3_BTM_STRT_ADD_LUMA              (0x0144)
+#define VPIF_CH3_TOP_STRT_ADD_CHROMA            (0x0148)
+#define VPIF_CH3_BTM_STRT_ADD_CHROMA            (0x014c)
+#define VPIF_CH3_TOP_STRT_ADD_HANC              (0x0150)
+#define VPIF_CH3_BTM_STRT_ADD_HANC              (0x0154)
+#define VPIF_CH3_TOP_STRT_ADD_VANC              (0x0158)
+#define VPIF_CH3_BTM_STRT_ADD_VANC              (0x015c)
+#define VPIF_CH3_SP_CFG                         (0x0160)
+#define VPIF_CH3_IMG_ADD_OFST                   (0x0164)
+#define VPIF_CH3_HANC_ADD_OFST                  (0x0168)
+#define VPIF_CH3_H_CFG                          (0x016c)
+#define VPIF_CH3_V_CFG_00                       (0x0170)
+#define VPIF_CH3_V_CFG_01                       (0x0174)
+#define VPIF_CH3_V_CFG_02                       (0x0178)
+#define VPIF_CH3_V_CFG_03                       (0x017c)
+#define VPIF_CH3_HANC0_STRT                     (0x0180)
+#define VPIF_CH3_HANC0_SIZE                     (0x0184)
+#define VPIF_CH3_HANC1_STRT                     (0x0188)
+#define VPIF_CH3_HANC1_SIZE                     (0x018c)
+#define VPIF_CH3_VANC0_STRT                     (0x0190)
+#define VPIF_CH3_VANC0_SIZE                     (0x0194)
+#define VPIF_CH3_VANC1_STRT                     (0x0198)
+#define VPIF_CH3_VANC1_SIZE                     (0x019c)
+
+#define VPIF_IODFT_CTRL                         (0x01c0)
+
+/* Macros for BIT Manipulation */
+#define SETBIT(reg, bit)                ((reg) |= ((0x00000001)<<bit))
+#define RESETBIT(reg, bit)              ((reg) &= (~((0x00000001)<<bit)))
+
+/* Macros */
+/* Macro for Generating mask */
+#ifdef GENERATE_MASK
+#undef GENERATE_MASK
+#endif
+
+#define GENERATE_MASK(bits, pos)        ((((0xFFFFFFFF) << (32-bits)) >> \
+		(32-bits)) << pos)
+
+/* Bit positions in the channel control registers */
+#define VPIF_CH_DATA_MODE_BIT                   (2)
+#define VPIF_CH_YC_MUX_BIT                      (3)
+#define VPIF_CH_SDR_FMT_BIT                     (4)
+#define VPIF_CH_HANC_EN_BIT                     (8)
+#define VPIF_CH_VANC_EN_BIT                     (9)
+
+#define VPIF_CAPTURE_CH_NIP			(10)
+#define VPIF_DISPLAY_CH_NIP			(11)
+
+#define VPIF_DISPLAY_PIX_EN_BIT			(10)
+
+#define VPIF_CH_INPUT_FIELD_FRAME_BIT           (12)
+
+#define VPIF_CH_FID_POLARITY_BIT		(15)
+#define VPIF_CH_V_VALID_POLARITY_BIT		(14)
+#define VPIF_CH_H_VALID_POLARITY_BIT		(13)
+#define VPIF_CH_DATA_WIDTH_BIT			(28)
+
+#define VPIF_CH_CLK_EDGE_CTRL_BIT               (31)
+
+/* Mask various length */
+#define VPIF_CH_EAVSAV_MASK             GENERATE_MASK(13, 0)
+#define VPIF_CH_LEN_MASK                GENERATE_MASK(12, 0)
+#define VPIF_CH_WIDTH_MASK              GENERATE_MASK(13, 0)
+#define VPIF_CH_LEN_SHIFT               (16)
+
+/* VPIF masks for registers */
+#define VPIF_REQ_SIZE_MASK              (0x1ff)
+
+/* enable/disables interrupt in vpif_ch_intr register */
+#define VPIF_INTEN_FRAME_CH0		(0x00000001)
+/* enable/disables interrupt in vpif_ch_intr register */
+#define VPIF_INTEN_FRAME_CH1		(0x00000002)
+/* bit position of clock enable in vpif_ch0_ctrl register */
+#define VPIF_CH0_CLK_EN		        (0x00000002)
+/* bit position to enable channel2 in vpif_ch0_ctrl register */
+#define VPIF_CH0_EN		        (0x00000001)
+/* bit position to enable channel2 in vpif_ch0_ctrl register */
+#define VPIF_CH1_EN		        (0x00000001)
+/* bit position of clock enable in vpif_ch0_ctrl register */
+#define VPIF_CH1_CLK_EN			(0x00000002)
+
+#define VPIF_CH_CLK_EN			(0x00000002)
+#define VPIF_CH_EN		        (0x00000001)
+
+/* enable/disables interrupt in vpif_ch_intr register */
+#define VPIF_INTEN_FRAME_CH2		(0x00000004)
+/* enable/disables interrupt in vpif_ch_intr register */
+#define VPIF_INTEN_FRAME_CH3		(0x00000008)
+/* bit position of clock enable in vpif_ch0_ctrl register */
+#define VPIF_CH2_CLK_EN		        (0x00000002)
+/* bit position to enable channel2 in vpif_ch0_ctrl register */
+#define VPIF_CH2_EN		        (0x00000001)
+/* bit position to enable channel2 in vpif_ch0_ctrl register */
+#define VPIF_CH3_EN		        (0x00000001)
+/* bit position of clock enable in vpif_ch0_ctrl register */
+#define VPIF_CH3_CLK_EN			(0x00000002)
+
+
+#define VPIF_INT_TOP			(0x00)
+#define VPIF_INT_BOTTOM			(0x01)
+#define VPIF_INT_BOTH			(0x02)
+
+#define VPIF_CH0_INT_CTRL_SHIFT		6
+#define VPIF_CH1_INT_CTRL_SHIFT		6
+#define VPIF_CH2_INT_CTRL_SHIFT		6
+#define VPIF_CH3_INT_CTRL_SHIFT		6
+#define VPIF_CH_INT_CTRL_SHIFT		6
+/* enabled interrupt on both the fields on vpid_ch0_ctrl register */
+#define channel0_intr_assert() 		(regw((regr(VPIF_CH0_CTRL)|\
+					(VPIF_INT_BOTH << \
+					VPIF_CH0_INT_CTRL_SHIFT)), \
+					VPIF_CH0_CTRL))
+
+/* enabled interrupt on both the fields on vpid_ch1_ctrl register */
+#define channel1_intr_assert() 		(regw((regr(VPIF_CH1_CTRL)|\
+					(VPIF_INT_BOTH << \
+					VPIF_CH1_INT_CTRL_SHIFT)), \
+					VPIF_CH1_CTRL))
+
+/* enabled interrupt on both the fields on vpid_ch0_ctrl register */
+#define channel2_intr_assert() 		(regw((regr(VPIF_CH2_CTRL)|\
+					(VPIF_INT_BOTH << \
+					VPIF_CH2_INT_CTRL_SHIFT)), \
+					VPIF_CH2_CTRL))
+
+/* enabled interrupt on both the fields on vpid_ch1_ctrl register */
+#define channel3_intr_assert() 		(regw((regr(VPIF_CH3_CTRL)|\
+					(VPIF_INT_BOTH << \
+					VPIF_CH3_INT_CTRL_SHIFT)), \
+					VPIF_CH3_CTRL))
+
+
+#define VPIF_CH_FID_MASK		0x20
+#define VPIF_CH_FID_SHIFT		5
+
+#define VPIF_NTSC_VBI_START_FIELD0	1
+#define VPIF_NTSC_VBI_START_FIELD1	263
+#define VPIF_PAL_VBI_START_FIELD0	624
+#define VPIF_PAL_VBI_START_FIELD1	311
+
+#define VPIF_NTSC_HBI_START_FIELD0	1
+#define VPIF_NTSC_HBI_START_FIELD1	263
+#define VPIF_PAL_HBI_START_FIELD0	624
+#define VPIF_PAL_HBI_START_FIELD1	311
+
+#define VPIF_NTSC_VBI_COUNT_FIELD0	20
+#define VPIF_NTSC_VBI_COUNT_FIELD1	19
+#define VPIF_PAL_VBI_COUNT_FIELD0	24
+#define VPIF_PAL_VBI_COUNT_FIELD1	25
+
+#define VPIF_NTSC_HBI_COUNT_FIELD0	263
+#define VPIF_NTSC_HBI_COUNT_FIELD1	262
+#define VPIF_PAL_HBI_COUNT_FIELD0	312
+#define VPIF_PAL_HBI_COUNT_FIELD1	313
+
+#define VPIF_NTSC_VBI_SAMPLES_PER_LINE	720
+#define VPIF_PAL_VBI_SAMPLES_PER_LINE	720
+#define VPIF_NTSC_HBI_SAMPLES_PER_LINE	268
+#define VPIF_PAL_HBI_SAMPLES_PER_LINE	280
+
+#define VPIF_CH_VANC_EN			0x20
+#define VPIF_DMA_REQ_SIZE		0x080
+#define VPIF_EMULATION_DISABLE		0x01
+
+extern u8 irq_vpif_capture_channel[VPIF_NUM_CHANNELS];
+
+/* inline function to enable/disable channel2 */
+static inline void enable_channel0(int enable)
+{
+	if (enable) {
+		/* Enable clock and channel2 */
+		regw((regr(VPIF_CH0_CTRL) | (VPIF_CH0_EN)), VPIF_CH0_CTRL);
+	} else {
+		/* Disable clock and channel2 */
+		regw((regr(VPIF_CH0_CTRL) & (~VPIF_CH0_EN)),
+		     VPIF_CH0_CTRL);
+	}
+}
+
+/* inline function to enable/disable channel2 */
+static inline void enable_channel1(int enable)
+{
+	if (enable) {
+		/* Enable clock and channel3 */
+		regw((regr(VPIF_CH1_CTRL) | (VPIF_CH1_EN)), VPIF_CH1_CTRL);
+	} else {
+		/* Disable clock and channel3 */
+		regw((regr(VPIF_CH1_CTRL) & (~VPIF_CH1_EN)),
+		     VPIF_CH1_CTRL);
+	}
+}
+
+/* inline function to enable interrupt for channel 2 */
+static inline void channel0_intr_enable(int enable)
+{
+	if (enable) {
+
+		regw((regr(VPIF_INTEN) | 0x10), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | 0x10), VPIF_INTEN_SET);
+
+		regw((regr(VPIF_INTEN) | VPIF_INTEN_FRAME_CH0),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH0),
+		     VPIF_INTEN_SET);
+	} else {
+		regw((regr(VPIF_INTEN) & (~VPIF_INTEN_FRAME_CH0)),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH0),
+		     VPIF_INTEN_SET);
+	}
+}
+
+/* inline function to enable interrupt for channel 3 */
+static inline void channel1_intr_enable(int enable)
+{
+	if (enable) {
+		regw((regr(VPIF_INTEN) | 0x10), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | 0x10), VPIF_INTEN_SET);
+
+		regw((regr(VPIF_INTEN) | VPIF_INTEN_FRAME_CH1),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH1),
+		     VPIF_INTEN_SET);
+	} else {
+		regw((regr(VPIF_INTEN) & (~VPIF_INTEN_FRAME_CH1)),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH1),
+		     VPIF_INTEN_SET);
+	}
+}
+
+/* static inline function to set buffer addresses in in case of Y/C
+   non mux mode */
+static inline void ch0_set_videobuf_addr_yc_nmux(unsigned long
+						 top_strt_luma,
+						 unsigned long
+						 btm_strt_luma,
+						 unsigned long
+						 top_strt_chroma,
+						 unsigned long
+						 btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH0_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH0_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH1_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH1_BTM_STRT_ADD_CHROMA);
+}
+
+/* static inline function to set buffer addresses in VPIF registers for
+   video data */
+static inline void ch0_set_videobuf_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH0_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH0_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH0_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH0_BTM_STRT_ADD_CHROMA);
+}
+
+static inline void ch1_set_videobuf_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+
+	regw(top_strt_luma, VPIF_CH1_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH1_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH1_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH1_BTM_STRT_ADD_CHROMA);
+}
+
+static inline void ch0_set_vbi_addr(unsigned long top_vbi,
+	unsigned long btm_vbi, unsigned long a, unsigned long b)
+{
+	regw(top_vbi, VPIF_CH0_TOP_STRT_ADD_VANC);
+	regw(btm_vbi, VPIF_CH0_BTM_STRT_ADD_VANC);
+}
+static inline void ch0_set_hbi_addr(unsigned long top_vbi,
+	unsigned long btm_vbi, unsigned long a, unsigned long b)
+{
+	regw(top_vbi, VPIF_CH0_TOP_STRT_ADD_HANC);
+	regw(btm_vbi, VPIF_CH0_BTM_STRT_ADD_HANC);
+}
+
+static inline void ch1_set_vbi_addr(unsigned long top_vbi,
+	unsigned long btm_vbi, unsigned long a, unsigned long b)
+{
+	regw(top_vbi, VPIF_CH1_TOP_STRT_ADD_VANC);
+	regw(btm_vbi, VPIF_CH1_BTM_STRT_ADD_VANC);
+}
+static inline void ch1_set_hbi_addr(unsigned long top_vbi,
+	unsigned long btm_vbi, unsigned long a, unsigned long b)
+{
+	regw(top_vbi, VPIF_CH1_TOP_STRT_ADD_HANC);
+	regw(btm_vbi, VPIF_CH1_BTM_STRT_ADD_HANC);
+}
+/* Inline function to enable raw vbi in the given channel */
+static inline void disable_raw_feature(u8 channel_id, u8 index)
+{
+	u32 ctrl_reg;
+	u32 val;
+	if(0 == channel_id)
+		ctrl_reg = VPIF_CH0_CTRL;
+	else
+		ctrl_reg = VPIF_CH1_CTRL;
+	val = regr(ctrl_reg);
+	if(1 == index)
+		RESETBIT(val, VPIF_CH_VANC_EN_BIT);
+	else
+		RESETBIT(val, VPIF_CH_HANC_EN_BIT);
+	regw(val, ctrl_reg);
+
+}
+
+static inline void enable_raw_feature(u8 channel_id, u8 index)
+{
+	u32 ctrl_reg;
+	u32 val;
+	if(0 == channel_id)
+		ctrl_reg = VPIF_CH0_CTRL;
+	else
+		ctrl_reg = VPIF_CH1_CTRL;
+
+	val = regr(ctrl_reg);
+	if(1 == index)
+		SETBIT(val, VPIF_CH_VANC_EN_BIT);
+	else
+		SETBIT(val, VPIF_CH_HANC_EN_BIT);
+	regw(val, ctrl_reg);
+
+}
+
+/* inline function to enable/disable channel2 */
+static inline void enable_channel2(int enable)
+{
+	if (enable) {
+		/* Enable clock and channel2 */
+		regw((regr(VPIF_CH2_CTRL) | (VPIF_CH2_CLK_EN)),
+		     VPIF_CH2_CTRL);
+		regw((regr(VPIF_CH2_CTRL) | (VPIF_CH2_EN)), VPIF_CH2_CTRL);
+	} else {
+		/* Disable clock and channel2 */
+		regw((regr(VPIF_CH2_CTRL) & (~VPIF_CH2_CLK_EN)),
+		     VPIF_CH2_CTRL);
+		regw((regr(VPIF_CH2_CTRL) & (~VPIF_CH2_EN)),
+		     VPIF_CH2_CTRL);
+	}
+}
+
+/* inline function to enable/disable channel2 */
+static inline void enable_channel3(int enable)
+{
+	if (enable) {
+		/* Enable clock and channel3 */
+		regw((regr(VPIF_CH3_CTRL) | (VPIF_CH3_CLK_EN)),
+		     VPIF_CH3_CTRL);
+		regw((regr(VPIF_CH3_CTRL) | (VPIF_CH3_EN)), VPIF_CH3_CTRL);
+	} else {
+		/* Disable clock and channel3 */
+		regw((regr(VPIF_CH3_CTRL) & (~VPIF_CH3_CLK_EN)),
+		     VPIF_CH3_CTRL);
+		regw((regr(VPIF_CH3_CTRL) & (~VPIF_CH3_EN)),
+		     VPIF_CH3_CTRL);
+	}
+}
+
+/* inline function to enable interrupt for channel 2 */
+static inline void channel2_intr_enable(int enable)
+{
+	if (enable) {
+		regw((regr(VPIF_INTEN) | 0x10), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | 0x10), VPIF_INTEN_SET);
+
+		regw((regr(VPIF_INTEN) | VPIF_INTEN_FRAME_CH2),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH2),
+		     VPIF_INTEN_SET);
+	} else {
+		regw((regr(VPIF_INTEN) & (~VPIF_INTEN_FRAME_CH2)),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH2),
+		     VPIF_INTEN_SET);
+	}
+}
+
+/* inline function to enable interrupt for channel 3 */
+static inline void channel3_intr_enable(int enable)
+{
+	if (enable) {
+		regw((regr(VPIF_INTEN) | 0x10), VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | 0x10), VPIF_INTEN_SET);
+
+		regw((regr(VPIF_INTEN) | VPIF_INTEN_FRAME_CH3),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH3),
+		     VPIF_INTEN_SET);
+	} else {
+		regw((regr(VPIF_INTEN) & (~VPIF_INTEN_FRAME_CH3)),
+		     VPIF_INTEN);
+		regw((regr(VPIF_INTEN_SET) | VPIF_INTEN_FRAME_CH3),
+		     VPIF_INTEN_SET);
+	}
+}
+
+/* inline function to enable raw vbi data for channel 2 */
+static inline void channel2_raw_enable(int enable, u8 index)
+{
+	u32 mask, val;
+	if(1 == index)
+		mask = VPIF_CH_VANC_EN_BIT;
+	else
+		mask = VPIF_CH_HANC_EN_BIT;
+	val = regr(VPIF_CH2_CTRL);
+	if (enable) {
+		/*regw((regr(VPIF_CH3_CTRL) | mask), VPIF_CH3_CTRL);*/
+		SETBIT(val, mask);
+	} else {
+		RESETBIT(val, mask);
+	}
+	regw(val, VPIF_CH2_CTRL);
+}
+
+/* inline function to enable raw vbi data for channel 3*/
+static inline void channel3_raw_enable(int enable, u8 index)
+{
+	u32 mask, val;
+	if(1 == index)
+		mask = VPIF_CH_VANC_EN_BIT;
+	else
+		mask = VPIF_CH_HANC_EN_BIT;
+	val = regr(VPIF_CH3_CTRL);
+	if (enable) {
+		/*regw((regr(VPIF_CH3_CTRL) | mask), VPIF_CH3_CTRL);*/
+		SETBIT(val, mask);
+	} else {
+		RESETBIT(val, mask);
+	}
+	regw(val, VPIF_CH3_CTRL);
+}
+
+/* static inline function to set buffer addresses in in case of Y/C
+   non mux mode */
+static inline void ch2_set_videobuf_addr_yc_nmux(unsigned long
+						 top_strt_luma,
+						 unsigned long
+						 btm_strt_luma,
+						 unsigned long
+						 top_strt_chroma,
+						 unsigned long
+						 btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH2_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH2_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH3_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH3_BTM_STRT_ADD_CHROMA);
+}
+
+/* static inline function to set buffer addresses in VPIF registers for
+   video data */
+static inline void ch2_set_videobuf_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH2_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH2_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH2_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH2_BTM_STRT_ADD_CHROMA);
+
+}
+
+static inline void ch3_set_videobuf_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH3_TOP_STRT_ADD_LUMA);
+	regw(btm_strt_luma, VPIF_CH3_BTM_STRT_ADD_LUMA);
+	regw(top_strt_chroma, VPIF_CH3_TOP_STRT_ADD_CHROMA);
+	regw(btm_strt_chroma, VPIF_CH3_BTM_STRT_ADD_CHROMA);
+
+}
+
+/* static inline function to set buffer addresses in VPIF registers for
+   vbi data */
+static inline void ch2_set_vbi_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH2_TOP_STRT_ADD_VANC);
+	regw(btm_strt_luma, VPIF_CH2_BTM_STRT_ADD_VANC);
+}
+
+static inline void ch3_set_vbi_addr(unsigned long top_strt_luma,
+					 unsigned long btm_strt_luma,
+					 unsigned long top_strt_chroma,
+					 unsigned long btm_strt_chroma)
+{
+	regw(top_strt_luma, VPIF_CH3_TOP_STRT_ADD_VANC);
+	regw(btm_strt_luma, VPIF_CH3_BTM_STRT_ADD_VANC);
+}
+
+#define VPIF_MAX_NAME   30
+
+/* This structure will store size parameters as per the mode selected by
+   the user */
+struct vpif_channel_config_params {
+	char name[VPIF_MAX_NAME];	/* Name of the */
+	u16 width;		/* Indicates width of the image for
+				   this mode */
+	u16 height;		/* Indicates height of the image for
+				   this mode */
+	u8 fps;
+	u8 frm_fmt;		/* Indicates whether this is interlaced
+				   or progressive format */
+	u8 ycmux_mode;		/* Indicates whether this mode requires
+				   single or two channels */
+	u16 eav2sav;		/* length of sav 2 eav */
+	u16 sav2eav;		/* length of sav 2 eav */
+	u16 l1, l3, l5, l7, l9, l11;	/* Other parameter configurations */
+	u16 vsize;		/* Vertical size of the image */
+	u8 capture_format;	/* Indicates whether capture format
+				   is in BT or in CCD/CMOS */
+	u8  vbi_supported;	  /* Indicates whether this mode
+				     supports capturing vbi or not */
+	u8 hd_sd;
+};
+
+struct vpif_stdinfo {
+	u8 channel_id;
+	u32 activepixels;
+	u32 activelines;
+	u16 fps;
+	u8 frame_format;
+	char name[VPIF_MAX_NAME];
+	u8 ycmux_mode;
+	u8 vbi_supported;	  /* Indicates whether this mode
+				     supports capturing vbi or not */
+	u8 hd_sd;
+};
+
+struct vpif_interface;
+struct vpif_params;
+struct vpif_vbi_params;
+
+int vpif_get_mode_info(struct vpif_stdinfo *std_info);
+
+int vpif_set_video_params(struct vpif_params *, u8 channel_id);
+
+int vpif_set_vbi_display_params(struct vpif_vbi_params *vbiparams,
+	       	u8 channel_id);
+
+int vpif_channel_getfid(u8 channel_id);
+
+int vpif_get_irq_number(int);
+#endif				/* End of #ifdef __KERNEL__ */
+
+/* Enumerated data types */
+typedef enum {
+	VPIF_CAPTURE_PINPOL_SAME = 0,
+	VPIF_CAPTURE_PINPOL_INVERT = 1
+} vpif_capture_pinpol;
+
+typedef enum {
+	_8BITS = 0,
+	_10BITS,
+	_12BITS,
+} data_size;
+
+typedef struct {
+	data_size data_sz;
+	vpif_capture_pinpol fid_pol;
+	vpif_capture_pinpol vd_pol;
+	vpif_capture_pinpol hd_pol;
+} vpif_capture_params_raw;
+
+/* structure for vpif parameters */
+struct vpif_interface {
+	char name[25];
+	__u8 storage_mode;	/* Indicates whether it is field or field
+				   based storage mode */
+	unsigned long hpitch;
+};
+
+/* Structure for vpif parameters for raw vbi data */
+struct vpif_vbi_params {
+	__u32 hstart0;  /* Horizontal start of raw vbi data for first field */
+	__u32 vstart0;  /* Vertical start of raw vbi data for first field */
+	__u32 hsize0;   /* Horizontal size of raw vbi data for first field */
+	__u32 vsize0;   /* Vertical size of raw vbi data for first field */
+	__u32 hstart1;  /* Horizontal start of raw vbi data for second field */
+	__u32 vstart1;  /* Vertical start of raw vbi data for second field */
+	__u32 hsize1;   /* Horizontal size of raw vbi data for second field */
+	__u32 vsize1;   /* Vertical size of raw vbi data for second field */
+};
+
+struct vpif_params {
+	struct vpif_interface video_params;
+	union param{
+		struct vpif_vbi_params      	vbi_params;
+		vpif_capture_params_raw 	raw_params;
+	}params;
+};
+
+#endif				/* End of #ifndef VPIF_H */
+
Index: linux-2.6.18/arch/arm/mach-davinci/video_hdevm.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-davinci/video_hdevm.c
@@ -0,0 +1,238 @@
+/*
+ *
+ * Copyright (C) 2007 Texas Instruments	Inc
+ *
+ * This	program	is free	software; you can redistribute it and/or modify
+ * it under the	terms of the GNU General Public	License	as published by
+ * the Free Software Foundation; either	version	2 of the License, or
+ * (at your option)any	later version.
+ *
+ * This	program	is distributed in the hope that	it will	be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not,write to the	Free Software
+ * Foundation, Inc., 59	Temple Place, Suite 330, Boston, MA  02111-1307	USA
+ */
+/* video_hdevm.h */
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <asm/arch/video_hdevm.h>
+#include <asm/arch/i2c-client.h>
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+
+#define CPLD_BASE_ADDRESS	(0x3A)
+#define CPLD_RESET_POWER_REG	(0)
+#define CPLD_VIDEO_REG		(0x3B)
+#define CDCE949			(0x6C)
+static int cpld_initialized = 0;
+
+static int __init cpld_init(void) {
+	int err = 0;
+	/* power up tvp5147 and tvp7002 */
+	u8 val=0x0;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	if (!err) {
+		cpld_initialized = 1;
+	}
+	return err;
+}
+static void __exit cpld_cleanup(void) {
+}
+int set_cpld_for_tvp5147() {
+	int err = 0;
+        u8 val;
+	err = davinci_i2c_read(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	val &= 0xEF;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	return err;
+}
+
+int set_cpld_for_tvp7002() {
+	int err = 0;
+	u8 val;
+	err = davinci_i2c_read(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	val |= 0x10;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	return err;
+}
+
+int set_vid_in_mode_for_tvp5147() {
+	int err = 0;
+	u8 val;
+	unsigned int value;
+	unsigned int sys_vsclk =
+		(unsigned int)IO_ADDRESS(0x01C40038);
+	err = davinci_i2c_read(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	val &= 0xDF;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+
+	value = inl(sys_vsclk);
+	value |= (1<<4);
+	outl(value, sys_vsclk);
+
+	return err;
+}
+
+int set_vid_in_mode_for_tvp7002() {
+
+	int err = 0;
+	u8 val;
+	unsigned int value;
+	unsigned int sys_vsclk =
+		(unsigned int)IO_ADDRESS(0x01C40038);
+
+	err = davinci_i2c_read(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	val |= 0x20;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+
+	value = inl(sys_vsclk);
+	value &= ~(1<<4);
+	outl(value, sys_vsclk);
+
+	return err;
+}
+int set_vid_out_mode_for_sd() {
+
+	int err = 0;
+	u8 val;
+
+	unsigned int value;
+	unsigned int sys_vsclk =
+		(unsigned int)IO_ADDRESS(0x01C40038);
+
+	err = davinci_i2c_read(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	val &= 0xBF;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+
+	value = inl(sys_vsclk);
+	value &= ~(7<<8);
+	value |= (3<<8);
+	outl(value, sys_vsclk);
+
+	return err;
+}
+
+int set_vid_clock(int hd)
+{
+	int err = 0;
+	unsigned int value;
+	unsigned int sys_vsclk =
+		(unsigned int)IO_ADDRESS(0x01C40038);
+	if(hd >= 1) {
+		value = inl(sys_vsclk);
+		value &= ~(7<<8);
+		value &= ~(7<<12);
+		value |= (2<<8);
+		value |= (2<<12);
+		outl(value, sys_vsclk);
+	} else {
+		value = inl(sys_vsclk);
+		value &= ~(7<<8);
+		value |= (3<<8);
+		value |= (3<<12);
+		outl(value, sys_vsclk);
+	}
+	return err;
+}
+
+int set_vid_out_mode_for_hd() {
+
+	int err = 0;
+	u8 val;
+	unsigned int value;
+	unsigned int sys_vsclk =
+		(unsigned int)IO_ADDRESS(0x01C40038);
+	err = davinci_i2c_read(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+	val |= 0x40;
+	err = davinci_i2c_write(1, &val, CPLD_VIDEO_REG);
+	if(err)
+		return err;
+
+        value = inl(sys_vsclk);
+        value &= ~(7<<8);
+        value &= ~(7<<12);
+	value |= (2<<8);
+	value |= (2<<12);
+	outl(value, sys_vsclk);
+
+	return err;
+}
+
+/*
+Capture :: bits PTSIMUX = 0x, PTSOMUX = 0x, STSIMUX = 00
+Display :: bits STSOMUX = 0x, PTSOMUX = 0x, STSIMUX = 00
+
+bits
+17:16 PTSIMUX
+19:18 PTSOMUX
+21:20 STSIMUX
+23:22 STSOMUX
+
+*/
+void set_vpif_pinmux()
+{
+
+	unsigned int pinmux0
+		= (unsigned int)IO_ADDRESS(0x01C40000);
+	unsigned int sys_vsclkdis =
+		(unsigned int)IO_ADDRESS(0x01C4006C);
+	unsigned int sys_vdd3p3vpwdn =
+		(unsigned int)IO_ADDRESS(0x01C40048);
+	unsigned int value;
+
+	/* make 17th bit(PTSIMUX), 19th bit(PTSOMUX), 21:20 bits(STSIMUX), 23rd
+	 * bit(STSOMUX) to zero */
+	value = inl(pinmux0);
+	value &= ~(unsigned int)(0x00FF0000);
+	outl(value, pinmux0);
+
+	value = inl(sys_vsclkdis);
+	value &= ~(unsigned int)(0x00000F00);
+	outl(value, sys_vsclkdis);
+
+	value = inl(sys_vdd3p3vpwdn);
+	value &= ~(unsigned int)(0x0000000F);
+	outl(value, sys_vdd3p3vpwdn);
+
+	return;
+}
+
+EXPORT_SYMBOL(set_cpld_for_tvp5147);
+EXPORT_SYMBOL(set_cpld_for_tvp7002);
+EXPORT_SYMBOL(set_vid_in_mode_for_tvp5147);
+EXPORT_SYMBOL(set_vid_in_mode_for_tvp7002);
+EXPORT_SYMBOL(set_vid_out_mode_for_sd);
+EXPORT_SYMBOL(set_vid_out_mode_for_hd);
+EXPORT_SYMBOL(set_vpif_pinmux);
+EXPORT_SYMBOL(set_vid_clock);
+MODULE_LICENSE("GPL");
+/* Function for module initialization and cleanup */
+module_init(cpld_init);
+module_exit(cpld_cleanup);
Index: linux-2.6.18/drivers/char/Kconfig
===================================================================
--- linux-2.6.18.orig/drivers/char/Kconfig
+++ linux-2.6.18/drivers/char/Kconfig
@@ -1155,6 +1155,13 @@ config TELCLOCK
 	  sysfs directory, /sys/devices/platform/telco_clock, with a number of
 	  files for controlling the behavior of this hardware.
 
+config VDCE
+        tristate "DaVinci VDCE Driver"
+        default n
+        depends on MACH_DAVINCI_DM6467_EVM
+        help
+                DaVinci VDCE Driver.
+
 config DAVINCI_PWM
         tristate "DaVinci PWM Driver Support"
         default n
Index: linux-2.6.18/drivers/char/Makefile
===================================================================
--- linux-2.6.18.orig/drivers/char/Makefile
+++ linux-2.6.18/drivers/char/Makefile
@@ -107,6 +107,9 @@ obj-$(CONFIG_IPMI_HANDLER)	+= ipmi/
 obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM)		+= tpm/
 
+davinci_vdce_driver-objs := davinci_vdce.o davinci_vdce_hw.o
+obj-$(CONFIG_VDCE) += davinci_vdce_driver.o
+
 obj-$(CONFIG_DAVINCI_PWM) += davinci_pwm.o
 
 obj-$(CONFIG_DM646x_CIR)	+= cir.o
Index: linux-2.6.18/drivers/char/davinci_vdce.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/char/davinci_vdce.c
@@ -0,0 +1,2959 @@
+/* *
+ * Copyright (C) 2007 Texas Instruments	Inc
+ *
+ * This	program	is free	software; you can redistribute it and/or modify
+ * it under the	terms of the GNU General Public	License	as published by
+ * the Free Software Foundation; either	version	2 of the License, or
+ * (at your option)any	later version.
+ *
+ * This	program	is distributed in the hope that	it will	be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not,write to the	Free Software
+ * Foundation, Inc., 59	Temple Place, Suite 330, Boston, MA  02111-1307	USA
+ */
+/* davinci_vdce.c	file */
+
+/*Header files*/
+#include <linux/kernel.h>
+#include <linux/fs.h>		/*     everything... */
+#include <linux/errno.h>	/*     error codes     */
+#include <linux/types.h>	/*     size_t */
+#include <linux/cdev.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+#include <linux/platform_device.h>
+#include <asm/arch/davinci_vdce_hw.h>
+#include <asm/arch/davinci_vdce.h>
+#include <linux/init.h>
+#include <asm/cacheflush.h>
+#include <asm/arch/edma.h>
+#define TCINTEN_SHIFT               20
+#define ITCINTEN_SHIFT              21
+
+/* edma isr status tracking variable */
+static int irqraised1;
+#define	DRIVERNAME	"DavinciHD_vdce"
+#define VDCE_INTERRUPT	12
+
+MODULE_LICENSE("GPL");
+DECLARE_TASKLET(short_tasklet, process_bottomhalf, 0);
+
+/*Global structute shared between all applications
+  struct device_params device_config;*/
+device_params_t device_config;
+/* For registeration of	character device*/
+static struct cdev c_dev;
+/* device structure to make entry in device*/
+static dev_t dev;
+/* for holding device entry*/
+struct device *vdce_device = NULL;
+
+static u32 inter_bufsize = 1920 * 1080;
+module_param(inter_bufsize, uint, S_IRUGO);
+
+/* default values for various modes */
+#define COMMON_DEFAULT_PARAMS {VDCE_PROGRESSIVE, VDCE_FRAME_MODE, \
+VDCE_FRAME_MODE, VDCE_FRAME_MODE, VDCE_LUMA_CHROMA_ENABLE, \
+VDCE_TOP_BOT_ENABLE, 720, 480, 120, 60, 0, 0, 0, 0, 0, 720, 480, 0, 0, 0}
+
+#define RSZ_DEFAULT_PARAMS {VDCE_MODE_422, VDCE_CODECMODE_MPEG2_MPEG4, \
+VDCE_ALGO_TAP_4LINEAR_INTERPOLATION, VDCE_ALGO_TAP_4LINEAR_INTERPOLATION, \
+VDCE_FEATURE_DISABLE, VDCE_FEATURE_DISABLE, VDCE_ALFMODE_AUTOMATIC, 0}
+
+#define CCV_DEFAULT_PARAMS {VDCE_CCV_MODE_422_420, VDCE_CODECMODE_MPEG2_MPEG4, \
+VDCE_CODECMODE_MPEG2_MPEG4, VDCE_ALGO_TAP_4LINEAR_INTERPOLATION, \
+VDCE_ALGO_TAP_4LINEAR_INTERPOLATION }
+
+#define RMAP_DEFAULT_PARAMS {10, VDCE_FEATURE_ENABLE, 10, VDCE_FEATURE_ENABLE}
+
+#define BLEND_TABLE {0x36, 0x22, 0x91, 0xff}
+
+#define BLEND_DEFAULT_PARAMS {VDCE_MODE_422, BLEND_TABLE, BLEND_TABLE, \
+BLEND_TABLE, BLEND_TABLE}
+
+#define EPAD_DEFAULT_PARAMS {16, 8, 16, 8}
+
+#define PRECODEC_PARAMS	{RSZ_DEFAULT_PARAMS, CCV_DEFAULT_PARAMS}
+
+#define POSTCODEC_PARAMS {RSZ_DEFAULT_PARAMS, RMAP_DEFAULT_PARAMS, \
+BLEND_DEFAULT_PARAMS, CCV_DEFAULT_PARAMS}
+
+#define TRANSCODEC_PARAMS {RSZ_DEFAULT_PARAMS, RMAP_DEFAULT_PARAMS, \
+BLEND_DEFAULT_PARAMS, EPAD_DEFAULT_PARAMS, CCV_DEFAULT_PARAMS}
+
+/* Default pre-codec params */
+static vdce_params_t precodec_default_params = {
+	VDCE_OPERATION_PRE_CODECMODE,
+	0x5,
+	COMMON_DEFAULT_PARAMS,
+	.vdce_mode_params.precodec_params = PRECODEC_PARAMS
+};
+
+/* Default post-codec params */
+static vdce_params_t postcodec_default_params = {
+	VDCE_OPERATION_POST_CODECMODE,
+	0x1,
+	COMMON_DEFAULT_PARAMS,
+	.vdce_mode_params.postcodec_params.rsz_params = RSZ_DEFAULT_PARAMS,
+	.vdce_mode_params.postcodec_params.rmap_params = RMAP_DEFAULT_PARAMS,
+	.vdce_mode_params.postcodec_params.blend_params.blend_mode =
+	    VDCE_MODE_422,
+	.vdce_mode_params.postcodec_params.blend_params.bld_lut[0] =
+	    BLEND_TABLE,
+	.vdce_mode_params.postcodec_params.blend_params.bld_lut[1] =
+	    BLEND_TABLE,
+	.vdce_mode_params.postcodec_params.blend_params.bld_lut[2] =
+	    BLEND_TABLE,
+	.vdce_mode_params.postcodec_params.blend_params.bld_lut[3] =
+	    BLEND_TABLE,
+	.vdce_mode_params.postcodec_params.ccv_params = CCV_DEFAULT_PARAMS
+};
+
+/* Default trans-codec params */
+static vdce_params_t transcodec_default_params = {
+	VDCE_OPERATION_TRANS_CODECMODE,
+	0x1,
+	COMMON_DEFAULT_PARAMS,
+	.vdce_mode_params.transcodec_params.rsz_params = RSZ_DEFAULT_PARAMS,
+	.vdce_mode_params.transcodec_params.rmap_params = RMAP_DEFAULT_PARAMS,
+	.vdce_mode_params.transcodec_params.blend_params.blend_mode =
+	    VDCE_MODE_422,
+	.vdce_mode_params.transcodec_params.blend_params.bld_lut[0] =
+	    BLEND_TABLE,
+	.vdce_mode_params.transcodec_params.blend_params.bld_lut[1] =
+	    BLEND_TABLE,
+	.vdce_mode_params.transcodec_params.blend_params.bld_lut[2] =
+	    BLEND_TABLE,
+	.vdce_mode_params.transcodec_params.blend_params.bld_lut[3] =
+	    BLEND_TABLE,
+	.vdce_mode_params.transcodec_params.epad_params = EPAD_DEFAULT_PARAMS,
+	.vdce_mode_params.transcodec_params.ccv_params = CCV_DEFAULT_PARAMS
+};
+
+/* Default edgepadding params */
+static vdce_params_t epad_default_params = {
+	VDCE_OPERATION_EDGE_PADDING,
+	0x0,
+	COMMON_DEFAULT_PARAMS,
+	.vdce_mode_params.epad_params = EPAD_DEFAULT_PARAMS
+};
+
+/* Default resising params */
+static vdce_params_t rsz_default_params = {
+	VDCE_OPERATION_RESIZING,
+	0x0,
+	COMMON_DEFAULT_PARAMS,
+	.vdce_mode_params.rsz_params = RSZ_DEFAULT_PARAMS
+};
+
+/* Default CCV params */
+static vdce_params_t ccv_default_params = {
+	VDCE_OPERATION_CHROMINANCE_CONVERSION,
+	0x0,
+	COMMON_DEFAULT_PARAMS,
+	.vdce_mode_params.ccv_params = CCV_DEFAULT_PARAMS
+};
+
+/* Default blending params */
+static vdce_params_t blend_default_params = {
+	VDCE_OPERATION_BLENDING,
+	0x0,
+	COMMON_DEFAULT_PARAMS,
+	.vdce_mode_params.blend_params.blend_mode = VDCE_MODE_422,
+	.vdce_mode_params.blend_params.bld_lut[0] = BLEND_TABLE,
+	.vdce_mode_params.blend_params.bld_lut[1] = BLEND_TABLE,
+	.vdce_mode_params.blend_params.bld_lut[2] = BLEND_TABLE,
+	.vdce_mode_params.blend_params.bld_lut[3] = BLEND_TABLE
+};
+
+/* Default rangemapping params */
+static vdce_params_t rmap_default_params = {
+	VDCE_OPERATION_RANGE_MAPPING,
+	0x0,
+	COMMON_DEFAULT_PARAMS,
+	.vdce_mode_params.rmap_params = RMAP_DEFAULT_PARAMS
+};
+static int prcs_array_value[] = { 16, 32, 64, 128, 256 };
+
+/*
+ * vdce_free_pages : Function to free memory of buffers
+ */
+inline void vdce_free_pages(unsigned long addr, unsigned long bufsize)
+{
+	unsigned long size;
+	unsigned long tempaddr = addr;
+	if (!addr)
+		return;
+	size = PAGE_SIZE << (get_order(bufsize));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(tempaddr, get_order(bufsize));
+}
+
+/*
+ * vdce_uservirt_to_phys : This inline function is used to
+ * convert user space virtual address to physical address.
+ */
+static inline unsigned long vdce_uservirt_to_phys(unsigned long virtp)
+{
+	unsigned long physp = 0;
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+	/* For kernel direct-mapped memory, take the easy way */
+	if (virtp >= PAGE_OFFSET)
+		physp = virt_to_phys((void *)virtp);
+
+	/* this will catch, kernel-allocated, mmaped-to-usermode addresses */
+	else if ((vma = find_vma(mm, virtp)) &&
+		 (vma->vm_flags & VM_IO) && (vma->vm_pgoff)) {
+		physp = (vma->vm_pgoff << PAGE_SHIFT) + (virtp - vma->vm_start);
+	}
+	/* otherwise, use get_user_pages() for general userland pages */
+	else {
+		int res, nr_pages = 1;
+		struct page *pages;
+		down_read(&current->mm->mmap_sem);
+
+		res = get_user_pages(current, current->mm,
+				     virtp, nr_pages, 1, 0, &pages, NULL);
+		up_read(&current->mm->mmap_sem);
+
+		if (res == nr_pages) {
+			physp =
+			    __pa(page_address(&pages[0]) +
+				 (virtp & ~PAGE_MASK));
+		} else {
+			dev_err(vdce_device,
+				" Unable to find phys addr for 0x%08lx\n",
+				virtp);
+			dev_err(vdce_device,
+				"get_user_pages() failed: %d\n", res);
+		}
+	}
+	return physp;
+}
+
+/*
+ * malloc_buff : Function to allocate memory to input
+ * and output buffers
+ */
+int malloc_buff(vdce_reqbufs_t * reqbuff, channel_config_t * vdce_conf_chan)
+{
+	/* for looping purpose */
+	int i = 0;
+	/* for pointing to input output buffer or bitmap pointer */
+	int *buf_ptr;
+	/* to calculate no of max buffers; */
+	int maxbuffers;
+	/* to calculate number of buffers allocated */
+	int numbuffers = 0;
+	/* for storing buffer size */
+	int *buf_size;
+	/* Stores requested buffer size */
+	unsigned int req_buffersize = 0;
+	/* to make sure buffer pointer never swapped */
+	unsigned long adr;
+	unsigned long size;
+	int multiplier;
+
+	dev_dbg(vdce_device, " <fn> malloc_buff Entering E </fn>\n");
+
+	dev_dbg(vdce_device, "Input buffer requested \n");
+	buf_ptr =
+	    (unsigned int *)vdce_conf_chan->vdce_buffer[reqbuff->
+							buf_type].buffers;
+	buf_size = &vdce_conf_chan->vdce_buffer[reqbuff->buf_type].size;
+	maxbuffers = MAX_BUFFERS;
+	numbuffers =
+	    vdce_conf_chan->vdce_buffer[reqbuff->buf_type].num_allocated;
+	if (reqbuff->buf_type > VDCE_BUF_BMP) {
+		dev_dbg(vdce_device, "Invalid type \n");
+		return -EINVAL;
+	}
+	multiplier = GET_DIVIDE_FACTOR(reqbuff->image_type);
+	req_buffersize =
+	    ((reqbuff->num_lines * reqbuff->bytes_per_line * multiplier) / 2);
+	/* check the request for number of buffers */
+	if (reqbuff->count > maxbuffers)
+		return -EINVAL;
+
+	/* free all the buffers if the count is zero */
+	if ((reqbuff->count == FREE_BUFFER) ||
+	    ((numbuffers != 0) && (req_buffersize != *buf_size))) {
+		/* free all the buffers */
+		free_num_buffers(buf_ptr, *buf_size, numbuffers);
+		return 0;
+	}
+	dev_dbg(vdce_device,
+		"The	no of requested	buffers	are %d \n ", reqbuff->count);
+	/* free the remainning buffers . ie total allocated is 7 requested is 5
+	   than free 2 buffers */
+	if ((numbuffers - reqbuff->count) > 0) {
+		buf_ptr = buf_ptr + reqbuff->count;
+		/* free the remainning buffers */
+		free_num_buffers(buf_ptr, *buf_size,
+				 (numbuffers - reqbuff->count));
+	} else {
+		buf_ptr = buf_ptr + numbuffers;
+		for (i = numbuffers; i < reqbuff->count; i++) {
+			/* assign memory to buffer */
+			*buf_ptr =
+			    (int)(__get_free_pages
+				  (GFP_KERNEL | GFP_DMA,
+				   get_order(req_buffersize)));
+			if (!(*buf_ptr)) {
+				reqbuff->count = numbuffers + i;
+				*buf_size = req_buffersize;
+				dev_dbg(vdce_device,
+					"requestbuffer:not enough memory");
+				return -ENOMEM;
+			}
+			adr = *buf_ptr;
+			size = PAGE_SIZE << (get_order(req_buffersize));
+			while (size > 0) {
+				/* make  sure the frame buffers
+				   are never swapped out of memory */
+				SetPageReserved(virt_to_page(adr));
+				adr += PAGE_SIZE;
+				size -= PAGE_SIZE;
+			}
+			buf_ptr++;
+		}
+	}
+	reqbuff->count = numbuffers + i;
+
+	vdce_conf_chan->vdce_buffer[reqbuff->buf_type].num_allocated =
+	    numbuffers + i;
+	/* set the buffer size to requested size */
+	/* this will be useful only when numbuffers = 0 */
+	*buf_size = req_buffersize;
+	dev_dbg(vdce_device, "<fn> malloc_buff Leaving </fn>\n");
+	return 0;
+}
+
+/*
+ * free_num_buffers :Function to free the number of
+ *  buffers specified by count
+ */
+int free_num_buffers(int *addr, unsigned long bufsize, unsigned long count)
+{
+	int i;
+	for (i = 0; i < count; i++) {
+		/* free memory allocate for the image */
+		dev_dbg(vdce_device, "Free all the allocated	buffers	\n");
+		/* free buffers using free_pages */
+		vdce_free_pages((int)*addr, bufsize);
+		/* assign buffer zero to indicate its free */
+		*addr = (int)NULL;
+		addr++;
+	}
+	return 0;
+}
+
+/*
+ * get_buf_address : Function to query the  physical address
+ * of the buffer  requested by index
+ */
+int get_buf_address(vdce_buffer_t * buffer, channel_config_t * vdce_conf_chan)
+{
+	dev_dbg(vdce_device, "<fn>get_buf_address Entering </fn>\n");
+	if (!buffer || !vdce_conf_chan) {
+		dev_err(vdce_device, "query_buffer: error in argument\n");
+		return -EINVAL;
+	}
+	if (buffer->buf_type > VDCE_BUF_BMP) {
+		dev_dbg(vdce_device, "Invalid type \n");
+		return -EINVAL;
+	}
+	/*checking the index requested */
+	if (buffer->index >=
+	    (vdce_conf_chan->vdce_buffer[buffer->buf_type].num_allocated)) {
+		dev_dbg(vdce_device, "Requested buffer not allocated	\n");
+		return -EINVAL;
+	}
+	/* assignning the  input address to offset which will be
+	   used in mmap */
+	buffer->offset =
+	    (unsigned int)vdce_conf_chan->vdce_buffer[buffer->buf_type].
+	    buffers[buffer->index];
+	buffer->size = vdce_conf_chan->vdce_buffer[buffer->buf_type].size;
+	buffer->offset = virt_to_phys((void *)buffer->offset);
+
+	dev_dbg(vdce_device, "the physical offset returned after query \
+						is %x", buffer->offset);
+	dev_dbg(vdce_device, "<fn>get_buf_address Leaving </fn>\n");
+	return 0;
+}
+
+/*
+ * free_buff : This function free the input and output buffers alloated
+ */
+int free_buff(channel_config_t * vdce_conf_chan)
+{
+	int buffercounter = 0;
+	int i;
+	dev_dbg(vdce_device, " <fn>free_buff E</fn>\n");
+	/* free all the  buffers */
+	for (i = 0; i < 3; i++) {
+		while ((vdce_conf_chan->vdce_buffer[i].
+			buffers[buffercounter] != NULL)
+		       && buffercounter < MAX_BUFFERS) {
+			/* free the memory */
+			vdce_free_pages((unsigned long)vdce_conf_chan->
+					vdce_buffer[i].buffers[buffercounter]
+					, vdce_conf_chan->vdce_buffer[i].size);
+			/* assign buffer zero to indicate its free */
+			vdce_conf_chan->vdce_buffer[i].
+			    buffers[buffercounter] = (unsigned long)NULL;
+			buffercounter++;
+		}
+		buffercounter = 0;
+	}
+	dev_dbg(vdce_device, "<fn> free_buff L</fn>\n");
+	return 0;
+}
+
+/*
+edma call back function.
+*/
+static void callback1(int lch, unsigned short ch_status, void *data)
+{
+	switch (ch_status) {
+	case DMA_COMPLETE:
+		irqraised1 = 1;
+		break;
+	case DMA_EVT_MISS_ERROR:
+		irqraised1 = -1;
+		break;
+	case QDMA_EVT_MISS_ERROR:
+		irqraised1 = -2;
+		break;
+	default:
+		break;
+	}
+	complete(&(device_config.edma_sem));
+}
+
+/* edma3 memcpy functiom which copies the luma data
+*/
+static int edma3_memcpy(int acnt, int bcnt, int ccnt,
+			vdce_address_start_t * vdce_start)
+{
+	int result = 0;
+	unsigned int dma_ch = 0;
+	unsigned int tcc = EDMA_TCC_ANY;
+	int i, p = 0;
+	unsigned int Istestpassed = 0u;
+	unsigned int numenabled = 0;
+	unsigned int BRCnt = 0;
+	int srcbidx = 0;
+	int desbidx = 0;
+	int srccidx = 0;
+	int descidx = 0;
+	int ret = 0;
+	struct paramentry_descriptor param_set;
+	unsigned int numtimes = 0;
+	unsigned int src_inc = 0, dst_inc = 0;
+
+	/* Setting up the SRC/DES Index */
+	srcbidx = vdce_start->src_horz_pitch;
+	desbidx = vdce_start->res_horz_pitch;
+
+	if (ccnt == 2 && (((bcnt != vdce_start->buffers[1].
+			    size / (vdce_start->res_horz_pitch * 4))) ||
+			  ((bcnt != vdce_start->buffers[0].
+			    size / (vdce_start->src_horz_pitch * 4))))) {
+
+		numtimes = 1;
+		srccidx = acnt;
+		descidx = acnt;
+		BRCnt = bcnt;
+		src_inc = 0;
+		dst_inc = 0;
+		ccnt = 1;
+	} else {
+		/* A Sync Transfer Mode */
+		srccidx = acnt;
+		descidx = acnt;
+		BRCnt = bcnt;
+		src_inc = 0;
+		dst_inc = 0;
+		numtimes = 0;
+	}
+	if (ccnt == 2 && ((bcnt == vdce_start->buffers[1].
+			   size / (vdce_start->res_horz_pitch * 4)))) {
+		bcnt = bcnt * 2;
+	}
+	src_inc = 0;
+	dst_inc = 0;
+
+	for (p = 0; p <= numtimes; p++) {
+		result = davinci_request_dma(EDMA_DMA_CHANNEL_ANY,
+					     "AB-SYNC_DMA0",
+					     callback1, NULL,
+					     &dma_ch, &tcc, EVENTQ_1);
+
+		if (0 != result) {
+			dev_err(vdce_device, "emda request error:%d\n", result);
+			return result;
+		}
+
+		davinci_set_dma_src_params(dma_ch,
+					   (unsigned long)vdce_start->
+					   buffers[0].offset + src_inc,
+					   INCR, W8BIT);
+
+		davinci_set_dma_dest_params(dma_ch,
+					    (unsigned long)vdce_start->
+					    buffers[1].offset + dst_inc,
+					    INCR, W8BIT);
+
+		davinci_set_dma_src_index(dma_ch, srcbidx, srccidx);
+
+		davinci_set_dma_dest_index(dma_ch, desbidx, descidx);
+
+		/* A Sync Transfer Mode */
+		davinci_set_dma_transfer_params(dma_ch, acnt, bcnt, ccnt,
+						BRCnt, ABSYNC);
+
+		/* Enable the Interrupts on Channel 1 */
+		davinci_get_dma_params(dma_ch, &param_set);
+		param_set.opt |= (1 << ITCINTEN_SHIFT);
+		param_set.opt |= (1 << TCINTEN_SHIFT);
+		davinci_set_dma_params(dma_ch, &param_set);
+
+		numenabled = 1;
+
+		for (i = 0; i < numenabled; i++) {
+			irqraised1 = 0;
+
+			/*
+			 * Now enable the transfer as calculated above.
+			 */
+			device_config.edma_sem.done = 0;
+			result = davinci_start_dma(dma_ch);
+			if (result != 0) {
+				dev_err(vdce_device, "dma start failed \n");
+				break;
+			}
+			ret =
+			    wait_for_completion_interruptible_timeout(&
+								      (device_config.
+								       edma_sem),
+								      10000);
+			if (ret <= 0) {
+				davinci_stop_dma(dma_ch);
+				davinci_free_dma(dma_ch);
+				dev_err(vdce_device, "EDMA Interrupt did not \
+					Occur \n");
+				return -EINVAL;
+			}
+			/* Check the status of the completed transfer */
+			if (irqraised1 < 0) {
+				/* Some error occured, break from the FOR loop. */
+				break;
+			}
+		}
+		if (0 == result) {
+			Istestpassed = 1;
+			davinci_stop_dma(dma_ch);
+			davinci_free_dma(dma_ch);
+		}
+		src_inc = vdce_start->buffers[0].size / 4;
+		dst_inc = vdce_start->buffers[1].size / 4;
+	}
+	return result;
+}
+
+/*
+ * vdce_set_address : This function is used to set the addres register
+ */
+int vdce_set_address(vdce_address_start_t * vdce_start,
+		     channel_config_t * vdce_conf_chan, int num_pass,
+		     unsigned int res_size, unsigned int address,
+		     unsigned int pitch)
+{
+
+	int no_of_lines = 0, no_of_lines_output = 0;
+	int divider;
+	unsigned int multiplier = 1;
+	unsigned int temp_lines = 1;
+	unsigned int src_vsp = 0;
+	unsigned int res_vsp = 0;
+	int res_mode, src_mode;
+	unsigned int src_pitch, res_pitch, src_address;
+	unsigned int flag = 0, buffer_index, res_address;
+
+	dev_dbg(vdce_device, "<fn> vdce_set_address	E </fn>\n");
+	/* Top field luma address is the src starting address */
+	src_address = vdce_start->buffers[0].offset;
+	src_pitch = vdce_start->src_horz_pitch;
+	/* For resizing set source mode for second pass equals result mode */
+	src_mode = vdce_conf_chan->get_params.common_params.src_mode;
+
+	if (vdce_conf_chan->num_pass == VDCE_MULTIPASS) {
+		if (num_pass == 1 &&
+		    (vdce_conf_chan->luma_chroma_phased == 0) &&
+		    vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING) {
+			src_mode =
+			    vdce_conf_chan->get_params.common_params.res_mode;
+		}
+	}
+	if (num_pass == 1) {
+
+		if (vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING) {
+			src_address = address;
+			src_pitch = vdce_start->res_horz_pitch;
+		} else {
+			src_pitch =
+			    vdce_conf_chan->register_config[0].
+			    vdce_res_strt_off_ytop;
+
+			src_address =
+			    vdce_conf_chan->
+			    register_config[0].vdce_res_strt_add_ytop;
+		}
+	}
+	vdce_conf_chan->register_config[num_pass].vdce_src_strt_add_ytop =
+	    src_address +
+	    (vdce_conf_chan->get_params.common_params.src_vsp_luminance *
+	     vdce_start->src_horz_pitch);
+	if (vdce_conf_chan->get_params.common_params.src_mode ==
+	    VDCE_FIELD_MODE) {
+		src_vsp =
+		    vdce_conf_chan->get_params.common_params.
+		    src_vsp_luminance * vdce_start->src_horz_pitch;
+	}
+	/* no of lines in horizonatl direction for top/bottom field data */
+	/* ie if v pitch is 48num_pass  than ytop will be of 240 lines */
+	if (vdce_conf_chan->image_type_in == VDCE_IMAGE_FMT_420) {
+		vdce_start->buffers[0].size =
+		    (vdce_start->buffers[0].size * 4) / 3;
+	}
+	no_of_lines = (vdce_start->buffers[0].size / (4));
+
+	if ((vdce_conf_chan->get_params.common_params.
+	     src_processing_mode == VDCE_INTERLACED)
+	    && (src_mode == VDCE_FRAME_MODE)) {
+		multiplier = 1;
+	}
+	/* offset would be horizontal luma size */
+	vdce_conf_chan->register_config[num_pass].vdce_src_add_ofst_ytop =
+	    src_pitch * multiplier;
+	/* offset configuration */
+	vdce_conf_chan->register_config[num_pass].vdce_src_add_ofst_ybot =
+	    src_pitch * multiplier;
+	vdce_conf_chan->register_config[num_pass].vdce_src_add_ofst_ctop =
+	    vdce_start->src_horz_pitch * multiplier;
+	vdce_conf_chan->register_config[num_pass].vdce_src_add_ofst_cbot =
+	    vdce_start->src_horz_pitch * multiplier;
+
+/* configure bottom field luma addreess is ytop + (no_of_lines*hpitch) */
+	multiplier = src_pitch;
+	if (src_mode == VDCE_FIELD_MODE) {
+		temp_lines = no_of_lines;
+		multiplier = 1;
+	}
+	/* offset would be horizontal luma size */
+	vdce_conf_chan->register_config[num_pass].vdce_src_strt_add_ybot =
+	    (vdce_conf_chan->register_config[num_pass].
+	     vdce_src_strt_add_ytop + (temp_lines * multiplier));
+
+	if (num_pass == 1 && (src_mode == VDCE_FIELD_MODE)) {
+		vdce_conf_chan->register_config[num_pass].
+		    vdce_src_strt_add_ybot = vdce_conf_chan->
+		    register_config[0].vdce_res_strt_add_ybot;
+	}
+	src_address = vdce_start->buffers[0].offset +
+	    (vdce_conf_chan->get_params.common_params.src_vsp_luminance *
+	     src_pitch);
+	if (num_pass != 1) {
+		src_address = (src_address + ((no_of_lines * 2)));
+	}
+	vdce_conf_chan->register_config[num_pass].vdce_src_strt_add_ctop =
+	    (src_address);
+
+	divider = GET_CHROMA_DIVIDE_FACTOR(vdce_conf_chan->image_type_in);
+	if (src_mode == VDCE_FRAME_MODE) {
+		vdce_conf_chan->register_config[num_pass].
+		    vdce_src_strt_add_cbot =
+		    (vdce_conf_chan->register_config[num_pass].
+		     vdce_src_strt_add_ctop + vdce_start->src_horz_pitch);
+	} else {
+		vdce_conf_chan->register_config[num_pass].
+		    vdce_src_strt_add_cbot =
+		    (vdce_conf_chan->register_config[num_pass].
+		     vdce_src_strt_add_ctop + ((temp_lines * 2 / divider)));
+	}
+	/* bitmap offset configuration is bitmap hsize */
+	vdce_conf_chan->register_config[num_pass].
+	    vdce_src_strt_off_bmp_top = vdce_start->bmp_pitch;
+
+	vdce_conf_chan->register_config[num_pass].
+	    vdce_src_strt_off_bmp_bot = vdce_start->bmp_pitch;
+	/* bitmap starting address is starting address for bitmap offset */
+	vdce_conf_chan->register_config[num_pass].
+	    vdce_src_strt_add_bmp_top = vdce_start->buffers[2].offset;
+
+	/* bitmap bottom field starting address */
+	vdce_conf_chan->register_config[num_pass].
+	    vdce_src_strt_add_bmp_bot =
+	    vdce_conf_chan->register_config[num_pass].
+	    vdce_src_strt_add_bmp_top +
+	    (vdce_conf_chan->get_params.common_params.bmp_vsize / 2);
+
+	/* result address for top field */
+	if (vdce_conf_chan->image_type_out == VDCE_IMAGE_FMT_420) {
+		vdce_start->buffers[1].size =
+		    (vdce_start->buffers[1].size * 4) / 3;
+	}
+	no_of_lines_output = (vdce_start->buffers[1].size / (2));
+
+	res_mode = vdce_conf_chan->get_params.common_params.res_mode;
+	if (vdce_conf_chan->num_pass == VDCE_MULTIPASS) {
+		if (num_pass == 0 && (vdce_conf_chan->luma_chroma_phased == 0)) {
+			if (vdce_conf_chan->mode_state ==
+			    VDCE_OPERATION_BLENDING) {
+				res_mode = vdce_conf_chan->
+				    get_params.common_params.src_mode;
+				address = vdce_start->buffers[0].offset;
+			}
+			flag = 1;
+		}
+	}
+	buffer_index = (flag == 1) ? 0 : 1;
+	res_pitch = vdce_start->res_horz_pitch;
+	if (buffer_index == 0) {
+		res_pitch = pitch;
+
+	}
+	if (vdce_conf_chan->num_pass != VDCE_MULTIPASS) {
+		address = vdce_start->buffers[buffer_index].offset;
+	}
+
+	/* top field luma address is the src starting address */
+	vdce_conf_chan->register_config[num_pass].vdce_res_strt_add_ytop =
+	    address +
+	    (vdce_conf_chan->get_params.common_params.res_vsp_luminance *
+	     vdce_start->res_horz_pitch);
+	if (vdce_conf_chan->get_params.common_params.res_mode ==
+	    VDCE_FIELD_MODE) {
+		res_vsp =
+		    vdce_conf_chan->get_params.common_params.
+		    res_vsp_luminance * vdce_start->res_horz_pitch;
+	}
+	multiplier = 1;
+	/* offset would be horizontal luma size */
+	if ((vdce_conf_chan->get_params.common_params.
+	     src_processing_mode == VDCE_INTERLACED)
+	    && (vdce_conf_chan->get_params.common_params.res_mode ==
+		VDCE_FRAME_MODE)) {
+		multiplier = 1;
+	}
+	vdce_conf_chan->register_config[num_pass].vdce_res_strt_off_ytop =
+	    res_pitch * multiplier;
+	/* offset configuration */
+	vdce_conf_chan->register_config[num_pass].vdce_res_strt_off_ybot =
+	    res_pitch * multiplier;
+	vdce_conf_chan->register_config[num_pass].vdce_res_strt_off_ctop =
+	    vdce_start->res_horz_pitch * multiplier;
+	vdce_conf_chan->register_config[num_pass].vdce_res_strt_off_cbot =
+	    vdce_start->res_horz_pitch * multiplier;
+
+	/* no of lines in horizonatl direction for top/bottom field data */
+	/* ie if v pitch is 48num_pass  than ytop will be of 24num_pass lines */
+	dev_dbg(vdce_device, "The number of lines are %d\n\n",
+		no_of_lines_output);
+
+	/* configure bottom field luma addreess */
+	if (res_mode == VDCE_FRAME_MODE) {
+		vdce_conf_chan->
+		    register_config[num_pass].vdce_res_strt_add_ybot =
+		    (vdce_conf_chan->register_config[num_pass].
+		     vdce_res_strt_add_ytop + res_pitch);
+	} else {
+
+		if ((vdce_conf_chan->num_pass == VDCE_MULTIPASS) &&
+		    (num_pass == 0)
+		    && (vdce_conf_chan->luma_chroma_phased == 0)) {
+			if (vdce_conf_chan->mode_state ==
+			    VDCE_OPERATION_BLENDING) {
+
+				vdce_conf_chan->register_config[num_pass].
+				    vdce_res_strt_add_ybot =
+				    vdce_conf_chan->
+				    register_config[num_pass].
+				    vdce_src_strt_add_ybot;
+			} else {
+				vdce_conf_chan->register_config[num_pass].
+				    vdce_res_strt_add_ybot =
+				    (vdce_conf_chan->
+				     register_config[num_pass].
+				     vdce_res_strt_add_ytop) + (res_size / 4);
+			}
+
+		} else {
+
+			vdce_conf_chan->
+			    register_config[num_pass].
+			    vdce_res_strt_add_ybot =
+			    (vdce_conf_chan->register_config[num_pass].
+			     vdce_res_strt_add_ytop +
+			     (((no_of_lines_output / 2))));
+		}
+	}
+	/* configure top field chroma addreess */
+	res_address = vdce_start->buffers[1].offset +
+	    (vdce_conf_chan->get_params.common_params.res_vsp_luminance *
+	     vdce_start->res_horz_pitch);
+	if (flag == 0) {
+		res_address = (res_address + (no_of_lines_output));
+	}
+	vdce_conf_chan->register_config[num_pass].vdce_res_strt_add_ctop =
+	    (res_address);
+
+	/* configuration of cbottom */
+	divider = GET_CHROMA_DIVIDE_FACTOR(vdce_conf_chan->image_type_out);
+	if (res_mode == VDCE_FRAME_MODE) {
+		vdce_conf_chan->
+		    register_config[num_pass].vdce_res_strt_add_cbot =
+		    (vdce_conf_chan->register_config[num_pass].
+		     vdce_res_strt_add_ctop + vdce_start->res_horz_pitch);
+	} else {
+		vdce_conf_chan->
+		    register_config[num_pass].vdce_res_strt_add_cbot =
+		    (vdce_conf_chan->register_config[num_pass].
+		     vdce_res_strt_add_ctop + ((no_of_lines_output / divider)));
+	}
+	dev_dbg(vdce_device, "<fn	>Leaving out of	set address </fn>\n");
+	/* configure top field chroma addreess */
+	return 0;
+}
+
+/*
+ * vdce_set_multipass_address :This function is process in 4:2:2 format for
+ * resizing and blending mode
+ */
+int vdce_set_multipass_address(vdce_address_start_t * vdce_start,
+			       channel_config_t * vdce_conf_chan)
+{
+
+	static unsigned int temp_address, temp_hsz_pitch;
+	int ret = 0;
+	int temp_size;
+	int divider = 2;
+	int req_size = 0;
+	unsigned int address = 0, pitch = 0, res_size = 0;
+	dev_dbg(vdce_device,
+		"<fn>vdce_set_multipass_address	Entering\n</fn>");
+	/* initially this first pass , so we have this flag as started */
+	/* take the offset and pitch into temporary variables */
+	req_size = (vdce_conf_chan->get_params.common_params.
+		    src_hsz_luminance *
+		    vdce_conf_chan->get_params.common_params.src_vsz_luminance);
+	if (device_config.inter_size < req_size) {
+		dev_err(vdce_device,
+			"intermediate buffer size is less than required\n");
+		return -EINVAL;
+	}
+	temp_address = vdce_start->buffers[1].offset;
+	address = vdce_start->buffers[1].offset;
+	if (vdce_conf_chan->mode_state == VDCE_OPERATION_BLENDING) {
+		pitch = vdce_start->src_horz_pitch;
+	} else {
+		pitch = vdce_start->res_horz_pitch;
+	}
+	temp_hsz_pitch = vdce_start->res_horz_pitch;
+	vdce_start->res_horz_pitch =
+	    (vdce_conf_chan->get_params.common_params.dst_hsz_luminance);
+	temp_size = vdce_start->buffers[1].size;
+	res_size = temp_size;
+
+	vdce_start->buffers[1].size = ((device_config.inter_size * 2));
+
+	/* Since first we have to do 4:2:2 to 4:2:0  */
+	/* assign in intermediate address to output address */
+	vdce_start->buffers[1].offset =
+	    virt_to_phys(((void *)device_config.inter_buffer));
+	/* change the output size */
+	vdce_conf_chan->register_config[0].res_Y_sz =
+	    ((vdce_conf_chan->get_params.common_params.
+	      dst_hsz_luminance << RES_Y_HSZ_SHIFT)
+	     & (RES_Y_HSZ_MASK));
+	if (vdce_conf_chan->get_params.common_params.src_processing_mode ==
+	    VDCE_INTERLACED) {
+		divider = 4;
+	}
+	vdce_conf_chan->register_config[0].res_C_sz |=
+	    ((vdce_conf_chan->get_params.common_params.dst_vsz_luminance /
+	      divider << RES_C_VSZ_SHIFT) & (RES_C_VSZ_MASK));
+	if (vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING) {
+		vdce_conf_chan->register_config[1].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[1].
+			   vdce_ctrl, SET_CHROMA_ENABLE);
+		vdce_conf_chan->register_config[1].vdce_ctrl =
+		    BITRESET(vdce_conf_chan->register_config[1].
+			     vdce_ctrl, SET_LUMA_ENABLE);
+	} else {
+		vdce_conf_chan->register_config[0].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[0].
+			   vdce_ctrl, SET_CHROMA_ENABLE);
+		vdce_conf_chan->register_config[0].vdce_ctrl =
+		    BITRESET(vdce_conf_chan->register_config[0].
+			     vdce_ctrl, SET_LUMA_ENABLE);
+	}
+	/* assignning the address to the register configuration */
+	ret = vdce_set_address(vdce_start, vdce_conf_chan, 0,
+			       res_size, address, pitch);
+
+	/* second pass. configuration */
+	vdce_start->buffers[0].offset =
+	    virt_to_phys(((void *)device_config.inter_buffer));
+	/* configure input pitch */
+	vdce_start->src_horz_pitch =
+	    (vdce_conf_chan->get_params.common_params.dst_hsz_luminance);
+	vdce_start->buffers[0].size = ((device_config.inter_size * 2));
+	vdce_start->buffers[1].size = temp_size;
+	/*configure output pitch and address */
+	vdce_start->buffers[1].offset = temp_address;
+	vdce_start->res_horz_pitch = temp_hsz_pitch;
+
+	/* configure the addrress */
+	ret = vdce_set_address(vdce_start, vdce_conf_chan, 1,
+			       res_size, address, pitch);
+	/* configure input and output size */
+	vdce_conf_chan->register_config[1].src_Y_sz &= ~(SRC_Y_VSZ_MASK);
+	if (vdce_conf_chan->get_params.common_params.src_processing_mode ==
+	    VDCE_INTERLACED) {
+		divider = 2;
+	} else {
+		divider = 1;
+	}
+
+	vdce_conf_chan->register_config[0].res_Y_sz |=
+	    ((vdce_conf_chan->get_params.common_params.
+	      dst_vsz_luminance / divider << RES_Y_VSZ_SHIFT)
+	     & (RES_Y_VSZ_MASK));
+
+	vdce_conf_chan->register_config[1].src_Y_sz =
+	    ((vdce_conf_chan->get_params.common_params.dst_hsz_luminance
+	      << SRC_Y_HSZ_SHIFT) & (SRC_Y_HSZ_MASK));
+
+	vdce_conf_chan->register_config[1].src_C_sz =
+	    ((vdce_conf_chan->get_params.common_params.
+	      dst_hsz_luminance << SRC_C_HSZ_SHIFT) & (SRC_C_HSZ_MASK));
+
+	vdce_conf_chan->register_config[1].res_Y_sz |=
+	    ((vdce_conf_chan->get_params.common_params.
+	      dst_hsz_luminance << RES_Y_HSZ_SHIFT)
+	     & (RES_Y_HSZ_MASK));
+
+	if (vdce_conf_chan->get_params.common_params.src_processing_mode
+	    == VDCE_INTERLACED) {
+
+		vdce_conf_chan->register_config[1].res_Y_sz |=
+		    (((vdce_conf_chan->get_params.common_params.
+		       dst_vsz_luminance / 2) << RES_Y_VSZ_SHIFT) &
+		     (RES_Y_VSZ_MASK));
+		vdce_conf_chan->register_config[1].src_Y_sz |=
+		    ((vdce_conf_chan->get_params.common_params.
+		      dst_vsz_luminance / 2 << SRC_Y_VSZ_SHIFT) &
+		     (SRC_Y_VSZ_MASK));
+		vdce_conf_chan->register_config[1].src_C_sz |=
+		    ((vdce_conf_chan->get_params.common_params.
+		      dst_vsz_luminance / 4 << SRC_C_VSZ_SHIFT) &
+		     (SRC_C_VSZ_MASK));
+	} else {
+		vdce_conf_chan->register_config[1].res_Y_sz |=
+		    ((vdce_conf_chan->get_params.common_params.
+		      dst_vsz_luminance << RES_Y_VSZ_SHIFT) & (RES_Y_VSZ_MASK));
+		vdce_conf_chan->register_config[1].src_Y_sz |=
+		    ((vdce_conf_chan->get_params.common_params.
+		      dst_vsz_luminance << SRC_Y_VSZ_SHIFT) & (SRC_Y_VSZ_MASK));
+		vdce_conf_chan->register_config[1].src_C_sz |=
+		    ((vdce_conf_chan->get_params.common_params.
+		      dst_vsz_luminance / 2 << SRC_C_VSZ_SHIFT) &
+		     (SRC_C_VSZ_MASK));
+	}
+	/* function to enable hardware */
+	dev_dbg(vdce_device,
+		"<fn>vdce_set_multipass_address	Leaving\n</fn>");
+	return ret;
+}
+
+/*
+ * vdce_start : This function enable the resize bit after doing
+ * the hardware register configuration after which resizing
+ * will be carried on.
+ */
+int vdce_start(vdce_address_start_t * vdce_start,
+	       channel_config_t * vdce_conf_chan)
+{
+	/* holds the return value; */
+	int ret = 0;
+	/* conatains the input put and output buffer allocated size */
+	int bufsize[3];
+	int divider_in, divider_out, blend_enable, i;
+	int dst_hsz_luma = 0, dst_vsz_luma = 0;
+	int ccnt = 1;
+	unsigned int edma_operation = 0, ccv_only = 0, luma_status = 0;
+	if (vdce_conf_chan->status == VDCE_CHAN_BUSY) {
+		dev_err(vdce_device, "Channel is busy.Try after some time \n");
+		return -EINVAL;
+	}
+	/* checking the configuartion status */
+	if (vdce_conf_chan->status == VDCE_CHAN_FREE) {
+		vdce_conf_chan->status = VDCE_CHAN_PARAMS_INITIALISED;
+	}
+	if (vdce_conf_chan->status != VDCE_CHAN_PARAMS_INITIALISED) {
+		dev_err(vdce_device, "State not configured \n");
+		return -EINVAL;
+	}
+	/* channel status is FREE */
+	vdce_conf_chan->status = VDCE_CHAN_FREE;
+
+	/* check tht hpitch and vpitch should be greater or equal
+	   than hsize and vsize */
+	if (vdce_start->src_horz_pitch <
+	    vdce_conf_chan->get_params.common_params.src_hsz_luminance) {
+		dev_err(vdce_device, "src horizontal pitch less than width \n");
+		return -EINVAL;
+	}
+	if (vdce_start->res_horz_pitch
+	    < vdce_conf_chan->get_params.common_params.dst_hsz_luminance) {
+		dev_err(vdce_device, "horizontal pitch less than width \n");
+		return -EINVAL;
+	}
+	divider_in = GET_DIVIDE_FACTOR(vdce_conf_chan->image_type_in);
+	divider_out = GET_DIVIDE_FACTOR(vdce_conf_chan->image_type_out);
+	/* check for the 8byte alignment for input address of
+	   ytop,ybot,ctop and cbot in both image format */
+
+	/* get the buffer size */
+	bufsize[VDCE_BUF_IN] =
+	    (vdce_start->src_horz_pitch *
+	     (vdce_conf_chan->get_params.common_params.src_vsz_luminance *
+	      divider_in / 2));
+	bufsize[VDCE_BUF_OUT] =
+	    (vdce_start->res_horz_pitch *
+	     (vdce_conf_chan->get_params.common_params.dst_vsz_luminance *
+	      divider_out) / 2);
+	if ((vdce_start->res_horz_pitch) % 0x8 != 0) {
+		dev_err(vdce_device, " invalid resultant pitch offset \n");
+		return -EINVAL;
+	}
+	if ((vdce_start->src_horz_pitch) % 0x8 != 0) {
+		dev_err(vdce_device, " invalid source  pitch offset \n");
+		return -EINVAL;
+	}
+	bufsize[VDCE_BUF_BMP] =
+	    (vdce_conf_chan->get_params.common_params.bmp_hsize *
+	     vdce_conf_chan->get_params.common_params.bmp_vsize) / 4;
+	blend_enable =
+	    BITGET(vdce_conf_chan->register_config[0].vdce_ctrl,
+		   SET_BLEND_ENABLE);
+	blend_enable |=
+	    BITGET(vdce_conf_chan->register_config[1].vdce_ctrl,
+		   SET_BLEND_ENABLE);
+	for (i = VDCE_BUF_IN; i <= VDCE_BUF_BMP; i++) {
+		if (i == VDCE_BUF_BMP && blend_enable != 1) {
+			continue;
+		}		/* user pointer case */
+		if (vdce_start->buffers[i].index < 0) {
+			/* assignning the address to the register conf  */
+			if (vdce_start->buffers[i].size < bufsize[i]) {
+				dev_err(vdce_device, " invalid size \n");
+				return -EINVAL;
+			}
+			if ((void *)vdce_start->buffers[i].virt_ptr == NULL) {
+				dev_err(vdce_device, " Address is NULL \n");
+				return -EINVAL;
+			}
+			/* user virtual pointer to physical address */
+			vdce_start->buffers[i].offset =
+			    vdce_uservirt_to_phys(vdce_start->buffers[i].
+						  virt_ptr /*offset */ );
+		} else {
+			/*checking the index requested */
+			if ((vdce_start->buffers[i].index)
+			    > ((vdce_conf_chan->vdce_buffer[i].
+				num_allocated - 1))) {
+				dev_err(vdce_device,
+					"Requested buffer not allocatedn");
+				return -EINVAL;
+			}
+			vdce_start->buffers[i].offset = virt_to_phys(((void *)
+								      vdce_conf_chan->vdce_buffer[i].
+								      buffers
+								      [vdce_start->
+								       buffers
+								       [i].
+								       index]));
+			vdce_start->buffers[i].size =
+			    vdce_conf_chan->vdce_buffer[i].size;
+		}
+		/* check alignment for ytop */
+		if (vdce_start->buffers[i].offset % 0x8 != 0) {
+			dev_err(vdce_device, "Address not 8 byte aligned \n");
+			return -EINVAL;
+		}
+	}
+	if (blend_enable) {
+		if ((vdce_start->bmp_pitch * 4) <
+		    vdce_conf_chan->get_params.common_params.bmp_hsize) {
+			dev_err(vdce_device, "bmp pitch less than width \n");
+			return -EINVAL;
+		}
+		if (vdce_start->bmp_pitch % 0x8 != 0) {
+			dev_err(vdce_device, " bmp pitch not aligned \n");
+			return -EINVAL;
+		}
+	}
+	/* check for the 8byte alignment for output address of
+	   ytop,ybot,ctop and cbot in both image format */
+	if ((((vdce_start->buffers[0].size) / 4) % 0x8) != 0) {
+		dev_err(vdce_device, " invalid src address  \n");
+		return -EINVAL;
+	}
+	if (((vdce_start->buffers[1].size) / 4) % 0x8) {
+		dev_err(vdce_device, " invalid resultant address \n");
+		return -EINVAL;
+	}
+
+	if ((vdce_conf_chan->num_pass == VDCE_MULTIPASS) &&
+	    (vdce_conf_chan->luma_chroma_phased == 0)) {
+		ret = vdce_set_multipass_address(vdce_start, vdce_conf_chan);
+		if (ret < 0) {
+			return -EINVAL;
+		}
+	} else {
+		/* assignning the address to the register configuration */
+		ret = vdce_set_address(vdce_start, vdce_conf_chan, 0, 0, 0, 0);
+
+		if (vdce_conf_chan->luma_chroma_phased == 1) {
+			memcpy(&vdce_conf_chan->register_config[1],
+			       &vdce_conf_chan->register_config[0],
+			       sizeof(struct vdce_hw_config));
+			vdce_conf_chan->register_config[0].vdce_ctrl =
+			    BITRESET(vdce_conf_chan->register_config[0].
+				     vdce_ctrl, SET_CHROMA_ENABLE);
+			vdce_conf_chan->register_config[1].vdce_ctrl =
+			    BITRESET(vdce_conf_chan->register_config[1].
+				     vdce_ctrl, SET_LUMA_ENABLE);
+		}
+	}
+	/* Channel is busy */
+	vdce_conf_chan->status = VDCE_CHAN_PENDING;
+	/* function call to add the entry of application in array */
+	ret = add_to_array(vdce_conf_chan);
+
+	/* If non-blocking case than return */
+	if (ret == -1 && vdce_conf_chan->channel_mode == VDCE_MODE_NON_BLOCKING) {
+		return 0;
+	}
+	vdce_conf_chan->status = VDCE_CHAN_BUSY;
+	/* start the process */
+	vdce_conf_chan->vdce_complete = VDCE_PASS1_STARTED;
+	if (vdce_conf_chan->mode_state ==
+	    VDCE_OPERATION_CHROMINANCE_CONVERSION ||
+	    vdce_conf_chan->mode_state == VDCE_OPERATION_PRE_CODECMODE ||
+	    vdce_conf_chan->mode_state == VDCE_OPERATION_POST_CODECMODE ||
+	    vdce_conf_chan->mode_state == VDCE_OPERATION_TRANS_CODECMODE) {
+		edma_operation = 1;
+
+		luma_status = vdce_conf_chan->register_config[0].vdce_ctrl;
+		if ((luma_status & 0x6) == 0x6) {
+			edma_operation = 1;
+		} else {
+			edma_operation = 0;
+		}
+		if ((vdce_conf_chan->get_params.common_params.src_mode !=
+		     vdce_conf_chan->get_params.common_params.res_mode)) {
+			edma_operation = 0;
+		}
+		ccv_only = vdce_conf_chan->register_config[0].vdce_ctrl;
+		if (ccv_only & 0xb00) {
+			edma_operation = 0;
+		}
+		if (edma_operation == 1) {
+			vdce_conf_chan->register_config[0].vdce_ctrl =
+			    BITRESET(vdce_conf_chan->register_config[0].
+				     vdce_ctrl, SET_LUMA_ENABLE);
+		}
+	}
+	vdce_hw_setup(&vdce_conf_chan->register_config[0]);
+	enable_irq(VDCE_INTERRUPT);
+	/*function call to enable ge hardware */
+	ret = vdce_enable(&vdce_conf_chan->register_config[0]);
+
+	if (edma_operation == 1) {
+		dst_hsz_luma = vdce_conf_chan->
+		    get_params.common_params.dst_hsz_luminance;
+
+		dst_vsz_luma = vdce_conf_chan->
+		    get_params.common_params.dst_vsz_luminance;
+		if (vdce_conf_chan->get_params.common_params.src_mode ==
+		    VDCE_FIELD_MODE) {
+			ccnt = 2;
+			dst_vsz_luma = dst_vsz_luma / 2;
+		}
+		ret = edma3_memcpy(dst_hsz_luma, dst_vsz_luma,
+				   ccnt, vdce_start);
+		vdce_conf_chan->register_config[0].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[0].
+			   vdce_ctrl, SET_LUMA_ENABLE);
+	}
+
+	/* waiting for processing to be complete */
+	if (vdce_conf_chan->channel_mode != VDCE_MODE_NON_BLOCKING) {
+		wait_for_completion_interruptible(&(device_config.sem_isr));
+		vdce_conf_chan->status = VDCE_CHAN_FREE;
+
+	}
+	dev_dbg(vdce_device, "<fn> vdce_start L</fn>\n");
+	return ret;
+}
+
+/*
+ * add_to_array : Function to add the current channel configuration
+ * into array according to priority.
+ */
+int add_to_array(channel_config_t * vdce_conf_chan)
+{
+	int array_index, device_index;
+	dev_dbg(vdce_device, "<fn> add_to_array E</fn>\n");
+
+	/* locking the configuartion aaray */
+	down(&device_config.array_sem);
+	/* add configuration to the     queue according to its priority */
+	if (device_config.array_count == EMPTY) {
+		/* if array empty insert at top position */
+		dev_dbg(vdce_device, "First request for resizing \n");
+		device_config.channel_configuration[device_config.array_count]
+		    = vdce_conf_chan;
+	} else {
+		/* check the priority and insert according to the priority */
+		/* it will start from first     index */
+		for (array_index = SECONDENTRY;
+		     array_index < device_config.array_count; array_index++) {
+			if (device_config.
+			    channel_configuration[array_index]->priority <
+			    vdce_conf_chan->priority)
+				break;
+		}
+		/* shift all the elements one step down in array */
+		/* iF firstelement and second have same prioroty than insert */
+		/* below first */
+		for (device_index = device_config.array_count;
+		     device_index > array_index; device_index--) {
+			device_config.channel_configuration[device_index] =
+			    device_config.
+			    channel_configuration[device_index - 1];
+		}
+
+		device_config.channel_configuration[array_index] =
+		    vdce_conf_chan;
+	}
+	/* incrementing number of requests for VDCE */
+	device_config.array_count++;
+	dev_dbg(vdce_device, "The total request for resizing are %d",
+		device_config.array_count);
+	if (device_config.array_count != SECONDENTRY) {
+
+		up(&device_config.array_sem);
+		/* if non-blocking return than channel in use */
+		if (vdce_conf_chan->channel_mode == VDCE_MODE_NON_BLOCKING) {
+			return -1;
+		} else {
+			/* if the request is pending that lock the request */
+			wait_for_completion_interruptible
+			    (&(vdce_conf_chan->channel_sem));
+		}
+	} else {
+		up(&device_config.array_sem);
+	}
+	dev_dbg(vdce_device, "<fn> add_to_array L</fn>\n");
+	return 0;
+}
+
+/*
+ * delete_from_array : Function to delete the processed array entry
+ * form the array
+ */
+int delete_from_array()
+{
+	int array_index = FIRSTENTRY, device_index;
+	channel_config_t *vdce_conf_chan;
+
+	dev_dbg(vdce_device, "<fn> delete_from_array E</fn>\n");
+	/*shift the     entried in array */
+	if (device_config.array_count != SECONDENTRY) {
+		/* decrementing the     request count */
+		device_config.array_count--;
+		/* shift all the elements one step up in array */
+		for (device_index = array_index;
+		     device_index < device_config.array_count; device_index++) {
+
+			device_config.channel_configuration[device_index] =
+			    device_config.
+			    channel_configuration[device_index + 1];
+		}
+		/* making last entry NULL; */
+		device_config.channel_configuration[device_index + 1] = NULL;
+	} else {
+		/* remove the top entry */
+		dev_dbg(vdce_device, "\n Removing	the first request");
+		device_config.array_count--;
+		device_config.channel_configuration[FIRSTENTRY] = NULL;
+	}
+	if (device_config.array_count != FIRSTENTRY) {
+		/* get config having highest priority in array
+		   vdce_device.config
+		   and unlock config.sem of that config */
+		dev_dbg(vdce_device,
+			"Releasing array lock of the second entry\n");
+
+		vdce_conf_chan =
+		    (device_config.channel_configuration[FIRSTENTRY]);
+		/* non-blocking indicatind the first entry is nonblocking */
+		if ((vdce_conf_chan->channel_mode) == VDCE_MODE_NON_BLOCKING) {
+			return -1;
+		} else {
+			complete(&(device_config.channel_configuration
+				   [FIRSTENTRY]->channel_sem));
+		}
+	} else {
+		dev_dbg(vdce_device, "Releasing array lock \n");
+	}
+	dev_dbg(vdce_device, "<fn> delete_from_array L</fn>\n");
+	return 0;
+}
+
+/*
+ * vdce_check_global_params : Function to check the error conditions
+ */
+int vdce_check_common_params(vdce_params_t * params)
+{
+	int ret = 0;
+	int hrsz_mag = 0, vrsz_mag = 0;
+	int i = 0, prcs = 0;
+	dev_dbg(vdce_device, "<fn>vdce_check_global_params E</fn>\n");
+	/* Checking the validity of various enums */
+	ret = CHECK_MODE_RANGE(params->vdce_mode, VDCE_OPERATION_BLENDING);
+	if (ret) {
+		dev_err(vdce_device, "Invalid mode\n");
+		return -EINVAL;
+	}
+	/* checking validity for precodec params */
+	if (params->vdce_mode == VDCE_OPERATION_POST_CODECMODE ||
+	    params->vdce_mode == VDCE_OPERATION_TRANS_CODECMODE) {
+		/* checking validity for postcodec params */
+		if ((params->modes_control & RSZ_ENABLE_MASK) ==
+		    (RSZ_ENABLE_MASK)
+		    && (params->modes_control & BLEND_ENABLE_MASK) ==
+		    (BLEND_ENABLE_MASK)) {
+			dev_err(vdce_device,
+				"Cannot	enable due to Hardware limitation \n");
+			return -EINVAL;
+
+		}
+	}
+	/* if resizing than check for resize ratio */
+	if ((params->vdce_mode == VDCE_OPERATION_RESIZING) ||
+	    ((params->vdce_mode == VDCE_OPERATION_PRE_CODECMODE) &&
+	     ((params->modes_control & RSZ_ENABLE_MASK) == (RSZ_ENABLE_MASK)))
+	    || ((params->vdce_mode == VDCE_OPERATION_POST_CODECMODE)
+		&& ((params->modes_control & RSZ_ENABLE_MASK) ==
+		    (RSZ_ENABLE_MASK)))
+	    || ((params->vdce_mode == VDCE_OPERATION_TRANS_CODECMODE)
+		&& ((params->modes_control & RSZ_ENABLE_MASK) ==
+		    (RSZ_ENABLE_MASK)))) {
+		hrsz_mag =
+		    (params->common_params.src_hsz_luminance * 256) /
+		    (params->common_params.dst_hsz_luminance);
+		vrsz_mag =
+		    (params->common_params.src_vsz_luminance * 256) /
+		    (params->common_params.dst_vsz_luminance);
+		/* checking horizontal phase */
+		if ((hrsz_mag < MIN_RSZ_MAG_RATIO) ||
+		    (hrsz_mag > MAX_RSZ_MAG_RATIO)) {
+			dev_err(vdce_device, "Invalid Horizontal ratio \n");
+			ret = -EINVAL;
+		}
+		/* checking vertical phase */
+		if ((vrsz_mag < MIN_RSZ_MAG_RATIO)
+		    || (vrsz_mag > MAX_RSZ_MAG_RATIO)) {
+			dev_err(vdce_device, "Invalid Vertical ratio \n");
+			ret = -EINVAL;
+		}
+	}
+	if ((params->vdce_mode == VDCE_OPERATION_RESIZING) &&
+	    (params->vdce_mode_params.rsz_params.
+	     rsz_op_mode == VDCE_CODECMODE_MPEG1)) {
+		dev_err(vdce_device,
+			" This facility not supported due to hardware \n\n");
+	}
+	if (params->common_params.prcs_unit_value == 0) {
+		prcs = hrsz_mag / 256;
+		for (i = 4; i >= 0; i--) {
+			if ((prcs_array_value[i] * prcs + 9) <= 256) {
+				break;
+			}
+		}
+		if (i < 0) {
+			i = 0;
+		}
+		prcs = prcs_array_value[i];
+	} else {
+		prcs = params->common_params.prcs_unit_value;
+	}
+	if (prcs > 256) {
+		return -EINVAL;
+	}
+	if (params->vdce_mode == VDCE_OPERATION_EDGE_PADDING) {
+		if ((params->vdce_mode_params.epad_params.hext_luma > prcs)
+		    || (params->vdce_mode_params.epad_params.hext_chroma >
+			prcs))
+			return -EINVAL;
+	}
+	if (params->common_params.src_processing_mode == VDCE_PROGRESSIVE) {
+		if ((params->common_params.src_mode == VDCE_FIELD_MODE) ||
+		    (params->common_params.res_mode == VDCE_FIELD_MODE)) {
+			dev_err(vdce_device, "Invalid Mode ratio \n");
+			return -EINVAL;
+		}
+	}
+	if (ret) {
+		dev_dbg(vdce_device, "Inavlid return \n");
+		return -EINVAL;
+	} else {
+		return 0;
+	}
+	dev_dbg(vdce_device, "<fn>vdce_check_global_params L</fn>\n");
+}
+
+/*
+ * vdce_set_size_fmt : Setting resizing parameters .
+ */
+int vdce_set_size_fmt(vdce_common_params_t * params,
+		      channel_config_t * vdce_conf_chan, int num_pass)
+{
+	int ret = 0;
+	int mode;
+	int prcs_nvalue = 0, i = 0;
+	int prcs = 0;
+	vdce_image_fmt_t src_image_type, divider = 1;
+	dev_dbg(vdce_device, "<fn>vdce_set_size_fmt	E</fn>\n");
+	/* setting luminance processing enable bit */
+	if (params->proc_control == VDCE_LUMA_ENABLE) {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[num_pass].
+			   vdce_ctrl, SET_LUMA_ENABLE);
+	} else if (params->proc_control == VDCE_CHROMA_ENABLE) {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[num_pass].
+			   vdce_ctrl, SET_CHROMA_ENABLE);
+	} else {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[num_pass].
+			   vdce_ctrl, SET_CHROMA_ENABLE);
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[num_pass].
+			   vdce_ctrl, SET_LUMA_ENABLE);
+	}
+
+	/* setting input horizontal alf enable */
+	if (params->field_status == VDCE_TOP_ENABLE) {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[num_pass].
+			   vdce_ctrl, SET_TOP_ENABLE);
+	} else if (params->field_status == VDCE_BOTTOM_ENABLE) {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[num_pass].
+			   vdce_ctrl, SET_BOT_ENABLE);
+	} else {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[num_pass].
+			   vdce_ctrl, SET_BOT_ENABLE);
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[num_pass].
+			   vdce_ctrl, SET_TOP_ENABLE);
+	}
+	/* setting src i/o mode */
+	if (params->src_mode == VDCE_FRAME_MODE) {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[num_pass].
+			   vdce_ctrl, SET_SRC_MODE);
+	} else {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITRESET(vdce_conf_chan->register_config[num_pass].
+			     vdce_ctrl, SET_SRC_MODE);
+	}
+	/* setting res i/o mode */
+	if (params->res_mode == VDCE_FRAME_MODE) {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[num_pass].
+			   vdce_ctrl, SET_RES_MODE);
+	} else {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITRESET(vdce_conf_chan->register_config[num_pass].
+			     vdce_ctrl, SET_RES_MODE);
+	}
+	if (num_pass == 1 &&
+	    (vdce_conf_chan->mode_state != VDCE_OPERATION_RESIZING)) {
+		if (params->src_mode == VDCE_FRAME_MODE) {
+			vdce_conf_chan->register_config[0].vdce_ctrl =
+			    BITSET(vdce_conf_chan->register_config[0].
+				   vdce_ctrl, SET_RES_MODE);
+		} else {
+
+			vdce_conf_chan->register_config[0].vdce_ctrl =
+			    BITRESET(vdce_conf_chan->register_config[0].
+				     vdce_ctrl, SET_RES_MODE);
+		}
+	}
+	if (num_pass == 1 &&
+	    (vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING)) {
+		if (params->res_mode == VDCE_FRAME_MODE) {
+			vdce_conf_chan->register_config[1].vdce_ctrl =
+			    BITSET(vdce_conf_chan->register_config[1].
+				   vdce_ctrl, SET_SRC_MODE);
+		} else {
+
+			vdce_conf_chan->register_config[1].vdce_ctrl =
+			    BITRESET(vdce_conf_chan->register_config[1].
+				     vdce_ctrl, SET_SRC_MODE);
+		}
+	}
+	/* setting bmp i/o mode */
+	if (params->src_bmp_mode == VDCE_FRAME_MODE) {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[num_pass].
+			   vdce_ctrl, SET_BMP_MODE);
+	} else {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITRESET(vdce_conf_chan->register_config[num_pass].
+			     vdce_ctrl, SET_BMP_MODE);
+	}
+	/* setting bmp i/o mode */
+	if (params->src_processing_mode == VDCE_PROGRESSIVE) {
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITSET(vdce_conf_chan->register_config[num_pass].
+			   vdce_ctrl, SET_PRO_MODE);
+	} else {
+		/* atleat top field or bottom field should be configured for
+		   interlaced */
+		vdce_conf_chan->register_config[num_pass].vdce_ctrl =
+		    BITRESET(vdce_conf_chan->register_config[num_pass].
+			     vdce_ctrl, SET_PRO_MODE);
+	}
+	vdce_conf_chan->register_config[num_pass].vdce_req_sz =
+	    vdce_conf_chan->register_config[num_pass].
+	    vdce_req_sz & ~(VDCE_REQ_SZ_MASK);
+
+	vdce_conf_chan->register_config[num_pass].vdce_req_sz =
+	    (vdce_conf_chan->register_config[num_pass].vdce_req_sz |
+	     ((256) << VDCE_REQ_SZ_SHIFT));
+
+	if (params->prcs_unit_value == 0) {
+		prcs_nvalue =
+		    (params->src_hsz_luminance / (params->dst_hsz_luminance));
+		for (i = 4; i >= 0; i--) {
+			if ((prcs_array_value[i] * prcs_nvalue + 9) <= 256) {
+				break;
+			}
+		}
+		if (i < 0) {
+			i = 0;
+		}
+		prcs = prcs_array_value[i];
+	} else {
+		prcs = params->prcs_unit_value;
+	}
+	vdce_conf_chan->register_config[num_pass].vdce_prcs_unit_size =
+	    prcs & (VDCE_PRCS_UNIT_SIZE_MASK);
+
+	/* Configuration of luma size */
+	vdce_conf_chan->register_config[num_pass].src_Y_sz |=
+	    ((params->src_hsz_luminance << SRC_Y_HSZ_SHIFT) & (SRC_Y_HSZ_MASK));
+
+	if (params->src_processing_mode == VDCE_INTERLACED) {
+
+		vdce_conf_chan->register_config[num_pass].src_Y_sz |=
+		    ((params->
+		      src_vsz_luminance /
+		      2 << SRC_Y_VSZ_SHIFT) & (SRC_Y_VSZ_MASK));
+	} else {
+		vdce_conf_chan->register_config[num_pass].src_Y_sz |=
+		    ((params->
+		      src_vsz_luminance << SRC_Y_VSZ_SHIFT) & (SRC_Y_VSZ_MASK));
+	}
+
+	vdce_conf_chan->register_config[num_pass].res_Y_sz |=
+	    ((params->dst_hsz_luminance << RES_Y_HSZ_SHIFT) & (RES_Y_HSZ_MASK));
+
+	if (params->src_processing_mode == VDCE_INTERLACED) {
+		vdce_conf_chan->register_config[num_pass].res_Y_sz |=
+		    ((params->
+		      dst_vsz_luminance /
+		      2 << RES_Y_VSZ_SHIFT) & (RES_Y_VSZ_MASK));
+	} else {
+		vdce_conf_chan->register_config[num_pass].res_Y_sz |=
+		    ((params->
+		      dst_vsz_luminance << RES_Y_VSZ_SHIFT) & (RES_Y_VSZ_MASK));
+	}
+	/* Configuration of chroma size */
+	mode = ((vdce_conf_chan->register_config[num_pass].vdce_ctrl
+		 & VDCE_MODE_MASK) >> VDCE_MODE_SHIFT);
+
+	if ((vdce_conf_chan->mode_state == VDCE_OPERATION_PRE_CODECMODE) ||
+	    ((vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING) &&
+	     (mode == MODE_PRECODEC)) ||
+	    ((vdce_conf_chan->mode_state ==
+	      VDCE_OPERATION_CHROMINANCE_CONVERSION) &&
+	     (mode == MODE_PRECODEC)) || (mode == MODE_PRECODEC) ||
+	    (vdce_conf_chan->mode_state == VDCE_OPERATION_EDGE_PADDING)) {
+		src_image_type = VDCE_IMAGE_FMT_422;
+
+	} else {
+		src_image_type = VDCE_IMAGE_FMT_420;
+	}
+	/* mode is 420 so chroma value is reduced by 2 */
+	divider = (params->src_processing_mode == VDCE_INTERLACED) ? 4 : 2;
+	if (src_image_type == VDCE_IMAGE_FMT_420) {
+		divider = (params->
+			   src_processing_mode == VDCE_INTERLACED) ? 4 : 2;
+		vdce_conf_chan->register_config[num_pass].src_C_sz |=
+		    ((params->src_vsz_luminance / divider << SRC_C_VSZ_SHIFT)
+		     & (SRC_C_VSZ_MASK));
+	} else if (src_image_type == VDCE_IMAGE_FMT_422) {
+		divider = (params->
+			   src_processing_mode == VDCE_INTERLACED) ? 2 : 1;
+		vdce_conf_chan->register_config[num_pass].src_C_sz |=
+		    vdce_conf_chan->register_config[num_pass].src_C_sz |=
+		    ((params->src_vsz_luminance / divider << SRC_C_VSZ_SHIFT)
+		     & (SRC_C_VSZ_MASK));
+
+	} else {
+		return -EINVAL;
+	}
+
+	vdce_conf_chan->register_config[num_pass].src_C_sz |=
+	    ((params->src_hsz_luminance << SRC_C_HSZ_SHIFT) & (SRC_C_HSZ_MASK));
+
+	vdce_conf_chan->register_config[num_pass].res_C_sz |=
+	    ((params->dst_hsz_luminance << RES_C_HSZ_SHIFT) & (RES_C_HSZ_MASK));
+	if ((vdce_conf_chan->mode_state == VDCE_OPERATION_PRE_CODECMODE) ||
+	    (mode == MODE_TRANSCODEC) || (mode == MODE_PRECODEC)) {
+
+		divider = (params->
+			   src_processing_mode == VDCE_INTERLACED) ? 4 : 2;
+
+	} else {
+		divider = (params->
+			   src_processing_mode == VDCE_INTERLACED) ? 2 : 1;
+	}
+	vdce_conf_chan->register_config[num_pass].res_C_sz |=
+	    ((params->
+	      dst_vsz_luminance /
+	      divider << RES_C_VSZ_SHIFT) & (RES_C_VSZ_MASK));
+	/* Configuration of bitmap size */
+	divider = (params->src_processing_mode == VDCE_INTERLACED) ? 2 : 1;
+	vdce_conf_chan->register_config[num_pass].src_bmp_sz |=
+	    ((params->bmp_hsize << SRC_BMP_HSZ_SHIFT) & (SRC_BMP_HSZ_MASK));
+
+	vdce_conf_chan->register_config[num_pass].src_bmp_sz |=
+	    ((params->
+	      bmp_vsize / divider << SRC_BMP_VSZ_SHIFT) & (SRC_BMP_VSZ_MASK));
+
+	/* configuration for starting position */
+	vdce_conf_chan->register_config[num_pass].src_Y_strt_ps =
+	    params->src_hsp_luminance;
+	vdce_conf_chan->register_config[num_pass].src_C_strt_ps =
+	    params->src_hsp_luminance;
+	vdce_conf_chan->register_config[num_pass].res_Y_strt_ps =
+	    params->res_hsp_luminance;
+
+	vdce_conf_chan->register_config[num_pass].src_bmp_strt_ps |=
+	    ((params->bmp_hsp_bitmap) & (SRC_BMP_STRT_HPS_MASK));
+
+	vdce_conf_chan->register_config[num_pass].res_bmp_strt_ps |=
+	    ((params->res_hsp_bitmap) & (SRC_BMP_HSZ_MASK));
+
+	vdce_conf_chan->register_config[num_pass].res_bmp_strt_ps |=
+	    ((params->res_vsp_bitmap << RES_BMP_STRT_VPS_SHIFT)
+	     & (RES_BMP_STRT_VPS_MASK));
+	/* hardcoding the image format as raster scanning */
+	vdce_conf_chan->register_config[num_pass].vdce_sdr_fmt =
+	    VDCE_RASTER_SCANNING;
+
+	dev_dbg(vdce_device, "<fn>vdce_set_size_fmt	L\n</fn>");
+	return ret;
+}
+
+/*
+ * vdce_set_rmapparams : Setting range mapping parameters.
+ */
+int vdce_set_rmapparams(vdce_rmap_params_t * params,
+			channel_config_t * vdce_conf_chan, int index)
+{
+	int ret = 0;
+	dev_dbg(vdce_device, "<fn>vdce_set_rmmaparams E\n</fn>");
+	dev_dbg(vdce_device, "The	value s	%d\n", params->coeff_y);
+	if (params->rmap_yenable == VDCE_FEATURE_ENABLE) {
+		vdce_conf_chan->register_config[index].rgmp_ctrl =
+		    BITSET(vdce_conf_chan->register_config[index].
+			   rgmp_ctrl, SET_RMAP_YENABLE);
+
+		dev_dbg(vdce_device, "Entering and setting value \n");
+		vdce_conf_chan->register_config[index].rgmp_ctrl |=
+		    ((params->coeff_y) << RANGE_MAP_Y_SHIFT) & RANGE_MAP_Y_MASK;
+
+	} else {
+		vdce_conf_chan->register_config[index].rgmp_ctrl =
+		    BITRESET(vdce_conf_chan->register_config[index].
+			     rgmp_ctrl, SET_RMAP_YENABLE);
+	}
+	if (params->rmap_cenable == VDCE_FEATURE_ENABLE) {
+		vdce_conf_chan->register_config[index].rgmp_ctrl =
+		    BITSET(vdce_conf_chan->register_config[index].
+			   rgmp_ctrl, SET_RMAP_CENABLE);
+
+		vdce_conf_chan->register_config[index].rgmp_ctrl |=
+		    ((params->
+		      coeff_c) << (RANGE_MAP_C_SHIFT)) & RANGE_MAP_C_MASK;
+	} else {
+		vdce_conf_chan->register_config[index].rgmp_ctrl =
+		    BITRESET(vdce_conf_chan->register_config[index].
+			     rgmp_ctrl, SET_RMAP_CENABLE);
+	}
+	vdce_conf_chan->register_config[index].vdce_ctrl =
+	    BITSET(vdce_conf_chan->register_config[index].vdce_ctrl,
+		   SET_RMAP_ENABLE);
+	dev_dbg(vdce_device, "<fn>vdce_set_rmapparams L\n</fn>");
+	return ret;
+}
+
+/*
+ * vdce_set_rszparams : Setting resizing parameters .
+ */
+int vdce_set_rszparams(vdce_params_t * params,
+		       channel_config_t * vdce_conf_chan,
+		       vdce_mode_operation_t mode, int index)
+{
+	int ret = 0;
+	vdce_rsz_params_t rsz_params;
+	int hrsz_mag, vrsz_mag;
+	if (mode == VDCE_OPERATION_PRE_CODECMODE) {
+		rsz_params =
+		    (params->vdce_mode_params.precodec_params.rsz_params);
+	} else if (mode == VDCE_OPERATION_POST_CODECMODE) {
+		rsz_params =
+		    (params->vdce_mode_params.postcodec_params.rsz_params);
+	} else if (mode == VDCE_OPERATION_TRANS_CODECMODE) {
+		rsz_params =
+		    (params->vdce_mode_params.transcodec_params.rsz_params);
+	} else if (mode == VDCE_OPERATION_RESIZING) {
+		rsz_params = (params->vdce_mode_params.rsz_params);
+	} else
+		return -EINVAL;
+
+	dev_dbg(vdce_device, "<fn>vdce_set_rszparams E\n</fn>");
+	/* setting input horizontal alf enable */
+	if (rsz_params.hrsz_alf_enable == VDCE_FEATURE_ENABLE) {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
+			   SET_HRSZ_ALF_ENABLE);
+	} else {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITRESET(vdce_conf_chan->register_config[index].
+			     rsz_mode, SET_HRSZ_ALF_ENABLE);
+	}
+	/* setting input vertical alf format */
+	if (rsz_params.vrsz_alf_enable == VDCE_FEATURE_ENABLE) {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
+			   SET_VRSZ_ALF_ENABLE);
+	} else {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITRESET(vdce_conf_chan->register_config[index].
+			     rsz_mode, SET_VRSZ_ALF_ENABLE);
+	}
+	/* setting H type */
+	if (rsz_params.vrsz_mode == VDCE_ALGO_TAP_4LINEAR_INTERPOLATION) {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
+			   SET_RSZ_V_TYPE);
+	} else {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITRESET(vdce_conf_chan->register_config[index].
+			     rsz_mode, SET_RSZ_V_TYPE);
+	}
+	/* setting V type */
+	if (rsz_params.hrsz_mode == VDCE_ALGO_TAP_4LINEAR_INTERPOLATION) {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
+			   SET_RSZ_H_TYPE);
+	} else {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITRESET(vdce_conf_chan->register_config[index].
+			     rsz_mode, SET_RSZ_H_TYPE);
+	}
+	/* setting V type */
+	if (rsz_params.hrsz_alf_mode == VDCE_ALFMODE_MANUAL) {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
+			   SET_RSZ_H_ALF_mode);
+	} else {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITRESET(vdce_conf_chan->register_config[index].
+			     rsz_mode, SET_RSZ_H_ALF_mode);
+	}
+	/* setting intensity of resizer */
+	if ((rsz_params.hrsz_alf_mode == VDCE_ALFMODE_MANUAL)
+	    && (rsz_params.hrsz_alf_enable == VDCE_FEATURE_ENABLE)) {
+		if (rsz_params.hrsz_alf_intensity > MAX_RSZ_INTENSITY) {
+			rsz_params.hrsz_alf_intensity = MAX_RSZ_INTENSITY;
+		} else {
+			vdce_conf_chan->register_config[index].
+			    rsz_alf_intensity |=
+			    (((rsz_params.
+			       hrsz_alf_intensity) << RSZ_ALF_INTENSITY_SHIFT)
+			     & RSZ_ALF_INTENSITY_MASK);
+		}
+	} else {
+		vdce_conf_chan->register_config[index].rsz_alf_intensity = 0;
+	}
+	/* if resizer used check for the params */
+	hrsz_mag =
+	    (params->common_params.src_hsz_luminance *
+	     256) / (params->common_params.dst_hsz_luminance);
+	vdce_conf_chan->register_config[index].rsz_h_mag |=
+	    (((hrsz_mag) << RSZ_H_MAG_SHIFT) & (RSZ_H_MAG_MASK));
+	vrsz_mag =
+	    (params->common_params.src_vsz_luminance *
+	     256) / (params->common_params.dst_vsz_luminance);
+	vdce_conf_chan->register_config[index].rsz_v_mag |=
+	    (((vrsz_mag) << RSZ_V_MAG_SHIFT)) & (RSZ_V_MAG_MASK);
+
+	/* setting horizontal enable bit */
+	if (hrsz_mag >= 256) {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
+			   SET_HRSZ_ENABLE);
+	} else {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITRESET(vdce_conf_chan->register_config[index].
+			     rsz_mode, SET_HRSZ_ENABLE);
+	}
+	/* setting vertical enable bit */
+	if (vrsz_mag >= 256) {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITSET(vdce_conf_chan->register_config[index].rsz_mode,
+			   SET_VRSZ_ENABLE);
+	} else {
+		vdce_conf_chan->register_config[index].rsz_mode =
+		    BITRESET(vdce_conf_chan->register_config[index].
+			     rsz_mode, SET_VRSZ_ENABLE);
+	}
+	vdce_conf_chan->register_config[index].vdce_ctrl =
+	    BITSET(vdce_conf_chan->register_config[index].vdce_ctrl,
+		   SET_RSZ_ENABLE);
+	dev_dbg(vdce_device, "<fn>vdce_set_rszparams L\n</fn>");
+	return ret;
+}
+
+/*
+ * vdce_set_epadparams : Setting EPAD parameters.
+ */
+int vdce_set_epadparams(vdce_epad_params_t * params,
+			channel_config_t * vdce_conf_chan, int index)
+{
+	int ret = 0;
+	dev_dbg(vdce_device, "<fn>vdce_set_epadparams E \n</fn>");
+	/* configuring luma vertical extension value */
+	vdce_conf_chan->register_config[index].epd_luma_width |=
+	    (((params->vext_luma) << EPD_Y_VEXT_SHIFT) & EPD_Y_VEXT_MASK);
+
+	/* configuring luma horizontal extension value */
+	vdce_conf_chan->register_config[index].epd_luma_width |=
+	    ((params->hext_luma) << (EPD_Y_HEXT_SHIFT)) & (EPD_Y_HEXT_MASK);
+
+	/* configuring chroma vertical extension value */
+	vdce_conf_chan->register_config[index].epd_chroma_width |=
+	    ((params->vext_chroma) << (EPD_C_VEXT_SHIFT)) & EPD_C_VEXT_MASK;
+
+	/* configuring chroma horizontal extension value */
+	vdce_conf_chan->register_config[index].epd_chroma_width |=
+	    (((params->hext_chroma) << EPD_C_HEXT_SHIFT) & EPD_C_HEXT_MASK);
+	dev_dbg(vdce_device, "<fn>vdce_set_epadparams L\n</fn>");
+	return ret;
+}
+
+/*
+ * vdce_set_ccvparams : Setting CCV parameters.
+ */
+int vdce_set_ccvparams(vdce_ccv_params_t * params,
+		       channel_config_t * vdce_conf_chan, int mode, int index)
+{
+	int ret = 0;
+	dev_dbg(vdce_device, "<fn>vdce_set_ccvparams E\n</fn>");
+	/* setting output format */
+	if (mode == MODE_PRECODEC || mode == MODE_TRANSCODEC) {
+		if (params->codec_mode_out == VDCE_CODECMODE_MPEG1) {
+			vdce_conf_chan->register_config[index].ccv_mode =
+			    BITSET(vdce_conf_chan->register_config[index].
+				   ccv_mode, SET_CCV_OUT_MPEG1);
+
+			vdce_conf_chan->register_config[index].vdce_ctrl =
+			    BITSET(vdce_conf_chan->register_config[index].
+				   vdce_ctrl, SET_CCV_ENABLE);
+
+		} else {
+			vdce_conf_chan->register_config[index].ccv_mode =
+			    BITRESET(vdce_conf_chan->
+				     register_config[index].ccv_mode,
+				     SET_CCV_OUT_MPEG1);
+		}
+	}
+	if (mode == MODE_POSTCODEC || mode == MODE_TRANSCODEC) {
+		/* setting input format */
+		if (params->codec_mode_in == VDCE_CODECMODE_MPEG1) {
+			vdce_conf_chan->register_config[index].ccv_mode =
+			    BITSET(vdce_conf_chan->register_config[index].
+				   ccv_mode, SET_CCV_IN_MPEG1);
+			vdce_conf_chan->register_config[index].vdce_ctrl =
+			    BITSET(vdce_conf_chan->register_config[index].
+				   vdce_ctrl, SET_CCV_ENABLE);
+		} else {
+			vdce_conf_chan->register_config[index].ccv_mode =
+			    BITRESET(vdce_conf_chan->
+				     register_config[index].ccv_mode,
+				     SET_CCV_IN_MPEG1);
+		}
+	}
+	/* setting H type */
+	if (params->hccv_type == VDCE_ALGO_TAP_4LINEAR_INTERPOLATION) {
+		vdce_conf_chan->register_config[index].ccv_mode =
+		    BITSET(vdce_conf_chan->register_config[index].ccv_mode,
+			   SET_CCV_H_TYPE);
+	} else {
+		vdce_conf_chan->register_config[index].ccv_mode =
+		    BITRESET(vdce_conf_chan->register_config[index].
+			     ccv_mode, SET_CCV_H_TYPE);
+	}
+	/* setting V type */
+	if (params->vccv_type == VDCE_ALGO_TAP_4LINEAR_INTERPOLATION) {
+		vdce_conf_chan->register_config[index].ccv_mode =
+		    BITSET(vdce_conf_chan->register_config[index].ccv_mode,
+			   SET_CCV_V_TYPE);
+	} else {
+		vdce_conf_chan->register_config[index].ccv_mode =
+		    BITRESET(vdce_conf_chan->register_config[index].
+			     ccv_mode, SET_CCV_V_TYPE);
+	}
+	vdce_conf_chan->register_config[index].vdce_ctrl |=
+	    ((mode << VDCE_MODE_SHIFT) & (VDCE_MODE_MASK));
+	dev_dbg(vdce_device, "<fn>vdce_get_ccvparams L\n</fn>");
+	return ret;
+}
+
+/*
+ * vdce_set_blendparams : Setting blending parameters.
+ */
+int vdce_set_blendparams(vdce_blend_params_t * params,
+			 channel_config_t * vdce_conf_chan, int mode, int index)
+{
+	int i = 0;
+	int ret = 0;
+	dev_dbg(vdce_device, "<fn>vdce_set_blendparams E\n</fn>");
+	for (i = 0; i < MAX_BLEND_TABLE; i++) {
+		/* configuring blend factor for zero blend value parameters */
+		vdce_conf_chan->register_config[index].bld_lut[i] |=
+		    ((params->bld_lut[i].
+		      blend_value) << BLD_LUT_FCT_SHIFT) & (BLD_LUT_FCT_MASK);
+
+		/* configuring Cr value for zero blend value parameters */
+		vdce_conf_chan->register_config[index].bld_lut[i] |=
+		    ((params->bld_lut[i].blend_cr) << BLD_LUT_CR_SHIFT) &
+		    (BLD_LUT_CR_MASK);
+
+		/* configuring cb value for zero blend value parameters */
+		vdce_conf_chan->register_config[index].bld_lut[i] |=
+		    ((params->bld_lut[i].blend_cb) << BLD_LUT_CB_SHIFT) &
+		    (BLD_LUT_CB_MASK);
+		/* configuring Y value for zero blend value parameters */
+		vdce_conf_chan->register_config[index].bld_lut[i] |=
+		    ((params->bld_lut[i].blend_y) << BLD_LUT_Y_SHIFT) &
+		    BLD_LUT_Y_MASK;
+	}
+	vdce_conf_chan->register_config[index].vdce_ctrl =
+	    BITSET(vdce_conf_chan->register_config[index].vdce_ctrl,
+		   SET_BLEND_ENABLE);
+	dev_dbg(vdce_device, "<fn>vdce_set_blendparams E\n</fn>");
+	return ret;
+}
+
+/*
+ * vdce_set_params : Function to set the ge parameters
+ */
+int vdce_set_params(vdce_params_t * params, channel_config_t * vdce_conf_chan)
+{
+	int ret = 0;
+	int pass_num = 0;
+	int mode;
+	vdce_ccv_params_t ccv_params;
+	dev_dbg(vdce_device, "<fn> vdce_set_params E\n</fn>");
+
+	memset(&(vdce_conf_chan->register_config[0]), 0,
+	       sizeof(vdce_hw_config_t));
+	memset(&(vdce_conf_chan->register_config[1]), 0,
+	       sizeof(vdce_hw_config_t));
+
+	vdce_conf_chan->status = VDCE_CHAN_UNINITIALISED;
+	vdce_conf_chan->mode_state = params->vdce_mode;
+	vdce_conf_chan->num_pass = VDCE_SINGLE_PASS;
+	/* configuration of Pre-codec mode */
+	if (params->vdce_mode == VDCE_OPERATION_PRE_CODECMODE) {
+		if (((params->modes_control & RSZ_ENABLE_MASK) ==
+		     (RSZ_ENABLE_MASK))) {
+			ret = vdce_set_rszparams(params, vdce_conf_chan,
+						 VDCE_OPERATION_PRE_CODECMODE,
+						 pass_num);
+		}
+		ret = vdce_set_ccvparams(&(params->vdce_mode_params.
+					   precodec_params.ccv_params),
+					 vdce_conf_chan, MODE_PRECODEC,
+					 pass_num);
+
+		vdce_conf_chan->register_config[pass_num].vdce_ctrl |=
+		    ((MODE_PRECODEC << VDCE_MODE_SHIFT) & (VDCE_MODE_MASK));
+
+	} else if (params->vdce_mode == VDCE_OPERATION_POST_CODECMODE) {
+		/* configuration of Post-codec mode */
+		/* setting resizing params and enabling it */
+		if (((params->modes_control & RSZ_ENABLE_MASK) ==
+		     (RSZ_ENABLE_MASK))) {
+			ret = vdce_set_rszparams(params, vdce_conf_chan,
+						 VDCE_OPERATION_POST_CODECMODE,
+						 pass_num);
+			if (params->vdce_mode_params.postcodec_params.
+			    ccv_params.codec_mode_in == VDCE_CODECMODE_MPEG1) {
+				vdce_conf_chan->luma_chroma_phased = 1;
+			}
+		}
+		ret =
+		    vdce_set_ccvparams(&
+				       (params->vdce_mode_params.
+					postcodec_params.ccv_params),
+				       vdce_conf_chan, MODE_POSTCODEC,
+				       pass_num);
+		/* setting range-mapping params and enabling it */
+		if (((params->modes_control & RMAP_ENABLE_MASK) ==
+		     (RMAP_ENABLE_MASK))) {
+			ret =
+			    vdce_set_rmapparams(&
+						(params->vdce_mode_params.
+						 postcodec_params.
+						 rmap_params),
+						vdce_conf_chan, pass_num);
+		}
+		/* setting blending params and enabling it */
+		if (((params->modes_control & BLEND_ENABLE_MASK) ==
+		     (BLEND_ENABLE_MASK))) {
+			ret =
+			    vdce_set_blendparams(&
+						 (params->vdce_mode_params.
+						  postcodec_params.
+						  blend_params),
+						 vdce_conf_chan,
+						 VDCE_OPERATION_POST_CODECMODE,
+						 pass_num);
+		}
+		vdce_conf_chan->register_config[pass_num].vdce_ctrl |=
+		    ((MODE_POSTCODEC << VDCE_MODE_SHIFT) & (VDCE_MODE_MASK));
+
+	} else if (params->vdce_mode == VDCE_OPERATION_TRANS_CODECMODE) {
+		/* Configuration of Trans-codec mode */
+		/* setting resizing params and enabling it */
+		if (((params->modes_control & RSZ_ENABLE_MASK) ==
+		     (RSZ_ENABLE_MASK))) {
+			ret = vdce_set_rszparams(params, vdce_conf_chan,
+						 VDCE_OPERATION_TRANS_CODECMODE,
+						 pass_num);
+			if (params->vdce_mode_params.transcodec_params.
+			    ccv_params.codec_mode_in == VDCE_CODECMODE_MPEG1) {
+				vdce_conf_chan->luma_chroma_phased = 1;
+			}
+		}
+		/* setting range-mapping params and enabling it */
+		if (((params->modes_control & RMAP_ENABLE_MASK) ==
+		     (RMAP_ENABLE_MASK))) {
+			ret =
+			    vdce_set_rmapparams(&
+						(params->vdce_mode_params.
+						 transcodec_params.
+						 rmap_params),
+						vdce_conf_chan, pass_num);
+		}
+		/* setting blend params and enabling it */
+		if (((params->modes_control & BLEND_ENABLE_MASK) ==
+		     (BLEND_ENABLE_MASK))) {
+			ret =
+			    vdce_set_blendparams(&
+						 (params->vdce_mode_params.
+						  transcodec_params.
+						  blend_params),
+						 vdce_conf_chan,
+						 VDCE_OPERATION_TRANS_CODECMODE,
+						 pass_num);
+		}
+		/* setting ccv params and enabling it */
+		if (((params->modes_control & CCV_ENABLE_MASK) ==
+		     (CCV_ENABLE_MASK))) {
+			ret =
+			    vdce_set_ccvparams(&
+					       (params->vdce_mode_params.
+						transcodec_params.
+						ccv_params),
+					       vdce_conf_chan,
+					       MODE_TRANSCODEC, pass_num);
+		}
+		vdce_conf_chan->register_config[pass_num].vdce_ctrl |=
+		    ((MODE_TRANSCODEC << VDCE_MODE_SHIFT) & (VDCE_MODE_MASK));
+
+	} else if (params->vdce_mode == VDCE_OPERATION_EDGE_PADDING) {
+		/* configuration of Edge-padding mode */
+		ret = vdce_set_epadparams(&(params->vdce_mode_params.
+					    epad_params)
+					  , vdce_conf_chan, pass_num);
+		vdce_conf_chan->register_config[pass_num].vdce_ctrl |=
+		    ((MODE_EPAD << VDCE_MODE_SHIFT) & (VDCE_MODE_MASK));
+	} else if (params->vdce_mode == VDCE_OPERATION_RESIZING) {
+		/* Configuration of Resizing mode */
+		if (params->vdce_mode_params.rsz_params.rsz_mode ==
+		    VDCE_MODE_422) {
+			memset(&ccv_params, 0, sizeof(vdce_ccv_params_t));
+			vdce_conf_chan->num_pass = VDCE_MULTIPASS;
+			/* set mode as pre-codec */
+			vdce_conf_chan->register_config[pass_num].
+			    vdce_ctrl |=
+			    ((MODE_PRECODEC << VDCE_MODE_SHIFT) &
+			     (VDCE_MODE_MASK));
+			ret =
+			    vdce_set_ccvparams(&ccv_params, vdce_conf_chan,
+					       MODE_PRECODEC, pass_num);
+			ret =
+			    vdce_set_rszparams(params, vdce_conf_chan,
+					       VDCE_OPERATION_RESIZING,
+					       pass_num);
+			pass_num = 1;
+			ret =
+			    vdce_set_ccvparams(&ccv_params, vdce_conf_chan,
+					       MODE_POSTCODEC, pass_num);
+
+			vdce_conf_chan->register_config[pass_num].
+			    vdce_ctrl |=
+			    ((MODE_POSTCODEC << VDCE_MODE_SHIFT) &
+			     (VDCE_MODE_MASK));
+		} else {
+			vdce_conf_chan->register_config[pass_num].
+			    vdce_ctrl |=
+			    ((MODE_TRANSCODEC << VDCE_MODE_SHIFT) &
+			     (VDCE_MODE_MASK));
+			ret = vdce_set_rszparams(params, vdce_conf_chan,
+						 VDCE_OPERATION_RESIZING,
+						 pass_num);
+			if (params->vdce_mode_params.rsz_params.
+			    rsz_op_mode == VDCE_CODECMODE_MPEG1) {
+				vdce_conf_chan->luma_chroma_phased = 1;
+			}
+		}
+	} else if (params->vdce_mode == VDCE_OPERATION_CHROMINANCE_CONVERSION) {
+		/* Configuration of CCV mode */
+		if (params->vdce_mode_params.ccv_params.conversion_type ==
+		    VDCE_CCV_MODE_420_422) {
+			ret =
+			    vdce_set_ccvparams(&
+					       (params->vdce_mode_params.
+						ccv_params),
+					       vdce_conf_chan,
+					       MODE_POSTCODEC, pass_num);
+		} else if (params->vdce_mode_params.ccv_params.
+			   conversion_type == VDCE_CCV_MODE_422_420) {
+			ret =
+			    vdce_set_ccvparams(&
+					       (params->vdce_mode_params.
+						ccv_params),
+					       vdce_conf_chan,
+					       MODE_PRECODEC, pass_num);
+		} else {
+			ret =
+			    vdce_set_ccvparams(&
+					       (params->vdce_mode_params.
+						ccv_params),
+					       vdce_conf_chan,
+					       MODE_TRANSCODEC, pass_num);
+		}
+	} else if (params->vdce_mode == VDCE_OPERATION_RANGE_MAPPING) {
+		/* Configuration of Range-mapping */
+		ret = vdce_set_rmapparams(&(params->vdce_mode_params.
+					    rmap_params), vdce_conf_chan,
+					  pass_num);
+		vdce_conf_chan->register_config[pass_num].vdce_ctrl |=
+		    ((MODE_TRANSCODEC << VDCE_MODE_SHIFT) & (VDCE_MODE_MASK));
+	} else if (params->vdce_mode == VDCE_OPERATION_BLENDING) {
+		/* Configuration of Blending mode */
+		if (params->vdce_mode_params.blend_params.blend_mode ==
+		    VDCE_MODE_422) {
+			memset(&ccv_params, 0, sizeof(vdce_ccv_params_t));
+			/* set mode as pre-codec */
+			vdce_conf_chan->num_pass = VDCE_MULTIPASS;
+			ret =
+			    vdce_set_ccvparams(&ccv_params, vdce_conf_chan,
+					       MODE_PRECODEC, pass_num);
+			vdce_conf_chan->register_config[pass_num].
+			    vdce_ctrl |=
+			    ((MODE_PRECODEC << VDCE_MODE_SHIFT) &
+			     (VDCE_MODE_MASK));
+			pass_num = 1;
+			ret =
+			    vdce_set_blendparams(&
+						 (params->vdce_mode_params.
+						  blend_params),
+						 vdce_conf_chan,
+						 MODE_POSTCODEC, 1);
+			ret =
+			    vdce_set_ccvparams(&ccv_params, vdce_conf_chan,
+					       MODE_POSTCODEC, pass_num);
+
+			vdce_conf_chan->register_config[pass_num].
+			    vdce_ctrl |=
+			    ((MODE_POSTCODEC << VDCE_MODE_SHIFT) &
+			     (VDCE_MODE_MASK));
+		} else {
+			vdce_conf_chan->register_config[pass_num].
+			    vdce_ctrl |=
+			    ((MODE_TRANSCODEC << VDCE_MODE_SHIFT) &
+			     (VDCE_MODE_MASK));
+
+			ret =
+			    vdce_set_blendparams(&
+						 (params->vdce_mode_params.
+						  blend_params),
+						 vdce_conf_chan,
+						 MODE_TRANSCODEC, 0);
+		}
+	} else {
+		/* error */
+		dev_err(vdce_device, "\n mode not supported ");
+		ret = -EINVAL;
+	}
+	if (pass_num == 0) {
+		vdce_set_size_fmt(&(params->common_params), vdce_conf_chan, 0);
+	} else {
+		vdce_set_size_fmt(&(params->common_params), vdce_conf_chan, 0);
+		vdce_set_size_fmt(&(params->common_params), vdce_conf_chan, 1);
+	}
+	mode = ((vdce_conf_chan->register_config[0].vdce_ctrl
+		 & VDCE_MODE_MASK) >> VDCE_MODE_SHIFT);
+
+	if ((vdce_conf_chan->mode_state == VDCE_OPERATION_PRE_CODECMODE) ||
+	    ((vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING) &&
+	     (vdce_conf_chan->num_pass == VDCE_MULTIPASS)) ||
+	    ((vdce_conf_chan->
+	      mode_state == VDCE_OPERATION_CHROMINANCE_CONVERSION) &&
+	     (vdce_conf_chan->num_pass == VDCE_MULTIPASS)) ||
+	    (mode == MODE_PRECODEC) ||
+	    (vdce_conf_chan->mode_state == VDCE_OPERATION_EDGE_PADDING)) {
+		vdce_conf_chan->image_type_in = VDCE_IMAGE_FMT_422;
+	} else {
+		vdce_conf_chan->image_type_in = VDCE_IMAGE_FMT_420;
+	}
+	if ((vdce_conf_chan->mode_state == VDCE_OPERATION_POST_CODECMODE)
+	    || ((vdce_conf_chan->mode_state == VDCE_OPERATION_RESIZING)
+		&& (vdce_conf_chan->num_pass == VDCE_MULTIPASS))
+	    ||
+	    ((vdce_conf_chan->mode_state ==
+	      VDCE_OPERATION_CHROMINANCE_CONVERSION)
+	     && (vdce_conf_chan->num_pass == VDCE_MULTIPASS))
+	    ||
+	    ((vdce_conf_chan->mode_state == VDCE_OPERATION_BLENDING
+	      && vdce_conf_chan->num_pass == VDCE_MULTIPASS)
+	     || mode == MODE_POSTCODEC)
+	    || (vdce_conf_chan->mode_state == VDCE_OPERATION_EDGE_PADDING)) {
+		vdce_conf_chan->image_type_out = VDCE_IMAGE_FMT_422;
+
+	} else {
+		vdce_conf_chan->image_type_out = VDCE_IMAGE_FMT_420;
+	}
+	if (vdce_conf_chan->luma_chroma_phased == 1) {
+		if (params->common_params.proc_control ==
+		    VDCE_LUMA_CHROMA_ENABLE) {
+			vdce_conf_chan->luma_chroma_phased = 1;
+			vdce_conf_chan->num_pass = VDCE_MULTIPASS;
+		} else {
+			vdce_conf_chan->luma_chroma_phased = 0;
+			vdce_conf_chan->num_pass = VDCE_SINGLE_PASS;
+		}
+
+	}
+	if (ret == 0) {
+		dev_dbg(vdce_device, "VDCE State configured \n");
+		memcpy(&vdce_conf_chan->get_params, params,
+		       sizeof(vdce_params_t));
+		vdce_conf_chan->status = VDCE_CHAN_PARAMS_INITIALISED;
+	}
+	dev_dbg(vdce_device, "<fn> vdce_set_params L\n</fn>");
+	return ret;
+}
+
+/*
+ * vdce_get_Params : Function to get the parameters values
+ */
+int vdce_get_params(vdce_params_t * params, channel_config_t * vdce_conf_chan)
+{
+	if (vdce_conf_chan->status == VDCE_CHAN_UNINITIALISED) {
+		dev_err(vdce_device, "State not configured \n");
+		return -EINVAL;
+	}
+	memcpy(params, &vdce_conf_chan->get_params, sizeof(vdce_params_t));
+	return 0;
+}
+
+/*
+ * vdce_set_priority : This function sets a priority of hardware and channel.
+ */
+int vdce_set_priority(int priority, channel_config_t * vdce_conf_chan)
+{
+	dev_dbg(vdce_device, "<fn> vdce_set_priority E\n</fn>");
+	/* check the prioroty range and assign the priority */
+	if (priority > VDCE_MAX_PRIORITY || priority < VDCE_MIN_PRIORITY) {
+		return -EINVAL;
+	} else {
+		vdce_conf_chan->priority = priority;
+		dev_dbg(vdce_device, "the channel prioroty is %d", priority);
+	}
+	dev_dbg(vdce_device, "<fn> vdce_set_priority L\n</fn>");
+	return 0;
+}
+
+/*
+ * vdce_get_priority : This function gets a priority of hardware and channel.
+ */
+int vdce_get_priority(int *priority, channel_config_t * vdce_conf_chan)
+{
+	dev_dbg(vdce_device, "<fn> vdce_Get_priority E\n</fn>");
+	/* get the priority from the channel */
+	*priority = vdce_conf_chan->priority;
+	dev_dbg(vdce_device, "the	value is %d", *priority);
+	dev_dbg(vdce_device, "<fn> vdce_Get_priority L\n</fn>");
+	return 0;
+}
+
+/*
+ * vdce_get_status : This function gets a status of hardware and channel.
+ */
+int vdce_get_status(vdce_hw_status_t * hw_status,
+		    channel_config_t * vdce_conf_chan)
+{
+	dev_dbg(vdce_device, "<fn> vdce_Get_status E\n</fn>");
+	hw_status->chan_status = vdce_conf_chan->status;
+	dev_dbg(vdce_device, "<fn>vdce_Get_status E\n</fn>");
+	return 0;
+}
+
+/*
+ * vdce_get_status : This function used to get default params
+*/
+int vdce_get_default(vdce_params_t * def_params)
+{
+	vdce_params_t *vdce_temp_params = NULL;
+	if (def_params->vdce_mode == VDCE_OPERATION_PRE_CODECMODE) {
+		vdce_temp_params = &precodec_default_params;
+	} else if (def_params->vdce_mode == VDCE_OPERATION_POST_CODECMODE) {
+		vdce_temp_params = &postcodec_default_params;
+	} else if (def_params->vdce_mode == VDCE_OPERATION_TRANS_CODECMODE) {
+		vdce_temp_params = &transcodec_default_params;
+	} else if (def_params->vdce_mode == VDCE_OPERATION_EDGE_PADDING) {
+		vdce_temp_params = &epad_default_params;
+	} else if (def_params->vdce_mode == VDCE_OPERATION_RESIZING) {
+		vdce_temp_params = &rsz_default_params;
+	} else if (def_params->vdce_mode == VDCE_OPERATION_BLENDING) {
+		vdce_temp_params = &blend_default_params;
+	} else if (def_params->vdce_mode == VDCE_OPERATION_RANGE_MAPPING) {
+		vdce_temp_params = &rmap_default_params;
+	} else if (def_params->
+		   vdce_mode == VDCE_OPERATION_CHROMINANCE_CONVERSION) {
+		vdce_temp_params = &ccv_default_params;
+	}
+	memcpy(def_params, vdce_temp_params, sizeof(vdce_params_t));
+	return 0;
+
+}
+
+/*
+ * vdce_open : This function creates a channels.
+ */
+static int vdce_open(struct inode *inode, struct file *filp)
+{
+	channel_config_t *vdce_conf_chan;
+
+	dev_dbg(vdce_device, "<fn> vdce_open E\n</fn>");
+	/* if usage counter is greater than maximum supported channels
+	   return error */
+	if (device_config.module_usage_count >= MAX_CHANNELS) {
+		dev_err(vdce_device,
+			"\n modules usage count	is greater than	supported ");
+		return -EBUSY;
+	}
+	if (device_config.module_usage_count == 0) {
+		device_config.sem_isr.done = 0;
+	}
+	/* allocate memory for a new configuration */
+	vdce_conf_chan = kmalloc(sizeof(channel_config_t), GFP_KERNEL);
+
+	if (vdce_conf_chan == NULL) {
+		dev_err(vdce_device,
+			"\n cannot allocate memory ro channel config");
+		return -ENOMEM;
+	}
+	dev_dbg(vdce_device,
+		"Malloc	Done for channel configuration structure\n");
+	if (filp->f_flags == (O_NONBLOCK | O_RDWR)) {
+		vdce_conf_chan->channel_mode = VDCE_MODE_NON_BLOCKING;
+	}
+	/* zeroing register config */
+	memset(vdce_conf_chan, 0, sizeof(channel_config_t));
+	if (filp->f_flags == (O_NONBLOCK | O_RDWR)) {
+		vdce_conf_chan->channel_mode = VDCE_MODE_NON_BLOCKING;
+	}
+
+	/* increment usage counter */
+	/* Lock the global variable and increment the counter */
+	down_interruptible(&device_config.device_mutex);
+	device_config.module_usage_count++;
+	up(&device_config.device_mutex);
+
+	/*sTATE_NOT_CONFIGURED and priority to zero */
+	vdce_conf_chan->priority = 0;
+	vdce_conf_chan->mode_state = VDCE_CHAN_UNINITIALISED;
+
+	dev_dbg(vdce_device, "Initializing of channel done \n");
+
+	/* initializing of application mutex */
+	init_completion(&(vdce_conf_chan->channel_sem));
+	vdce_conf_chan->channel_sem.done = 0;
+
+	init_MUTEX(&(vdce_conf_chan->chan_protection));
+	/* taking the configuartion     structure in private data */
+	filp->private_data = vdce_conf_chan;
+
+	dev_dbg(vdce_device, "<fn> vdce_open L\n</fn>");
+
+	return 0;
+}
+
+/*
+ * vdce_release : The Function is used to release the number of
+ * resources occupied by the channel
+*/
+static int vdce_release(struct inode *inode, struct file *filp)
+{
+
+	/* get the configuratin of this channel from private_date member of
+	   file */
+	int ret = 0;
+	channel_config_t *vdce_conf_chan =
+	    (channel_config_t *) filp->private_data;
+
+	dev_dbg(vdce_device, "<fn> vdce_release E\n</fn>");
+
+	ret = down_trylock(&(vdce_conf_chan->chan_protection));
+	if (ret != 0) {
+
+		dev_dbg(vdce_device, "Channel in use %d", ret);
+		return -EBUSY;
+	}
+	vdce_clear_status();
+	/* it will free all the input and output buffers */
+	free_buff(vdce_conf_chan);
+	/* decrements the module usage count; */
+	/* lock the global variable and decrement variable */
+	down_interruptible(&device_config.device_mutex);
+	device_config.module_usage_count--;
+	up(&device_config.device_mutex);
+	up(&(vdce_conf_chan->chan_protection));
+	kfree(vdce_conf_chan);
+	dev_dbg(vdce_device, "<fn> vdce_release L\n</fn>");
+
+	return 0;
+}
+
+/*
+ * vdce_mmap : Function to map device memory into user space
+ */
+static int vdce_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	/* get the configuratin of this channel from private_date
+	   member of file */
+	/* for looping purpuse */
+	int buffercounter = 0;
+	int i;
+	/* for checking purpose */
+	int flag = 0;
+	/* hold number of input and output buffer allocated */
+	int buffer_offset = 0;
+	unsigned int offset = vma->vm_pgoff << PAGE_SHIFT;
+
+	channel_config_t *vdce_conf_chan =
+	    (channel_config_t *) filp->private_data;
+
+	dev_dbg(vdce_device, "<fn> vdce_mmap E\n</fn>");
+
+	for (i = 0; i < 3; i++) {
+		/*find the input address which  is to be mapped */
+		for (buffercounter = 0; buffercounter <
+		     vdce_conf_chan->vdce_buffer[i].num_allocated;
+		     buffercounter++) {
+			buffer_offset =
+			    virt_to_phys(vdce_conf_chan->vdce_buffer[i].
+					 buffers[buffercounter]);
+			if (buffer_offset == offset) {
+				flag = 1;
+				break;
+			}
+		}
+		if (flag == 1) {
+			break;
+		}
+
+	}
+	/* the address to be mapped is not found so return error */
+	if (flag == 0)
+		return -EAGAIN;
+
+	dev_dbg(vdce_device, "The	address	mapped via mmap");
+	/* map the address from user space to kernel space */
+	if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+			    vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+	dev_dbg(vdce_device, "<fn> vdce_mmap L\n</fn>");
+
+	return 0;
+}
+
+/*
+ * vdce_ioctl : This function will process IOCTL commands sent by
+ * the application and control .
+ */
+static int vdce_ioctl(struct inode *inode, struct file *file,
+		      unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	vdce_address_start_t start;
+	vdce_params_t params;
+	vdce_buffer_t buffer;
+	vdce_reqbufs_t reqbuff;
+	/*get the configuratin of this channel from
+	   private_date member of file */
+	channel_config_t *vdce_conf_chan =
+	    (channel_config_t *) file->private_data;
+
+	dev_dbg(vdce_device, " vdce_ioctl E\n");
+	/* before decoding check for correctness of cmd */
+	if (_IOC_TYPE(cmd) != VDCE_IOC_BASE) {
+		dev_err(vdce_device, "Bad command Value \n");
+		return -1;
+	}
+	if (_IOC_NR(cmd) > VDCE_IOC_MAXNR) {
+		dev_err(vdce_device, "Bad Command Value\n");
+		return -1;
+	}
+	/*veryfying access permission of commands */
+	if (_IOC_DIR(cmd) & _IOC_READ) {
+
+		ret = !access_ok(VERIFY_WRITE, (void *)arg, _IOC_SIZE(cmd));
+	} else if (_IOC_DIR(cmd) & _IOC_WRITE) {
+
+		ret = !access_ok(VERIFY_READ, (void *)arg, _IOC_SIZE(cmd));
+	}
+	if (ret) {
+		dev_err(vdce_device, "access denied\n");
+		return -1;	/*error in access */
+	}
+	ret = down_trylock(&(vdce_conf_chan->chan_protection));
+	if (ret != 0) {
+
+		dev_dbg(vdce_device, "Channel in use %d", ret);
+		return -EBUSY;
+	}
+	/* switch according value of cmd */
+	switch (cmd) {
+		/*this ioctl is used to request frame buffers to be
+		   allocated by the ge module. The allocated buffers
+		   are channel  specific and can be     addressed
+		   by indexing */
+	case VDCE_REQBUF:
+		/* function to allocate the memory to input
+		   or output buffer. */
+		if (copy_from_user(&reqbuff, (vdce_reqbufs_t *) arg,
+				   sizeof(vdce_reqbufs_t))) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = malloc_buff(&reqbuff, vdce_conf_chan);
+
+		if (copy_to_user((vdce_reqbufs_t *) arg,
+				 &reqbuff, sizeof(vdce_reqbufs_t)))
+			ret = -EFAULT;
+		break;
+		/*this ioctl is used to query the physical address of a
+		   particular frame buffer. */
+	case VDCE_QUERYBUF:
+		if (copy_from_user(&buffer, (vdce_buffer_t *) arg,
+				   sizeof(vdce_buffer_t))) {
+			ret = -EFAULT;
+			break;
+		}
+		ret = get_buf_address(&buffer, vdce_conf_chan);
+
+		if (copy_to_user((vdce_buffer_t *) arg,
+				 &buffer, sizeof(vdce_buffer_t)))
+			ret = -EFAULT;
+		break;
+		/* this ioctl is used to set the priority of the current
+		   logical channel. If multiple GE tasks from multiple
+		   logical channels are currently *pending, the task
+		   associated with the  highest priority logical channel
+		   will be executed first */
+	case VDCE_SET_PRIORITY:
+		dev_dbg(vdce_device, "\n VDCE_Priority:start");
+		ret = vdce_set_priority((*(int *)arg), vdce_conf_chan);
+		dev_dbg(vdce_device, "\n VDCE_Priority:end");
+		break;
+		/* this ioctl is used to get the priority of
+		   the current logic channel */
+	case VDCE_GET_PRIORITY:
+		dev_dbg(vdce_device, "\n Get VDCE_Priority:start");
+		ret = vdce_get_priority((int *)arg, vdce_conf_chan);
+		dev_dbg(vdce_device, "\n Get VDCE_Priority:end");
+		break;
+		/* this ioctl is used to set the parameters
+		   of the GE hardware, parameters. */
+	case VDCE_SET_PARAMS:
+		/* function to set the hardware configuration */
+		if (copy_from_user(&params, (vdce_params_t *) arg,
+				   sizeof(vdce_params_t))) {
+			ret = -EFAULT;
+			break;
+		}
+		ret = vdce_check_common_params(&params);
+		if (0 == ret) {
+			ret = vdce_set_params(&params, vdce_conf_chan);
+		} else {
+			dev_err(vdce_device, "\n VDCE wrong parameters \n");
+		}
+		break;
+		/*this ioctl is used to get the GE hardware settings
+		   associated with the current logical channel represented
+		   by fd. */
+	case VDCE_GET_PARAMS:
+		/* function to get the hardware configuration */
+		ret = vdce_get_params((vdce_params_t *) arg, vdce_conf_chan);
+		break;
+		/* this ioctl is used to check the current status
+		   of the ge hardware */
+	case VDCE_GET_DEFAULT:
+		/* this ioctl is used to get the default parameters
+		   of the ge hardware */
+		ret = vdce_get_default((vdce_params_t *) arg);
+		break;
+	case VDCE_GET_STATUS:
+		ret = vdce_get_status((vdce_hw_status_t *) arg, vdce_conf_chan);
+		break;
+		/*this ioctl submits a VDCE task .The call can either be blocked
+		   until the task is completed or returned immediately based
+		   on the value of the blocking argument in the open
+		   structure. If  it is blocking, the     status of the task
+		   can be checked by calling ioctl   VDCE_GET_STATUS.
+		   Only one taskcan  be outstanding for each logical channel. */
+	case VDCE_START:
+		if (copy_from_user(&start, (vdce_address_start_t *) arg,
+				   sizeof(vdce_address_start_t))) {
+			ret = -EFAULT;
+			break;
+		}
+
+		ret = vdce_start(&start, vdce_conf_chan);
+		break;
+	default:
+		dev_dbg(vdce_device, "VDCE_ioctl: Invalid Command Value");
+		ret = -EINVAL;
+	}
+
+	dev_dbg(vdce_device, " vdce_ioctl L\n");
+	up(&(vdce_conf_chan->chan_protection));
+
+	return ret;
+}
+static struct file_operations vdce_fops = {
+	.owner = THIS_MODULE,
+	.open = vdce_open,
+	.release = vdce_release,
+	.mmap = vdce_mmap,
+	.ioctl = vdce_ioctl,
+};
+
+/*
+ * vdce_isr : Function to register the ge character device driver
+ */
+irqreturn_t vdce_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int ret;
+	/* to suggest that resizing has been completed */
+	channel_config_t *vdce_conf_chan =
+	    device_config.channel_configuration[FIRSTENTRY];
+
+	dev_dbg(vdce_device, "<fn> vdce_isr E \n</fn>");
+	/* if the current call in blocking release the semaphore */
+	if (((vdce_conf_chan->num_pass == VDCE_MULTIPASS) &&
+	     (vdce_conf_chan->vdce_complete == VDCE_PASS1_STARTED))) {
+		vdce_conf_chan->vdce_complete = VDCE_PASS2_STARTED;
+
+		tasklet_schedule(&short_tasklet);
+
+	} else {
+		vdce_conf_chan->vdce_complete = VDCE_COMPLETED;
+
+	}
+	/* if process is completed than remove the entry from array */
+	if (vdce_conf_chan->vdce_complete == VDCE_COMPLETED) {
+		if (vdce_conf_chan->channel_mode != VDCE_MODE_NON_BLOCKING) {
+			complete(&(device_config.sem_isr));
+		}
+		disable_irq(VDCE_INTERRUPT);
+		ret = delete_from_array();
+		vdce_conf_chan->status = VDCE_CHAN_FREE;
+		if (ret == 0) {
+			return IRQ_HANDLED;
+		} else {
+			tasklet_schedule(&short_tasklet);
+		}
+	}
+	dev_dbg(vdce_device, "<fn> vdce_isr L\n</fn>");
+	return IRQ_HANDLED;
+}
+
+/*
+ * process_nonblock : Function to process_nonblocking call
+ */
+void process_bottomhalf(unsigned long ret)
+{
+	/* codec mode used */
+	channel_config_t *vdce_conf_chan =
+	    device_config.channel_configuration[FIRSTENTRY];
+	int pass_num;
+	if (vdce_conf_chan->vdce_complete == VDCE_PASS2_STARTED) {
+		/* set 2 pass register configuration */
+		pass_num = 1;
+	} else {
+		vdce_conf_chan->vdce_complete = VDCE_PASS1_STARTED;
+		/* set 1 pass register configuration */
+		pass_num = 0;
+	}
+	/*function call to set up the hardware */
+	vdce_hw_setup(&vdce_conf_chan->register_config[pass_num]);
+	/*function call to enable ge hardware */
+	if (pass_num == 0) {
+		enable_irq(VDCE_INTERRUPT);
+	}
+	ret = vdce_enable(&vdce_conf_chan->register_config[pass_num]);
+
+	dev_dbg(vdce_device, "<fn> process_nonblock L</fn>\n");
+}
+static void vdce_platform_release(struct device *device)
+{
+	/* this is called when the reference count goes to zero */
+}
+static int __init vdce_probe(struct device *device)
+{
+	vdce_device = device;
+	return 0;
+}
+static int vdce_remove(struct device *device)
+{
+	return 0;
+}
+static struct class *vdce_class;
+
+static struct platform_device graphics_device = {
+	.name = DRIVERNAME,.id = 2,.dev = {
+					   .release = vdce_platform_release,}
+};
+static struct device_driver vdce_driver = {
+	.name = DRIVERNAME,
+	.bus = &platform_bus_type,
+	.probe = vdce_probe,
+	.remove = vdce_remove,
+};
+
+/*
+ * vdce_init : Function to register ge character driver
+ */
+static int __init vdce_init(void)
+{
+	int result;
+	int adr;
+	int size;
+	device_config.module_usage_count = 0;
+	device_config.array_count = 0;
+
+	/* register the driver in the kernel */
+	result = alloc_chrdev_region(&dev, 0, 1, DRIVER_NAME);
+	if (result < 0) {
+		printk(KERN_ERR "\nDaVincige: Module intialization failed.\
+		could not register character device");
+		return -ENODEV;
+	}
+	/* initialize of character device */
+	cdev_init(&c_dev, &vdce_fops);
+	c_dev.owner = THIS_MODULE;
+	c_dev.ops = &vdce_fops;
+	/* addding character device */
+	result = cdev_add(&c_dev, dev, 1);
+	if (result) {
+		printk(KERN_ERR "NOtICE \nDaVincige:Error %d adding DavinciVDCE\
+				 ..error no:", result);
+		result = -EINVAL;
+		goto label1;
+	}
+	/* registeration of character device */
+	register_chrdev(MAJOR(dev), DRIVER_NAME, &vdce_fops);
+
+	/* register driver as a platform driver */
+	if (driver_register(&vdce_driver) != 0) {
+		result = -EINVAL;
+		goto label2;
+	}
+	/* register the drive as a platform device */
+	if (platform_device_register(&graphics_device) != 0) {
+		result = -EINVAL;
+		goto label3;
+	}
+	vdce_class = class_create(THIS_MODULE, DRIVERNAME);
+	if (!vdce_class) {
+		result = -EIO;
+		goto label4;
+	}
+
+	class_device_create(vdce_class, NULL, dev, NULL, DRIVERNAME);
+
+	init_completion(&(device_config.sem_isr));
+	init_completion(&(device_config.edma_sem));
+
+	device_config.sem_isr.done = 0;
+	device_config.edma_sem.done = 0;
+
+	/* initialize the device mutex */
+	init_MUTEX(&device_config.array_sem);
+	init_MUTEX(&device_config.device_mutex);
+
+	/* set up the Interrupt handler for     ge interrupt */
+	result =
+	    request_irq(VDCE_INTERRUPT, vdce_isr, SA_INTERRUPT,
+			"DavinciHD_VDCE", (void *)NULL);
+	disable_irq(VDCE_INTERRUPT);
+	if (result < 0) {
+		printk(KERN_ERR "Cannot initialize IRQ \n");
+		result = -EINVAL;
+		goto label5;
+
+	}
+	device_config.inter_size = inter_bufsize;
+	if (device_config.inter_size > 0) {
+		device_config.inter_buffer =
+		    (void *)(__get_free_pages(GFP_KERNEL | GFP_DMA,
+					      get_order((device_config.
+							 inter_size))));
+		if (!(device_config.inter_buffer)) {
+			goto label5;
+		}
+
+		adr = (unsigned int)device_config.inter_buffer;
+		size = PAGE_SIZE << (get_order((device_config.inter_size)));
+		while (size > 0) {
+			/* make  sure the frame buffers
+			   are never swapped out of memory */
+			SetPageReserved(virt_to_page(adr));
+			adr += PAGE_SIZE;
+			size -= PAGE_SIZE;
+		}
+	}
+	result = vdce_enable_int();
+	if (result < 0) {
+		printk(KERN_ERR "Cannot init register \n");
+		result = -EINVAL;
+		goto label5;
+
+	} else {
+		result = 0;
+		goto done;
+	}
+
+      label5:
+	class_device_destroy(vdce_class, dev);
+	class_destroy(vdce_class);
+      label4:
+	platform_device_unregister(&graphics_device);
+      label3:
+	driver_unregister(&vdce_driver);
+      label2:
+	cdev_del(&c_dev);
+	unregister_chrdev(MAJOR(dev), DRIVER_NAME);
+      label1:
+	unregister_chrdev_region(dev, 1);
+
+      done:
+	return result;
+}
+
+/*
+ * vdce_cleanup : Function is called by the kernel. It unregister
+ * the device.
+ */
+void __exit vdce_cleanup(void)
+{
+	unregister_chrdev_region(dev, 1);
+	/* remove class device */
+	class_device_destroy(vdce_class,dev);
+
+	/* destroy class */
+	class_destroy(vdce_class);
+	/* remove platform driver */
+	driver_unregister(&vdce_driver);
+	/* disable interrupt */
+	free_irq(VDCE_INTERRUPT, (void *)NULL);
+	/* remove platform device */
+	platform_device_unregister(&graphics_device);
+	cdev_del(&c_dev);
+	/* unregistering the driver from the kernel */
+	unregister_chrdev(MAJOR(dev), DRIVER_NAME);
+	if (device_config.inter_size > 0) {
+		vdce_free_pages((int)device_config.inter_buffer,
+				((device_config.inter_size)));
+	}
+}
+
+module_init(vdce_init)
+    module_exit(vdce_cleanup)
Index: linux-2.6.18/drivers/char/davinci_vdce_hw.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/char/davinci_vdce_hw.c
@@ -0,0 +1,320 @@
+/* *
+ * Copyright (C) 2007 Texas Instruments	Inc
+ *
+ * This	program	is free	software; you can redistribute it and/or modify
+ * it under the	terms of the GNU General Public	License	as published by
+ * the Free Software Foundation; either	version	2 of the License, or
+ * (at your option) any	later version.
+ *
+ * This	program	is distributed in the hope that	it will	be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A	PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59	Temple Place, Suite 330, Boston, MA 02111-1307	USA
+ */
+/* davinci_vdce_hw.c	file */
+
+/*Header files*/
+#include <asm/types.h>
+#include <asm/arch/davinci_vdce_hw.h>
+#include <linux/kernel.h>	/* printk()     */
+#include <linux/device.h>
+#include <asm/arch/davinci_vdce.h>
+
+extern struct device *vdce_device;
+/*
+ * vdce_hardware_setup :Function to set GE hardware configuration registers
+ */
+void vdce_hw_setup(vdce_hw_config_t * register_config)
+{
+	/* all devdbg will be removed after UT */
+	int status;
+	dev_dbg(vdce_device, " vdce_hw_setup E\n");
+
+	/* setting the hardware register GE ctrl */
+	regw(register_config->vdce_ctrl, VDCE_CTRL);
+	dev_dbg(vdce_device, "GE CTRL : %x	regr = %x \n",
+		register_config->vdce_ctrl, regr(VDCE_CTRL));
+
+	regw(register_config->vdce_emulation_ctrl, VDCE_EMULATION_CTRL);
+	dev_dbg(vdce_device, "VDCE_EMULATION_CTRL	%x regr	= %x\n",
+		register_config->vdce_emulation_ctrl,
+		regr(VDCE_EMULATION_CTRL));
+
+	/* setting the hardware register sdr_fmt */
+	regw(register_config->vdce_sdr_fmt, VDCE_SDR_FMT);
+	dev_dbg(vdce_device, "VDCE_SDR_FMT %x regr = %x\n",
+		register_config->vdce_sdr_fmt, regr(VDCE_SDR_FMT));
+
+	/* setting the hardware register req_sz */
+	regw(register_config->vdce_req_sz, VDCE_REQ_SZ);
+	dev_dbg(vdce_device, "VDCE_REQ_SZ %x	regr = %x\n",
+		register_config->vdce_req_sz, regr(VDCE_REQ_SZ));
+
+	regw(register_config->vdce_prcs_unit_size, VDCE_PRCS_UNIT_SIZE);
+	dev_dbg(vdce_device, "VDCE_PRCS_UNIT_SIZE :	%x	regr = %x \n",
+		register_config->vdce_prcs_unit_size,
+		regr(VDCE_PRCS_UNIT_SIZE));
+
+	regw(register_config->src_Y_strt_ps, SRC_Y_STRT_PS);
+	dev_dbg(vdce_device, "SRC_Y_STRT_PS : %x	regr = %x \n",
+		register_config->src_Y_strt_ps, regr(SRC_Y_STRT_PS));
+
+	regw(register_config->src_Y_sz, SRC_Y_SZ);
+	dev_dbg(vdce_device, "SRC_Y_SZ : %x	regr = %x \n",
+		register_config->src_Y_sz, regr(SRC_Y_SZ));
+
+	regw(register_config->src_C_strt_ps, SRC_C_STRT_PS);
+	dev_dbg(vdce_device, "SRC_C_STRT_PS : %x	regr = %x \n",
+		register_config->src_C_strt_ps, regr(SRC_C_STRT_PS));
+
+	regw(register_config->src_C_sz, SRC_C_SZ);
+	dev_dbg(vdce_device, "SRC_C_SZ : %x	regr = %x \n",
+		register_config->src_C_sz, regr(SRC_C_SZ));
+
+	regw(register_config->src_bmp_strt_ps, SRC_BMP_STRT_PS);
+	dev_dbg(vdce_device, "SRC_BMP_STRT_PS : %x	regr = %x \n",
+		register_config->src_bmp_strt_ps, regr(SRC_BMP_STRT_PS));
+
+	regw(register_config->src_bmp_sz, SRC_BMP_SZ);
+	dev_dbg(vdce_device, "SRC_BMP_SZ : %x	regr = %x \n",
+		register_config->src_bmp_sz, regr(SRC_BMP_SZ));
+
+	regw(register_config->res_Y_strt_ps, RES_Y_STRT_PS);
+	dev_dbg(vdce_device, "RES_Y_STRT_PS : %x	regr = %x \n",
+		register_config->res_Y_strt_ps, regr(RES_Y_STRT_PS));
+
+	regw(register_config->res_Y_sz, RES_Y_SZ);
+	dev_dbg(vdce_device, "RES_Y_SZ : %x	regr = %x \n",
+		register_config->res_Y_sz, regr(RES_Y_SZ));
+
+	regw(register_config->res_C_strt_ps, RES_C_STRT_PS);
+	dev_dbg(vdce_device, "RES_C_STRT_PS : %x	regr = %x \n",
+		register_config->res_C_strt_ps, regr(RES_C_STRT_PS));
+
+	regw(register_config->res_C_sz, RES_C_SZ);
+	dev_dbg(vdce_device, "RES_C_SZ : %x	regr = %x \n",
+		register_config->res_C_sz, regr(RES_C_SZ));
+
+	regw(register_config->res_bmp_strt_ps, RES_BMP_STRT_PS);
+	dev_dbg(vdce_device, "RES_BMP_STRT_PS : %x	regr = %x \n",
+		register_config->res_bmp_strt_ps, regr(RES_BMP_STRT_PS));
+
+	regw(register_config->rsz_mode, RSZ_MODE);
+	dev_dbg(vdce_device, "RSZ_MODE : %x	regr = %x \n",
+		register_config->rsz_mode, regr(RSZ_MODE));
+
+	regw(register_config->rsz_h_mag, RSZ_H_MAG);
+	dev_dbg(vdce_device, "RSZ_H_MAG :	%x	regr = %x \n",
+		register_config->rsz_h_mag, regr(RSZ_H_MAG));
+
+	regw(register_config->rsz_v_mag, RSZ_V_MAG);
+	dev_dbg(vdce_device, "RSZ_V_MAG :	%x	regr = %x \n",
+		register_config->rsz_v_mag, regr(RSZ_V_MAG));
+
+	regw(register_config->rsz_h_phase, RSZ_H_PHASE);
+	dev_dbg(vdce_device, "RSZ_H_PHASE	: %x	regr = %x \n",
+		register_config->rsz_h_phase, regr(RSZ_H_PHASE));
+
+	regw(register_config->rsz_v_phase, RSZ_V_PHASE);
+	dev_dbg(vdce_device, "RSZ_V_PHASE	: %x	regr = %x \n",
+		register_config->rsz_v_phase, regr(RSZ_V_PHASE));
+
+	regw(register_config->rsz_alf_intensity, RSZ_ALF_INTENSITY);
+	dev_dbg(vdce_device, "RSZ_ALF_INTENSITY :	%x	regr = %x \n",
+		register_config->rsz_alf_intensity, regr(RSZ_ALF_INTENSITY));
+
+	regw(register_config->ccv_mode, CCV_MODE);
+	dev_dbg(vdce_device, "CCV_MODE : %x	regr = %x \n",
+		register_config->ccv_mode, regr(CCV_MODE));
+
+	regw(register_config->bld_lut[0], BLD_LUT_00);
+	dev_dbg(vdce_device, "BLD_LUT_00 : %x	regr = %x \n",
+		register_config->bld_lut[0], regr(BLD_LUT_00));
+
+	regw(register_config->bld_lut[1], BLD_LUT_01);
+	dev_dbg(vdce_device, "BLD_LUT_01 : %x	regr = %x \n",
+		register_config->bld_lut[1], regr(BLD_LUT_01));
+
+	regw(register_config->bld_lut[2], BLD_LUT_02);
+	dev_dbg(vdce_device, "BLD_LUT_02 : %x	regr = %x \n",
+		register_config->bld_lut[2], regr(BLD_LUT_02));
+
+	regw(register_config->bld_lut[3], BLD_LUT_03);
+	dev_dbg(vdce_device, "BLD_LUT_03 : %x	regr = %x \n",
+		register_config->bld_lut[3], regr(BLD_LUT_03));
+
+	regw(register_config->rgmp_ctrl, RGMP_CTRL);
+	dev_dbg(vdce_device, "RGMP_CTRL :	%x	regr = %x \n",
+		register_config->rgmp_ctrl, regr(RGMP_CTRL));
+
+	regw(register_config->epd_luma_width, EPD_LUMA_WIDTH);
+	dev_dbg(vdce_device, "EPD_LUMA_WIDTH : %x	regr = %x \n",
+		register_config->epd_luma_width, regr(EPD_LUMA_WIDTH));
+
+	regw(register_config->epd_chroma_width, EPD_CHROMA_WIDTH);
+	dev_dbg(vdce_device, "EPD_CHROMA_WIDTH : %x	regr = %x \n",
+		register_config->epd_chroma_width, regr(EPD_CHROMA_WIDTH));
+
+	/* source addres for luma and chroma */
+	regw(register_config->vdce_src_strt_add_ytop, VDCE_SRC_STRT_ADD_YTOP);
+
+	dev_dbg(vdce_device, "VDCE_SRC_STRT_ADD_YTOP %x	regr = %x\n",
+		register_config->vdce_src_strt_add_ytop,
+		regr(VDCE_SRC_STRT_ADD_YTOP));
+
+	regw(register_config->vdce_src_strt_add_ctop, VDCE_SRC_STRT_ADD_CTOP);
+
+	dev_dbg(vdce_device, "VDCE_SRC_STRT_ADD_CTOP %x	regr = %x\n",
+		register_config->vdce_src_strt_add_ctop,
+		regr(VDCE_SRC_STRT_ADD_CTOP));
+
+	regw(register_config->vdce_src_strt_add_ybot, VDCE_SRC_STRT_ADD_YBOT);
+
+	dev_dbg(vdce_device, "VDCE_SRC_STRT_ADD_YBOT %x	regr = %x\n",
+		register_config->vdce_src_strt_add_ybot,
+		regr(VDCE_SRC_STRT_ADD_YBOT));
+
+	regw(register_config->vdce_src_strt_add_cbot, VDCE_SRC_STRT_ADD_CBOT);
+
+	dev_dbg(vdce_device, "VDCE_SRC_STRT_ADD_CBOT %x	regr = %x\n",
+		register_config->vdce_src_strt_add_cbot,
+		regr(VDCE_SRC_STRT_ADD_CBOT));
+
+	/* result address for luma and chroma */
+	regw(register_config->vdce_res_strt_add_ytop, VDCE_RES_STRT_ADD_YTOP);
+
+	dev_dbg(vdce_device, "VDCE_RES_STRT_ADD_YTOP %x	regr = %x\n",
+		register_config->vdce_res_strt_add_ytop,
+		regr(VDCE_RES_STRT_ADD_YTOP));
+
+	regw(register_config->vdce_res_strt_add_ctop, VDCE_RES_STRT_ADD_CTOP);
+	dev_dbg(vdce_device, "VDCE_RES_STRT_ADD_CTOP %x	regr = %x\n",
+		register_config->vdce_res_strt_add_ctop,
+		regr(VDCE_RES_STRT_ADD_CTOP));
+
+	regw(register_config->vdce_res_strt_add_ybot, VDCE_RES_STRT_ADD_YBOT);
+
+	dev_dbg(vdce_device, "VDCE_RES_STRT_ADD_YTOP %x	regr = %x\n",
+		register_config->vdce_res_strt_add_ybot,
+		regr(VDCE_RES_STRT_ADD_YBOT));
+
+	regw(register_config->vdce_res_strt_add_cbot, VDCE_RES_STRT_ADD_CBOT);
+	dev_dbg(vdce_device, "VDCE_RES_STRT_ADD_CBOT %x	regr = %x\n",
+		register_config->vdce_res_strt_add_cbot,
+		regr(VDCE_RES_STRT_ADD_CBOT));
+
+	/* source offset for luma and chroma */
+	regw(register_config->vdce_src_add_ofst_ytop, VDCE_SRC_STRT_OFF_YTOP);
+	dev_dbg(vdce_device, "VDCE_SRC_STRT_OFF_YTOP %x	regr = %x\n",
+		register_config->vdce_src_add_ofst_ytop,
+		regr(VDCE_SRC_STRT_OFF_YTOP));
+
+	regw(register_config->vdce_src_add_ofst_ctop, VDCE_SRC_STRT_OFF_CTOP);
+	dev_dbg(vdce_device, "VDCE_SRC_STRT_OFF_CTOP %x	regr = %x\n",
+		register_config->vdce_src_add_ofst_ctop,
+		regr(VDCE_SRC_STRT_OFF_CTOP));
+
+	regw(register_config->vdce_src_add_ofst_ybot, VDCE_SRC_STRT_OFF_YBOT);
+	dev_dbg(vdce_device, "VDCE_SRC_STRT_OFF_YBOT %x	regr = %x\n",
+		register_config->vdce_src_add_ofst_ybot,
+		regr(VDCE_SRC_STRT_OFF_YBOT));
+
+	regw(register_config->vdce_src_add_ofst_cbot, VDCE_SRC_STRT_OFF_CBOT);
+	dev_dbg(vdce_device, "VDCE_SRC_STRT_OFF_CBOT %x	regr = %x\n",
+		register_config->vdce_src_add_ofst_cbot,
+		regr(VDCE_SRC_STRT_OFF_CBOT));
+
+	/* result offset for luma and chroma */
+	regw(register_config->vdce_res_strt_off_ytop, VDCE_RES_STRT_OFF_YTOP);
+	dev_dbg(vdce_device, "VDCE_RES_STRT_OFF_YTOP %x	regr = %x\n",
+		register_config->vdce_res_strt_off_ytop,
+		regr(VDCE_RES_STRT_OFF_YTOP));
+
+	regw(register_config->vdce_res_strt_off_ctop, VDCE_RES_STRT_OFF_CTOP);
+	dev_dbg(vdce_device, "VDCE_RES_STRT_OFF_CTOP %x	regr = %x\n",
+		register_config->vdce_res_strt_off_ctop,
+		regr(VDCE_RES_STRT_OFF_CTOP));
+
+	regw(register_config->vdce_res_strt_off_ybot, VDCE_RES_STRT_OFF_YBOT);
+	dev_dbg(vdce_device, "VDCE_RES_STRT_OFF_YBOT %x	regr = %x\n",
+		register_config->vdce_res_strt_off_ybot,
+		regr(VDCE_RES_STRT_OFF_YBOT));
+
+	regw(register_config->vdce_res_strt_off_cbot, VDCE_RES_STRT_OFF_CBOT);
+	dev_dbg(vdce_device, "VDCE_RES_STRT_OFF_CBOT %x	regr = %x\n",
+		register_config->vdce_res_strt_off_cbot,
+		regr(VDCE_RES_STRT_OFF_CBOT));
+
+	/* bitmap address and offset for luma and chroma */
+	regw(register_config->vdce_src_strt_add_bmp_top,
+	     VDCE_SRC_STRT_ADD_BMP_TOP);
+	dev_dbg(vdce_device, "VDCE_SRC_STRT_ADD_BMP_TOP %x	regr = %x\n",
+		register_config->vdce_src_strt_add_bmp_top,
+		regr(VDCE_SRC_STRT_ADD_BMP_TOP));
+
+	regw(register_config->vdce_src_strt_add_bmp_bot,
+	     VDCE_SRC_STRT_ADD_BMP_BOT);
+	dev_dbg(vdce_device, "VDCE_SRC_STRT_ADD_BMP_BOT %x	regr = %x\n",
+		register_config->vdce_src_strt_add_bmp_bot,
+		regr(VDCE_SRC_STRT_ADD_BMP_BOT));
+
+	regw(register_config->vdce_src_strt_off_bmp_top,
+	     VDCE_SRC_STRT_OFF_BMP_TOP);
+	dev_dbg(vdce_device, "VDCE_SRC_STRT_OFF_BMP_TOP %x	regr = %x\n",
+		register_config->vdce_src_strt_off_bmp_top,
+		regr(VDCE_SRC_STRT_OFF_BMP_TOP));
+
+	regw(register_config->vdce_src_strt_off_bmp_bot,
+	     VDCE_SRC_STRT_OFF_BMP_BOT);
+
+	status = regr(VDCE_STATUS);
+	dev_dbg(vdce_device, "VDCE_SRC_STRT_OFF_BMP_BOT %x	regr = %x\n",
+		register_config->vdce_src_strt_off_bmp_bot,
+		regr(VDCE_SRC_STRT_OFF_BMP_BOT));
+	dev_dbg(vdce_device, "vdce_hw_setup L\n");
+}
+
+/*
+ * vdce_enable : Function to enable the	ge module
+ */
+int vdce_enable(vdce_hw_config_t * register_config)
+{
+	dev_dbg(vdce_device, " vdce_enable E\n");
+	/* enabling the resizer the setting enable bit */
+	register_config->vdce_ctrl =
+	    BITSET(register_config->vdce_ctrl, VDCE_ENABLE);
+
+	regw(register_config->vdce_ctrl, VDCE_CTRL);
+
+	register_config->vdce_ctrl =
+	    BITRESET(register_config->vdce_ctrl, VDCE_ENABLE);
+
+	dev_dbg(vdce_device, "vdce enable L\n");
+
+	return 0;
+}
+
+/*
+ * vdce_interrupt set : Function to set interrupt
+ */
+inline int vdce_enable_int(void)
+{
+	regw(1, VDCE_INTEN);
+	regw(1, VDCE_INTEN_SET);
+	/* Disable emulation control signal */
+	regw(1, VDCE_EMULATION_CTRL);
+	return 0;
+}
+
+/*
+ * vdce_clear_status : Function to clear the status
+ */
+inline int vdce_clear_status(void)
+{
+	regw(1, VDCE_STATUS_CLR);
+	return 0;
+}
Index: linux-2.6.18/include/asm-arm/arch-davinci/davinci_vdce.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/davinci_vdce.h
@@ -0,0 +1,460 @@
+/* *
+ * Copyright (C) 2007 Texas Instruments	Inc
+ *
+ * This	program	is free	software; you can redistribute it and/or modify
+ * it under the	terms of the GNU General Public	License	as published by
+ * the Free Software Foundation; either	version	2 of the License, or
+ * (at your option any)	later version.
+ * This	program	is distributed in the hope that	it will	be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not,write to the	Free Software
+ * Foundation, Inc., 59	Temple Place, Suite 330, Boston, MA  02111-1307	 USA
+ */
+/* davinci_vdce.h	file */
+
+#ifndef	DAVINCI_VDCE_H
+#define	DAVINCI_VDCE_H
+#ifdef __KERNEL__
+/* include Linux files */
+#include <linux/interrupt.h>
+#endif
+#include <asm/arch/davinci_vdce_hw.h>
+#define	  VDCE_IOC_BASE			   'G'
+#define	  VDCE_IOC_MAXNR			    9
+/* Ioctl options which are to be passed	while calling the ioctl	*/
+#define	VDCE_SET_PARAMS		 _IOWR(VDCE_IOC_BASE, 1, vdce_params_t)
+#define	VDCE_GET_PARAMS		 _IOR(VDCE_IOC_BASE, 2, vdce_params_t)
+#define	VDCE_GET_STATUS		 _IOR(VDCE_IOC_BASE, 3, vdce_hw_status_t)
+#define	VDCE_START		 _IOWR(VDCE_IOC_BASE, 4, vdce_address_start_t)
+#define	VDCE_REQBUF		 _IOWR(VDCE_IOC_BASE, 5, vdce_reqbufs_t)
+#define	VDCE_QUERYBUF		 _IOWR(VDCE_IOC_BASE, 6, vdce_buffer_t)
+#define VDCE_GET_DEFAULT	 _IOWR(VDCE_IOC_BASE, 7, vdce_params_t)
+#define	VDCE_SET_PRIORITY	 _IOWR(VDCE_IOC_BASE, 8, int)
+#define	VDCE_GET_PRIORITY	 _IOR(VDCE_IOC_BASE, 9, int)
+
+#define	VDCE_MAX_PRIORITY		  5
+#define	VDCE_MIN_PRIORITY		  0
+#define	VDCE_DEFAULT_PRIORITY		  0
+#define	MAX_BUFFERS			  8
+
+#ifdef __KERNEL__
+#define	MAX_RSZ_INTENSITY		  128
+#define	MIN_RSZ_MAG_RATIO		  256
+#define	MAX_RSZ_MAG_RATIO		  2048
+#define	DRIVER_NAME			  "VDCE"
+#define	MAX_CHANNELS			  16
+#define	FIRSTENTRY			  0
+#define	SECONDENTRY			  1
+#define	EMPTY				  0
+#define	FREE_BUFFER			  0
+#define CHECK_MODE_RANGE(mode, limit)    ((mode < 0 || mode > limit)?1:0)
+#define GET_DIVIDE_FACTOR(format)	 ((format == 0)?3:4)
+#define GET_CHROMA_DIVIDE_FACTOR(format) ((format == 0)?4:2)
+#define GET_VAL(reg, mask, shift)
+#define RSZ_ENABLE_MASK			0x1
+#define BLEND_ENABLE_MASK		0x2
+#define RMAP_ENABLE_MASK		0x4
+#define CCV_ENABLE_MASK			0x8
+#endif
+
+/* enum	for selected VDCE mode */
+typedef enum vdce_mode_operation {
+	VDCE_OPERATION_PRE_CODECMODE = 0,/* set pre codec mode */
+	VDCE_OPERATION_POST_CODECMODE,	/* set post codec mode */
+	VDCE_OPERATION_TRANS_CODECMODE,	/* set trans codec mode */
+	VDCE_OPERATION_EDGE_PADDING,	/* enable edge padding */
+	VDCE_OPERATION_RESIZING,	/* For doing chrominance conversion */
+	VDCE_OPERATION_CHROMINANCE_CONVERSION,	/* For doing resizing */
+	VDCE_OPERATION_RANGE_MAPPING,	/* For doing range mapping */
+	VDCE_OPERATION_BLENDING		/* for doing blending */
+} vdce_mode_operation_t;
+
+/* enum	for enable disable status */
+typedef enum vdce_status {
+	VDCE_FEATURE_DISABLE = 0,	/* Suggest  disable status */
+	VDCE_FEATURE_ENABLE		/* Suggest Enable status   */
+} vdce_status_t;
+
+/* enum	for image_type */
+typedef enum vdce_image_type {
+	VDCE_BUF_IN = 0,	/* Suggest  buffer is of output type */
+	VDCE_BUF_OUT,		/* Suggest  buffer is of input type */
+	VDCE_BUF_BMP		/* Suggest  buffer is of bitmap type */
+} vdce_image_type_t;
+
+/* enum	to enable disable luma/chroma processing */
+typedef enum vdce_proc_control {
+	VDCE_LUMA_ENABLE = 0,	/* suggest luma processing is enable  */
+	VDCE_CHROMA_ENABLE,	/* suggest chroma processing is enable  */
+	VDCE_LUMA_CHROMA_ENABLE	/* suggest both processing is enable  */
+} vdce_proc_control_t;
+
+/* enum	to enable disable field	status */
+typedef enum vdce_field_status {
+	VDCE_TOP_ENABLE = 0,/* suggest top field processing is enable  */
+	VDCE_BOTTOM_ENABLE,/* suggest bottom field processing is enable */
+	VDCE_TOP_BOT_ENABLE/* suggest both processing is enable  */
+} vdce_field_status_t;
+
+/* enum	for codec mode */
+typedef enum vdce_codec_mode {
+	VDCE_CODECMODE_MPEG2_MPEG4 = 0,	/* suggest mpeg2 is selected */
+	VDCE_CODECMODE_MPEG1		/* suggest mpeg1 is selected */
+} vdce_codec_mode_t;
+
+/* ALF mode for	resizing */
+typedef enum vdce_alfmode {
+	VDCE_ALFMODE_AUTOMATIC = 0,	/* tap-4 */
+	VDCE_ALFMODE_MANUAL		/* tap linear */
+} vdce_alfmode_t;
+
+/* type	of algo*/
+typedef enum vdce_algo_type {
+
+	VDCE_ALGO_TAP_4CUBIC_CONVOLUTION = 0,	/* cubic convolution */
+	VDCE_ALGO_TAP_4LINEAR_INTERPOLATION	/* linear interpolation */
+} vdce_algo_type_t;
+
+/* for mode */
+typedef enum vdce_io_mode {
+	VDCE_FIELD_MODE = 0,	/* Indicate that field mode */
+	VDCE_FRAME_MODE		/* Indicate that frame mode */
+} vdce_io_mode_t;
+
+/* hardware and	channel	status */
+typedef enum vdce_processing_status {
+	VDCE_CHAN_FREE = 0,		/* channel free */
+	VDCE_CHAN_BUSY,			/* channel busy */
+	VDCE_CHAN_PENDING,		/* Request pending */
+	VDCE_CHAN_UNINITIALISED,	/* Parameters uninitialised */
+	VDCE_CHAN_PARAMS_INITIALISED,	/* Parameters initialised */
+} vdce_processing_status_t;
+
+/* processing mode of image */
+typedef enum vdce_processing_mode {
+	VDCE_INTERLACED = 0,		/* interlaced mode */
+	VDCE_PROGRESSIVE		/* progressive mode */
+} vdce_processing_mode_t;
+
+/* image format	*/
+typedef enum vdce_image_fmt {
+	VDCE_IMAGE_FMT_420 = 0,	    /* 4:2:0 image format */
+	VDCE_IMAGE_FMT_422 = 1	    /* 4:2:2 image format */
+
+} vdce_image_fmt_t;
+/*CCV operation	mode */
+typedef enum vdce_ccv_mode {
+	VDCE_CCV_MODE_422_420 = 0,	/* 4:2:2 to 4:2:0 */
+	VDCE_CCV_MODE_420_422,		/* 4:2:0 to 4:2:2 */
+	VDCE_CCV_MODE_420_420		/* 4:2:0 to 4:2:0 */
+} vdce_ccv_mode_t;
+/*Resize operation mode	*/
+typedef enum vdce_rsz_mode {
+	VDCE_MODE_420 = 0,	/* 4:2:2  */
+	VDCE_MODE_422,		/* 4:2:0 */
+} vdce_rsz_blend_mode_t;
+
+/* ---------------Interface Data structures-----------------------------------*/
+/* Structure to	configure the resize parameters	*/
+typedef struct vdce_rsz_params {
+	vdce_rsz_blend_mode_t rsz_mode;	/* Value will not be used in native */
+	/*Mode. It will be used for stanalone */
+	/*resizing only */
+	vdce_codec_mode_t rsz_op_mode;
+	vdce_algo_type_t hrsz_mode;/* To suggest horizontal resizing mode */
+					/*   eg convolution */
+	vdce_algo_type_t vrsz_mode;	/* To suggest Vertical resizing mode */
+					/* eg convolution */
+	vdce_status_t hrsz_alf_enable;	/* Suggest horizontal anti alias */
+					/*  filter is on */
+	vdce_status_t vrsz_alf_enable;	/* Suggest vertical anti alias filter */
+					/* is on */
+	vdce_alfmode_t hrsz_alf_mode;	/* Suggest the anti alias filter mode */
+	unsigned char hrsz_alf_intensity;/* Intensity for coefficients calc */
+} vdce_rsz_params_t;
+
+/* Structure to	configure the chrominance conversion parameters	*/
+typedef struct vdce_ccv_params {
+	vdce_ccv_mode_t conversion_type; /* Value will not be used in native */
+					/*Mode. It will be used for stanalone */
+					/*CCV only */
+	/* Below both parameters will be used only in case for trans codec */
+	vdce_codec_mode_t codec_mode_in;/* Type of input of codec conversion */
+					/*eg mpeg1 or other */
+	vdce_codec_mode_t codec_mode_out;/*Type of output of codec conversion */
+					/*eg mpeg2 or other */
+	vdce_algo_type_t hccv_type;	/* Chrominance conversion functional */
+					/*type selection bit (for horz) */
+	vdce_algo_type_t vccv_type;	/* Chrominance conversion functional */
+					/* type selection bit(for vert) */
+} vdce_ccv_params_t;
+
+/* Structure to	configure the range maping parameters */
+typedef struct vdce_rmap_params {
+
+	unsigned char coeff_y;		/* coeffcients of range mapping */
+					/*for Y component */
+	vdce_status_t rmap_yenable;	/* Suggest that luminance range */
+					/*mapping is enable */
+	unsigned char coeff_c;		/* coeffcients of range mapping for */
+					/* chroma component */
+	vdce_status_t rmap_cenable;	/* Suggest that chrominace range */
+					/* mapping is enable */
+} vdce_rmap_params_t;
+
+/* Structure to	configure the blending parameters */
+typedef struct blend_table {
+
+	unsigned char blend_cr;	/* blend value for cr component */
+	unsigned char blend_cb;	/* blend value for cb component */
+	unsigned char blend_y;	/* blend value for y component */
+	unsigned char blend_value;	/* Blend factor */
+} blend_table_t;
+
+typedef struct vdce_blend_params {
+
+	vdce_rsz_blend_mode_t blend_mode;
+	blend_table_t bld_lut[MAX_BLEND_TABLE];	/* 4 bitmap defined for blend */
+} vdce_blend_params_t;
+
+/* Structure to	configure edge padding parameters */
+typedef struct vdce_epad_params {
+
+	unsigned char vext_chroma;	/* Vertical extension value for */
+					/* chroma component */
+	unsigned char hext_chroma;	/* horizontal extension value for */
+					/*chroma component */
+	unsigned char vext_luma;	/* Vertical extension value for */
+					/* luma component */
+	unsigned char hext_luma;	/* horizontal extension value for */
+					/*chroma component */
+} vdce_epad_params_t;
+
+/* Structure to	configure input	output format and sizes	*/
+typedef struct vdce_common_params {
+
+	vdce_processing_mode_t src_processing_mode;/* source processing mode */
+						/*interlaced or progressive */
+	vdce_io_mode_t src_mode;	/* src mode field or frame  */
+	vdce_io_mode_t res_mode;	/* res mode field or frame  */
+	vdce_io_mode_t src_bmp_mode;	/* bmp mode field or frame */
+	vdce_proc_control_t proc_control;	/* Luminace processing */
+						/*enable or not */
+	vdce_field_status_t field_status;	/* Top field enable or not */
+
+	unsigned short src_hsz_luminance;/* input horizontal size for */
+					/*luminance component */
+	unsigned short src_vsz_luminance;/* input vertical size for */
+					/*luminance component */
+	unsigned short bmp_vsize;	/* input vertical size for */
+					/*bitmap component */
+	unsigned short bmp_hsize;	/* input horizontal size for */
+					/* bitmap component */
+	unsigned char src_hsp_luminance;/*horizontal starting position */
+					/* for luminance */
+	unsigned char src_vsp_luminance;/* vertical starting position */
+					/* for luminance */
+	unsigned char bmp_hsp_bitmap;	/* hrz starting position for */
+					/* bitmap */
+	unsigned char res_hsp_luminance;/* Hrz starting position for */
+					/*luminance component for res */
+	unsigned char res_vsp_luminance;/* Vertical starting position for */
+					/*luminance component for res */
+	unsigned short dst_hsz_luminance;/* Hrz starting size for */
+					/*luminance component for res */
+	unsigned short dst_vsz_luminance;/* Vertical size for */
+					/*   luminance */
+					/*component for result */
+	unsigned short res_hsp_bitmap;	/* Horizontal starting pos */
+					/*for bitmap component */
+	unsigned short res_vsp_bitmap;	/* vertical starting position */
+					/* for bitmap component */
+	unsigned short prcs_unit_value;/* Hold the prcs value by app */
+} vdce_common_params_t;
+
+/* precodec parameters configuration structure */
+typedef struct vdce_precodec_params {
+	vdce_rsz_params_t rsz_params;
+	vdce_ccv_params_t ccv_params;
+} vdce_precodec_params_t;
+
+/* postcodec parameters	configuration structure	*/
+typedef struct vdce_postcodec_params {
+	vdce_rsz_params_t rsz_params;
+	vdce_rmap_params_t rmap_params;
+	vdce_blend_params_t blend_params;
+	vdce_ccv_params_t ccv_params;
+} vdce_postcodec_params_t;
+
+/* transcodec parameters configuration structure */
+typedef struct vdce_transcodec_params {
+	vdce_rsz_params_t rsz_params;
+	vdce_rmap_params_t rmap_params;
+	vdce_blend_params_t blend_params;
+	vdce_epad_params_t epad_params;
+	vdce_ccv_params_t ccv_params;
+} vdce_transcodec_params_t;
+
+/* Passed for setting VDCE parameters */
+typedef struct vdce_params {
+	vdce_mode_operation_t vdce_mode;
+	/* Bits position for enabling the various sub-modes */
+	/* 1 bit defienes resizing 2 blending 3 range mapping and 4 ccv */
+	unsigned char modes_control;
+	vdce_common_params_t common_params;
+	union {
+		vdce_precodec_params_t precodec_params;
+		vdce_postcodec_params_t postcodec_params;
+		vdce_transcodec_params_t transcodec_params;
+		vdce_epad_params_t epad_params;
+		vdce_rsz_params_t rsz_params;
+		vdce_rmap_params_t rmap_params;
+		vdce_blend_params_t blend_params;
+		vdce_ccv_params_t ccv_params;
+	} vdce_mode_params;
+} vdce_params_t;
+
+/* status parameters structure */
+typedef struct vdce_hw_status {
+	vdce_processing_status_t chan_status;	/* get channel status */
+} vdce_hw_status_t;
+
+/* to allocate the memory*/
+typedef struct vdce_reqbufs {
+
+	vdce_image_type_t buf_type;	/* typeof frame buffer */
+	int count;		/* number of frame buffers to be allocated */
+	int num_lines;		/* Number of lines i.e.vertical pitch for */
+				/* luma componenet */
+	int bytes_per_line;	/* Number of lines i.e.horizontal pitch for */
+				/* luma componenet */
+	vdce_image_fmt_t image_type;	/* Input image format */
+} vdce_reqbufs_t;
+
+/* assessed for	quering	the buffer to get physical address*/
+typedef struct vdce_buffer {
+
+	int index;		/* buffer index number, 0 -> N-1 */
+	vdce_image_type_t buf_type;/* buffer type, input or output */
+	union {
+	unsigned int offset;	/* physical     address of the buffer, */
+	unsigned int virt_ptr;
+	};/* used in the mmap() system call */
+	int size;		/* size */
+} vdce_buffer_t;
+
+/* structure to	be passed while	VDCE oparation */
+typedef struct vdce_address_start {
+	/* 0 is input buffer 1 is output and 2 in bitmap buffer */
+	vdce_buffer_t buffers[3];
+	/* Horizontal and vertical pitch */
+	unsigned int src_horz_pitch;
+	unsigned int res_horz_pitch;
+	unsigned int bmp_pitch;
+} vdce_address_start_t;
+
+#ifdef __KERNEL__
+/* ---------------Driver Structures-------------------------------------------*/
+/* enum for suggesting num of passes required */
+typedef enum vdce_num_pass {
+	VDCE_SINGLE_PASS = 1,	/* VDCE driver will operate in single pass */
+	VDCE_MULTIPASS	/* VDCE driver will operate in Multipass pass */
+} vdce_num_pass_t;
+/* enum for suggesting channel mode */
+typedef enum vdce_mode {
+	VDCE_MODE_BLOCKING = 0,	/* channel opeend in blocking mode */
+	VDCE_MODE_NON_BLOCKING	/* channel opened in non-blocking */
+} vdce_mode_t;
+typedef enum vdce_start_status {
+	VDCE_PASS1_STARTED = 0,
+	VDCE_PASS2_STARTED,
+	VDCE_COMPLETED
+} vdce_start_status_t;
+/* Global structure in driver */
+typedef struct device_params {
+	int module_usage_count;	/* Keeps track of number of open chan */
+	struct completion sem_isr;	/* sem to indicate the completion */
+					/*in case for blocking call */
+	struct semaphore array_sem;	/* sem to protect array entry */
+	struct semaphore device_mutex;	/* sem to protect global variables */
+	struct channel_config *channel_configuration[MAX_CHANNELS];
+	/* Poniter */
+	/* to be stored in Channel Queue */
+	int array_count;	/* Total number of entries in array */
+	void *inter_buffer;	/* Address for inter buffer */
+	unsigned int inter_size; /* Size of intermediate buffer */
+	struct completion edma_sem;
+} device_params_t;
+typedef struct vdce_buffer_info {
+	void *buffers[MAX_BUFFERS];
+	int size;
+	int num_allocated;
+} vdce_buffer_info_t;
+/* Channel specific device structure */
+typedef struct channel_config {
+	struct vdce_hw_config register_config[2];/* Instance of register */
+						/* mapping structure */
+	vdce_num_pass_t num_pass;		/* Single pass or multipass */
+	vdce_buffer_info_t vdce_buffer[3];
+	vdce_params_t get_params;	/*Instance for parameters send */
+						/* by application */
+	vdce_params_t get_params1;
+	int priority;				/* Hold priority of channel */
+	struct completion channel_sem;		/* Completion semaphore to be */
+						/* used for blocking call */
+	struct semaphore chan_protection;	/* Semaphore to protect the */
+						/* channel */
+	vdce_mode_operation_t mode_state;	/* VDCE channel mode */
+	vdce_mode_t channel_mode;		/* Indiacte the blocking or */
+						/* non blocking */
+	int luma_chroma_phased;		/* if 1 indicates luma is phased */
+	vdce_processing_status_t status;	/* Indiacte channel */
+						/*free/pending/busy */
+	vdce_start_status_t vdce_complete;	/* To keep track of isr */
+	vdce_image_fmt_t image_type_out;	/* Input image type */
+	vdce_image_fmt_t image_type_in;		/* Output image type */
+
+} channel_config_t;
+
+typedef struct vdce_debug_info {
+	/* keeps track of number of interrupts */
+	int vdce_interrupt_count;
+	/* keeps track of number of non-block calls */
+	int vdce_nonblock_count;
+	/* keeps track of number of blocking calls */
+	int vdce_block_count;
+} vdce_debug_info_t;
+
+/* ---------------Function definition-----------------------------------------*/
+int malloc_buff(vdce_reqbufs_t *, channel_config_t *);
+int get_buf_address(vdce_buffer_t *, channel_config_t *);
+int free_buff(channel_config_t *);
+int vdce_set_multipass_address(vdce_address_start_t *, channel_config_t *);
+int vdce_set_address(vdce_address_start_t *, channel_config_t *,
+						 int, u32, u32, u32);
+int vdce_start(vdce_address_start_t *, channel_config_t *);
+int add_to_array(channel_config_t *);
+int delete_from_array(void);
+void process_bottomhalf(unsigned long);
+int vdce_get_default(vdce_params_t *);
+int vdce_check_common_params(vdce_params_t *);
+int vdce_set_size_fmt(vdce_common_params_t *, channel_config_t *, int);
+int vdce_set_rszparams(vdce_params_t *, channel_config_t *,
+		     vdce_mode_operation_t, int);
+int vdce_set_epadparams(vdce_epad_params_t *, channel_config_t *, int);
+int vdce_set_ccvparams(vdce_ccv_params_t *, channel_config_t *, int, int);
+int vdce_set_blendparams(vdce_blend_params_t *, channel_config_t *, int, int);
+int vdce_set_rmapparams(vdce_rmap_params_t *, channel_config_t *, int);
+int vdce_set_params(vdce_params_t *, channel_config_t *);
+int vdce_get_params(vdce_params_t *, channel_config_t *);
+int vdce_set_priority(int, channel_config_t *);
+int vdce_get_priority(int *, channel_config_t *);
+int vdce_get_status(vdce_hw_status_t *, channel_config_t *);
+int free_num_buffers(int *, unsigned long, unsigned long);
+irqreturn_t vdce_isr(int, void *, struct pt_regs *);
+#endif
+#endif
Index: linux-2.6.18/include/asm-arm/arch-davinci/davinci_vdce_hw.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/davinci_vdce_hw.h
@@ -0,0 +1,254 @@
+/* *
+ * Copyright (C) 2007 Texas Instruments	Inc
+ *
+ * This	program	is free	software; you can redistribute it and/or modify
+ * it under the	terms of the GNU General Public	License	as published by
+ * the Free Software Foundation; either	version	2 of the License, or
+ * (at your option) any	later version.
+ *
+ * This	program	is distributed in the hope that	it will	be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A	PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59	Temple Place, Suite 330, Boston, MA 02111-1307	USA
+ */
+/* davinci_vdce_hw.h	file */
+#ifndef	DAVINCI_VDCE_HW_H
+#define	DAVINCI_VDCE_HW_H
+#ifdef __KERNEL__
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+#endif
+#define	MAX_BLEND_TABLE			  4
+/* Register	offset mapping*/
+#ifdef __KERNEL__
+#define	BITSET(variable,bit)		((variable)| (1<<bit))
+#define	BITRESET(variable,bit)		((variable)& (~(0x00000001<<(bit))))
+#define	BITGET(variable,bit)		(((variable)& (1<<bit))>>(bit))
+
+/* Bit position for various bits . Used in BITSET */
+#define	 SET_CCV_V_TYPE		(2)
+#define	 SET_CCV_H_TYPE		(3)
+#define	 SET_CCV_IN_MPEG1	(1)
+#define	 SET_CCV_OUT_MPEG1	(0)
+#define	 SET_CCV_ENABLE		(10)
+#define	 VDCE_RASTER_SCANNING	(0)
+/* Bits position number to be used in bitset for setting various registers */
+#define	SET_HRSZ_ENABLE		(0)
+#define	SET_VRSZ_ENABLE		(4)
+#define	SET_HRSZ_ALF_ENABLE	(8)
+#define	SET_VRSZ_ALF_ENABLE	(12)
+#define	SET_RSZ_H_TYPE		(1)
+#define	SET_RSZ_V_TYPE		(5)
+#define	SET_RSZ_H_ALF_mode	(9)
+#define	SET_LUMA_ENABLE		(1)
+#define	SET_CHROMA_ENABLE	(2)
+#define	SET_TOP_ENABLE		(7)
+#define	SET_BOT_ENABLE		(6)
+#define	SET_SRC_MODE		(14)
+#define	SET_RES_MODE		(13)
+#define	SET_BMP_MODE		(15)
+#define	SET_PRO_MODE		(12)
+/* various modes supported in hardware. The value generated by them */
+#define	MODE_PRECODEC		(2)
+#define	MODE_POSTCODEC		(3)
+#define	MODE_TRANSCODEC		(1)
+#define	MODE_EPAD		(0)
+
+#define	SET_RSZ_ENABLE		(8)
+#define	SET_RMAP_ENABLE		(9)
+#define	SET_BLEND_ENABLE	(11)
+#define	FOUR_TWO_TWO		(1)
+#define	SET_RMAP_YENABLE	(3)
+#define	SET_RMAP_CENABLE	(11)
+
+/* various shifts and masks of register */
+#define	LUMA_CHROMA_ENABLE_MASK	(0x6)
+#define	LUMA_CHROMA_ENABLE_SHIFT (0x1)
+#define	TOP_BOTTOM_ENABLE_MASK	(0xc0)
+#define	TOP_BOTTOM_ENABLE_SHIFT	(0x6)
+
+/* Mask and shift values for range mapping registers */
+#define	RANGE_MAP_Y_SHIFT	(0)
+#define	RANGE_MAP_Y_MASK	(0x7<<RANGE_MAP_Y_SHIFT)
+#define	RANGE_MAP_C_SHIFT	(8)
+#define	RANGE_MAP_C_MASK	(0x7<<RANGE_MAP_C_SHIFT)
+/* Mask and shift values for Blending registers */
+#define	BLD_LUT_Y_SHIFT		(16)
+#define	BLD_LUT_Y_MASK		(0xff<<BLD_LUT_Y_SHIFT)
+#define	BLD_LUT_CB_SHIFT	(0)
+#define	BLD_LUT_CB_MASK		(0xff<<BLD_LUT_CB_SHIFT)
+#define	BLD_LUT_CR_SHIFT	(8)
+#define	BLD_LUT_CR_MASK		(0xff<<BLD_LUT_CR_SHIFT)
+#define	BLD_LUT_FCT_SHIFT	(24)
+#define	BLD_LUT_FCT_MASK	(0xff<<BLD_LUT_FCT_SHIFT)
+/* Mask and shift values for Edgepadding registers */
+#define	EPD_C_HEXT_SHIFT	(0)
+#define	EPD_C_HEXT_MASK		(0x3f<<EPD_C_HEXT_SHIFT)
+#define	EPD_C_VEXT_SHIFT	(8)
+#define	EPD_C_VEXT_MASK		(0x3f<<EPD_C_VEXT_SHIFT	 )
+#define	EPD_Y_VEXT_SHIFT	(8)
+#define	EPD_Y_VEXT_MASK		(0x3f<<EPD_Y_VEXT_SHIFT)
+#define	EPD_Y_HEXT_SHIFT	(0)
+#define	EPD_Y_HEXT_MASK		(0x3f<<EPD_Y_HEXT_SHIFT	)
+/* Mask and shift values for Resizing registers */
+#define	RSZ_H_MAG_SHIFT		(0)
+#define	RSZ_H_MAG_MASK		(0xfff<<RSZ_H_MAG_SHIFT	)
+#define	RSZ_V_MAG_SHIFT		(0)
+#define	RSZ_V_MAG_MASK		(0xfff<<RSZ_V_MAG_SHIFT	)
+
+#define	VDCE_REQ_SZ_SHIFT		(0)
+#define	VDCE_REQ_SZ_MASK		(0x1ff<<VDCE_REQ_SZ_SHIFT	)
+#define	VDCE_PRCS_UNIT_SIZE_SHIFT	 (0)
+#define	VDCE_PRCS_UNIT_SIZE_MASK	 (0x1ff<<VDCE_PRCS_UNIT_SIZE_SHIFT )
+/* source and result image size shift and mask */
+#define	SRC_Y_HSZ_SHIFT		(0)
+#define	SRC_Y_HSZ_MASK		(0xfff<<SRC_Y_HSZ_SHIFT	)
+#define	SRC_Y_VSZ_SHIFT		(16)
+#define	SRC_Y_VSZ_MASK		(0xfff<<SRC_Y_VSZ_SHIFT	)
+#define	RES_Y_HSZ_SHIFT		(0)
+#define	RES_Y_HSZ_MASK		(0xfff<<SRC_Y_HSZ_SHIFT	)
+#define	RES_Y_VSZ_SHIFT		(16)
+#define	RES_Y_VSZ_MASK		(0xfff<<RES_Y_VSZ_SHIFT	)
+#define	SRC_C_HSZ_SHIFT		(0)
+#define	SRC_C_HSZ_MASK		(0xfff<<SRC_C_HSZ_SHIFT	)
+#define	SRC_C_VSZ_SHIFT		(16)
+#define	SRC_C_VSZ_MASK		(0xfff<<SRC_C_VSZ_SHIFT	 )
+#define	RES_C_HSZ_SHIFT		(0)
+#define	RES_C_HSZ_MASK		(0xfff<<RES_C_HSZ_SHIFT	)
+#define	RES_C_VSZ_SHIFT		(16)
+#define	RES_C_VSZ_MASK		(0xfff<<RES_C_VSZ_SHIFT)
+#define	SRC_BMP_HSZ_SHIFT	(0)
+#define	SRC_BMP_HSZ_MASK	(0xfff<<SRC_BMP_HSZ_SHIFT )
+#define	SRC_BMP_VSZ_SHIFT	(16)
+#define	SRC_BMP_VSZ_MASK	(0xfff<<SRC_BMP_VSZ_SHIFT )
+#define	SRC_BMP_STRT_HPS_SHIFT	  (0)
+#define	SRC_BMP_STRT_HPS_MASK	  (0xfff<<SRC_BMP_STRT_HPS_SHIFT)
+#define	RES_BMP_STRT_VPS_SHIFT	(16)
+#define	RES_BMP_STRT_VPS_MASK	(0xfff<<RES_BMP_STRT_VPS_SHIFT )
+
+#define	VDCE_MODE_SHIFT		(4)
+#define	VDCE_MODE_MASK		(0x3 <<VDCE_MODE_SHIFT )
+#define	RSZ_ALF_INTENSITY_SHIFT	(0)
+#define	RSZ_ALF_INTENSITY_MASK	(0xff)
+/* Base address and offset for various ge registers */
+#define	VDCE_IOBASE_VADDR	IO_ADDRESS(0x01c12800)
+#define	VDCE_ENABLE		(0x0)
+#define	VDCE_CTRL		(0x04)
+#define	VDCE_INTEN		(0x08)
+#define	VDCE_INTEN_SET		(0x0c)
+#define	VDCE_EMULATION_CTRL	(0x1c)
+#define	VDCE_STATUS		(0x14)
+#define	VDCE_STATUS_CLR		(0x18)
+#define	VDCE_SDR_FMT		(0x20)
+#define	VDCE_REQ_SZ		(0x24)
+#define	VDCE_PRCS_UNIT_SIZE	(0x28)
+#define	VDCE_SRC_STRT_ADD_YTOP	(0x40)
+#define	VDCE_SRC_STRT_OFF_YTOP	(0x48)
+#define	VDCE_SRC_STRT_ADD_YBOT	(0x4c)
+#define	VDCE_SRC_STRT_OFF_YBOT	(0x54)
+#define	VDCE_SRC_STRT_ADD_CTOP	(0x58)
+#define	VDCE_SRC_STRT_OFF_CTOP	(0x60)
+#define	VDCE_SRC_STRT_ADD_CBOT	(0x64)
+#define	VDCE_SRC_STRT_OFF_CBOT	(0x6c)
+#define	VDCE_SRC_STRT_ADD_BMP_TOP	(0x70)
+#define	VDCE_SRC_STRT_OFF_BMP_TOP	(0x74)
+#define	VDCE_SRC_STRT_ADD_BMP_BOT	(0x78)
+#define	VDCE_SRC_STRT_OFF_BMP_BOT	(0x7c)
+#define	VDCE_RES_STRT_ADD_YTOP	(0x80)
+#define	VDCE_RES_STRT_OFF_YTOP	(0x88)
+#define	VDCE_RES_STRT_ADD_YBOT	(0x8c)
+#define	VDCE_RES_STRT_OFF_YBOT	(0x94)
+#define	VDCE_RES_STRT_ADD_CTOP	(0x98)
+#define	VDCE_RES_STRT_OFF_CTOP	(0xa0)
+#define	VDCE_RES_STRT_ADD_CBOT	(0xa4)
+#define	VDCE_RES_STRT_OFF_CBOT	(0xac)
+#define	SRC_Y_STRT_PS		(0xc0)
+#define	SRC_Y_SZ		(0xc4)
+#define	SRC_C_STRT_PS		(0xc8)
+#define	SRC_C_SZ		(0xcc)
+#define	SRC_BMP_STRT_PS		(0xd0)
+#define	SRC_BMP_SZ		(0xd4)
+#define	RES_Y_STRT_PS		(0xe0)
+#define	RES_Y_SZ		(0xe4)
+#define	RES_C_STRT_PS		(0xe8)
+#define	RES_C_SZ		(0xec)
+#define	RES_BMP_STRT_PS		(0xf0)
+#define	RSZ_MODE		(0x100)
+#define	RSZ_H_MAG		(0x104)
+#define	RSZ_V_MAG		(0x108)
+#define	RSZ_H_PHASE		(0x10c)
+#define	RSZ_V_PHASE		(0x110)
+#define	RSZ_ALF_INTENSITY	(0x114)
+#define	CCV_MODE		(0x120)
+#define	BLD_LUT_00		(0x140)
+#define	BLD_LUT_01		(0x144)
+#define	BLD_LUT_02		(0x148)
+#define	BLD_LUT_03		(0x14c)
+#define	RGMP_CTRL		(0x160)
+#define	EPD_LUMA_WIDTH		(0x184)
+#define	EPD_CHROMA_WIDTH	(0x188)
+/* Register read/write */
+#define	regw(val,reg)		outl(val,((reg)+ VDCE_IOBASE_VADDR))
+#define	regr(reg)		inl((reg)+VDCE_IOBASE_VADDR)
+
+/* register mapping structure */
+typedef struct vdce_hw_config {
+	unsigned int vdce_ctrl;
+	unsigned int vdce_emulation_ctrl;
+	unsigned int vdce_sdr_fmt;
+	unsigned int vdce_req_sz;
+	unsigned int vdce_prcs_unit_size;
+	u32 src_Y_strt_ps;
+	u32 src_Y_sz;
+	u32 src_C_strt_ps;
+	u32 src_C_sz;
+	u32 src_bmp_strt_ps;
+	u32 src_bmp_sz;
+	u32 res_Y_strt_ps;
+	u32 res_Y_sz;
+	u32 res_C_strt_ps;
+	u32 res_C_sz;
+	u32 res_bmp_strt_ps;
+	unsigned int vdce_src_strt_add_ytop;
+	unsigned int vdce_src_strt_add_ctop;
+	unsigned int vdce_src_strt_add_ybot;
+	unsigned int vdce_src_strt_add_cbot;
+	unsigned int vdce_res_strt_add_ytop;
+	unsigned int vdce_res_strt_add_ctop;
+	unsigned int vdce_res_strt_add_ybot;
+	unsigned int vdce_res_strt_add_cbot;
+	unsigned int vdce_src_add_ofst_ytop;
+	unsigned int vdce_src_add_ofst_ctop;
+	unsigned int vdce_src_add_ofst_ybot;
+	unsigned int vdce_src_add_ofst_cbot;
+	unsigned int vdce_src_strt_add_bmp_top;
+	unsigned int vdce_src_strt_add_bmp_bot;
+	unsigned int vdce_src_strt_off_bmp_top;
+	unsigned int vdce_src_strt_off_bmp_bot;
+	unsigned int vdce_res_strt_off_ytop;
+	unsigned int vdce_res_strt_off_ctop;
+	unsigned int vdce_res_strt_off_ybot;
+	unsigned int vdce_res_strt_off_cbot;
+	u32 rsz_mode;
+	u32 rsz_h_mag;
+	u32 rsz_v_mag;
+	u32 rsz_h_phase;
+	u32 rsz_v_phase;
+	u32 rsz_alf_intensity;
+	u32 ccv_mode;
+	u32 bld_lut[MAX_BLEND_TABLE];
+	u32 rgmp_ctrl;
+	u32 epd_luma_width;
+	u32 epd_chroma_width;
+} vdce_hw_config_t;
+
+int vdce_enable_int(void);
+int vdce_clear_status(void);
+int vdce_enable(vdce_hw_config_t *);
+void vdce_hw_setup(vdce_hw_config_t *);
+#endif
+#endif
Index: linux-2.6.18/include/media/davinci/adv7343.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/adv7343.h
@@ -0,0 +1,768 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*adv7343.h*/
+
+#ifndef ADV7343_H
+#define ADV7343_H
+
+#ifdef __KERNEL__
+
+/* Kernel Header files */
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <media/davinci/vid_encoder_types.h>
+
+#endif				/* __KERNEL__ */
+
+/* Macros */
+#define ADV7343_MAX_GAMMA_COEFFS	10	/* Maximum Gamma Coefficients */
+
+/* Enums */
+/* Enum for type of parameters */
+enum adv7343_params_type {
+	ADV7343_SDPARAMS = 0,	/* Indicates SD parameters */
+	ADV7343_HDPARAMS	/* Indicates HD parameters */
+};
+
+/* Enum for DNR modes */
+enum adv7343_dnr_mode {
+	ADV7343_MODE_DNR = 0,	/* Indicates DNR Mode */
+	ADV7343_MODE_DNR_SHARPNESS	/* Indicates DNR Sharpness Mode */
+};
+
+/* Enum for DNR block size */
+enum adv7343_dnr_blocksize {
+	ADV7343_DNR_BLOCK_8 = 0,	/* Indicates DNR block of 8x8 */
+	ADV7343_DNR_BLOCK_16	/* Indicates DNR block of 16x16 */
+};
+
+/* Enum for SD Luma filters */
+enum adv7343_sd_luma_filter {
+	ADV7343_LUMA_LPF_NTSC = 0,	/* HD Luma LPF Filter for NTSC */
+	ADV7343_LUMA_LPF_PAL,	/* HD Luma LPF Filter for PAL */
+	ADV7343_LUMA_NOTCH_NTSC,	/* HD Luma Notch Filter for NTSC */
+	ADV7343_LUMA_NOTCH_PAL,	/* HD Luma Notch Filter for NTSC */
+	ADV7343_LUMA_SSAF,	/* HD Luma SSAF Filter */
+	ADV7343_LUMA_CIF,	/* HD Luma CIF Filter */
+	ADV7343_LUMA_QCIF	/* HD Luma QCIF Filter */
+};
+
+/* Enum for SD Chroma filters */
+enum adv7343_sd_chroma_filter {
+	ADV7343_CHROMA_0_65 = 0,	/* SD Chroma 0.65MHz LPF */
+	ADV7343_CHROMA_1_0,	/* SD Chroma 1.0MHz LPF */
+	ADV7343_CHROMA_1_3,	/* SD Chroma 1.3MHz LPF */
+	ADV7343_CHROMA_2_0,	/* SD Chroma 2.0MHz LPF */
+	ADV7343_CHROMA_2_3,	/* SD Chroma 2.3MHz LPF */
+	ADV7343_CHROMA_CIF,	/* SD Chroma CIF Response LPF */
+	ADV7343_CHROMA_QCIF,	/* SD Chroma QCIF Response LPF */
+	ADV7343_CHROMA_SSAF,	/* SD SSAF Color difference filter */
+};
+
+/* Enum for HD Filters */
+enum adv7343_hd_filter {
+	ADV7343_SINC_FILTER = 1,	/* HD Sync filter on DAC D,E,F */
+	ADV7343_HD_CHROMA_SSAF = 2	/* HD Chroma SSAF filter */
+};
+
+/* Enum for selecting DNR filter */
+enum adv7343_dnr_filter {
+	ADV7343_DNR_FILTER_A = 0,	/* DNR Filter A */
+	ADV7343_DNR_FILTER_B,	/* DNR Filter B */
+	ADV7343_DNR_FILTER_C,	/* DNR Filter C */
+	ADV7343_DNR_FILTER_D	/* DNR Filter D */
+};
+
+/* Enum for selecting adaptive filter modes */
+enum adv7343_filter_mode {
+	ADV7343_FILTER_MODE_SHARPNESS = 0,	/* Adaptive Filter Sharpness
+						   mode */
+	ADV7343_FILTER_MODE_A,	/* Adaptive Filter Mode A */
+	ADV7343_FILTER_MODE_B	/* Adaptive Filter Mode B */
+};
+
+/* Enum for Border AREA DNR */
+enum adv7343_dnr_border_area {
+	ADV7343_BORDER_AREA_2 = 0,	/* Border area size is 2 pixels */
+	ADV7343_BORDER_AREA_4	/* Border area size is 4 pixels */
+};
+
+/* Enum for feature control */
+enum adv7343_feature {
+	ADV7343_DISABLE = 0,
+	ADV7343_ENABLE
+};
+/* structure */
+/* RGB Matrix for HD */
+struct adv7343_rgb_matrix {
+	enum adv7343_feature en_rgb_matrix;	/* Enables/Disabled
+						   RGB matrix */
+	unsigned short gy;	/* RGB Coeffs */
+	unsigned short gu;
+	unsigned short gv;
+	unsigned short bu;
+	unsigned short rv;
+};
+
+/* Filter parameters for HD */
+struct adv7343_filter_params {
+	enum adv7343_feature en_filter;	/* Used to enable/disable filters */
+	enum adv7343_filter_mode mode;	/* mode of the sharpness and adaptive
+					   filter */
+	unsigned char threshold_a;	/* Adaptive filter threshold A */
+	unsigned char threshold_b;	/* Adaptive filter threshold B */
+	unsigned char threshold_c;	/* Adaptive filter threshold C */
+	unsigned char gain1_vala;	/* Adaptive filter Gain1 Value A */
+	unsigned char gain1_valb;	/* Adaptive filter Gain1 Value B */
+	unsigned char gain2_vala;	/* Adaptive filter Gain2 Value A */
+	unsigned char gain2_valb;	/* Adaptive filter Gain2 Value B */
+	unsigned char gain3_vala;	/* Adaptive filter Gain3 Value A */
+	unsigned char gain3_valb;	/* Adaptive filter Gain3 Value B */
+	unsigned char sharpness;	/* Sharpness value */
+};
+
+/* DNR parameters structure */
+struct adv7343_dnr_params {
+	enum adv7343_feature en_dnr;	/* enables/disables DNR */
+	enum adv7343_dnr_mode mode;	/* Selects DNR Mode */
+	enum adv7343_dnr_blocksize block_size;	/* block size for DNR */
+	enum adv7343_dnr_border_area area;	/* Block size */
+	unsigned char border_gain;	/* Gain for the border of
+					   block */
+	unsigned char data_gain;	/* Gain for data except
+					   border of block */
+	enum adv7343_dnr_filter filt_select;	/* Selects on filter */
+	unsigned char block_offset;	/* Block offset */
+	unsigned char threshold;	/* DNR threshold */
+};
+
+/* SSAF Parameters structure */
+struct adv7343_ssaf_params {
+	enum adv7343_feature en_gain;	/* Enables/disables gain */
+	unsigned char gain;	/* Value of Gain */
+};
+
+/* SD Y and PbPr scaling parameters */
+struct adv7343_scale_params {
+	enum adv7343_feature en_scale;	/* This enabled/disabled scaling */
+	unsigned short y_scale;	/* Value of scaling for Y data */
+	unsigned short pb_scale;	/* Value of scaling for Pb data */
+	unsigned short pr_scale;	/* Value of scaling for Pr data */
+};
+
+/* Used to select gamma curve */
+enum adv7343_gamma_curve {
+	ADV7343_GAMMA_CURVE_A = 0,
+	ADV7343_GAMMA_CURVE_B
+};
+
+struct adv7343_gamma_params {
+	enum adv7343_feature en_gamma;	/* enables/disables
+					   gamma correction */
+	enum adv7343_gamma_curve curve;	/* Selects gamma
+					   correction curve */
+	unsigned char coeff[ADV7343_MAX_GAMMA_COEFFS];	/* Gamma correction
+							   coefficients */
+};
+
+/* SD Parameters structure */
+struct adv7343_sd_params {
+	enum adv7343_sd_luma_filter luma_filter;	/* SD Luma Filter */
+	enum adv7343_sd_chroma_filter chroma_filter;	/* SD Chroma Filter */
+	struct adv7343_ssaf_params ssaf;	/* SSAF Parameters */
+	struct adv7343_scale_params scale;	/* scaling parameters */
+	struct adv7343_dnr_params dnr;	/* DNR Parameters */
+	enum adv7343_feature active_step_edge_scale;	/* Enabled/disables
+							   active edge and
+							   step edge scale */
+	struct adv7343_gamma_params gamma;	/* gamma parameters */
+};
+
+/* HD Parameter structure */
+struct adv7343_hd_params {
+	enum adv7343_feature sinc_filter;	/* HD Sinc Filter */
+	enum adv7343_feature ssaf_filter;	/* HD ssaf Filter */
+	struct adv7343_rgb_matrix rgb;	/* RGB Matrix coefficients */
+	struct adv7343_filter_params filt_params;	/* Filter parameters */
+	struct adv7343_gamma_params gamma;	/* Gamma parameters */
+};
+
+/* ADV7343 parameters structure */
+typedef struct {
+	enum adv7343_params_type type;	/* Type of parameters SD or
+					   HD */
+	union {
+		struct adv7343_sd_params sd;	/* SD Parameters */
+		struct adv7343_hd_params hd;	/* HD Parameters */
+	} params;
+} adv7343_params;
+
+#ifdef __KERNEL__
+
+#define ADV7343_COMPOSITE_OUTPUT_NAME  	"COMPOSITE"
+#define ADV7343_COMPONENT_OUTPUT_NAME  	"COMPONENT"
+#define ADV7343_SVIDEO_OUTPUT_NAME	"SVIDEO"
+
+#define ADV7343_COMPOSITE_ID		0
+#define ADV7343_COMPONENT_ID		1
+#define ADV7343_SVIDEO_ID		2
+
+#define ADV7343_COMPOSITE_NO_CONTROLS		(3)
+#define ADV7343_COMPONENT_NO_CONTROLS		(1)
+#define ADV7343_SVIDEO_NO_CONTROLS		(3)
+
+#define ADV7343_NUM_CHANNELS			(1)
+
+/* encoder standard related strctures */
+#define ADV7343_MAX_NO_OUTPUTS			(3)
+#define ADV7343_COMPOSITE_NUM_STD		(2)
+#define ADV7343_COMPONENT_NUM_STD		(7+3+3)
+#define ADV7343_SVIDEO_NUM_STD			(2)
+#define ADV7343_MAX_NO_CONTROLS			(3)
+#define ADV7343_VBI_NUM_SERVICES		(3)
+
+struct adv7343_std_info {
+	unsigned char set_std_register;
+	volatile unsigned char *value;
+	u32 outputmode_val1;
+	u32 standard_val2;
+	u32 standard_val3;
+	u8 fsc0_reg, fsc0_val;
+	u8 fsc1_reg, fsc1_val;
+	u8 fsc2_reg, fsc2_val;
+	u8 fsc3_reg, fsc3_val;
+};
+
+struct adv7343_control_info {
+	int register_address;
+	int value;
+	enum vid_enc_ctrl_id id;
+	int minimum, maximum;
+};
+
+struct adv7343_config {
+	int no_of_outputs;
+	struct {
+		unsigned char power_val;
+		int output_type;
+		char output_name[VID_ENC_NAME_MAX_CHARS];
+		int no_of_standard;
+		struct vid_enc_mode_info *standard;
+		struct vid_enc_mode_info *def_std;
+		struct adv7343_std_info *std_info;
+		int no_of_controls;
+		struct adv7343_control_info *controls;
+	} output[ADV7343_MAX_NO_OUTPUTS];
+	unsigned short services_set;
+	u8 num_services;
+};
+
+struct adv7343_channel {
+	struct {
+		struct i2c_client client;
+		struct i2c_driver driver;
+		u8 i2c_addr;
+		int i2c_registration;
+	} i2c_dev;
+	struct vid_encoder_device *enc_device;
+	u8 current_output;
+	struct vid_enc_mode_info *mode_info;
+	unsigned short services_set;
+	adv7343_params params;
+};
+
+struct adv7343_service_data_reg {
+	u32 service_set;
+	struct {
+		u8 addr[2];
+	} field[2];
+	u8 bytestowrite;
+};
+
+struct adv7343_service_reg {
+	u32 service;
+	u8 reg;
+	u8 *reg_val;
+	u8 enable_val;
+	u8 disable_val;
+	struct vid_enc_mode_info *std;
+};
+
+#define ADV7343_VALID_FEATURE_VAL(val) ((ADV7343_DISABLE == (val))|| \
+					(ADV7343_ENABLE == (val)))
+#define ADV7343_VALID_GAMMA_CURVE(val) ((ADV7343_GAMMA_CURVE_A == (val))|| \
+					(ADV7343_GAMMA_CURVE_B == (val)))
+
+/* Register Macros */
+#define ADV7343_POWER_MODE_REG			0x00
+#define ADV7343_MODE_SELECT_REG			0X01
+#define ADV7343_MODE_REG0			0x02
+#define ADV7343_CSC_MATRIX0			0x03
+#define ADV7343_CSC_MATRIX1			0x04
+#define ADV7343_CSC_MATRIX2			0x05
+#define ADV7343_CSC_MATRIX3			0x06
+#define ADV7343_CSC_MATRIX4			0x07
+#define ADV7343_CSC_MATRIX5			0x08
+#define ADV7343_CSC_MATRIX6			0x09
+#define ADV7343_DAC1_OUTPUT_LEVEL		0x0a
+#define ADV7343_DAC2_OUTPUT_LEVEL		0x0b
+#define ADV7343_DAC_POWER_MODE			0x0d
+#define ADV7343_CABLE_DETECTION			0x10
+#define ADV7343_SBUS_READ			0x12
+#define ADV7343_YBUS_READ			0x13
+#define ADV7343_CBUS_READ			0x14
+#define ADV7343_CONTROL_READ			0x16
+#define ADV7343_SOFT_RESET			0x17
+#define ADV7343_HD_MODE_REG1			0x30
+#define ADV7343_HD_MODE_REG2			0x31
+#define ADV7343_HD_MODE_REG3			0x32
+#define ADV7343_HD_MODE_REG4			0x33
+#define ADV7343_HD_MODE_REG5			0x34
+#define ADV7343_HD_MODE_REG6			0x35
+#define ADV7343_HD_Y_LEVEL			0x36
+#define ADV7343_HD_CR_LEVEL			0x37
+#define ADV7343_HD_CB_LEVEL			0x38
+#define ADV7343_HD_MODE_REG7			0x39
+#define ADV7343_HD_SHARPNESS_FLTR_GAIN		0x40
+#define ADV7343_HD_CGMS_DATA_0			0x41
+#define ADV7343_HD_CGMS_DATA_1			0x42
+#define ADV7343_HD_CGMS_DATA_2			0x43
+#define ADV7343_HD_GAMMA_A0			0x44
+#define ADV7343_HD_GAMMA_A1			0x45
+#define ADV7343_HD_GAMMA_A2			0x46
+#define ADV7343_HD_GAMMA_A3			0x47
+#define ADV7343_HD_GAMMA_A4			0x48
+#define ADV7343_HD_GAMMA_A5			0x49
+#define ADV7343_HD_GAMMA_A6			0x4a
+#define ADV7343_HD_GAMMA_A7			0x4b
+#define ADV7343_HD_GAMMA_A8			0x4c
+#define ADV7343_HD_GAMMA_A9			0x4d
+#define ADV7343_HD_GAMMA_B0			0x4E
+#define ADV7343_HD_GAMMA_B1			0x4F
+#define ADV7343_HD_GAMMA_B2			0x50
+#define ADV7343_HD_GAMMA_B3			0x51
+#define ADV7343_HD_GAMMA_B4			0x52
+#define ADV7343_HD_GAMMA_B5			0x53
+#define ADV7343_HD_GAMMA_B6			0x54
+#define ADV7343_HD_GAMMA_B7			0x55
+#define ADV7343_HD_GAMMA_B8			0x56
+#define ADV7343_HD_GAMMA_B9			0x57
+#define ADV7343_HD_ADPT_FLTR_GAIN1		0x58
+#define ADV7343_HD_ADPT_FLTR_GAIN2		0x59
+#define ADV7343_HD_ADPT_FLTR_GAIN3		0x5a
+#define ADV7343_HD_ADPT_FLTR_THRLDA		0x5b
+#define ADV7343_HD_ADPT_FLTR_THRLDB		0x5c
+#define ADV7343_HD_ADPT_FLTR_THRLDC		0x5d
+#define ADV7343_HD_CGMS_B0			0x5E
+#define ADV7343_HD_CGMS_B1			0x5F
+#define ADV7343_HD_CGMS_B2			0x60
+#define ADV7343_HD_CGMS_B3			0x61
+#define ADV7343_HD_CGMS_B4			0x62
+#define ADV7343_HD_CGMS_B5			0x63
+#define ADV7343_HD_CGMS_B6			0x64
+#define ADV7343_HD_CGMS_B7			0x65
+#define ADV7343_HD_CGMS_B8			0x66
+#define ADV7343_HD_CGMS_B9			0x67
+#define ADV7343_HD_CGMS_B10			0x68
+#define ADV7343_HD_CGMS_B11			0x69
+#define ADV7343_HD_CGMS_B12			0x6A
+#define ADV7343_HD_CGMS_B13			0x6B
+#define ADV7343_HD_CGMS_B14			0x6C
+#define ADV7343_HD_CGMS_B15			0x6D
+#define ADV7343_HD_CGMS_B16			0x6E
+
+#define ADV7343_SD_MODE_REG1			0x80
+#define ADV7343_SD_MODE_REG2			0x82
+#define ADV7343_SD_MODE_REG3			0x83
+#define ADV7343_SD_MODE_REG4			0x84
+#define ADV7343_SD_MODE_REG5			0x86
+#define ADV7343_SD_MODE_REG6			0x87
+#define ADV7343_SD_MODE_REG7			0x88
+#define ADV7343_SD_MODE_REG8			0x89
+#define ADV7343_SD_TIMING_REG0			0x8A
+#define ADV7343_SD_TIMING_REG1			0x8B
+#define ADV7343_SD_FSC_REG0			0x8C
+#define ADV7343_SD_FSC_REG1			0x8D
+#define ADV7343_SD_FSC_REG2			0x8E
+#define ADV7343_SD_FSC_REG3			0x8F
+#define ADV7343_SD_FSC_PHASE			0x90
+#define ADV7343_SD_CLOSE_CAPTION_EVEN0		0x91
+#define ADV7343_SD_CLOSE_CAPTION_EVEN1		0x92
+#define ADV7343_SD_CLOSE_CAPTION_ODD0		0x93
+#define ADV7343_SD_CLOSE_CAPTION_ODD1		0x94
+#define ADV7343_SD_PEDESTAL_REG0		0x95
+#define ADV7343_SD_PEDESTAL_REG1		0x96
+#define ADV7343_SD_PEDESTAL_REG2		0x97
+#define ADV7343_SD_PEDESTAL_REG3		0x98
+#define ADV7343_SD_CGMS_WSS0			0x99
+#define ADV7343_SD_CGMS_WSS1			0x9A
+#define ADV7343_SD_CGMS_WSS2			0x9B
+
+#define ADV7343_SD_SCALE_LSB			0x9C
+#define ADV7343_SD_Y_SCALE			0x9D
+#define ADV7343_SD_CB_SCALE			0x9E
+#define ADV7343_SD_CR_SCALE			0x9F
+
+#define ADV7343_SD_HUE_REG			0xA0
+#define ADV7343_SD_BRIGHTNESS_WSS		0xA1
+#define ADV7343_SD_LUMA_SSAF			0xA2
+#define ADV7343_SD_DNR0				0xA3
+#define ADV7343_SD_DNR1				0xA4
+#define ADV7343_SD_DNR2				0xA5
+
+#define ADV7343_SD_GAMMA_A0			0xA6
+#define ADV7343_SD_GAMMA_A1			0xA7
+#define ADV7343_SD_GAMMA_A2			0xA8
+#define ADV7343_SD_GAMMA_A3			0xA9
+#define ADV7343_SD_GAMMA_A4			0xAA
+#define ADV7343_SD_GAMMA_A5			0xAB
+#define ADV7343_SD_GAMMA_A6			0xAC
+#define ADV7343_SD_GAMMA_A7			0xAD
+#define ADV7343_SD_GAMMA_A8			0xAE
+#define ADV7343_SD_GAMMA_A9			0xAF
+#define ADV7343_SD_GAMMA_B0			0xB0
+#define ADV7343_SD_GAMMA_B1			0xB1
+#define ADV7343_SD_GAMMA_B2			0xB2
+#define ADV7343_SD_GAMMA_B3			0xB3
+#define ADV7343_SD_GAMMA_B4			0xB4
+#define ADV7343_SD_GAMMA_B5			0xB5
+#define ADV7343_SD_GAMMA_B6			0xB6
+#define ADV7343_SD_GAMMA_B7			0xB7
+#define ADV7343_SD_GAMMA_B8			0xB8
+#define ADV7343_SD_GAMMA_B9			0xB9
+#define ADV7343_SD_BRIGHTNESS_DETECT		0xBA
+#define ADV7343_FIELD_COUNT_REG			0xBB
+#define ADV7343_10_BIT_INPUT			0x7C
+
+/* Default values for the registers */
+#define ADV7343_POWER_MODE_REG_DEFAULT		0x10	/* Changed */
+#define ADV7343_MODE_SELECT_REG_DEFAULT		0X00
+#define ADV7343_MODE_REG0_DEFAULT		0x20	/* Doubt on Sync
+							   signals */
+#define ADV7343_DAC1_OUTPUT_LEVEL_DEFAULT	0x00
+#define ADV7343_DAC2_OUTPUT_LEVEL_DEFAULT	0x00
+#define ADV7343_HD_MODE_REG1_DEFAULT		0x3C	/* Changed Default
+							   720p and EAV/SAV
+							   code */
+#define ADV7343_HD_MODE_REG2_DEFAULT		0x01	/* Changed Pixel data
+							   valid */
+#define ADV7343_HD_MODE_REG3_DEFAULT		0x00	/* Color delay is 0
+							   clks */
+#define ADV7343_HD_MODE_REG4_DEFAULT		0xE8	/* Changed */
+#define ADV7343_HD_MODE_REG5_DEFAULT		0x08
+#define ADV7343_HD_MODE_REG6_DEFAULT		0x00
+#define ADV7343_HD_MODE_REG7_DEFAULT		0x00
+
+#define ADV7343_SD_MODE_REG1_DEFAULT		0x00
+#define ADV7343_SD_MODE_REG2_DEFAULT		0xC9	/* Changed */
+#define ADV7343_SD_MODE_REG3_DEFAULT		0x10	/* Changed */
+#define ADV7343_SD_MODE_REG4_DEFAULT		0x01
+#define ADV7343_SD_MODE_REG5_DEFAULT		0x02
+#define ADV7343_SD_MODE_REG6_DEFAULT		0x0C	/*0x00 */
+#define ADV7343_SD_MODE_REG7_DEFAULT		0x04
+#define ADV7343_SD_MODE_REG8_DEFAULT		0x00
+#define ADV7343_SD_TIMING_REG0_DEFAULT		0x08
+#define ADV7343_SD_TIMING_REG1_DEFAULT		0x00
+#define ADV7343_SOFT_RESET_DEFAULT		0x02
+#define ADV7343_COMPOSITE_POWER_VALUE		0x80
+#define ADV7343_COMPONENT_POWER_VALUE		0x1C
+#define ADV7343_SVIDEO_POWER_VALUE		0x60
+#define ADV7343_SD_HUE_REG_DEFAULT		127
+#define ADV7343_SD_BRIGHTNESS_WSS_DEFAULT	0x03
+#define ADV7343_SD_CGMS_WSS0_DEFAULT		0x10
+
+#define ADV7343_SLICED_BUF_SIZE			256
+#define ADV7343_SERVICE_LINES_SIZE		(2*24*2)
+
+/* Macros for the Mode Select Register */
+#ifdef GENERATE_MASK
+#undef GENERATE_MASK
+#endif
+#define GENERATE_MASK(bits, pos)		((((0xFF) << (8-bits)) >> \
+		(8-bits)) << pos)
+
+/* Bit masks for Mode Select Register */
+#define YC_Y_BUS				0x80
+#define YC_S_BUS				0x7F
+#define INPUT_MODE_MASK				0x70
+#define SD_INPUT_MODE				0x00
+#define HD_720P_INPUT_MODE			0x10
+#define HD_1080I_INPUT_MODE			0x10
+#define HD_DDR_INPUT_MODE			0x20
+#define SD_HD_SDR_INPUT_MODE			0x30
+#define SD_HD_DDR_INPUT_MODE			0x40
+#define ED_INPUT_MODE				0x70
+
+/* Bit masks for Mode Register 0 */
+#define TEST_PATTERN_BLACK_BAR_EN		0x04
+#define TEST_PATTERN_BLACK_BAR_DI		0xFB
+#define YUV_OUTPUT_SELECT			0x20
+#define RGB_OUTPUT_SELECT			0xDF
+#define SD_SYNC_OUTPUT_EN			0x40
+#define SD_SYNC_OUTPUT_DI			0xBF
+#define HD_SYNC_OUTPUT_EN			0x80
+#define HD_SYNC_OUTPUT_DI			0x7F
+#define CSC_MATRIX_EN				0x08
+#define CSC_MATRIX_DI				0xF7
+
+/* Bit masks for CSC matrices */
+#define CSC_LSB_MASK				0x03
+#define CSC_MSB_MASK				0xFF
+#define CSC_SHIFT				2
+#define CSC_MATRIX_MASK				0x3FF
+
+/* Bit masks for DAC output levels */
+#define DAC_OUTPUT_LEVEL_MASK			0xFF
+#define POSITIVE_GAIN_MAX			0x40
+#define POSITIVE_GAIN_MIN			0x00
+#define NEGATIVE_GAIN_MAX			0xFF
+#define NEGATIVE_GAIN_MIN			0xC0
+
+/* Bit masks for soft reset register */
+#define SOFT_RESET				0x02
+
+/* Bit masks for HD Mode Register 1 */
+#define OUTPUT_STD_MASK				0x03
+#define OUTPUT_STD_SHIFT			0
+#define OUTPUT_STD_EIA0_2			0x00
+#define OUTPUT_STD_EIA0_1			0x01
+#define OUTPUT_STD_FULL				0x02
+#define EMBEDDED_SYNC				0x04
+#define EXTERNAL_SYNC				0xFB
+#define STD_MODE_SHIFT				3
+#define STD_MODE_MASK				0x1F
+#define STD_MODE_720P				0x05
+#define STD_MODE_720P_25			0x08
+#define STD_MODE_720P_30			0x07
+#define STD_MODE_720P_50			0x06
+#define STD_MODE_1080I				0x0D
+#define STD_MODE_1080I_25fps			0x0E
+#define STD_MODE_1080P_24			0x12
+#define STD_MODE_1080P_25			0x10
+#define STD_MODE_1080P_30			0x0F
+#define STD_MODE_525P				0x00
+#define STD_MODE_625P				0x03
+
+/* Bit masks for HD Mode Register 2 */
+#define HD_PIXEL_DATA_VALID			0x01
+#define HD_TEST_PATTERN_EN			0x04
+#define HD_TEST_PATTERN_DI			0xFB
+#define HD_TEST_PATTERN_HATCH			0xF7
+#define HD_TEST_PATTERN_FRAME			0x08
+#define HD_VBI_EN				0x10
+#define HD_VBI_DI				0xEF
+#define HD_UNDERSHOOTER_DI			0x9F
+#define HD_UNDERSHOOTER_11IRE			0x20
+#define HD_UNDERSHOOTER_6IRE			0x40
+#define HD_UNDERSHOOTER_1_5IRE			0x60
+#define HD_SHARPNESS_FLTR_EN			0x80
+#define HD_SHARPNESS_FLTR_DI			0x7F
+
+/* Bit masks for HD Mode Register 3 */
+#define HD_HSYNC_Y_DELAY_SHIFT			0
+#define HD_HSYNC_Y_DELAY_MASK			0x07
+#define HD_HSYNC_C_DELAY_SHIFT			3
+#define HD_HSYNC_C_DELAY_MASK			0x38
+#define HD_CGMS_EN				0x40
+#define HD_CGMS_DI				0xBF
+#define HD_CGMS_CRC_EN				0x80
+#define HD_CGMS_CRC_DI				0x7F
+
+/* Bit masks for HD Mode Register 4 */
+#define HD_HSYNC_CR				0x01
+#define HD_HSYNC_CB				0xFE
+#define HD_SYNC_FLTR_EN				0x08
+#define HD_SYNC_FLTR_DI				0xF7
+#define HD_CHROMA_SSAF_EN			0x20
+#define HD_CHROMA_SSAF_DI			0xDF
+#define HD_CHROMA_INPUT_422			0x40
+#define HD_CHROMA_INPUT_444			0xBF
+#define HD_DOUBLE_BUFFERING_EN			0x80
+#define HD_DOUBLE_BUFFERING_DI			0x7F
+
+/* Bit masks for HD Mode Register 5 */
+#define HD_MACROVISION_EN			0x10
+#define HD_MACROVISION_DI			0xEF
+
+/* Bit masks for HD Mode Register 6 */
+#define HD_RGB_INPUT_EN				0x02
+#define HD_RGB_INPUT_DI				0xFD
+#define HD_PBPR_SYNC_EN				0x04
+#define HD_PBPR_SYNC_DI				0xFB
+#define HD_DAC_SWAP_EN				0x08
+#define HD_DAC_SWAP_DI				0xF7
+#define HD_GAMMA_CURVE_A			0xEF
+#define HD_GAMMA_CURVE_B			0x10
+#define HD_GAMMA_EN				0x20
+#define HD_GAMMA_DI				0xDF
+#define HD_ADPT_FLTR_MODEB			0x40
+#define HD_ADPT_FLTR_MODEA			0xBF
+#define HD_ADPT_FLTR_EN				0x80
+#define HD_ADPT_FLTR_DI				0x7F
+
+/* Bit masks for HD Sharpness filter */
+#define HD_SHARPNESS_FLTR_A_SHIFT		0
+#define HD_SHARPNESS_FLTR_A_MASK		0x0F
+#define HD_SHARPNESS_FLTR_B_SHIFT		4
+#define HD_SHARPNESS_FLTR_B_MASK		0x0F
+
+#define GAMMA_MASK				0xFF
+
+#define HD_ADPT_FLTR_GAIN_A_SHIFT		0
+#define HD_ADPT_FLTR_GAIN_A_MASK		0x0F
+#define HD_ADPT_FLTR_GAIN_B_SHIFT		4
+#define HD_ADPT_FLTR_GAIN_B_MASK		0x0F
+#define HD_ADPT_FLTR_THRLD_MASK			0xFF
+
+/* Bit masks for SD Mode Register 1 */
+#define SD_STD_MASK				0x03
+#define SD_STD_NTSC				0x00
+#define SD_STD_PAL_BDGHI			0x01
+#define SD_STD_PAL_M				0x02
+#define SD_STD_PAL_N				0x03
+#define SD_LUMA_FLTR_MASK			0x7
+#define SD_LUMA_FLTR_SHIFT			0x2
+#define SD_CHROMA_FLTR_MASK			0x7
+#define SD_CHROMA_FLTR_SHIFT			0x5
+
+/* Bit masks for SD Mode Register 2 */
+#define SD_PBPR_SSAF_EN				0x01
+#define SD_PBPR_SSAF_DI				0xFE
+#define SD_DAC_1_DI				0xFD
+#define SD_DAC_2_DI				0xFB
+#define SD_PEDESTAL_EN				0x08
+#define SD_PEDESTAL_DI				0xF7
+#define SD_SQUARE_PIXEL_EN			0x10
+#define SD_SQUARE_PIXEL_DI			0xEF
+#define SD_PIXEL_DATA_VALID			0x40
+#define SD_ACTIVE_EDGE_EN			0x80
+#define SD_ACTIVE_EDGE_DI			0x7F
+
+/* Bit masks for SD Mode Register 3 */
+#define SD_CLOSE_CAPTION_DI			0x9F
+#define SD_CLOSE_CAPTION_EVEN			0x40
+#define SD_CLOSE_CAPTION_ODD			0x20
+#define SD_CLOSE_CAPTION_BOTH			0x60
+#define SD_VBI_EN				0x10
+#define SD_VBI_DI				0xEF
+#define SD_PEDESTAL_YPBPR_EN			0X01
+#define SD_PEDESTAL_YPBPR_DI			0xFE
+
+/* Bit masks for SD Mode Register 4 */
+#define SD_CHROMA_EN				0x10
+#define SD_CHROMA_DI				0xEF
+#define SD_BURST_EN				0x20
+#define SD_BURST_DI				0xDF
+#define SD_COLOR_BARS_EN			0x40
+#define SD_COLOR_BARS_DI			0xBF
+
+/* Bit masks for SD Mode Register 6 */
+#define SD_PBPR_SCALE_EN			0x01
+#define SD_PBPR_SCALE_DI			0xFE
+#define SD_Y_SCALE_EN				0x02
+#define SD_Y_SCALE_DI				0xFD
+#define SD_HUE_ADJST_EN				0x04
+#define SD_HUE_ADJST_DI				0xFB
+#define SD_BRIGHTNESS_EN			0x08
+#define SD_BRIGHTNESS_DI			0xF7
+#define SD_LUMA_SSAF_GAIN_EN			0x10
+#define SD_LUMA_SSAF_GAIN_DI			0xEF
+#define SD_AUTO_DETECT_EN			0x40
+#define SD_AUTO_DETECT_DI			0xBF
+#define SD_RGB_INPUT_EN				0x80
+#define SD_RGB_INPUT_DI				0x7F
+
+/* Bit masks for SD Mode Register 7 */
+#define SD_NON_INTERLACED_EN			0x02
+#define SD_NON_INTERLACED_DI			0xFD
+#define SD_DOUBLE_BUFFERING_EN			0x04
+#define SD_DOUBLE_BUFFERING_DI			0xFB
+#define SD_DNR_EN				0x20
+#define SD_DNR_DI				0xDF
+#define SD_GAMMA_EN				0x40
+#define SD_GAMMA_DI				0xBF
+#define SD_GAMMA_CURVE_B			0x80
+#define SD_GAMMA_CURVE_A			0x7F
+#define SD_INPUT_FORMAT_8BIT			0x00
+#define SD_INPUT_FORMAT_16BIT			0x08
+
+/* Bit masks for SD Timing Register 0 */
+#define SD_MASTER_MODE				0x01
+#define SD_SLAVE_MODE				0xFE
+#define SD_TIMING_MODE_SHIFT			1
+#define SD_TIMING_MODE_MASK			0x03
+#define SD_TIMING_MODE0				0xFC
+#define SD_TIMING_MODE1				0x01
+#define SD_TIMING_MODE2				0x02
+#define SD_TIMING_MODE3				0x03
+#define SD_LUMA_DELAY				0
+#define SD_MIN_LUMA_VAL_7_5IRE			0x40
+#define SD_MIN_LUMA_VAL_40IRE			0xBF
+#define SD_TIMING_RESET				0x80
+
+/* Macros for Timing Mode Register 1 */
+#define SD_HSYNC_DELAY				0
+#define SD_HSYNC2VSYNC_DELAY			0
+#define SD_HSYNC2DATA_DELAY			0
+#define SD_HSYNC2PIXELDATA_ADJUST		0
+
+#define SD_FSC_REG_MASK				0xFF
+#define SD_CLOSED_CAPT_MASK			0xFF
+#define SD_PEDESTAL_MASK			0xFF
+
+#define SD_CGMS_CRC_EN				0x10
+#define SD_CGMS_CRC_DI				0xEF
+#define SD_CGMS_EN				0x60
+#define SD_CGMS_ODD_FIELD_EN			0x20
+#define SD_CGMS_ODD_FIELD_DI			0xDF
+#define SD_CGMS_EVEN_FIELD_EN			0x40
+#define SD_CGMS_EVEN_FIELD_DI			0xBF
+#define SD_CGMS_DI				0x9F
+#define SD_WSS_EN				0x80
+#define SD_WSS_DI				0x7F
+
+#define SD_BRIGHTNESS_MASK			0x7F
+
+#define SD_DNR_BORDER_GAIN_MASK			0x0F
+#define SD_DNR_BORDER_GAIN_SHIFT		0x0
+#define SD_DNR_DATA_GAIN_MASK			0x0F
+#define SD_DNR_DATA_GAIN_SHIFT			0x4
+
+#define SD_DNR_THRESHOLD_MASK			0x3F
+#define SD_DNR_THRESHOLD_MAX			0x3F
+#define SD_BORDER_AREA_4PIXELS			0x40
+#define SD_BORDER_AREA_2PIXELS			0xBF
+#define SD_BLOCK_SIZE_16x16			0x80
+#define SD_BLOCK_SIZE_8x8			0x7F
+#define SD_DNR_INPUT_SELECT_MASK		0x07
+#define SD_DNR_SHARPNESS_MODE			0x08
+#define SD_DNR_MODE				0xF7
+#define SD_DNR_BLOCK_OFFSET_MASK		0x0F
+#define SD_DNR_BLOCK_OFFSET_SHIFT		0x04
+#define SD_DNR_GAIN_MAX				0x08
+
+#define SD_YPBPR_SCALE_SHIFT			0x02
+#define SD_YPBPR_SCALE_LMASK			0x03
+#define SD_YPBPR_SCALE_HMASK			0x3FC
+#define SD_YPBPR_SCALE_MASK			0x3FF
+
+#define SD_LUMA_SSAF_GAIN_MAX			0x0C
+
+#endif				/* End of #ifdef __KERNEL__ */
+
+#endif				/* End of #ifndef ADV7343_H */
Index: linux-2.6.18/drivers/media/video/Kconfig
===================================================================
--- linux-2.6.18.orig/drivers/media/video/Kconfig
+++ linux-2.6.18/drivers/media/video/Kconfig
@@ -28,6 +28,37 @@ config VIDEO_VIVI
 	  Say Y here if you want to test video apps or debug V4L devices.
 	  In doubt, say N.
 
+config CAPTURE_DAVINCIHD
+	tristate "DavinciHD Video Capture"
+	depends on VIDEO_DEV && MACH_DAVINCI_DM6467_EVM
+	select VIDEO_DAVINCIHD_VPIF
+	select VIDEO_BUF
+	select VIDEO_TVP5147
+	select VIDEO_TVP7002
+	help
+	  Support for Davinci based frame grabber through CCDC.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vpfe.
+
+config VIDEO_TVP5147
+	tristate "TVP5147 video decoder"
+	depends on I2C && MACH_DAVINCI_HD_EVM && CAPTURE_DAVINCIHD
+	help
+	  Support for I2C bus based TVP5147 configuration.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tvp5147.
+
+config VIDEO_TVP7002
+	tristate "TVP7002 video decoder"
+	depends on I2C && MACH_DAVINCI_HD_EVM && CAPTURE_DAVINCIHD
+	help
+	  Support for I2C bus based TVP7002 configuration.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tvp7002.
+
 source "drivers/media/video/bt8xx/Kconfig"
 
 config VIDEO_SAA6588
@@ -500,6 +531,36 @@ config DAVINCI_OSD
 	  To compile this driver as a module, choose M here: the
 	  module will be called vpif.
 
+config DISPLAY_DAVINCIHD
+	tristate "DavinciHD Video Display"
+	depends on VIDEO_DEV && MACH_DAVINCI_DM6467_EVM && DAVINCI_ENC_MNGR
+	select VIDEO_DAVINCIHD_VPIF
+	select VIDEO_BUF
+	select VIDEO_ADV7343
+	help
+	  Support for Davinci based frame grabber through CCDC.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vpfe.
+
+config VIDEO_ADV7343
+	tristate "ADV7343 video encoder"
+	depends on I2C && MACH_DAVINCI_DM6467_EVM && DISPLAY_DAVINCIHD && DAVINCI_ENC_MNGR
+	help
+	  Support for I2C bus based ADV7343 configuration.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called mt9t001.
+
+config VIDEO_DAVINCIHD_VPIF
+	tristate "DavinciHD VPIF Driver"
+	depends on CAPTURE_DAVINCIHD || DISPLAY_DAVINCIHD
+	help
+	  Support for DavinciHD VPIF Driver.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vpif.
+
 endmenu # encoder / decoder chips
 
 #
Index: linux-2.6.18/arch/arm/mach-davinci/Makefile
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-davinci/Makefile
+++ linux-2.6.18/arch/arm/mach-davinci/Makefile
@@ -9,6 +9,7 @@ obj-y 			:= time.o irq.o clock.o serial.
 
 # Board specific
 obj-$(CONFIG_MACH_DAVINCI_EVM)  += board-evm.o i2c-emac.o
-obj-$(CONFIG_MACH_DAVINCI_DM6467_EVM)  += board-dm6467-evm.o i2c-emac.o
 obj-$(CONFIG_MACH_DAVINCI_DM355_EVM)  += board-dm355-evm.o
 obj-$(CONFIG_DAVINCI_I2C_EXPANDER)      += i2c-client.o
+obj-$(CONFIG_MACH_DAVINCI_DM6467_EVM)  += board-dm6467-evm.o i2c-emac.o \
+                                       video_hdevm.o
Index: linux-2.6.18/mvl_patches/pro50-1579.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-1579.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1579);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

