#! /usr/bin/env bash
# Patch: -pro_arm_davinci_dm6446_dm355_capture
# Date: Fri Sep 19 14:01:11 2008
# Source: MontaVista Software, Inc.
# MR: 28149, 29375
# Type: Integration
# Disposition: merged from pro_40
# Signed-off-by: Pavel Kiryukhin <pkiryukhin@ru.mvista.com>
# Description: DaVinci dm6446 and dm355 capture support.
# 
#  drivers/media/video/Kconfig                |   30 
#  drivers/media/video/davinci/Makefile       |   15 
#  drivers/media/video/davinci/ccdc_davinci.c |  662 +++++++++
#  drivers/media/video/davinci/ccdc_dm355.c   | 1593 ++++++++++++++++++++++
#  drivers/media/video/davinci/davinci_vpfe.c | 2089 +++++++++++++++++++++++++++++
#  drivers/media/video/davinci/mt9t001.c      | 1343 ++++++++++++++++++
#  drivers/media/video/davinci/tvp5146.c      |  819 +++++++++++
#  include/media/davinci/ccdc_dm355.h         |  869 ++++++++++++
#  include/media/davinci/davinci_vpfe.h       |  169 ++
#  include/media/davinci/mt9t001.h            |  276 +++
#  include/media/davinci/tvp5146.h            |  122 +
#  11 files changed, 7987 insertions(+)
# 

PATCHNUM=1582
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc.
MR: 28149, 29375
Type: Integration
Disposition: merged from pro_40
Signed-off-by: Pavel Kiryukhin <pkiryukhin@ru.mvista.com>
Description: DaVinci dm6446 and dm355 capture support.

 drivers/media/video/Kconfig                |   30 
 drivers/media/video/davinci/Makefile       |   15 
 drivers/media/video/davinci/ccdc_davinci.c |  662 +++++++++
 drivers/media/video/davinci/ccdc_dm355.c   | 1593 ++++++++++++++++++++++
 drivers/media/video/davinci/davinci_vpfe.c | 2089 +++++++++++++++++++++++++++++
 drivers/media/video/davinci/mt9t001.c      | 1343 ++++++++++++++++++
 drivers/media/video/davinci/tvp5146.c      |  819 +++++++++++
 include/media/davinci/ccdc_dm355.h         |  869 ++++++++++++
 include/media/davinci/davinci_vpfe.h       |  169 ++
 include/media/davinci/mt9t001.h            |  276 +++
 include/media/davinci/tvp5146.h            |  122 +
 mvl_patches/pro50-1582.c                   |   16 
 12 files changed, 8003 insertions(+)

Index: linux-2.6.18/drivers/media/video/Kconfig
===================================================================
--- linux-2.6.18.orig/drivers/media/video/Kconfig
+++ linux-2.6.18/drivers/media/video/Kconfig
@@ -28,6 +28,18 @@ config VIDEO_VIVI
 	  Say Y here if you want to test video apps or debug V4L devices.
 	  In doubt, say N.
 
+config VIDEO_DAVINCI_CAPTURE
+	tristate "Davinci Video Capture"
+	depends on VIDEO_DEV && (ARCH_DAVINCI_DM644x || ARCH_DAVINCI_DM355)
+	select VIDEO_BUF
+	select VIDEO_TVP5146
+	select VIDEO_MT9T001
+	help
+	  Support for Davinci based frame grabber through CCDC.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vpfe.
+
 config CAPTURE_DAVINCIHD
 	tristate "DavinciHD Video Capture"
 	depends on VIDEO_DEV && MACH_DAVINCI_DM6467_EVM
@@ -41,6 +53,24 @@ config CAPTURE_DAVINCIHD
 	  To compile this driver as a module, choose M here: the
 	  module will be called vpfe.
 
+config VIDEO_TVP5146
+	tristate "TVP5146 video decoder"
+	depends on I2C && ARCH_DAVINCI && VIDEO_DAVINCI_CAPTURE
+	help
+	  Support for I2C bus based TVP5146 configuration.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tvp5146.
+
+config VIDEO_MT9T001
+	tristate "MT9T001 Sensor"
+	depends on I2C && ARCH_DAVINCI && VIDEO_DAVINCI_CAPTURE
+	help
+	  Support for I2C bus based MT9T001 Driver
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called mt9t001.
+
 config VIDEO_TVP5147
 	tristate "TVP5147 video decoder"
 	depends on I2C && MACH_DAVINCI_HD_EVM && CAPTURE_DAVINCIHD
Index: linux-2.6.18/drivers/media/video/davinci/Makefile
===================================================================
--- linux-2.6.18.orig/drivers/media/video/davinci/Makefile
+++ linux-2.6.18/drivers/media/video/davinci/Makefile
@@ -1,4 +1,19 @@
+#
+# Makefile for the davinci video device drivers.
+#
+
+# Capture: DaVinci and DM355
+ifdef CONFIG_ARCH_DAVINCI_DM644x
+davinci_capture-objs := ccdc_davinci.o davinci_vpfe.o
+endif
+ifdef CONFIG_ARCH_DAVINCI_DM355
+davinci_capture-objs := ccdc_dm355.o davinci_vpfe.o
+endif
+obj-$(CONFIG_VIDEO_TVP5146) += tvp5146.o
+obj-$(CONFIG_VIDEO_MT9T001) += mt9t001.o
+obj-$(CONFIG_VIDEO_DAVINCI_CAPTURE) += davinci_capture.o
 obj-$(CONFIG_DAVINCI_OSD) += davinci_osd.o davinci_platform.o
+
 # Encoder Manager and Encoders
 obj-$(CONFIG_DAVINCI_ENC_MNGR)  += davinci_enc_mngr.o
 obj-$(CONFIG_VIDEO_DAVINCI_DISPLAY) += davinci_display.o
Index: linux-2.6.18/drivers/media/video/davinci/ccdc_davinci.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/ccdc_davinci.c
@@ -0,0 +1,662 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* ccdc_davinci.c */
+
+#include <linux/device.h>
+#include <asm/uaccess.h>
+#include <media/davinci/ccdc_davinci.h>
+#include <asm/page.h>
+
+/*Object for CCDC raw mode */
+ccdc_params_raw ccdc_hw_params_raw = {
+	.pix_fmt = CCDC_PIXFMT_RAW,
+	.frm_fmt = CCDC_FRMFMT_PROGRESSIVE,
+	.win = VPFE_WIN_PAL,
+	.fid_pol = CCDC_PINPOL_POSITIVE,
+	.vd_pol = CCDC_PINPOL_POSITIVE,
+	.hd_pol = CCDC_PINPOL_POSITIVE,
+	.image_invert_enable = FALSE,
+	.data_sz = _10BITS,
+	.alaw = {
+		 .b_alaw_enable = FALSE}
+	,
+	.blk_clamp = {
+		      .b_clamp_enable = FALSE,
+		      .dc_sub = 0}
+	,
+	.blk_comp = {0, 0, 0, 0}
+	,
+	.fault_pxl = {
+		      .fpc_enable = FALSE}
+	,
+};
+
+/*Object for CCDC ycbcr mode */
+ccdc_params_ycbcr ccdc_hw_params_ycbcr = {
+	.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT,
+	.frm_fmt = CCDC_FRMFMT_INTERLACED,
+	.win = VPFE_WIN_PAL,
+	.fid_pol = CCDC_PINPOL_POSITIVE,
+	.vd_pol = CCDC_PINPOL_POSITIVE,
+	.hd_pol = CCDC_PINPOL_POSITIVE,
+	.bt656_enable = TRUE,
+	.pix_order = CCDC_PIXORDER_CBYCRY,
+	.buf_type = CCDC_BUFTYPE_FLD_INTERLEAVED
+};
+
+extern struct device *vpfe_dev;
+
+void ccdc_readregs(void)
+{
+	unsigned int val = 0;
+
+	val = regr(ALAW);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to ALAW...\n", val);
+	val = regr(CLAMP);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CLAMP...\n", val);
+	val = regr(DCSUB);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DCSUB...\n", val);
+	val = regr(BLKCMP);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to BLKCMP...\n", val);
+	val = regr(FPC_ADDR);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FPC_ADDR...\n", val);
+	val = regr(FPC);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FPC...\n", val);
+	val = regr(FMTCFG);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTCFG...\n", val);
+	val = regr(COLPTN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to COLPTN...\n", val);
+	val = regr(FMT_HORZ);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMT_HORZ...\n", val);
+	val = regr(FMT_VERT);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMT_VERT...\n", val);
+	val = regr(HSIZE_OFF);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to HSIZE_OFF...\n", val);
+	val = regr(SDOFST);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SDOFST...\n", val);
+	val = regr(VP_OUT);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to VP_OUT...\n", val);
+	val = regr(SYN_MODE);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SYN_MODE...\n", val);
+	val = regr(HORZ_INFO);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to HORZ_INFO...\n", val);
+	val = regr(VERT_START);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to VERT_START...\n", val);
+	val = regr(VERT_LINES);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to VERT_LINES...\n", val);
+}
+
+int validate_ccdc_param(ccdc_config_params_raw * ccdcparam)
+{
+	if ((ccdc_hw_params_raw.frm_fmt != CCDC_FRMFMT_INTERLACED)
+	    && (ccdcparam->image_invert_enable == TRUE)) {
+		dev_err(vpfe_dev, "\nImage invert not supported");
+		return -1;
+	}
+	if (ccdc_hw_params_raw.alaw.b_alaw_enable) {
+		if ((ccdcparam->alaw.gama_wd > BITS_09_0)
+		    || (ccdcparam->alaw.gama_wd < BITS_15_6)
+		    || (ccdcparam->alaw.gama_wd < ccdcparam->data_sz)) {
+			dev_err(vpfe_dev, "\nInvalid data line select");
+			return -1;
+		}
+	}
+	return 0;
+}
+
+int ccdc_update_ycbcr_params(void *arg)
+{
+	memcpy(&ccdc_hw_params_ycbcr,
+	       (ccdc_params_ycbcr *) arg, sizeof(ccdc_params_ycbcr));
+	return 0;
+}
+
+int ccdc_update_raw_params(void *arg)
+{
+	unsigned int *fpc_virtaddr = NULL;
+	unsigned int *fpc_physaddr = NULL;
+	ccdc_params_raw *ccd_params = &ccdc_hw_params_raw;
+	ccdc_config_params_raw *raw_params = (ccdc_config_params_raw *) arg;
+	ccd_params->image_invert_enable = raw_params->image_invert_enable;
+
+	dev_dbg(vpfe_dev, "\nimage_invert_enable = %d",
+		ccd_params->image_invert_enable);
+
+	ccd_params->data_sz = raw_params->data_sz;
+	dev_dbg(vpfe_dev, "\ndata_sz = %d", ccd_params->data_sz);
+
+	ccd_params->alaw.b_alaw_enable = raw_params->alaw.b_alaw_enable;
+	dev_dbg(vpfe_dev, "\nALaw Enable = %d", ccd_params->alaw.b_alaw_enable);
+	/* copy A-Law configurations to vpfe_device, from arg
+	 * passed by application */
+	if (ccd_params->alaw.b_alaw_enable) {
+		ccd_params->alaw.gama_wd = raw_params->alaw.gama_wd;
+		dev_dbg(vpfe_dev, "\nALaw Gama width = %d",
+			ccd_params->alaw.gama_wd);
+	}
+
+	/* copy Optical Balck Clamping configurations to
+	 * vpfe_device,from arg passed by application */
+	ccd_params->blk_clamp.b_clamp_enable
+	    = raw_params->blk_clamp.b_clamp_enable;
+	dev_dbg(vpfe_dev, "\nb_clamp_enable = %d",
+		ccd_params->blk_clamp.b_clamp_enable);
+	if (ccd_params->blk_clamp.b_clamp_enable) {
+		/*gain */
+		ccd_params->blk_clamp.sgain = raw_params->blk_clamp.sgain;
+		dev_dbg(vpfe_dev, "\nblk_clamp.sgain = %d",
+			ccd_params->blk_clamp.sgain);
+		/*Start pixel */
+		ccd_params->blk_clamp.start_pixel
+		    = raw_params->blk_clamp.start_pixel;
+		dev_dbg(vpfe_dev,
+			"\nblk_clamp.start_pixel = %d",
+			ccd_params->blk_clamp.start_pixel);
+		/*No of line to be avg */
+		ccd_params->blk_clamp.sample_ln
+		    = raw_params->blk_clamp.sample_ln;
+		dev_dbg(vpfe_dev,
+			"\nblk_clamp.sample_ln = %d",
+			ccd_params->blk_clamp.sample_ln);
+		/*No of pixel/line to be avg */
+		ccd_params->blk_clamp.sample_pixel
+		    = raw_params->blk_clamp.sample_pixel;
+		dev_dbg(vpfe_dev,
+			"\nblk_clamp.sample_pixel  = %d",
+			ccd_params->blk_clamp.sample_pixel);
+	} else {		/* configure DCSub */
+
+		ccd_params->blk_clamp.dc_sub = raw_params->blk_clamp.dc_sub;
+		dev_dbg(vpfe_dev,
+			"\nblk_clamp.dc_sub  = %d",
+			ccd_params->blk_clamp.dc_sub);
+	}
+
+	/* copy BalckLevel Compansation configurations to
+	 * vpfe_device,from arg passed by application
+	 */
+	ccd_params->blk_comp.r_comp = raw_params->blk_comp.r_comp;
+	ccd_params->blk_comp.gr_comp = raw_params->blk_comp.gr_comp;
+	ccd_params->blk_comp.b_comp = raw_params->blk_comp.b_comp;
+	ccd_params->blk_comp.gb_comp = raw_params->blk_comp.gb_comp;
+	dev_dbg(vpfe_dev, "\nblk_comp.r_comp   = %d",
+		ccd_params->blk_comp.r_comp);
+	dev_dbg(vpfe_dev, "\nblk_comp.gr_comp  = %d",
+		ccd_params->blk_comp.gr_comp);
+	dev_dbg(vpfe_dev, "\nblk_comp.b_comp   = %d",
+		ccd_params->blk_comp.b_comp);
+	dev_dbg(vpfe_dev, "\nblk_comp.gb_comp  = %d",
+		ccd_params->blk_comp.gb_comp);
+
+	/* copy FPC configurations to vpfe_device,from
+	 * arg passed by application
+	 */
+	ccd_params->fault_pxl.fpc_enable = raw_params->fault_pxl.fpc_enable;
+	dev_dbg(vpfe_dev, "\nfault_pxl.fpc_enable  = %d",
+		ccd_params->fault_pxl.fpc_enable);
+
+	if (ccd_params->fault_pxl.fpc_enable) {
+		fpc_physaddr =
+		    (unsigned int *)ccd_params->fault_pxl.fpc_table_addr;
+
+		fpc_virtaddr = (unsigned int *)
+		    phys_to_virt((unsigned long)
+				 fpc_physaddr);
+
+		/* Allocate memory for FPC table if current
+		 * FPC table buffer is not big enough to
+		 * accomodate FPC Number requested
+		 */
+		if (raw_params->fault_pxl.fp_num !=
+		    ccd_params->fault_pxl.fp_num) {
+			if (fpc_physaddr != NULL) {
+				free_pages((unsigned long)
+					   fpc_physaddr,
+					   get_order
+					   (ccd_params->
+					    fault_pxl.fp_num * FP_NUM_BYTES));
+
+			}
+
+			/* Allocate memory for FPC table */
+			fpc_virtaddr = (unsigned int *)
+			    __get_free_pages(GFP_KERNEL |
+					     GFP_DMA,
+					     get_order
+					     (raw_params->
+					      fault_pxl.fp_num * FP_NUM_BYTES));
+
+			if (fpc_virtaddr == NULL) {
+				dev_err(vpfe_dev, "\n Unable to allocate \
+					memory for FPC");
+				return -1;
+			}
+			fpc_physaddr =
+			    (unsigned int *)virt_to_phys((void *)fpc_virtaddr);
+		}
+
+		/* Copy number of fault pixels and FPC table */
+		ccd_params->fault_pxl.fp_num = raw_params->fault_pxl.fp_num;
+		copy_from_user((void *)fpc_virtaddr,
+			       (void *)raw_params->
+			       fault_pxl.fpc_table_addr,
+			       (unsigned long)ccd_params->
+			       fault_pxl.fp_num * FP_NUM_BYTES);
+
+		ccd_params->fault_pxl.fpc_table_addr =
+		    (unsigned int)fpc_physaddr;
+	}
+	return 0;
+}
+void ccdc_init(void)
+{
+	/* Do nothing for DM6446 */
+}
+
+void ccdc_cleanup(void)
+{
+	unsigned int *fpc_physaddr = NULL, *fpc_virtaddr = NULL;
+	fpc_physaddr = (unsigned int *)
+	    ccdc_hw_params_raw.fault_pxl.fpc_table_addr;
+
+	if (fpc_physaddr != NULL) {
+		fpc_virtaddr = (unsigned int *)
+		    phys_to_virt((unsigned long)fpc_physaddr);
+		free_pages((unsigned long)fpc_virtaddr,
+			   get_order(ccdc_hw_params_raw.fault_pxl.
+				     fp_num * FP_NUM_BYTES));
+	}
+}
+
+/*
+ * ======== ccdc_reset  ========
+ */
+/*This function will reset all CCDc reg */
+
+void ccdc_reset()
+{
+	int i;
+
+	/* disable CCDC */
+	ccdc_enable(0);
+	/* set all registers to default value */
+	for (i = 0; i <= 0x94; i += 4) {
+		regw(0, i);
+	}
+	regw(0, PCR);
+	regw(0, SYN_MODE);
+	regw(0, HD_VD_WID);
+	regw(0, PIX_LINES);
+	regw(0, HORZ_INFO);
+	regw(0, VERT_START);
+	regw(0, VERT_LINES);
+	regw(0xffff00ff, CULLING);
+	regw(0, HSIZE_OFF);
+	regw(0, SDOFST);
+	regw(0, SDR_ADDR);
+	regw(0, VDINT);
+	regw(0, REC656IF);
+	regw(0, CCDCFG);
+	regw(0, FMTCFG);
+	regw(0, VP_OUT);
+}
+
+/*
+ * ======== ccdc_setwin  ========
+ */
+/*This function will configure the window size to be capture in CCDC reg */
+void ccdc_setwin(ccdc_imgwin * image_win, ccdc_frmfmt frm_fmt, int ppc)
+{
+	int horz_start, horz_nr_pixels;
+	int vert_start, vert_nr_lines;
+	int val = 0, mid_img = 0;
+	dev_dbg(vpfe_dev, "\nStarting ccdc_setwin...");
+	/* configure horizonal and vertical starts and sizes */
+	/* Here, (ppc-1) will be different for raw and yuv modes */
+	horz_start = image_win->left << (ppc - 1);
+	horz_nr_pixels = (image_win->width << (ppc - 1)) - 1;
+	regw((horz_start << CCDC_HORZ_INFO_SPH_SHIFT) | horz_nr_pixels,
+	     HORZ_INFO);
+
+	vert_start = image_win->top;
+
+	if (frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		vert_nr_lines = (image_win->height >> 1) - 1;
+		vert_start >>= 1;
+		vert_start += 1; /* Since first line doesn't have any data */
+		/* configure VDINT0 */
+		val = (vert_start << CCDC_VDINT_VDINT0_SHIFT);
+		regw(val, VDINT);
+
+	} else {
+		vert_start += 1; /* Since first line doesn't have any data */
+		vert_nr_lines = image_win->height - 1;
+		/* configure VDINT0 and VDINT1 */
+		/* VDINT1 will be at half of image height */
+		mid_img = vert_start + (image_win->height / 2);
+		val = (vert_start << CCDC_VDINT_VDINT0_SHIFT) |
+		    (mid_img & CCDC_VDINT_VDINT1_MASK);
+		regw(val, VDINT);
+
+	}
+	regw((vert_start << CCDC_VERT_START_SLV0_SHIFT) | vert_start,
+	     VERT_START);
+	regw(vert_nr_lines, VERT_LINES);
+	dev_dbg(vpfe_dev, "\nEnd of ccdc_setwin...");
+}
+
+/*
+ * ======== ccdc_config_ycbcr  ========
+ */
+/*This function will configure CCDC for YCbCr parameters*/
+void ccdc_config_ycbcr(void)
+{
+	u32 syn_mode;
+	unsigned int val;
+	ccdc_params_ycbcr *params = &ccdc_hw_params_ycbcr;
+
+	/* first reset the CCDC                                          */
+	/* all registers have default values after reset                 */
+	/* This is important since we assume default values to be set in */
+	/* a lot of registers that we didn't touch                       */
+	dev_dbg(vpfe_dev, "\nStarting ccdc_config_ycbcr...");
+	ccdc_reset();
+
+	/* configure pixel format */
+	syn_mode = (params->pix_fmt & 0x3) << 12;
+
+	/* configure video frame format */
+	syn_mode |= (params->frm_fmt & 0x1) << 7;
+
+	/* setup BT.656 sync mode */
+	if (params->bt656_enable) {
+		regw(3, REC656IF);
+
+		/* configure the FID, VD, HD pin polarity */
+		/* fld,hd pol positive, vd negative, 8-bit pack mode */
+		syn_mode |= 0x00000F04;
+	} else {		/* y/c external sync mode */
+		syn_mode |= ((params->fid_pol & 0x1) << 4);
+		syn_mode |= ((params->hd_pol & 0x1) << 3);
+		syn_mode |= ((params->vd_pol & 0x1) << 2);
+	}
+
+	/* configure video window */
+	ccdc_setwin(&params->win, params->frm_fmt, 2);
+
+	/* configure the order of y cb cr in SD-RAM */
+	regw((params->pix_order << 11) | 0x8000, CCDCFG);
+
+	/* configure the horizontal line offset */
+	/* this is done by rounding up width to a multiple of 16 pixels */
+	/* and multiply by two to account for y:cb:cr 4:2:2 data */
+	regw(((params->win.width * 2) + 31) & 0xffffffe0, HSIZE_OFF);
+
+	/* configure the memory line offset */
+	if (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED) {
+		/* two fields are interleaved in memory */
+		regw(0x00000249, SDOFST);
+	}
+	/* enable output to SDRAM */
+	syn_mode |= (0x1 << 17);
+	/* enable internal timing generator */
+	syn_mode |= (0x1 << 16);
+
+	syn_mode |= CCDC_DATA_PACK_ENABLE;
+	regw(syn_mode, SYN_MODE);
+
+	val = (unsigned int)ccdc_sbl_reset();
+	dev_dbg(vpfe_dev, "\nReading 0x%x from SBL...\n", val);
+
+	dev_dbg(vpfe_dev, "\nEnd of ccdc_config_ycbcr...\n");
+	ccdc_readregs();
+}
+
+/*
+ * ======== ccdc_config_raw  ========
+ */
+/*This function will configure CCDC for Raw mode parameters*/
+void ccdc_config_raw()
+{
+
+	ccdc_params_raw *params = &ccdc_hw_params_raw;
+	unsigned int syn_mode = 0;
+	unsigned int val;
+	dev_dbg(vpfe_dev, "\nStarting ccdc_config_raw...");
+	/*      Reset CCDC */
+	ccdc_reset();
+	/* Disable latching function registers on VSYNC  */
+	regw(CCDC_LATCH_ON_VSYNC_DISABLE, CCDCFG);
+
+	/*      Configure the vertical sync polarity(SYN_MODE.VDPOL) */
+	syn_mode = (params->vd_pol & CCDC_VD_POL_MASK) << CCDC_VD_POL_SHIFT;
+
+	/*      Configure the horizontal sync polarity (SYN_MODE.HDPOL) */
+	syn_mode |= (params->hd_pol & CCDC_HD_POL_MASK) << CCDC_HD_POL_SHIFT;
+
+	/*      Configure frame id polarity (SYN_MODE.FLDPOL) */
+	syn_mode |= (params->fid_pol & CCDC_FID_POL_MASK) << CCDC_FID_POL_SHIFT;
+
+	/* Configure frame format(progressive or interlace) */
+	syn_mode |= (params->frm_fmt & CCDC_FRM_FMT_MASK) << CCDC_FRM_FMT_SHIFT;
+
+	/* Configure the data size(SYNMODE.DATSIZ) */
+	syn_mode |= (params->data_sz & CCDC_DATA_SZ_MASK) << CCDC_DATA_SZ_SHIFT;
+
+	/* Configure pixel format (Input mode) */
+	syn_mode |= (params->pix_fmt & CCDC_PIX_FMT_MASK) << CCDC_PIX_FMT_SHIFT;
+
+	/* Configure VP2SDR bit of syn_mode = 0 */
+	syn_mode &= CCDC_VP2SDR_DISABLE;
+
+	/* Enable write enable bit */
+	syn_mode |= CCDC_WEN_ENABLE;
+
+	/* Disable output to resizer */
+	syn_mode &= CCDC_SDR2RSZ_DISABLE;
+
+	/* enable internal timing generator */
+	syn_mode |= CCDC_VDHDEN_ENABLE;
+
+	/* Enable and configure aLaw register if needed */
+	if (params->alaw.b_alaw_enable) {
+		val = (params->alaw.gama_wd & CCDC_ALAW_GAMA_WD_MASK);
+		val |= CCDC_ALAW_ENABLE;	/*set enable bit of alaw */
+		regw(val, ALAW);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to ALAW...\n", val);
+	}
+
+	/* configure video window */
+	ccdc_setwin(&params->win, params->frm_fmt, PPC_RAW);
+
+	if (params->blk_clamp.b_clamp_enable) {
+		val = (params->blk_clamp.sgain) & CCDC_BLK_SGAIN_MASK;	/*gain */
+		val |= (params->blk_clamp.start_pixel & CCDC_BLK_ST_PXL_MASK)
+		    << CCDC_BLK_ST_PXL_SHIFT;	/*Start pixel */
+		val |= (params->blk_clamp.sample_ln & CCDC_BLK_SAMPLE_LINE_MASK)
+		    << CCDC_BLK_SAMPLE_LINE_SHIFT;	/*No of line to be avg */
+		val |=
+		    (params->blk_clamp.sample_pixel & CCDC_BLK_SAMPLE_LN_MASK)
+		    << CCDC_BLK_SAMPLE_LN_SHIFT;	/*No of pixel/line to be avg */
+		val |= CCDC_BLK_CLAMP_ENABLE;	/*Enable the Black clamping */
+		regw(val, CLAMP);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to CLAMP...\n", val);
+		regw(DCSUB_DEFAULT_VAL, DCSUB);	/*If Black clamping is enable
+						   then make dcsub 0 */
+		dev_dbg(vpfe_dev, "\nWriting 0x00000000 to DCSUB...\n");
+
+	} else {
+		/* configure DCSub */
+		val = (params->blk_clamp.dc_sub) & CCDC_BLK_DC_SUB_MASK;
+		regw(val, DCSUB);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to DCSUB...\n", val);
+		regw(CLAMP_DEFAULT_VAL, CLAMP);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x0000 to CLAMP...\n");
+	}
+
+	/*      Configure Black level compensation */
+	val = (params->blk_comp.b_comp & CCDC_BLK_COMP_MASK);
+	val |= (params->blk_comp.gb_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_GB_COMP_SHIFT;
+	val |= (params->blk_comp.gr_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_GR_COMP_SHIFT;
+	val |= (params->blk_comp.r_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_R_COMP_SHIFT;
+
+	regw(val, BLKCMP);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to BLKCMP...\n", val);
+	dev_dbg(vpfe_dev, "\nbelow 	regw(val, BLKCMP)...");
+	/* Initially disable FPC */
+	val = CCDC_FPC_DISABLE;
+	regw(val, FPC);
+	/* Configure Fault pixel if needed */
+	if (params->fault_pxl.fpc_enable) {
+		regw(params->fault_pxl.fpc_table_addr, FPC_ADDR);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to FPC_ADDR...\n",
+			(params->fault_pxl.fpc_table_addr));
+		/* Write the FPC params with FPC disable */
+		val = params->fault_pxl.fp_num & CCDC_FPC_FPC_NUM_MASK;
+		regw(val, FPC);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to FPC...\n", val);
+		/* read the FPC register */
+		val = regr(FPC);
+		val |= CCDC_FPC_ENABLE;
+		regw(val, FPC);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to FPC...\n", val);
+	}
+	/* If data size is 8 bit then pack the data */
+	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable) {
+		syn_mode |= CCDC_DATA_PACK_ENABLE;
+	}
+#if VIDEO_PORT_ENABLE
+	val = ENABLE_VIDEO_PORT;	/* enable video port */
+#else
+	val = DISABLE_VIDEO_PORT;	/* disable video port */
+#endif
+
+	if (params->data_sz == _8BITS)
+		val |= (_10BITS & CCDC_FMTCFG_VPIN_MASK)
+		    << CCDC_FMTCFG_VPIN_SHIFT;
+	else
+		val |= (params->data_sz & CCDC_FMTCFG_VPIN_MASK)
+		    << CCDC_FMTCFG_VPIN_SHIFT;
+
+	/* Write value in FMTCFG */
+	regw(val, FMTCFG);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to FMTCFG...\n", val);
+
+	/* Configure the color pattern according to mt9t001 sensor */
+	regw(CCDC_COLPTN_VAL, COLPTN);
+
+	dev_dbg(vpfe_dev, "\nWriting 0xBB11BB11 to COLPTN...\n");
+	/* Configure Data formatter(Video port) pixel selection
+	 * (FMT_HORZ, FMT_VERT)
+	 */
+	val = 0;
+	val |= ((params->win.left) & CCDC_FMT_HORZ_FMTSPH_MASK)
+	    << CCDC_FMT_HORZ_FMTSPH_SHIFT;
+	val |= (((params->win.width)) & CCDC_FMT_HORZ_FMTLNH_MASK);
+	regw(val, FMT_HORZ);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to FMT_HORZ...\n", val);
+	val = 0;
+	val |= (params->win.top & CCDC_FMT_VERT_FMTSLV_MASK)
+	    << CCDC_FMT_VERT_FMTSLV_SHIFT;
+	if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE)
+		val |= (params->win.height) & CCDC_FMT_VERT_FMTLNV_MASK;
+	else
+		val |= (params->win.height >> 1) & CCDC_FMT_VERT_FMTLNV_MASK;
+
+	dev_dbg(vpfe_dev, "\nparams->win.height  0x%x ...\n",
+		params->win.height);
+	regw(val, FMT_VERT);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to FMT_VERT...\n", val);
+
+	dev_dbg(vpfe_dev, "\nbelow regw(val, FMT_VERT)...");
+
+	/* Configure Horizontal offset register */
+	/* If pack 8 is enabled then 1 pixel will take 1 byte */
+	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable) {
+		regw(((params->win.width) + CCDC_32BYTE_ALIGN_VAL)
+		     & CCDC_HSIZE_OFF_MASK, HSIZE_OFF);
+
+	} else {		/* else one pixel will take 2 byte */
+
+		regw(((params->win.width * TWO_BYTES_PER_PIXEL)
+		      + CCDC_32BYTE_ALIGN_VAL)
+		     & CCDC_HSIZE_OFF_MASK, HSIZE_OFF);
+
+	}
+
+	/* Set value for SDOFST */
+
+	if (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		if (params->image_invert_enable) {
+			/* For intelace inverse mode */
+			regw(INTERLACED_IMAGE_INVERT, SDOFST);
+			dev_dbg(vpfe_dev, "\nWriting 0x4B6D to SDOFST...\n");
+		}
+
+		else {
+			/* For intelace non inverse mode */
+			regw(INTERLACED_NO_IMAGE_INVERT, SDOFST);
+			dev_dbg(vpfe_dev, "\nWriting 0x0249 to SDOFST...\n");
+		}
+	} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
+		regw(PROGRESSIVE_NO_IMAGE_INVERT, SDOFST);
+		dev_dbg(vpfe_dev, "\nWriting 0x0000 to SDOFST...\n");
+	}
+
+	/* Configure video port pixel selection (VPOUT) */
+	/* Here -1 is to make the height value less than FMT_VERT.FMTLNV */
+	if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
+		val = (((params->win.height - 1) & CCDC_VP_OUT_VERT_NUM_MASK))
+		    << CCDC_VP_OUT_VERT_NUM_SHIFT;
+	} else {
+		val =
+		    ((((params->win.
+			height >> CCDC_INTERLACED_HEIGHT_SHIFT) -
+		       1) & CCDC_VP_OUT_VERT_NUM_MASK))
+		    << CCDC_VP_OUT_VERT_NUM_SHIFT;
+	}
+
+	val |= ((((params->win.width))) & CCDC_VP_OUT_HORZ_NUM_MASK)
+	    << CCDC_VP_OUT_HORZ_NUM_SHIFT;
+	val |= (params->win.left) & CCDC_VP_OUT_HORZ_ST_MASK;
+	regw(val, VP_OUT);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to VP_OUT...\n", val);
+	regw(syn_mode, SYN_MODE);
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to SYN_MODE...\n", syn_mode);
+
+	val = (unsigned int)ccdc_sbl_reset();
+	dev_dbg(vpfe_dev, "\nReading 0x%x from SBL...\n", val);
+
+	dev_dbg(vpfe_dev, "\nend of ccdc_config_raw...");
+	ccdc_readregs();
+}
Index: linux-2.6.18/drivers/media/video/davinci/ccdc_dm355.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/ccdc_dm355.c
@@ -0,0 +1,1593 @@
+/*
+ *
+ *
+ * Copyright (C) 2005 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* ccdc_davinci.c */
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <asm/arch/mux.h>
+#include <media/davinci/ccdc_dm355.h>
+/*Object for CCDC raw mode */
+ccdc_params_raw ccdc_hw_params_raw = {
+	.pix_fmt = CCDC_PIXFMT_RAW,
+	.frm_fmt = CCDC_FRMFMT_PROGRESSIVE,
+	.win = VPFE_WIN_PAL,
+	.fid_pol = CCDC_PINPOL_POSITIVE,
+	.vd_pol = CCDC_PINPOL_POSITIVE,
+	.hd_pol = CCDC_PINPOL_POSITIVE,
+	.image_invert_enable = FALSE,
+	.data_sz = _10BITS,
+	.med_filt_thres = 0,
+	.mfilt1 = NO_MEDIAN_FILTER1,
+	.mfilt2 = NO_MEDIAN_FILTER2,
+	.ccdc_offset = 0,
+	.lpf_enable = FALSE,
+	.datasft = 2,
+	.alaw = {
+		 .b_alaw_enable = FALSE,
+		 .gama_wd = 2}
+	,
+	.blk_clamp = {
+		      .b_clamp_enable = FALSE,
+		      .sample_pixel = 1,
+		      .start_pixel = 0,
+		      .dc_sub = 25}
+	,
+	.blk_comp = {
+		     .b_comp = 0,
+		     .gb_comp = 0,
+		     .gr_comp = 0,
+		     .r_comp = 0}
+	,
+	.vertical_dft = {
+			 .ver_dft_en = FALSE}
+	,
+	.lens_sh_corr = {
+			 .lsc_enable = FALSE}
+	,
+	.data_formatter_r = {
+			     .fmt_enable = FALSE}
+	,
+	.color_space_con = {
+			    .csc_enable = FALSE}
+};
+
+/*Object for CCDC ycbcr mode */
+ccdc_params_ycbcr ccdc_hw_params_ycbcr = {
+	.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT,
+	.frm_fmt = CCDC_FRMFMT_INTERLACED,
+	.win = VPFE_WIN_PAL,
+	.fid_pol = CCDC_PINPOL_POSITIVE,
+	.vd_pol = CCDC_PINPOL_POSITIVE,
+	.hd_pol = CCDC_PINPOL_POSITIVE,
+	.bt656_enable = TRUE,
+	.pix_order = CCDC_PIXORDER_CBYCRY,
+	.buf_type = CCDC_BUFTYPE_FLD_INTERLEAVED
+};
+
+extern struct device *vpfe_dev;
+void ccdc_readregs(void)
+{
+	unsigned int val = 0;
+
+	val = regr(SYNCEN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SYNCEN...\n", val);
+	val = regr(MODESET);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to MODESET...\n", val);
+	val = regr(HDWIDTH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to HDWIDTH...\n", val);
+	val = regr(VDWIDTH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to VDWIDTH...\n", val);
+	val = regr(PPLN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to PPLN...\n", val);
+	val = regr(LPFR);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LPFR...\n", val);
+	val = regr(SPH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SPH...\n", val);
+	val = regr(NPH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to NPH...\n", val);
+	val = regr(SLV0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SLV0...\n", val);
+	val = regr(SLV1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SLV1...\n", val);
+	val = regr(NLV);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to NLV...\n", val);
+	val = regr(CULH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CULH...\n", val);
+	val = regr(CULV);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CULV...\n", val);
+	val = regr(HSIZE);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to HSIZE...\n", val);
+	val = regr(SDOFST);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to SDOFST...\n", val);
+	val = regr(STADRH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to STADRH...\n", val);
+	val = regr(STADRL);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to STADRL...\n", val);
+	val = regr(CLAMP);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CLAMP...\n", val);
+	val = regr(DCSUB);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DCSUB...\n", val);
+	val = regr(COLPTN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to COLPTN...\n", val);
+
+	val = regr(BLKCMP0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to BLKCMP0...\n", val);
+	val = regr(BLKCMP1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to BLKCMP1...\n", val);
+	val = regr(MEDFILT);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to MEDFILT...\n", val);
+	val = regr(RYEGAIN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to RYEGAIN...\n", val);
+	val = regr(GRCYGAIN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to GRCYGAIN...\n", val);
+	val = regr(GBGGAIN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to GBGGAIN...\n", val);
+	val = regr(BMGGAIN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to BMGGAIN...\n", val);
+	val = regr(OFFSET);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to OFFSET...\n", val);
+	val = regr(OUTCLIP);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to OUTCLIP...\n", val);
+	val = regr(VDINT0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to VDINT0...\n", val);
+	val = regr(VDINT1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to VDINT1...\n", val);
+	val = regr(RSV0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to RSV0...\n", val);
+	val = regr(GAMMAWD);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to GAMMAWD...\n", val);
+	val = regr(REC656IF);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to REC656IF...\n", val);
+	val = regr(CCDCFG);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CCDCFG...\n", val);
+	val = regr(FMTCFG);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTCFG...\n", val);
+	val = regr(FMTPLEN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPLEN...\n", val);
+	val = regr(FMTSPH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTSPH...\n", val);
+	val = regr(FMTLNH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTLNH...\n", val);
+	val = regr(FMTSLV);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTSLV...\n", val);
+	val = regr(FMTLNV);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTLNV...\n", val);
+	val = regr(FMTRLEN);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTRLEN...\n", val);
+	val = regr(FMTHCNT);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTHCNT...\n", val);
+	val = regr(FMT_ADDR_PTR_B);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMT_ADDR_PTR_B...\n", val);
+	val = regr(FMTPGM_VF0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_VF0...\n", val);
+	val = regr(FMTPGM_VF1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_VF1...\n", val);
+	val = regr(FMTPGM_AP0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP0...\n", val);
+	val = regr(FMTPGM_AP1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP1...\n", val);
+	val = regr(FMTPGM_AP2);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP2...\n", val);
+	val = regr(FMTPGM_AP3);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP3...\n", val);
+	val = regr(FMTPGM_AP4);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP4...\n", val);
+	val = regr(FMTPGM_AP5);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP5...\n", val);
+	val = regr(FMTPGM_AP6);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP6...\n", val);
+	val = regr(FMTPGM_AP7);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to FMTPGM_AP7...\n", val);
+
+	val = regr(LSCCFG1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCCFG1...\n", val);
+	val = regr(LSCCFG2);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCCFG2...\n", val);
+	val = regr(LSCH0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCH0...\n", val);
+	val = regr(LSCV0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCV0...\n", val);
+	val = regr(LSCKH);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCKH...\n", val);
+	val = regr(LSCKV);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCKV...\n", val);
+	val = regr(LSCMEMCTL);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCMEMCTL...\n", val);
+	val = regr(LSCMEMD);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCMEMD...\n", val);
+	val = regr(LSCMEMQ);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to LSCMEMQ...\n", val);
+	val = regr(DFCCTL);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCCTL...\n", val);
+	val = regr(DFCVSAT);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCVSAT...\n", val);
+	val = regr(DFCMEMCTL);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCMEMCTL...\n", val);
+	val = regr(DFCMEM0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCMEM0...\n", val);
+	val = regr(DFCMEM1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCMEM1...\n", val);
+	val = regr(DFCMEM2);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCMEM2...\n", val);
+	val = regr(DFCMEM3);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCMEM3...\n", val);
+	val = regr(DFCMEM4);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DFCMEM4...\n", val);
+	val = regr(CSCCTL);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCCTL...\n", val);
+	val = regr(CSCM0);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM0...\n", val);
+	val = regr(CSCM1);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM1...\n", val);
+
+	val = regr(CSCM2);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM2...\n", val);
+
+	val = regr(CSCM3);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM3...\n", val);
+	val = regr(CSCM4);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM4...\n", val);
+	val = regr(CSCM5);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM5...\n", val);
+
+	val = regr(CSCM6);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM6...\n", val);
+	val = regr(CSCM7);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to CSCM7...\n", val);
+	val = regr(DATAOFST);
+	dev_dbg(vpfe_dev, "\nReading 0x%x to DATAOFST...\n", val);
+}
+
+int ccdc_update_raw_params(void *arg)
+{
+	memcpy(&ccdc_hw_params_raw,
+	       (ccdc_config_params_raw *) arg, sizeof(ccdc_config_params_raw));
+	return 0;
+}
+
+int ccdc_update_ycbcr_params(void *arg)
+{
+	memcpy(&ccdc_hw_params_ycbcr,
+	       (ccdc_params_ycbcr *) arg, sizeof(ccdc_params_ycbcr));
+	return 0;
+}
+
+void ccdc_init(void)
+{
+	davinci_cfg_reg(DM355_VIN_PCLK);
+	davinci_cfg_reg(DM355_VIN_CAM_WEN);
+	davinci_cfg_reg(DM355_VIN_CAM_VD);
+	davinci_cfg_reg(DM355_VIN_CAM_HD);
+	davinci_cfg_reg(DM355_VIN_YIN_EN);
+	davinci_cfg_reg(DM355_VIN_CINL_EN);
+	davinci_cfg_reg(DM355_VIN_CINH_EN);
+}
+
+void ccdc_cleanup(void)
+{
+	/* Nothing for DM355 */
+}
+
+/*
+ * ======== ccdc_reset  ========
+ */
+/*This function will reset all CCDc reg */
+
+void ccdc_reset()
+{
+	int i, memctrl, clkctrl;
+	/* disable CCDC */
+	dev_dbg(vpfe_dev, "\nStarting ccdc_reset...");
+	mdelay(5);
+	ccdc_enable(0);
+	/* set all registers to default value */
+	for (i = 0; i <= 0x15c; i += 4) {
+		mdelay(5);
+		regw(0, i);
+	}
+	mdelay(5);
+	/* no culling support */
+	regw(0xffff, CULH);
+	mdelay(5);
+	regw(0xff, CULV);
+	mdelay(5);
+	/* always set the gain to 1 */
+	regw(0x100, RYEGAIN);
+	mdelay(5);
+	regw(0x100, GRCYGAIN);
+	mdelay(5);
+	regw(0x100, GBGGAIN);
+	mdelay(5);
+	regw(0x100, BMGGAIN);
+	mdelay(5);
+	/* up to 12 bit sensor */
+	regw(0x0FFF, OUTCLIP);
+	mdelay(5);
+
+	memctrl = regr_bl(MEMCTRL);
+	memctrl &= 0xfffffffe;	/*configuring DFC for IPIPE */
+	mdelay(5);
+	regw_bl(memctrl, MEMCTRL);
+	mdelay(5);
+	regw_bl(0x00, CCDCMUX);	/*CCDC input Mux select directly from sensor */
+	mdelay(5);
+	clkctrl = regr_clk(CLKCTRL);
+	clkctrl &= 0x3f;
+	clkctrl |= 0x40;
+	mdelay(5);
+	regw_clk(clkctrl, CLKCTRL);
+
+	dev_dbg(vpfe_dev, "\nEnd of ccdc_reset...");
+}
+
+/*
+ * ======== ccdc_setwin  ========
+ */
+/*This function will configure the window size to be capture in CCDC reg */
+void ccdc_setwin(ccdc_imgwin * image_win, ccdc_frmfmt frm_fmt, int ppc)
+{
+	int horz_start, horz_nr_pixels;
+	int vert_start, vert_nr_lines;
+	int mid_img = 0;
+	dev_dbg(vpfe_dev, "\nStarting ccdc_setwin...");
+	/* configure horizonal and vertical starts and sizes */
+	horz_start = image_win->left << (ppc - 1);
+	horz_nr_pixels = ((image_win->width) << (ppc - 1)) - 1;
+
+	/*Writing the horizontal info into the registers */
+	mdelay(5);
+	regw(horz_start & START_PX_HOR_MASK, SPH);
+	mdelay(5);
+	regw(horz_nr_pixels & NUM_PX_HOR_MASK, NPH);
+	vert_start = image_win->top;
+
+	if (frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		vert_nr_lines = (image_win->height >> 1) - 1;
+		vert_start >>= 1;
+		vert_start += 1; /* Since first line doesn't have any data */
+		/* configure VDINT0 and VDINT1 */
+		regw(vert_start, VDINT0);
+	} else {
+		vert_start += 1; /* Since first line doesn't have any data */
+		vert_nr_lines = image_win->height - 1;
+		/* configure VDINT0 and VDINT1 */
+		mid_img = vert_start + (image_win->height / 2);
+		regw(vert_start, VDINT0);
+		regw(mid_img, VDINT1);
+	}
+	mdelay(5);
+	regw(vert_start & START_VER_ONE_MASK, SLV0);
+	mdelay(5);
+	regw(vert_start & START_VER_TWO_MASK, SLV1);
+	mdelay(5);
+	regw(vert_nr_lines & NUM_LINES_VER, NLV);
+	dev_dbg(vpfe_dev, "\nEnd of ccdc_setwin...");
+}
+
+#if 0
+void ccdc_config_stillcapture(void *arg)
+{
+	ccdc_params_raw *params;
+	params = (ccdc_params_raw *) arg;
+	ccdc_config_raw(params);
+
+	/***/
+	regw(0x63, HDWIDTH);
+	regw(0x8, VDWIDTH);
+	regw(0x11c5, PPLN);
+	regw(0x947, LPFR);
+	regw(2, LSCCFG2);
+	/***/
+
+	regw(0xFFFF, CULH);
+	regw(0x159, HSIZE);
+	regw(0x100, RYEGAIN);
+	regw(0x100, GRCYGAIN);
+	regw(0x100, GBGGAIN);
+	regw(0x100, BMGGAIN);
+	regw(0x64, VDINT0);
+	regw(0x1e, VDINT1);
+	regw(0x9, GAMMAWD);
+	regw(0x20, FMTCFG);
+	regw(0x0, CCDCFG);
+
+}
+#endif
+
+/* following function is just for the reference, check the registers value ,
+not used any where */
+void ccdc_config_stillcapture1(void *arg)
+{
+	__REG(0x01C70600) = 0x00000000;
+	__REG(0x01C70604) = 0x00000800;
+	__REG(0x01C70608) = 0x00000063;
+	__REG(0x01C7060c) = 0x00000008;
+	__REG(0x01C70610) = 0x000011c5;
+	__REG(0x01C70614) = 0x00000947;
+	__REG(0x01C70618) = 0x0000037a;
+	__REG(0x01C7061c) = 0x00000e5f;
+	__REG(0x01C70620) = 0x00000037;
+	__REG(0x01C70624) = 0x00000037;
+	__REG(0x01C70628) = 0x00000395;
+	__REG(0x01C7062c) = 0x0000ffff;
+	__REG(0x01C70630) = 0x000000FF;
+	__REG(0x01C70634) = 0x00000159;
+	__REG(0x01C70638) = 0x00000000;
+	__REG(0x01C70644) = 0x00000000;
+	__REG(0x01C70648) = 0x00000000;
+	__REG(0x01C7064c) = 0x00004E4E;
+	__REG(0x01C70650) = 0x00000000;
+	__REG(0x01C70654) = 0x00000000;
+	__REG(0x01C70658) = 0x00000000;
+	__REG(0x01C7065c) = 0x00000100;
+	__REG(0x01C70660) = 0x00000100;
+	__REG(0x01C70664) = 0x00000100;
+	__REG(0x01C70668) = 0x00000100;
+	__REG(0x01C7066c) = 0x00000000;
+	__REG(0x01C70670) = 0x00003FFF;
+	__REG(0x01C70674) = 0x00000064;
+	__REG(0x01C70678) = 0x0000001e;
+	__REG(0x01C7067c) = 0x00000000;
+	__REG(0x01C70680) = 0x00000009;
+	__REG(0x01C70684) = 0x00000000;
+	__REG(0x01C70688) = 0x00000000;
+	__REG(0x01C7068c) = 0x00000020;
+	__REG(0x01C70690) = 0x00007722;
+	__REG(0x01C70694) = 0x0000036e;
+	__REG(0x01C70698) = 0x00000e57;
+	__REG(0x01C7069c) = 0x00000100;
+	__REG(0x01C706a0) = 0x00000395;
+	__REG(0x01C706a4) = 0x000004c7;
+	__REG(0x01C706a8) = 0x000004d2;
+	__REG(0x01C706ac) = 0x00000000;
+	__REG(0x01C706b0) = 0x00002000;
+	__REG(0x01C706b4) = 0x00004000;
+	__REG(0x01C706b8) = 0x00000000;
+	__REG(0x01C706bc) = 0x00000000;
+	__REG(0x01C706c0) = 0x00000000;
+	__REG(0x01C706c4) = 0x00000000;
+	__REG(0x01C706c8) = 0x00000000;
+	__REG(0x01C706cc) = 0x00000007;
+	__REG(0x01C706d0) = 0x00000007;
+	__REG(0x01C706d4) = 0x00000210;
+	__REG(0x01C706d8) = 0x00000000;
+	__REG(0x01C706dc) = 0x00000000;
+	__REG(0x01C706e0) = 0x00000000;
+	__REG(0x01C706e4) = 0x00000210;
+	__REG(0x01C706e8) = 0x00000000;
+	__REG(0x01C706ec) = 0x00000000;
+	__REG(0x01C706f0) = 0x00000000;
+	__REG(0x01C706f4) = 0x00000000;
+	__REG(0x01C706f8) = 0x00000002;
+	__REG(0x01C706fc) = 0x00000000;
+	__REG(0x01C70700) = 0x00000000;
+	__REG(0x01C70704) = 0x00000000;
+	__REG(0x01C70708) = 0x00000000;
+
+}
+
+/*This function will configure CCDC for YCbCr parameters*/
+void ccdc_config_ycbcr()
+{
+	u32 modeset;
+	ccdc_params_ycbcr *params = &ccdc_hw_params_ycbcr;
+
+	/* first reset the CCDC                                          */
+	/* all registers have default values after reset                 */
+	/* This is important since we assume default values to be set in */
+	/* a lot of registers that we didn't touch                       */
+	dev_dbg(vpfe_dev, "\nStarting ccdc_config_ycbcr...");
+	mdelay(5);
+	ccdc_reset();
+
+	/* configure pixel format */
+	modeset = (params->pix_fmt & 0x3) << 12;
+
+	/* configure video frame format */
+	modeset |= (params->frm_fmt & 0x1) << 7;
+
+	/* setup BT.656 sync mode */
+	if (params->bt656_enable) {
+		regw(3, REC656IF);
+		mdelay(5);
+		/* configure the FID, VD, HD pin polarity */
+		/* fld,hd pol positive, vd negative, 8-bit pack mode */
+		modeset |= 0x04;
+	} else {		/* y/c external sync mode */
+		modeset |= ((params->fid_pol & 0x1) << 4);
+		modeset |= ((params->hd_pol & 0x1) << 3);
+		modeset |= ((params->vd_pol & 0x1) << 2);
+	}
+
+	/* pack the data to 8-bit */
+	modeset |= 0x1 << 11;
+
+	regw(modeset, MODESET);
+	mdelay(5);
+
+	/* configure video window */
+	ccdc_setwin(&params->win, params->frm_fmt, 2);
+	mdelay(5);
+	/* configure the order of y cb cr in SD-RAM */
+	regw((params->pix_order << 11) | 0x8040, CCDCFG);
+	mdelay(5);
+
+	/* configure the horizontal line offset */
+	/* this is done by rounding up width to a multiple of 16 pixels */
+	/* and multiply by two to account for y:cb:cr 4:2:2 data */
+	regw(((((params->win.width * 2) + 31) & 0xffffffe0) >> 5), HSIZE);
+	mdelay(5);
+
+	/* configure the memory line offset */
+	if (params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED) {
+		/* two fields are interleaved in memory */
+		regw(0x00000249, SDOFST);
+		mdelay(5);
+	}
+	/*val = (unsigned int)ccdc_sbl_reset();
+	   dev_dbg(vpfe_dev, "\nReading 0x%x from SBL...\n", val); */
+
+	dev_dbg(vpfe_dev, "\nEnd of ccdc_config_ycbcr...\n");
+	/*ccdc_readregs(); */
+}
+
+/*
+ * ======== ccdc_config_raw  ========
+ */
+/*This function will configure CCDC for Raw mode parameters*/
+void ccdc_config_raw()
+{
+	ccdc_params_raw *params = &ccdc_hw_params_raw;
+	unsigned int mode_set = 0;
+	unsigned int val = 0, val1 = 0;
+	int temp1 = 0, temp2 = 0, i = 0, fmtreg_v = 0, shift_v = 0, flag = 0;
+	int temp_gf = 0, temp_lcs = 0;
+	dev_dbg(vpfe_dev, "\nStarting ccdc_config_raw...");
+	/*      Reset CCDC */
+	mdelay(5);
+	ccdc_reset();
+
+	/*
+	 *      C O N F I G U R I N G  T H E  C C D C F G  R E G I S T E R
+	 */
+
+	/*Set CCD Not to swap input since input is RAW data */
+	val |= CCDC_YCINSWP_RAW;
+
+	/*set FID detection function to Latch at V-Sync */
+	val |= CCDC_CCDCFG_FIDMD_LATCH_VSYNC << CCDC_CCDCFG_FIDMD_SHIFT;
+
+	/*set WENLOG - ccdc valid area */
+	val |= CCDC_CCDCFG_WENLOG_AND << CCDC_CCDCFG_WENLOG_SHIFT;
+
+	/*set TRGSEL */
+	val |= CCDC_CCDCFG_TRGSEL_WEN << CCDC_CCDCFG_TRGSEL_SHIFT;
+
+	/*set EXTRG */
+	val |= CCDC_CCDCFG_EXTRG_DISABLE << CCDC_CCDCFG_EXTRG_SHIFT;
+
+	/* Disable latching function registers on VSYNC-busy writable
+	   registers  */
+	/*regw(CCDC_LATCH_ON_VSYNC_DISABLE, CCDCFG); */
+
+	/* Enable latching function registers on VSYNC-shadowed registers */
+	val |= CCDC_LATCH_ON_VSYNC_DISABLE;
+	mdelay(5);
+	regw(val, CCDCFG);
+	/*
+	 *      C O N F I G U R I N G  T H E  M O D E S E T  R E G I S T E R
+	 */
+
+	/*Set VDHD direction to input */
+	mode_set |=
+	    (CCDC_VDHDOUT_INPUT & CCDC_VDHDOUT_MASK) << CCDC_VDHDOUT_SHIFT;
+
+	/*Set input type to raw input */
+	mode_set |=
+	    (CCDC_RAW_IP_MODE & CCDC_RAW_INPUT_MASK) << CCDC_RAW_INPUT_SHIFT;
+
+	/*      Configure the vertical sync polarity(MODESET.VDPOL) */
+	mode_set = (params->vd_pol & CCDC_VD_POL_MASK) << CCDC_VD_POL_SHIFT;
+
+	/*      Configure the horizontal sync polarity (MODESET.HDPOL) */
+	mode_set |= (params->hd_pol & CCDC_HD_POL_MASK) << CCDC_HD_POL_SHIFT;
+
+	/*      Configure frame id polarity (MODESET.FLDPOL) */
+	mode_set |= (params->fid_pol & CCDC_FID_POL_MASK) << CCDC_FID_POL_SHIFT;
+
+	/*      Configure data polarity */
+	mode_set |=
+	    (CCDC_DATAPOL_NORMAL & CCDC_DATAPOL_MASK) << CCDC_DATAPOL_SHIFT;
+
+	/*      Configure External WEN Selection */
+	mode_set |= (CCDC_EXWEN_DISABLE & CCDC_EXWEN_MASK) << CCDC_EXWEN_SHIFT;
+
+	/* Configure frame format(progressive or interlace) */
+	mode_set |= (params->frm_fmt & CCDC_FRM_FMT_MASK) << CCDC_FRM_FMT_SHIFT;
+
+	/* Configure pixel format (Input mode) */
+	mode_set |= (params->pix_fmt & CCDC_PIX_FMT_MASK) << CCDC_PIX_FMT_SHIFT;
+
+	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable) {
+		mode_set |= CCDC_DATA_PACK_ENABLE;
+	}
+
+	/*Configure for LPF */
+	if (params->lpf_enable) {
+		mode_set |=
+		    (params->lpf_enable & CCDC_LPF_MASK) << CCDC_LPF_SHIFT;
+	}
+
+	/*Configure the data shift */
+	mode_set |= (params->datasft & CCDC_DATASFT_MASK) << CCDC_DATASFT_SHIFT;
+	mdelay(5);
+	regw(mode_set, MODESET);
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to MODESET...\n", mode_set);
+
+	/*Configure the Median Filter threshold */
+	mdelay(5);
+	regw((params->med_filt_thres) & 0x3fff, MEDFILT);
+
+	/*
+	 *      C O N F I G U R E   T H E   G A M M A W D   R E G I S T E R
+	 */
+
+	val = 8;
+	val |=
+	    (CCDC_CFA_MOSAIC & CCDC_GAMMAWD_CFA_MASK) << CCDC_GAMMAWD_CFA_SHIFT;
+
+	/* Enable and configure aLaw register if needed */
+	if (params->alaw.b_alaw_enable) {
+		val |= (params->alaw.gama_wd & CCDC_ALAW_GAMA_WD_MASK) << 2;
+		val |= CCDC_ALAW_ENABLE;	/*set enable bit of alaw */
+	}
+
+	/*Configure Median filter1 for IPIPE capture */
+	val |= params->mfilt1 << CCDC_MFILT1_SHIFT;
+
+	/*Configure Median filter2 for SDRAM capture */
+	val |= params->mfilt2 << CCDC_MFILT2_SHIFT;
+
+	mdelay(5);
+	regw(val, GAMMAWD);
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to GAMMAWD...\n", val);
+
+	/* configure video window */
+	mdelay(5);
+	ccdc_setwin(&params->win, params->frm_fmt, 1);
+
+	/*
+	 *      O P T I C A L   B L A C K   A V E R A G I N G
+	 */
+	val = 0;
+	if (params->blk_clamp.b_clamp_enable) {
+		val |= (params->blk_clamp.start_pixel & CCDC_BLK_ST_PXL_MASK);
+
+		val1 |= (params->blk_clamp.sample_ln & CCDC_NUM_LINE_CALC_MASK)
+		    << CCDC_NUM_LINE_CALC_SHIFT;	/*No of line
+							   to be avg */
+		val |=
+		    (params->blk_clamp.sample_pixel & CCDC_BLK_SAMPLE_LN_MASK)
+		    << CCDC_BLK_SAMPLE_LN_SHIFT;	/*No of pixel/line to be avg */
+		val |= CCDC_BLK_CLAMP_ENABLE;	/*Enable the Black clamping */
+		mdelay(5);
+		regw(val, CLAMP);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to CLAMP...\n", val);
+		mdelay(5);
+		regw(val1, DCSUB);	/*If Black clamping is enable
+					   then make dcsub 0 */
+		dev_dbg(vpfe_dev, "\nWriting 0x00000000 to DCSUB...\n");
+
+	} else {
+		/* configure DCSub */
+		val = (params->blk_clamp.dc_sub) & CCDC_BLK_DC_SUB_MASK;
+		mdelay(5);
+		regw(val, DCSUB);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to DCSUB...\n", val);
+		mdelay(5);
+		regw(0x0000, CLAMP);
+
+		dev_dbg(vpfe_dev, "\nWriting 0x0000 to CLAMP...\n");
+	}
+
+	/*
+	 *  C O N F I G U R E   B L A C K   L E V E L   C O M P E N S A T I O N
+	 */
+	val = 0;
+	val = (params->blk_comp.b_comp & CCDC_BLK_COMP_MASK);
+	val |= (params->blk_comp.gb_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_GB_COMP_SHIFT;
+	mdelay(5);
+	regw(val, BLKCMP1);
+
+	val1 = 0;
+	val1 |= (params->blk_comp.gr_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_GR_COMP_SHIFT;
+	val1 |= (params->blk_comp.r_comp & CCDC_BLK_COMP_MASK)
+	    << CCDC_BLK_COMP_R_COMP_SHIFT;
+	mdelay(5);
+	regw(val1, BLKCMP0);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to BLKCMP1...\n", val);
+	dev_dbg(vpfe_dev, "\nWriting 0x%x to BLKCMP0...\n", val1);
+
+	/* Configure Vertical Defect Correction if needed */
+	if (params->vertical_dft.ver_dft_en) {
+
+		shift_v = 0;
+		shift_v = 0 << CCDC_DFCCTL_VDFCEN_SHIFT;
+		shift_v |=
+		    params->vertical_dft.gen_dft_en & CCDC_DFCCTL_GDFCEN_MASK;
+		shift_v |=
+		    (params->vertical_dft.dft_corr_ctl.
+		     vdfcsl & CCDC_DFCCTL_VDFCSL_MASK) <<
+		    CCDC_DFCCTL_VDFCSL_SHIFT;
+		shift_v |=
+		    (params->vertical_dft.dft_corr_ctl.
+		     vdfcuda & CCDC_DFCCTL_VDFCUDA_MASK) <<
+		    CCDC_DFCCTL_VDFCUDA_SHIFT;
+		shift_v |=
+		    (params->vertical_dft.dft_corr_ctl.
+		     vdflsft & CCDC_DFCCTL_VDFLSFT_MASK) <<
+		    CCDC_DFCCTL_VDFLSFT_SHIFT;
+		mdelay(5);
+		regw(shift_v, DFCCTL);
+		mdelay(5);
+		regw(params->vertical_dft.dft_corr_vert[0], DFCMEM0);
+		mdelay(5);
+		regw(params->vertical_dft.dft_corr_horz[0], DFCMEM1);
+		mdelay(5);
+		regw(params->vertical_dft.dft_corr_sub1[0], DFCMEM2);
+		mdelay(5);
+		regw(params->vertical_dft.dft_corr_sub2[0], DFCMEM3);
+		mdelay(5);
+		regw(params->vertical_dft.dft_corr_sub3[0], DFCMEM4);
+
+		shift_v = 0;
+		shift_v = regr(DFCMEMCTL);
+		shift_v |= 1 << CCDC_DFCMEMCTL_DFCMARST_SHIFT;
+		shift_v |= 1;
+		mdelay(5);
+		regw(shift_v, DFCMEMCTL);
+
+		while (1) {
+			flag = regr(DFCMEMCTL);
+			if ((flag & 0x01) == 0x00)
+				break;
+		}
+		flag = 0;
+		shift_v = 0;
+		shift_v = regr(DFCMEMCTL);
+		shift_v |= 0 << CCDC_DFCMEMCTL_DFCMARST_SHIFT;
+		mdelay(5);
+		regw(shift_v, DFCMEMCTL);
+
+		for (i = 1; i < 16; i++) {
+			mdelay(5);
+			regw(params->vertical_dft.dft_corr_vert[i], DFCMEM0);
+			mdelay(5);
+			regw(params->vertical_dft.dft_corr_horz[i], DFCMEM1);
+			mdelay(5);
+			regw(params->vertical_dft.dft_corr_sub1[i], DFCMEM2);
+			mdelay(5);
+			regw(params->vertical_dft.dft_corr_sub2[i], DFCMEM3);
+			mdelay(5);
+			regw(params->vertical_dft.dft_corr_sub3[i], DFCMEM4);
+
+			shift_v = 0;
+			shift_v = regr(DFCMEMCTL);
+			shift_v |= 1;
+			mdelay(5);
+			regw(shift_v, DFCMEMCTL);
+
+			while (1) {
+				mdelay(5);
+				flag = regr(DFCMEMCTL);
+				if ((flag & 0x01) == 0x00)
+					break;
+			}
+			flag = 0;
+		}
+		mdelay(5);
+		regw(params->vertical_dft.
+		     saturation_ctl & CCDC_VDC_DFCVSAT_MASK, DFCVSAT);
+
+		shift_v = 0;
+		shift_v = regr(DFCCTL);
+		shift_v |= 1 << CCDC_DFCCTL_VDFCEN_SHIFT;
+		mdelay(5);
+		regw(shift_v, DFCCTL);
+	}
+
+	/* Configure Lens Shading Correction if needed */
+	if (params->lens_sh_corr.lsc_enable) {
+		dev_dbg(vpfe_dev, "\nlens shading Correction entered....\n");
+
+		/*first disable the LSC */
+		mdelay(5);
+		regw(CCDC_LSC_DISABLE, LSCCFG1);
+
+		/*UPDATE PROCEDURE FOR GAIN FACTOR TABLE 1 */
+
+		/*select table 1 */
+		mdelay(5);
+		regw(CCDC_LSC_TABLE1_SLC, LSCMEMCTL);
+
+		/*Reset memory address */
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_RESET;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Update gainfactor for table 1 - u8q8 */
+		temp_gf =
+		    ((int)(params->lens_sh_corr.gf_table1[0].frac_no * 256))
+		    & CCDC_LSC_FRAC_MASK_T1;
+		temp_gf |=
+		    (((int)(params->lens_sh_corr.gf_table1[0].frac_no * 256))
+		     & CCDC_LSC_FRAC_MASK_T1) << 8;
+		mdelay(5);
+		regw(temp_gf, LSCMEMD);
+
+		while (1) {
+			if ((regr(LSCMEMCTL) & 0x10) == 0)
+				break;
+		}
+
+		/*set the address to incremental mode */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_INCR;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		for (i = 2; i < 255; i += 2) {
+			temp_gf = 0;
+			temp_gf = ((int)
+				   (params->lens_sh_corr.gf_table1[0].frac_no *
+				    256))
+			    & CCDC_LSC_FRAC_MASK_T1;
+			temp_gf |= (((int)
+				     (params->lens_sh_corr.gf_table1[0].
+				      frac_no * 256))
+				    & CCDC_LSC_FRAC_MASK_T1) << 8;
+			mdelay(5);
+			regw(temp_gf, LSCMEMD);
+
+			while (1) {
+				if ((regr(LSCMEMCTL) & 0x10) == 0)
+					break;
+			}
+		}
+
+		/*UPDATE PROCEDURE FOR GAIN FACTOR TABLE 2 */
+
+		/*select table 2 */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_TABLE2_SLC;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Reset memory address */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_RESET;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Update gainfactor for table 2 - u16q14 */
+		temp_gf =
+		    (params->lens_sh_corr.gf_table2[0].
+		     int_no & CCDC_LSC_INT_MASK) << 14;
+		temp_gf |=
+		    ((int)(params->lens_sh_corr.gf_table2[0].frac_no) * 16384)
+		    & CCDC_LSC_FRAC_MASK;
+		mdelay(5);
+		regw(temp_gf, LSCMEMD);
+
+		while (1) {
+			if ((regr(LSCMEMCTL) & 0x10) == 0)
+				break;
+		}
+
+		/*set the address to incremental mode */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_INCR;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		for (i = 1; i < 128; i++) {
+			temp_gf = 0;
+			temp_gf =
+			    (params->lens_sh_corr.gf_table2[i].
+			     int_no & CCDC_LSC_INT_MASK) << 14;
+			temp_gf |=
+			    ((int)(params->lens_sh_corr.gf_table2[0].frac_no) *
+			     16384)
+			    & CCDC_LSC_FRAC_MASK;
+			mdelay(5);
+			regw(temp_gf, LSCMEMD);
+
+			while (1) {
+				mdelay(5);
+				if ((regr(LSCMEMCTL) & 0x10) == 0)
+					break;
+			}
+		}
+
+		/*UPDATE PROCEDURE FOR GAIN FACTOR TABLE 3 */
+
+		/*select table 3 */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_TABLE3_SLC;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Reset memory address */
+		temp_lcs = 0;
+		temp_lcs = regr(LSCMEMCTL);
+		temp_lcs |= CCDC_LSC_MEMADDR_RESET;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		/*Update gainfactor for table 2 - u16q14 */
+		temp_gf =
+		    (params->lens_sh_corr.gf_table3[0].
+		     int_no & CCDC_LSC_INT_MASK) << 14;
+		temp_gf |=
+		    ((int)(params->lens_sh_corr.gf_table3[0].frac_no) * 16384)
+		    & CCDC_LSC_FRAC_MASK;
+		mdelay(5);
+		regw(temp_gf, LSCMEMD);
+
+		while (1) {
+			mdelay(5);
+			if ((regr(LSCMEMCTL) & 0x10) == 0)
+				break;
+		}
+
+		/*set the address to incremental mode */
+		temp_lcs = 0;
+		mdelay(5);
+		temp_lcs = regr(LSCMEMCTL);
+		mdelay(5);
+		temp_lcs |= CCDC_LSC_MEMADDR_INCR;
+		mdelay(5);
+		regw(temp_lcs, LSCMEMCTL);
+
+		for (i = 1; i < 128; i++) {
+			temp_gf = 0;
+			temp_gf =
+			    (params->lens_sh_corr.gf_table3[i].
+			     int_no & CCDC_LSC_INT_MASK) << 14;
+			temp_gf |=
+			    ((int)(params->lens_sh_corr.gf_table3[0].frac_no) *
+			     16384)
+			    & CCDC_LSC_FRAC_MASK;
+			mdelay(5);
+			regw(temp_gf, LSCMEMD);
+
+			while (1) {
+				mdelay(5);
+				if ((regr(LSCMEMCTL) & 0x10) == 0)
+					break;
+			}
+		}
+		/*Configuring the optical centre of the lens */
+		mdelay(5);
+		regw(params->lens_sh_corr.
+		     lens_center_horz & CCDC_LSC_CENTRE_MASK, LSCH0);
+		mdelay(5);
+		regw(params->lens_sh_corr.
+		     lens_center_vert & CCDC_LSC_CENTRE_MASK, LSCV0);
+
+		val = 0;
+		val =
+		    ((int)(params->lens_sh_corr.horz_left_coef.frac_no * 128)) &
+		    0x7f;
+		val |= (params->lens_sh_corr.horz_left_coef.int_no & 0x01) << 7;
+		val |=
+		    (((int)(params->lens_sh_corr.horz_right_coef.frac_no * 128))
+		     & 0x7f) << 8;
+		val |=
+		    (params->lens_sh_corr.horz_right_coef.int_no & 0x01) << 15;
+		mdelay(5);
+		regw(val, LSCKH);
+
+		val = 0;
+		val =
+		    ((int)(params->lens_sh_corr.ver_up_coef.frac_no * 128)) &
+		    0x7f;
+		val |= (params->lens_sh_corr.ver_up_coef.int_no & 0x01) << 7;
+		val |=
+		    (((int)(params->lens_sh_corr.ver_low_coef.frac_no * 128)) &
+		     0x7f) << 8;
+		val |= (params->lens_sh_corr.ver_low_coef.int_no & 0x01) << 15;
+		mdelay(5);
+		regw(val, LSCKV);
+
+		/*configuring the lsc configuration register 2 */
+		temp_lcs = 0;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     gf_table_scaling_fact & CCDC_LSCCFG_GFTSF_MASK) <<
+		    CCDC_LSCCFG_GFTSF_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     gf_table_interval & CCDC_LSCCFG_GFTINV_MASK) <<
+		    CCDC_LSCCFG_GFTINV_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     epel & CCDC_LSC_GFTABLE_SEL_MASK) <<
+		    CCDC_LSC_GFTABLE_EPEL_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     opel & CCDC_LSC_GFTABLE_SEL_MASK) <<
+		    CCDC_LSC_GFTABLE_OPEL_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     epol & CCDC_LSC_GFTABLE_SEL_MASK) <<
+		    CCDC_LSC_GFTABLE_EPOL_SHIFT;
+		temp_lcs |=
+		    (params->lens_sh_corr.lsc_config.
+		     opol & CCDC_LSC_GFTABLE_SEL_MASK) <<
+		    CCDC_LSC_GFTABLE_OPOL_SHIFT;
+		mdelay(5);
+		regw(temp_lcs, LSCCFG2);
+
+		/*configuring the LSC configuration register 1 */
+		temp_lcs = 0;
+		temp_lcs |= CCDC_LSC_ENABLE;
+		temp_lcs |= (params->lens_sh_corr.lsc_config.gfmode &
+			     CCDC_LSC_GFMODE_MASK) << CCDC_LSC_GFMODE_SHIFT;
+		mdelay(5);
+		regw(temp_lcs, LSCCFG1);
+	}
+
+	/* Configure data formatter if needed */
+	if (params->data_formatter_r.fmt_enable
+	    && (!params->color_space_con.csc_enable)) {
+		dev_dbg(vpfe_dev,
+			"\ndata formatter will be configured now....\n");
+
+		/*Configuring the FMTPLEN */
+		fmtreg_v = 0;
+		fmtreg_v |=
+		    (params->data_formatter_r.fmtplen.
+		     plen0 & CCDC_FMTPLEN_P0_MASK);
+		fmtreg_v |=
+		    ((params->data_formatter_r.fmtplen.
+		      plen1 & CCDC_FMTPLEN_P1_MASK)
+		     << CCDC_FMTPLEN_P1_SHIFT);
+		fmtreg_v |=
+		    ((params->data_formatter_r.fmtplen.
+		      plen2 & CCDC_FMTPLEN_P2_MASK)
+		     << CCDC_FMTPLEN_P2_SHIFT);
+		fmtreg_v |=
+		    ((params->data_formatter_r.fmtplen.
+		      plen3 & CCDC_FMTPLEN_P3_MASK)
+		     << CCDC_FMTPLEN_P3_SHIFT);
+		mdelay(5);
+		regw(fmtreg_v, FMTPLEN);
+
+		/*Configurring the FMTSPH */
+		mdelay(5);
+		regw((params->data_formatter_r.fmtsph & CCDC_FMTSPH_MASK),
+		     FMTSPH);
+
+		/*Configurring the FMTLNH */
+		mdelay(5);
+		regw((params->data_formatter_r.fmtlnh & CCDC_FMTLNH_MASK),
+		     FMTLNH);
+
+		/*Configurring the FMTSLV */
+		mdelay(5);
+		regw((params->data_formatter_r.fmtslv & CCDC_FMTSLV_MASK),
+		     FMTSLV);
+
+		/*Configurring the FMTLNV */
+		mdelay(5);
+		regw((params->data_formatter_r.fmtlnv & CCDC_FMTLNV_MASK),
+		     FMTLNV);
+
+		/*Configurring the FMTRLEN */
+		mdelay(5);
+		regw((params->data_formatter_r.fmtrlen & CCDC_FMTRLEN_MASK),
+		     FMTRLEN);
+
+		/*Configurring the FMTHCNT */
+		mdelay(5);
+		regw((params->data_formatter_r.fmthcnt & CCDC_FMTHCNT_MASK),
+		     FMTHCNT);
+
+		/*Configuring the FMTADDR_PTR */
+		for (i = 0; i < 8; i++) {
+			fmtreg_v = 0;
+
+			if (params->data_formatter_r.fmtaddr_ptr[i].init >
+			    (params->data_formatter_r.fmtrlen - 1)) {
+				dev_dbg(vpfe_dev,
+					"\nInvalid init parameter for FMTADDR_PTR....\n");
+				return;
+			}
+
+			fmtreg_v =
+			    (params->data_formatter_r.fmtaddr_ptr[i].
+			     init & CCDC_ADP_INIT_MASK);
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtaddr_ptr[i].
+			      line & CCDC_ADP_LINE_MASK) <<
+			     CCDC_ADP_LINE_SHIFT);
+			mdelay(5);
+			regw(fmtreg_v, FMT_ADDR_PTR(i));
+		}
+
+		/*Configuring the FMTPGM_VF0 */
+		fmtreg_v = 0;
+		for (i = 0; i < 16; i++) {
+			fmtreg_v |= params->data_formatter_r.pgm_en[i] << i;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_VF0);
+
+		/*Configuring the FMTPGM_VF1 */
+		fmtreg_v = 0;
+		for (i = 16; i < 32; i++) {
+			fmtreg_v |=
+			    params->data_formatter_r.pgm_en[i] << (i - 16);
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_VF1);
+
+		/*Configuring the FMTPGM_AP0 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 0; i < 4; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP0);
+
+		/*Configuring the FMTPGM_AP1 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 4; i < 8; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP1);
+
+		/*Configuring the FMTPGM_AP2 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 8; i < 12; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP2);
+
+		/*Configuring the FMTPGM_AP3 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 12; i < 16; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP3);
+
+		/*Configuring the FMTPGM_AP4 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 16; i < 20; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP4);
+
+		/*Configuring the FMTPGM_AP5 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 20; i < 24; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP5);
+
+		/*Configuring the FMTPGM_AP6 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 24; i < 28; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP6);
+
+		/*Configuring the FMTPGM_AP7 */
+		fmtreg_v = 0;
+		shift_v = 0;
+		for (i = 28; i < 32; i++) {
+			fmtreg_v |=
+			    ((params->data_formatter_r.fmtpgm_ap[i].
+			      pgm_aptr & CCDC_FMTPGN_APTR_MASK) << shift_v);
+			fmtreg_v |=
+			    (params->data_formatter_r.fmtpgm_ap[i].
+			     pgmupdt << (shift_v + 3));
+			shift_v += 4;
+		}
+		mdelay(5);
+		regw(fmtreg_v, FMTPGM_AP7);
+
+		/*Configuring the FMTCFG register */
+		fmtreg_v = 0;
+		fmtreg_v = CCDC_DF_ENABLE;
+		fmtreg_v |=
+		    ((params->data_formatter_r.fmtcfg.
+		      fmtmode & CCDC_FMTCFG_FMTMODE_MASK)
+		     << CCDC_FMTCFG_FMTMODE_SHIFT);
+		fmtreg_v |=
+		    ((params->data_formatter_r.fmtcfg.
+		      lnum & CCDC_FMTCFG_LNUM_MASK)
+		     << CCDC_FMTCFG_LNUM_SHIFT);
+		fmtreg_v |=
+		    ((params->data_formatter_r.fmtcfg.
+		      addrinc & CCDC_FMTCFG_ADDRINC_MASK)
+		     << CCDC_FMTCFG_ADDRINC_SHIFT);
+		mdelay(5);
+		regw(fmtreg_v, FMTCFG);
+
+	} else if (params->data_formatter_r.fmt_enable) {
+		dev_dbg(vpfe_dev,
+			"\nCSC and Data Formatter Enabled at same time....\n");
+	}
+
+	/*
+	 *      C O N F I G U R E   C O L O R   S P A C E   C O N V E R T E R
+	 */
+
+	if ((params->color_space_con.csc_enable)
+	    && (!params->data_formatter_r.fmt_enable)) {
+		dev_dbg(vpfe_dev, "\nconfiguring the CSC Now....\n");
+
+		/*Enable the CSC sub-module */
+		mdelay(5);
+		regw(CCDC_CSC_ENABLE, CSCCTL);
+
+		/*Converting the co-eff as per the format of the register */
+		for (i = 0; i < 16; i++) {
+			temp1 = params->color_space_con.csc_dec_coeff[i];
+			/*Masking the data for 3 bits */
+			temp1 &= CCDC_CSC_COEFF_DEC_MASK;
+			/*Recovering the fractional part and converting to
+			   binary of 5 bits */
+			temp2 =
+			    (int)(params->color_space_con.csc_frac_coeff[i] *
+				  (32 / 10));
+			temp2 &= CCDC_CSC_COEFF_FRAC_MASK;
+			/*shifting the decimal to the MSB */
+			temp1 = temp1 << CCDC_CSC_DEC_SHIFT;
+			temp1 |= temp2;	/*appending the fraction at LSB */
+			params->color_space_con.csc_dec_coeff[i] = temp1;
+		}
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[0], CSCM0);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[1] << CCDC_CSC_COEFF_SHIFT, CSCM0);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[2], CSCM1);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[3] << CCDC_CSC_COEFF_SHIFT, CSCM1);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[4], CSCM2);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[5] << CCDC_CSC_COEFF_SHIFT, CSCM2);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[6], CSCM3);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[7] << CCDC_CSC_COEFF_SHIFT, CSCM3);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[8], CSCM4);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[9] << CCDC_CSC_COEFF_SHIFT, CSCM4);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[10], CSCM5);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[11] << CCDC_CSC_COEFF_SHIFT, CSCM5);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[12], CSCM6);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[13] << CCDC_CSC_COEFF_SHIFT, CSCM6);
+		mdelay(5);
+		regw(params->color_space_con.csc_dec_coeff[14], CSCM7);
+		mdelay(5);
+		regw(params->color_space_con.
+		     csc_dec_coeff[15] << CCDC_CSC_COEFF_SHIFT, CSCM7);
+
+	} else if (params->color_space_con.csc_enable) {
+		dev_err(vpfe_dev,
+			"\nCSC and Data Formatter Enabled at same time....\n");
+	}
+
+	/*Configure the offset control */
+	if (params->ccdc_offset) {
+		if (params->ccdc_offset < 1024) {
+			mdelay(5);
+			regw(params->ccdc_offset & CCDC_OFFSET_MASK, OFFSET);
+		} else
+			dev_err(vpfe_dev, "\ninvalid offset value....\n");
+	}
+
+	/*
+	 *      C O N F I G U R E  C O L O R  P A T T E R N  A S
+	 *      P E R  N N 1 2 8 6 A  S E N S O R
+	 */
+	mdelay(5);
+	regw(0x4E4E, COLPTN);
+
+	dev_dbg(vpfe_dev, "\nWriting 0x4e4e to COLPTN...\n");
+
+	/*
+	 *      C O N F I G U R I N G  T H E  H S I Z E  R E G I S T E R
+	 */
+	val = 0;
+	val |=
+	    (params->data_offset_s.
+	     horz_offset & CCDC_DATAOFST_MASK) << CCDC_DATAOFST_H_SHIFT;
+	val |=
+	    (params->data_offset_s.
+	     vert_offset & CCDC_DATAOFST_MASK) << CCDC_DATAOFST_V_SHIFT;
+	mdelay(5);
+	regw(val, DATAOFST);
+
+	/*
+	 *      C O N F I G U R I N G  T H E  H S I Z E  R E G I S T E R
+	 */
+	val = 0;
+	val |=
+	    (params->
+	     horz_flip_enable & CCDC_HSIZE_FLIP_MASK) << CCDC_HSIZE_FLIP_SHIFT;
+
+	/* If pack 8 is enable then 1 pixel will take 1 byte */
+	if ((params->data_sz == _8BITS) || params->alaw.b_alaw_enable) {
+		val |= (((params->win.width) + 31) >> 5) & 0x0fff;
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to HSIZE...\n",
+			(((params->win.width) + 31) >> 5) & 0x0fff);
+	} else {		/* else one pixel will take 2 byte */
+
+		val |= (((params->win.width * 2) + 31) >> 5) & 0x0fff;
+
+		dev_dbg(vpfe_dev, "\nWriting 0x%x to HSIZE...\n",
+			(((params->win.width * 2) + 31) >> 5) & 0x0fff);
+	}
+	mdelay(5);
+	regw(val, HSIZE);
+
+	/*
+	 *      C O N F I G U R E   S D O F S T  R E G I S T E R
+	 */
+
+	if (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {
+		if (params->image_invert_enable) {
+			/* For interlace inverse mode */
+			mdelay(5);
+			regw(0x4B6D, SDOFST);
+			dev_dbg(vpfe_dev, "\nWriting 0x4B6D to SDOFST...\n");
+		}
+
+		else {
+			/* For interlace non inverse mode */
+			regw(0x0B6D, SDOFST);
+			mdelay(5);
+			dev_dbg(vpfe_dev, "\nWriting 0x0B6D to SDOFST...\n");
+		}
+	} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
+		if (params->image_invert_enable) {
+			/* For progessive inverse mode */
+			mdelay(5);
+			regw(0x4000, SDOFST);
+			dev_dbg(vpfe_dev, "\nWriting 0x4000 to SDOFST...\n");
+		}
+
+		else {
+			/* For progessive non inverse mode */
+			mdelay(5);
+			regw(0x0000, SDOFST);
+			dev_dbg(vpfe_dev, "\nWriting 0x0000 to SDOFST...\n");
+		}
+
+	}
+
+	/*
+	 *      C O N F I G U R E   I N T E R R U P T   R E G I S T E R S
+	 */
+	if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {
+		val = params->win.height / 2;
+		mdelay(5);
+		regw(136, VDINT0);
+		regw(149, VDINT0);
+		mdelay(5);
+		regw(0, VDINT1);
+	} else {
+		mdelay(5);
+		regw(0, VDINT0);
+		mdelay(5);
+		regw(0, VDINT1);
+	}
+
+	dev_dbg(vpfe_dev, "\nend of ccdc_config_raw...");
+	/*ccdc_readregs(); */
+}
+
+int validate_ccdc_param(ccdc_config_params_raw * ccdcparam)
+{
+	if (ccdcparam->pix_fmt != 0) {
+		dev_err(vpfe_dev,
+			"Invalid value of pix_fmt, other than RAW data input is \
+ not supported\n");
+		return -1;
+	}
+
+	if (ccdcparam->frm_fmt != 0) {
+		dev_err(vpfe_dev,
+			"Other than Progressive fram format is not supported\n");
+		return -1;
+	}
+
+	if (ccdcparam->fid_pol != CCDC_PINPOL_POSITIVE
+	    && ccdcparam->fid_pol != CCDC_PINPOL_NEGATIVE) {
+		dev_err(vpfe_dev, "Invalid value of field id polarity\n");
+		return -1;
+	}
+
+	if (ccdcparam->vd_pol != CCDC_PINPOL_POSITIVE
+	    && ccdcparam->vd_pol != CCDC_PINPOL_NEGATIVE) {
+		dev_err(vpfe_dev, "Invalid value of VD polarity\n");
+		return -1;
+	}
+
+	if (ccdcparam->hd_pol != CCDC_PINPOL_POSITIVE
+	    && ccdcparam->hd_pol != CCDC_PINPOL_NEGATIVE) {
+		dev_err(vpfe_dev, "Invalid value of HD polarity\n");
+		return -1;
+	}
+
+	if (ccdcparam->datasft < NO_SHIFT || ccdcparam->datasft > _6BIT) {
+		dev_err(vpfe_dev, "Invalid value of data shift\n");
+		return -1;
+	}
+
+	if (ccdcparam->mfilt1 < NO_MEDIAN_FILTER1
+	    || ccdcparam->mfilt1 > MEDIAN_FILTER1) {
+		dev_err(vpfe_dev, "Invalid value of median filter1\n");
+		return -1;
+	}
+
+	if (ccdcparam->mfilt2 < NO_MEDIAN_FILTER2
+	    || ccdcparam->mfilt2 > MEDIAN_FILTER2) {
+		dev_err(vpfe_dev, "Invalid value of median filter2\n");
+		return -1;
+	}
+
+	if (ccdcparam->ccdc_offset < 0 || ccdcparam->ccdc_offset > 1023) {
+		dev_err(vpfe_dev, "Invalid value of offset\n");
+		return -1;
+	}
+
+	if (ccdcparam->med_filt_thres < 0 || ccdcparam->med_filt_thres > 0x3FFF) {
+		dev_err(vpfe_dev, "Invalid value of median filter thresold\n");
+		return -1;
+	}
+
+	if (ccdcparam->data_sz < _16BITS || ccdcparam->data_sz > _8BITS) {
+		dev_err(vpfe_dev, "Invalid value of data size\n");
+		return -1;
+	}
+
+	if (ccdcparam->alaw.b_alaw_enable) {
+		if (ccdcparam->alaw.gama_wd < BITS_13_4
+		    || ccdcparam->alaw.gama_wd > BITS_09_0) {
+			dev_err(vpfe_dev, "Invalid value of ALAW\n");
+			return -1;
+		}
+	}
+
+	if (ccdcparam->blk_clamp.b_clamp_enable) {
+		if (ccdcparam->blk_clamp.sample_pixel < _1PIXELS
+		    && ccdcparam->blk_clamp.sample_pixel > _16PIXELS) {
+			dev_err(vpfe_dev, "Invalid value of sample pixel\n");
+			return -1;
+		}
+		if (ccdcparam->blk_clamp.sample_ln < _1LINES
+		    && ccdcparam->blk_clamp.sample_ln > _16LINES) {
+			dev_err(vpfe_dev, "Invalid value of sample lines\n");
+			return -1;
+		}
+
+	}
+
+	if (ccdcparam->vertical_dft.ver_dft_en) {
+		dev_err(vpfe_dev, "Defect correction is not supported\n");
+		return -1;
+	}
+
+	if (ccdcparam->lens_sh_corr.lsc_enable) {
+		dev_err(vpfe_dev,
+			"Lens shadding correction is not supported\n");
+		return -1;
+	}
+	if (ccdcparam->color_space_con.csc_enable) {
+		dev_err(vpfe_dev, "Color Space converter not supported\n");
+		return -1;
+	}
+	return 0;
+}
Index: linux-2.6.18/drivers/media/video/davinci/davinci_vpfe.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/davinci_vpfe.c
@@ -0,0 +1,2089 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* davinci_vpfe.c */
+/* !FIXME needs to add code to program the i2c switch on the EVM to select tvp5146 or mt9t001 */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/kdev_t.h>
+#include <linux/string.h>
+#include <linux/wait.h>
+#include <linux/dma-mapping.h>
+#include <linux/time.h>
+#include <linux/platform_device.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+#include <asm/io.h>
+#include <asm/dma-mapping.h>
+
+#include <media/davinci/davinci_vpfe.h>
+#ifdef CONFIG_MACH_DAVINCI_DM355_EVM
+#include <media/davinci/ccdc_dm355.h>
+#else
+#include <media/davinci/ccdc_davinci.h>
+#endif
+
+MODULE_LICENSE("GPL");
+
+/* Global variable for insmode command which will decide that either MT9T001
+ * (device =0)  or TVP5146 (device = 1) is the device
+ */
+static int device_type = TVP5146;
+//static int device_type = MT9T001;
+
+struct device *vpfe_dev;
+
+module_param(device_type, int, 0);
+
+#ifndef MODULE
+/*
+ * Pass boot-time options by adding the following string to the boot params:
+ * 	v4l2_video_capture:[option[:option]]
+ * Valid options:
+ * 	device=[MT9T031|MT9T001|TVP5146]
+ */
+
+char *dm355_devices[] = { "MT9T001", "TVP5146", "MT9T031" };
+int __init dm355_v4l2_device_setup(char *options)
+{
+	char *this_opt;
+
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ":")) != NULL) {
+
+		if (!*this_opt)
+			continue;
+
+		if (!strncmp(this_opt, "device=", 6)) {
+			if (!strncmp(this_opt + 7, "MT9T031", 7)) {
+				device_type = MT9T031;
+			} else if (!strncmp(this_opt + 7, "MT9T001", 7)) {
+				device_type = MT9T001;
+			} else if (!strncmp(this_opt + 7, "TVP5146", 7)) {
+				device_type = TVP5146;
+			}
+		}
+	}
+	return 0;
+}
+
+__setup("v4l2_video_capture=", dm355_v4l2_device_setup);
+#endif
+
+static struct v4l2_rect ntsc_bounds = VPFE_WIN_NTSC;
+static struct v4l2_rect pal_bounds = VPFE_WIN_PAL;
+static struct v4l2_fract ntsc_aspect = VPFE_PIXELASPECT_NTSC;
+static struct v4l2_fract pal_aspect = VPFE_PIXELASPECT_PAL;
+static struct v4l2_rect ntscsp_bounds = VPFE_WIN_NTSC_SP;
+static struct v4l2_rect palsp_bounds = VPFE_WIN_PAL_SP;
+static struct v4l2_fract sp_aspect = VPFE_PIXELASPECT_NTSC_SP;
+
+static struct v4l2_rect VGA_bounds = VPFE_WIN_VGA;
+static struct v4l2_rect SVGA_bounds = VPFE_WIN_SVGA;
+static struct v4l2_rect XGA_bounds = VPFE_WIN_XGA;
+static struct v4l2_rect P480_bounds = VPFE_WIN_480p;
+static struct v4l2_rect P576_bounds = VPFE_WIN_576p;
+static struct v4l2_rect P720_bounds = VPFE_WIN_720p;
+static struct v4l2_rect P1080_bounds = VPFE_WIN_1080p;
+static struct v4l2_fract default_aspect = VPFE_PIXELASPECT_DEFAULT;
+
+static vpfe_obj vpfe_device_ycbcr = {	/* the default format is NTSC */
+	.usrs = 0,
+	.io_usrs = 0,
+	.std = VPFE_STD_AUTO,
+	.vwin = VPFE_WIN_PAL,
+	.bounds = VPFE_WIN_PAL,
+	.pixelaspect = VPFE_PIXELASPECT_NTSC,
+	.pixelfmt = V4L2_PIX_FMT_UYVY,
+	.field = V4L2_FIELD_INTERLACED,
+	.numbuffers = VPFE_DEFNUM_FBUFS,
+	.capture_device = TVP5146,
+	.tvp5146_params = {
+			   .mode = TVP5146_MODE_AUTO,
+			   .amuxmode = TVP5146_AMUX_COMPOSITE,
+			   .enablebt656sync = TRUE,
+			   .data_width = TVP5146_WIDTH_8BIT},
+
+	.irqlock = SPIN_LOCK_UNLOCKED
+};
+
+static vpfe_obj vpfe_device_raw = {	/*Default is vga mode */
+	.usrs = 0,
+	.io_usrs = 0,
+	.std = V4L2_STD_MT9T001_VGA_30FPS,
+	.vwin = VPFE_WIN_VGA,
+	.bounds = VPFE_WIN_VGA,
+	.pixelaspect = VPFE_PIXELASPECT_DEFAULT,
+	.pixelfmt = V4L2_PIX_FMT_SBGGR8,
+	.field = V4L2_FIELD_NONE,
+	.numbuffers = VPFE_DEFNUM_FBUFS,
+	.capture_device = MT9T001,
+	.irqlock = SPIN_LOCK_UNLOCKED
+	/* .resizer_no = -1, */    /* Extra field for resizer number filled in open */
+	/* .otf_on = 0 */          /* On the Fly Flag initialize to 0 i.e. Disabled */
+};
+
+static ccdc_frmfmt frm_format;
+static ccdc_imgwin image_window;
+static vpfe_obj vpfe_device = { 0 };
+
+struct v4l2_capability vpfe_drvcap = {
+	.driver = "vpfe driver",
+#ifdef CONFIG_MACH_DAVINCI_DM355_EVM
+	.card = "dm355 EVM",
+#else
+	.card = "DaVinci EVM",
+#endif
+	.bus_info = "Platform",
+	.version = VPFE_VERSION_CODE,
+	.capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING
+};
+
+/* inline function to free reserved pages  */
+void inline free_reserved_pages(unsigned long bufaddr, unsigned long bufsize)
+{
+	unsigned long size, addr;
+	if (!bufaddr)
+		return;
+	addr = bufaddr;
+	size = PAGE_SIZE << (get_order(bufsize));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(addr));
+		addr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(bufaddr, get_order(bufsize));
+}
+
+/*
+ * ======== sense_std ========
+ */
+/*This function will get current input standard for TVP5146*/
+static int sense_std(v4l2_std_id * std_id)
+{
+	v4l2_std_id id = 0;
+	tvp5146_mode mode;
+	int ret;
+	dev_dbg(vpfe_dev, "\nStarting Davinci_vpfe sense_std...");
+	ret = tvp5146_ctrl(TVP5146_GET_STD, &mode);
+	if (ret < 0)
+		return ret;
+	switch (mode & 0x7) {
+	case TVP5146_MODE_NTSC:
+		id = V4L2_STD_NTSC;
+		break;
+	case TVP5146_MODE_PAL:
+		id = V4L2_STD_PAL;
+		break;
+	case TVP5146_MODE_PAL_M:
+		id = V4L2_STD_PAL_M;
+		break;
+	case TVP5146_MODE_PAL_CN:
+		id = V4L2_STD_PAL_N;
+		break;
+	case TVP5146_MODE_SECAM:
+		id = V4L2_STD_SECAM;
+		break;
+	case TVP5146_MODE_PAL_60:
+		id = V4L2_STD_PAL_60;
+		break;
+	}
+	if (mode & 0x8) {	/* square pixel mode */
+		id <<= 32;
+	}
+	if (mode == TVP5146_MODE_AUTO) {
+		id = VPFE_STD_AUTO;	/* auto-detection for all other modes */
+	} else if (mode == TVP5146_MODE_AUTO_SQP) {
+		id = VPFE_STD_AUTO_SQP;
+	}
+	if (id == 0)
+		return -EINVAL;
+	*std_id = id;
+	dev_dbg(vpfe_dev, "\nEnd of Davinci_vpfe sense_std...");
+	return 0;
+}
+
+/*
+ * ======== vpfe_isr ========
+ */
+/*ISR for VINT0*/
+static irqreturn_t vpfe_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	vpfe_obj *vpfe = &vpfe_device;
+	int fid;
+	unsigned long jiffies_time = get_jiffies_64();
+	struct timeval timevalue;
+	int val = 0;
+
+	val = ccdc_sbl_reset();
+
+	/*Convert time representations between jiffies and struct timeval */
+	jiffies_to_timeval(jiffies_time, &timevalue);
+
+	dev_dbg(vpfe_dev, "\nStarting Davinci_vpfe\vpfe_isr...");
+	if (frm_format == CCDC_FRMFMT_INTERLACED) {
+		/* check which field we are in hardware */
+		fid = ccdc_getfid();
+		/* switch the software maintained field id */
+		vpfe->field_id ^= 1;
+		dev_dbg(vpfe_dev, "field id = %x:%x.\n", fid, vpfe->field_id);
+		if (fid == vpfe->field_id) {	/* we are in-sync here,continue */
+			if (fid == 0) {
+				/*  One frame is just being captured. If the
+				 * next frame is available, release the current
+				 * frame and move on
+				 */
+				if (vpfe->curFrm != vpfe->nextFrm) {
+					/* Copy frame capture time value in
+					 * curFrm->ts
+					 */
+					vpfe->curFrm->ts = timevalue;
+					vpfe->curFrm->state = STATE_DONE;
+					wake_up_interruptible(&vpfe->
+							      curFrm->done);
+					vpfe->curFrm = vpfe->nextFrm;
+				}
+				/* based on whether the two fields are stored
+				 * interleavely or separately in memory,
+				 * reconfigure the CCDC memory address
+				 */
+				if (vpfe->field == V4L2_FIELD_SEQ_TB) {
+					u32 addr =
+					    vpfe->curFrm->boff +
+					    vpfe->field_offset;
+					ccdc_setfbaddr((unsigned long)
+						       addr);
+				}
+			} else if (fid == 1) {
+				/* if one field is just being captured */
+				/* configure the next frame */
+				/* get the next frame from the empty queue */
+				/* if no frame is available, */
+				/* hold on to the current buffer */
+				if (!list_empty(&vpfe->dma_queue)
+				    && vpfe->curFrm == vpfe->nextFrm) {
+					vpfe->nextFrm =
+					    list_entry(vpfe->dma_queue.
+						       next, struct
+						       videobuf_buffer, queue);
+					list_del(&vpfe->nextFrm->queue);
+					vpfe->nextFrm->state = STATE_ACTIVE;
+					ccdc_setfbaddr((unsigned long)
+						       vpfe->nextFrm->boff);
+				}
+				if (vpfe->mode_changed) {
+					ccdc_setwin(&image_window,
+						    frm_format, 2);
+					/* update the field offset */
+					vpfe->field_offset =
+					    (vpfe->vwin.height -
+					     2) * vpfe->vwin.width;
+					vpfe->mode_changed = FALSE;
+				}
+			}
+		} else if (fid == 0) {
+			/* recover from any hardware out-of-sync due to */
+			/* possible switch of video source              */
+			/* for fid == 0, sync up the two fids           */
+			/* for fid == 1, no action, one bad frame will  */
+			/* go out, but it is not a big deal             */
+			vpfe->field_id = fid;
+		}
+	} else if (frm_format == CCDC_FRMFMT_PROGRESSIVE) {
+
+		dev_dbg(vpfe_dev, "\nframe format is progressive...");
+		if (vpfe->curFrm != vpfe->nextFrm) {
+			/* Copy frame capture time value in curFrm->ts */
+			vpfe->curFrm->ts = timevalue;
+			vpfe->curFrm->state = STATE_DONE;
+			wake_up_interruptible(&vpfe->curFrm->done);
+			vpfe->curFrm = vpfe->nextFrm;
+		}
+
+	}
+	dev_dbg(vpfe_dev, "interrupt returned.\n");
+	return IRQ_RETVAL(1);
+}
+
+static irqreturn_t vdint1_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+
+	vpfe_obj *vpfe = &vpfe_device;
+
+	dev_dbg(vpfe_dev, "\nInside vdint1_isr...");
+
+	if (frm_format == CCDC_FRMFMT_PROGRESSIVE) {
+		if (!list_empty(&vpfe->dma_queue)
+		    && vpfe->curFrm == vpfe->nextFrm) {
+			vpfe->nextFrm =
+			    list_entry(vpfe->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			list_del(&vpfe->nextFrm->queue);
+			vpfe->nextFrm->state = STATE_ACTIVE;
+			ccdc_setfbaddr((unsigned long)vpfe->nextFrm->boff);
+		}
+	}
+	return IRQ_RETVAL(1);
+}
+
+/*
+ * ======== buffer_prepare ========
+ */
+/* this is the callback function called from videobuf_qbuf() function */
+/* the buffer is prepared and queued into the dma queue */
+static int buffer_prepare(struct videobuf_queue *q,
+			  struct videobuf_buffer *vb, enum v4l2_field field)
+{
+	vpfe_obj *vpfe = &vpfe_device;
+	unsigned int buf_size;
+	dev_dbg(vpfe_dev, "\nstarting buffer_prepare");
+	if (device_type == TVP5146) {
+		buf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
+	} else {
+		buf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
+	}
+	if (vb->state == STATE_NEEDS_INIT) {
+		vb->width = vpfe->vwin.width;
+		vb->height = vpfe->vwin.height;
+		vb->size = buf_size;
+		vb->field = field;
+	}
+	vb->state = STATE_PREPARED;
+	dev_dbg(vpfe_dev, "\nEnd of buffer_prepare");
+	return 0;
+
+}
+
+/*
+ * ======== buffer_config ========
+ */
+ /* This function is responsible to queue up vpfe buffer is into video buffer
+  * queue.
+  */
+static void buffer_config(struct videobuf_queue *q, unsigned int count)
+{
+	vpfe_obj *vpfe = &vpfe_device;
+	int i;
+	dev_dbg(vpfe_dev, "\nstarting buffer_config");
+	for (i = 0; i < count; i++) {
+		q->bufs[i]->boff = virt_to_phys(vpfe->fbuffers[i]);
+		dev_dbg(vpfe_dev, "buffer address: %x\n", q->bufs[i]->boff);
+	}
+	dev_dbg(vpfe_dev, "\nEnd of buffer_config");
+}
+
+/*
+ * ======== buffer_setup ========
+ */
+ /* This function allocate free pages and makes it sure that they will not
+  * swapped
+  */
+static int
+buffer_setup(struct videobuf_queue *q, unsigned int *count, unsigned int *size)
+{
+	vpfe_obj *vpfe = &vpfe_device;
+	int i;
+	unsigned int buf_size;
+	dev_dbg(vpfe_dev, "\nstarting buffer_setup");
+	if (device_type == TVP5146) {
+		*size = buf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
+	} else {
+		*size = buf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
+	}
+
+	for (i = VPFE_DEFNUM_FBUFS; i < *count; i++) {
+		u32 size = PAGE_SIZE << (get_order(buf_size));
+		void *mem = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+						     get_order(buf_size));
+		if (mem) {
+			unsigned long adr = (unsigned long)mem;
+			while (size > 0) {
+				/* make sure the frame buffers are never
+				   swapped out of memory */
+				SetPageReserved(virt_to_page(adr));
+				adr += PAGE_SIZE;
+				size -= PAGE_SIZE;
+			}
+			vpfe->fbuffers[i] = mem;
+		} else {
+			break;
+		}
+	}
+	*count = vpfe->numbuffers = i;
+	dev_dbg(vpfe_dev, "\nEnd of buffer_setup");
+	return 0;
+}
+
+/*
+ * ======== buffer_queue ========
+ */
+ /* This function adds the buffer to DMA queue */
+static void buffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)
+{
+	vpfe_obj *vpfe = &vpfe_device;
+	/* add the buffer to the DMA queue */
+	dev_dbg(vpfe_dev, "\nstarting buffer_queue");
+	list_add_tail(&vb->queue, &vpfe->dma_queue);
+	vb->state = STATE_QUEUED;
+	dev_dbg(vpfe_dev, "\nEnding buffer_queue");
+}
+
+/*
+ * ======== buffer_release ========
+ */
+ /* This function will free the buffer if it is not one
+  * of the 3 allocated at initialization time.
+  */
+static void buffer_release(struct videobuf_queue *q, struct videobuf_buffer *vb)
+{
+	unsigned int buf_size;
+	dev_dbg(vpfe_dev, "\nStarting buffer_release");
+	if (device_type == TVP5146) {
+		buf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
+	} else {
+		buf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
+	}
+
+	/* free the buffer if it is not one of the 3 allocated at initializaiton
+	 * time
+	 */
+	if (vb->i < vpfe_device.numbuffers
+	    && vb->i >= VPFE_DEFNUM_FBUFS && vpfe_device.fbuffers[vb->i]) {
+		free_reserved_pages((unsigned long)vpfe_device.
+				    fbuffers[vb->i], get_order(buf_size));
+		vpfe_device.fbuffers[vb->i] = NULL;
+	}
+	vb->state = STATE_NEEDS_INIT;
+	dev_dbg(vpfe_dev, "\nEnd of buffer_release");
+}
+
+static struct videobuf_queue_ops video_qops = {
+	.buf_setup = buffer_setup,
+	.buf_prepare = buffer_prepare,
+	.buf_queue = buffer_queue,
+	.buf_release = buffer_release,
+	.buf_config = buffer_config,
+};
+
+/*
+ * ======== vpfe_doioctl ========
+ */
+ /* This function will provide different V4L2 commands.This function can be
+  * used to configure driver or get status of driver as per command passed
+  * by application.
+  */
+static int vpfe_doioctl(struct inode *inode, struct file *file,
+			unsigned int cmd, void *arg)
+{
+	vpfe_obj *vpfe = &vpfe_device;
+	vpfe_fh *fh = file->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case VIDIOC_S_CTRL:
+	case VIDIOC_S_FMT:
+	case VIDIOC_S_STD:
+	case VIDIOC_S_CROP:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_CTRL ioctl");
+		ret = v4l2_prio_check(&vpfe->prio, &fh->prio);
+		if (0 != ret) {
+			return ret;
+		}
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_CTRL ioctl");
+		break;
+	}
+
+	switch (cmd) {
+	case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *cap =
+			    (struct v4l2_capability *)arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_QUEYCAP ioctl");
+			memset(cap, 0, sizeof(*cap));
+			*cap = vpfe_drvcap;
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QUEYCAP ioctl");
+			break;
+		}
+	case VIDIOC_ENUM_FMT:
+		{
+			struct v4l2_fmtdesc *fmt = (struct v4l2_fmtdesc *)arg;
+			u32 index = fmt->index;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_ENUM_FMT ioctl");
+			memset(fmt, 0, sizeof(*fmt));
+
+			fmt->index = index;
+			if (device_type == TVP5146) {
+				if (index == 0) {
+					/* only yuv4:2:2 format is supported
+					 * at this point
+					 */
+					fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+					strcpy(fmt->description,
+					       "YCbCr4:2:2 Interleaved UYUV");
+					fmt->pixelformat = V4L2_PIX_FMT_UYVY;
+				} else if (index == 1) {
+					fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+					strcpy(fmt->description,
+					       "YCbCr4:2:2 Interleaved YUYV");
+					fmt->pixelformat = V4L2_PIX_FMT_YUYV;
+				} else {
+					ret = -EINVAL;
+				}
+			} else if (device_type == MT9T001
+				   || device_type == MT9T031) {
+				if (index == 0) {
+					/* only Bayer Raw Mode format is
+					 * supported at this point
+					 */
+					fmt->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+					strcpy(fmt->description,
+					       "Raw Mode -Bayer Pattern GrRBGb");
+					fmt->pixelformat = V4L2_PIX_FMT_SBGGR8;
+				} else {
+					ret = -EINVAL;
+				}
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_ENUM_FMT ioctl");
+
+			break;
+		}
+	case VIDIOC_G_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_G_FMT ioctl");
+			if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				ret = -EINVAL;
+			} else {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				down_interruptible(&vpfe->lock);
+				pixfmt->width = vpfe->vwin.width;
+				pixfmt->height = vpfe->vwin.height;
+				pixfmt->field = vpfe->field;
+				pixfmt->pixelformat = vpfe->pixelfmt;
+				if (device_type == TVP5146) {
+					pixfmt->bytesperline =
+					    pixfmt->width * 2;
+				} else {
+					pixfmt->bytesperline =
+					    (((ccdc_raw_data_size() == _8BITS)
+					      || ccdc_alaw_enable())? pixfmt->
+					     width : (pixfmt->width * 2));
+
+				}
+				pixfmt->sizeimage =
+				    pixfmt->bytesperline * pixfmt->height;
+				pixfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;
+				up(&vpfe->lock);
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_FMT ioctl");
+			break;
+		}
+	case VIDIOC_S_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+			enum hw_frame frame_type;
+
+			if (device_type == TVP5146)
+				frame_type = CCDC_YCBCR;
+			else
+				frame_type = CCDC_RAW;
+
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_FMT ioctl");
+			if (vpfe->started) {
+				/* make sure streaming is not started */
+				ret = -EBUSY;
+				break;
+			}
+
+			down_interruptible(&vpfe->lock);
+			dev_dbg(vpfe_dev, "\nAfter down_interruptible");
+			if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				ret = -EINVAL;
+				up(&vpfe->lock);
+				break;
+			}
+
+			if ((pixfmt->width + vpfe->vwin.left <=
+			     vpfe->bounds.width)
+			    && (pixfmt->height + vpfe->vwin.top <=
+				vpfe->bounds.height)) {
+				/* this is the case when no scaling is
+				 * supported
+				 */
+				/* crop window is directed modified */
+				vpfe->vwin.height = pixfmt->height;
+				vpfe->vwin.width = pixfmt->width;
+				ccdc_set_image_window(frame_type, vpfe->vwin);
+			} else {
+				ret = -EINVAL;
+				dev_dbg(vpfe_dev, "\n window size error!");
+				up(&vpfe->lock);
+				break;
+			}
+
+			/* setup the CCDC parameters accordingly */
+			if (device_type == TVP5146) {
+
+				if (pixfmt->pixelformat == V4L2_PIX_FMT_YUYV) {
+					ccdc_set_pix_order
+					    (CCDC_PIXORDER_YCBYCR);
+					vpfe->pixelfmt = pixfmt->pixelformat;
+				} else if (pixfmt->pixelformat ==
+					   V4L2_PIX_FMT_UYVY) {
+					ccdc_set_pix_order
+					    (CCDC_PIXORDER_CBYCRY);
+					vpfe->pixelfmt = pixfmt->pixelformat;
+				} else {
+					/* not supported format */
+					ret = -EINVAL;
+					up(&vpfe->lock);
+					break;
+				}
+			} else if (device_type == MT9T001
+				   || device_type == MT9T031) {
+
+				if (pixfmt->pixelformat == V4L2_PIX_FMT_SBGGR8) {
+					vpfe->pixelfmt = pixfmt->pixelformat;
+				} else {
+					/* not supported format */
+					dev_dbg(vpfe_dev,
+						"\n format not supported");
+					ret = -EINVAL;
+					up(&vpfe->lock);
+					break;
+				}
+			}
+
+			/* Configure buffer type and frame format as per field
+			 *  value passed
+			 */
+			if (pixfmt->field == V4L2_FIELD_INTERLACED) {
+				ccdc_set_buf_type(frame_type,
+						  CCDC_BUFTYPE_FLD_INTERLEAVED);
+				ccdc_set_frame_format(frame_type,
+						      CCDC_FRMFMT_INTERLACED);
+				vpfe->field = pixfmt->field;
+			} else if (pixfmt->field == V4L2_FIELD_SEQ_TB) {
+				ccdc_set_buf_type(frame_type,
+						  CCDC_BUFTYPE_FLD_SEPARATED);
+				ccdc_set_frame_format(frame_type,
+						      CCDC_FRMFMT_INTERLACED);
+				vpfe->field = pixfmt->field;
+			} else if (pixfmt->field == V4L2_FIELD_NONE) {
+				ccdc_set_frame_format(frame_type,
+						      CCDC_FRMFMT_PROGRESSIVE);
+				vpfe->field = pixfmt->field;
+			} else {
+				dev_dbg(vpfe_dev, "\n field error!");
+				ret = -EINVAL;
+			}
+
+			up(&vpfe->lock);
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_FMT ioctl");
+			break;
+		}
+	case VIDIOC_TRY_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_TRY_FMT ioctl");
+			if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				ret = -EINVAL;
+			} else {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+
+				if (device_type == TVP5146) {
+					if (pixfmt->width >
+					    vpfe->bounds.width
+					    || pixfmt->height >
+					    vpfe->bounds.height
+					    || (pixfmt->pixelformat !=
+						V4L2_PIX_FMT_UYVY
+						&& pixfmt->pixelformat !=
+						V4L2_PIX_FMT_YUYV)) {
+						ret = -EINVAL;
+					}
+				} else if (device_type == MT9T001
+					   || device_type == MT9T031) {
+					if (pixfmt->width > vpfe->bounds.width
+					    || pixfmt->height >
+					    vpfe->bounds.height
+					    || (pixfmt->pixelformat !=
+						V4L2_PIX_FMT_SBGGR8)) {
+						ret = -EINVAL;
+					}
+				}
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_TRY_FMT ioctl");
+			break;
+		}
+	case VIDIOC_G_STD:
+		{
+			v4l2_std_id *id = (v4l2_std_id *) arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_G_FMT ioctl");
+			*id = vpfe->std;
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_FMT ioctl");
+			break;
+		}
+	case VIDIOC_S_STD:
+		{
+			v4l2_std_id id = *(v4l2_std_id *) arg;
+			tvp5146_mode mode = TVP5146_MODE_INV;
+			int sqp = 0;
+			dev_dbg(vpfe_dev, "\nStarting of VIDIOC_S_STD ioctl");
+			/* make sure streaming is not started */
+			if (vpfe->started) {
+				ret = -EBUSY;
+				break;
+			}
+			down_interruptible(&vpfe->lock);
+
+			if (device_type == TVP5146) {
+				if (id & V4L2_STD_625_50) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = pal_bounds;
+					vpfe->pixelaspect = pal_aspect;
+					ccdc_set_image_window(CCDC_YCBCR,
+							      pal_bounds);
+				} else if (id & V4L2_STD_525_60) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = ntsc_bounds;
+					vpfe->pixelaspect = ntsc_aspect;
+					ccdc_set_image_window(CCDC_YCBCR,
+							      ntsc_bounds);
+				} else if (id & VPFE_STD_625_50_SQP) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin =
+					    palsp_bounds;
+					vpfe->pixelaspect = sp_aspect;
+					sqp = 1;
+					id >>= 32;
+				} else if (id & VPFE_STD_525_60_SQP) {
+					vpfe->std = id;
+					sqp = 1;
+					vpfe->std = id;
+					id >>= 32;
+					vpfe->bounds = vpfe->vwin =
+					    ntscsp_bounds;
+					vpfe->pixelaspect = sp_aspect;
+					ccdc_set_image_window(CCDC_YCBCR,
+							      ntscsp_bounds);
+				} else if (id & VPFE_STD_AUTO) {
+					mode = TVP5146_MODE_AUTO;
+					vpfe->bounds = vpfe->vwin = pal_bounds;
+					vpfe->pixelaspect = pal_aspect;
+					ccdc_set_image_window(CCDC_YCBCR,
+							      pal_bounds);
+					vpfe->std = id;
+				} else if (id & VPFE_STD_AUTO_SQP) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin =
+					    palsp_bounds;
+					vpfe->pixelaspect = sp_aspect;
+					sqp = 1;
+					mode = TVP5146_MODE_AUTO_SQP;
+					vpfe->pixelaspect = sp_aspect;
+				} else {
+					ret = -EINVAL;
+				}
+				if (id == V4L2_STD_PAL_60) {
+					mode = TVP5146_MODE_PAL_60;
+				} else if (id == V4L2_STD_PAL_M) {
+					mode = TVP5146_MODE_PAL_M;
+				} else if (id == V4L2_STD_PAL_Nc
+					   || id == V4L2_STD_PAL_N) {
+					mode = TVP5146_MODE_PAL_CN;
+				} else if (id & V4L2_STD_PAL) {
+					mode = TVP5146_MODE_PAL;
+				} else if (id & V4L2_STD_NTSC) {
+					mode = TVP5146_MODE_NTSC;
+				} else if (id & V4L2_STD_SECAM) {
+					mode = TVP5146_MODE_SECAM;
+				}
+				vpfe->tvp5146_params.mode = mode | (sqp << 3);
+				tvp5146_ctrl(TVP5146_CONFIG,
+					     &vpfe->tvp5146_params);
+			} else if (device_type == MT9T001
+				   || device_type == MT9T031) {
+				/* Store image window paramters and pixel
+				 * aspect values as per standard
+				 * passed by application
+				 */
+				if ((id == V4L2_STD_MT9T001_VGA_30FPS)
+				    || (id == V4L2_STD_MT9T001_VGA_60FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = VGA_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      VGA_bounds);
+				} else if ((id == V4L2_STD_MT9T001_SVGA_30FPS)
+					   || (id ==
+					       V4L2_STD_MT9T001_SVGA_60FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = SVGA_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      SVGA_bounds);
+				} else if ((id == V4L2_STD_MT9T001_XGA_30FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = XGA_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      XGA_bounds);
+				} else if ((id == V4L2_STD_MT9T001_480p_30FPS)
+					   || (id ==
+					       V4L2_STD_MT9T001_480p_60FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = P480_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      P480_bounds);
+				} else if ((id == V4L2_STD_MT9T001_576p_25FPS)
+					   || (id ==
+					       V4L2_STD_MT9T001_576p_50FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = P576_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      P576_bounds);
+				} else if ((id == V4L2_STD_MT9T001_720p_24FPS)
+					   || (id ==
+					       V4L2_STD_MT9T001_720p_30FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin = P720_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      P720_bounds);
+				} else if ((id == V4L2_STD_MT9T001_1080p_18FPS)) {
+					vpfe->std = id;
+					vpfe->bounds = vpfe->vwin =
+					    P1080_bounds;
+					vpfe->pixelaspect = default_aspect;
+					ccdc_set_image_window(CCDC_RAW,
+							      P1080_bounds);
+				} else {
+					ret = -EINVAL;
+				}
+				if (ret != -EINVAL) {
+					/* Call device control function to
+					 * configure video standard
+					 */
+					dev_dbg(vpfe_dev,
+						"\ncalling mt9t001 setup in SET_STD");
+					ret =
+					    vpfe->
+					    config_dev_fxn(MT9T001_SET_STD,
+							   &vpfe->std,
+							   vpfe->device_params);
+				}
+			}
+			dev_dbg(vpfe_dev, "\nAbove up(&vpfe->lock)");
+			up(&vpfe->lock);
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_STD ioctl");
+			break;
+		}
+	case VIDIOC_ENUMSTD:
+		{
+			struct v4l2_standard *std = (struct v4l2_standard *)arg;
+			u32 index = std->index;
+			dev_dbg(vpfe_dev, "\nStarting of VIDIOC_ENUMSTD ioctl");
+			memset(std, 0, sizeof(*std));
+			std->index = index;
+
+			if (device_type == TVP5146) {
+				if (index == 0) {
+					std->id = V4L2_STD_525_60;
+					strcpy(std->name, "SD-525line-30fps");
+					std->framelines = 525;
+					std->frameperiod.numerator = 1001;
+					std->frameperiod.denominator = 30000;
+				} else if (index == 1) {
+					std->id = V4L2_STD_625_50;
+					strcpy(std->name, "SD-625line-25fps");
+					std->framelines = 625;
+					std->frameperiod.numerator = 1;
+					std->frameperiod.denominator = 25;
+				} else if (index == 2) {
+					std->id = VPFE_STD_625_50_SQP;
+					strcpy(std->name,
+					       "SD-625line-25fps square pixel");
+					std->framelines = 625;
+					std->frameperiod.numerator = 1;
+					std->frameperiod.denominator = 25;
+				} else if (index == 3) {
+					std->id = VPFE_STD_525_60_SQP;
+					strcpy(std->name,
+					       "SD-525line-25fps square pixel");
+					std->framelines = 525;
+					std->frameperiod.numerator = 1001;
+					std->frameperiod.denominator = 30000;
+				} else if (index == 4) {
+					std->id = VPFE_STD_AUTO;
+					strcpy(std->name, "automatic detect");
+					std->framelines = 625;
+					std->frameperiod.numerator = 1;
+					std->frameperiod.denominator = 1;
+				} else if (index == 5) {
+					std->id = VPFE_STD_AUTO_SQP;
+					strcpy(std->name,
+					       "automatic detect square pixel");
+					std->framelines = 625;
+					std->frameperiod.numerator = 1;
+					std->frameperiod.denominator = 1;
+				} else {
+					ret = -EINVAL;
+				}
+			} else if (device_type == MT9T001
+				   || device_type == MT9T031) {
+				/* fill number of lines per frame and FPS value
+				 *  as per standard passed by application
+				 */
+				if (index == 0) {
+					std->id = V4L2_STD_MT9T001_VGA_30FPS;
+					strcpy(std->name, "VGA-480line- 30fps");
+					std->framelines = FMT_VGA_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_30_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_30_DENOMIRATOR;
+				} else if (index == 1) {
+					std->id = V4L2_STD_MT9T001_VGA_60FPS;
+					strcpy(std->name, "VGA-480line- 60fps");
+					std->framelines = FMT_VGA_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_60_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_60_DENOMIRATOR;
+				} else if (index == 2) {
+					std->id = V4L2_STD_MT9T001_SVGA_30FPS;
+					strcpy(std->name,
+					       "SVGA-600line- 30fps");
+					std->framelines = FMT_SVGA_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_30_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_30_DENOMIRATOR;
+				} else if (index == 3) {
+					std->id = V4L2_STD_MT9T001_SVGA_60FPS;
+					strcpy(std->name,
+					       "SVGA-600line- 60fps");
+					std->framelines = FMT_SVGA_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_60_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_30_DENOMIRATOR;
+				} else if (index == 4) {
+					std->id = V4L2_STD_MT9T001_XGA_30FPS;
+					strcpy(std->name, "XGA-768line- 30fps");
+					std->framelines = FMT_XGA_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_30_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_30_DENOMIRATOR;
+				} else if (index == 5) {
+					std->id = V4L2_STD_MT9T001_480p_30FPS;
+					strcpy(std->name, "480p-480line-30fps");
+					std->framelines = FMT_480p_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_30_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_30_DENOMIRATOR;
+				} else if (index == 6) {
+					std->id = V4L2_STD_MT9T001_480p_60FPS;
+					strcpy(std->name, "480p-480line-60fps");
+					std->framelines = FMT_480p_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_60_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_60_DENOMIRATOR;
+				} else if (index == 7) {
+					std->id = V4L2_STD_MT9T001_576p_25FPS;
+					strcpy(std->name, "576p-576line-25fps");
+					std->framelines = FMT_576p_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_25_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_25_DENOMIRATOR;
+				} else if (index == 8) {
+					std->id = V4L2_STD_MT9T001_576p_50FPS;
+					strcpy(std->name, "576p-576line-50fps");
+					std->framelines = FMT_576p_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_50_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_50_DENOMIRATOR;
+				} else if (index == 9) {
+					std->id = V4L2_STD_MT9T001_720p_24FPS;
+					strcpy(std->name, "720p-720line-24fps");
+					std->framelines = FMT_720p_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_24_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_24_DENOMIRATOR;
+				} else if (index == 10) {
+					std->id = V4L2_STD_MT9T001_720p_30FPS;
+					strcpy(std->name, "720p-720line-30fps");
+					std->framelines = FMT_720p_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_30_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_30_DENOMIRATOR;
+				} else if (index == 11) {
+					std->id = V4L2_STD_MT9T001_1080p_18FPS;
+					strcpy(std->name,
+					       "1080p-1080line-18fps");
+					std->framelines = FMT_1080i_NUMLINES;
+					std->frameperiod.numerator =
+					    FPS_18_NUMERATOR;
+					std->frameperiod.denominator =
+					    FPS_18_DENOMIRATOR;
+				} else {
+					ret = -EINVAL;
+				}
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_ENUMSTD ioctl");
+			break;
+		}
+	case VIDIOC_ENUMINPUT:
+		{
+			u32 index = 0;
+			struct v4l2_input *input = (struct v4l2_input *)arg;
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_ENUMINPUT ioctl");
+			if (device_type != TVP5146) {
+				return -1;
+			}
+			/* only two inputs are available */
+			if (input->index > 1)
+				ret = -EINVAL;
+			index = input->index;
+			memset(input, 0, sizeof(*input));
+			input->index = index;
+			input->type = V4L2_INPUT_TYPE_CAMERA;
+			input->std = V4L2_STD_ALL;
+			if (input->index == 0) {
+				sprintf(input->name, "COMPOSITE");
+			} else if (input->index == 1) {
+				sprintf(input->name, "S-VIDEO");
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_ENUMINPUT ioctl");
+			break;
+		}
+	case VIDIOC_G_INPUT:
+		{
+			int *index = (int *)arg;
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_G_INPUT ioctl");
+			if (device_type != TVP5146) {
+				return -1;
+			}
+			*index = vpfe->tvp5146_params.amuxmode;
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_G_INPUT ioctl");
+			break;
+		}
+	case VIDIOC_S_INPUT:
+		{
+			int *index = (int *)arg;
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_S_INPUT ioctl");
+			if (device_type != TVP5146) {
+				return -1;
+			}
+			if (*index > 1 || *index < 0) {
+				ret = -EINVAL;
+			}
+			vpfe->tvp5146_params.amuxmode = *index;
+			tvp5146_ctrl(TVP5146_SET_AMUXMODE, index);
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_S_INPUT ioctl");
+			break;
+		}
+	case VIDIOC_CROPCAP:
+		{
+			struct v4l2_cropcap *cropcap =
+			    (struct v4l2_cropcap *)arg;
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_CROPCAP ioctl");
+			cropcap->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+			down_interruptible(&vpfe->lock);
+			cropcap->bounds = cropcap->defrect = vpfe->vwin;
+			cropcap->pixelaspect = vpfe->pixelaspect;
+			up(&vpfe->lock);
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_CROPCAP ioctl");
+			break;
+		}
+	case VIDIOC_G_PARM:
+		{
+			struct v4l2_streamparm *parm =
+			    (struct v4l2_streamparm *)arg;
+			dev_dbg(vpfe_dev, "\nStart of VIDIOC_G_PARM ioctl");
+			if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				/* only capture is supported */
+				ret = -EINVAL;
+			} else {
+				struct v4l2_captureparm *capparm =
+				    &parm->parm.capture;
+				memset(capparm, 0,
+				       sizeof(struct v4l2_captureparm));
+				down_interruptible(&vpfe->lock);
+
+				if (device_type == TVP5146) {
+					if (vpfe->std & V4L2_STD_625_50) {
+						/* PAL 25fps */
+						capparm->timeperframe.
+						    numerator = 1;
+						capparm->timeperframe.
+						    denominator = 25;
+					} else {
+						/*NTSC 29.97fps */
+						capparm->timeperframe.
+						    numerator = 1001;
+						capparm->timeperframe.
+						    denominator = 30000;
+					}
+				} else if (device_type == MT9T001
+					   || device_type == MT9T031) {
+					/* fill FPS value as per standard */
+					if (vpfe->
+					    std & V4L2_STD_MT9T001_VGA_30FPS) {
+						capparm->timeperframe.
+						    numerator =
+						    FPS_30_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_30_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_VGA_60FPS) {
+						capparm->timeperframe.
+						    numerator =
+						    FPS_60_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_60_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_SVGA_30FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_30_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_30_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_SVGA_60FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_60_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_60_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_XGA_30FPS) {
+						capparm->timeperframe.
+						    numerator =
+						    FPS_30_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_30_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_480p_30FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_30_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_30_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_480p_60FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_60_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_60_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_576p_25FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_25_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_25_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_576p_50FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_50_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_50_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_720p_24FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_24_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_24_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_720p_30FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_30_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_30_DENOMIRATOR;
+					} else if (vpfe->
+						   std &
+						   V4L2_STD_MT9T001_1080p_18FPS)
+					{
+						capparm->timeperframe.
+						    numerator =
+						    FPS_18_NUMERATOR;
+						capparm->timeperframe.
+						    denominator =
+						    FPS_18_DENOMIRATOR;
+					}
+
+				}
+
+				/* Copy number of buffers allocated to arg
+				 * passed
+				 */
+				capparm->readbuffers = vpfe->numbuffers;
+
+				up(&vpfe->lock);
+				dev_dbg(vpfe_dev,
+					"\nEnd of VIDIOC_G_PARM ioctl");
+			}
+			break;
+		}
+	case VIDIOC_G_CTRL:
+		dev_dbg(vpfe_dev, "\nStart of VIDIOC_G_CTRL ioctl");
+		down_interruptible(&vpfe->lock);
+
+		if (device_type == TVP5146) {
+			tvp5146_ctrl(VIDIOC_G_CTRL, arg);
+		} else if (device_type == MT9T001 || device_type == MT9T031) {
+			/* Call device control function to get control value */
+			ret = vpfe->config_dev_fxn(VIDIOC_G_CTRL, arg,
+						   vpfe->device_params);
+		}
+		up(&vpfe->lock);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_CTRL ioctl");
+		break;
+	case VIDIOC_S_CTRL:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_CTRL ioctl");
+		down_interruptible(&vpfe->lock);
+
+		if (device_type == TVP5146) {
+			ret = tvp5146_ctrl(VIDIOC_S_CTRL, arg);
+		} else if (device_type == MT9T001 || device_type == MT9T031) {
+			/* Call device control function to configure control
+			 * value
+			 */
+			ret = vpfe->config_dev_fxn(VIDIOC_S_CTRL, arg,
+						   vpfe->device_params);
+		}
+		up(&vpfe->lock);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_CTRL ioctl");
+		break;
+	case VIDIOC_QUERYCTRL:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_QUERYCTRL ioctl");
+		down_interruptible(&vpfe->lock);
+
+		if (device_type == TVP5146) {
+			tvp5146_ctrl(VIDIOC_QUERYCTRL, arg);
+		} else if (device_type == MT9T001 || device_type == MT9T031) {
+			/* Call device control function to query about
+			 * supported control commands
+			 */
+			ret = vpfe->config_dev_fxn(VIDIOC_QUERYCTRL, arg,
+						   vpfe->device_params);
+		}
+
+		up(&vpfe->lock);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QUERYCTRL ioctl");
+
+		break;
+	case VIDIOC_G_CROP:
+		{
+			struct v4l2_crop *crop = arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_G_CROP ioctl");
+			if (crop->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+				ret = -EINVAL;
+			} else {
+				crop->c = vpfe->vwin;
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_CROP ioctl");
+			break;
+		}
+	case VIDIOC_S_CROP:
+		{
+			struct v4l2_crop *crop = arg;
+			enum hw_frame frame_type =
+			    (device_type == TVP5146) ? CCDC_YCBCR : CCDC_RAW;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_CROP ioctl");
+			if (vpfe->started) {
+				/* make sure streaming is not started */
+				ret = -EBUSY;
+				break;
+			}
+			/* adjust the width to 16 pixel boundry */
+			crop->c.width = ((crop->c.width + 15) / 16) * 16;
+
+			/* make sure parameters are valid */
+			if (crop->type == V4L2_BUF_TYPE_VIDEO_CAPTURE
+			    && (crop->c.left + crop->c.width
+				<= vpfe->bounds.left + vpfe->bounds.width)
+			    && (crop->c.top + crop->c.height
+				<= vpfe->bounds.top + vpfe->bounds.height)) {
+
+				down_interruptible(&vpfe->lock);
+				vpfe->vwin = crop->c;
+				ccdc_set_image_window(frame_type, vpfe->vwin);
+				up(&vpfe->lock);
+			} else {
+				ret = -EINVAL;
+			}
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_CROP ioctl");
+			break;
+		}
+	case VIDIOC_QUERYSTD:
+		{
+			v4l2_std_id *id = (v4l2_std_id *) arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_QUERYSTD ioctl");
+
+			if (device_type == TVP5146) {
+				down_interruptible(&vpfe->lock);
+				ret = sense_std(id);
+				up(&vpfe->lock);
+			} else {
+				/* return -EINVAL indicating this ioctl
+				 * is not supported
+				 */
+				ret = -EINVAL;
+			}
+
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QUERYSTD ioctl");
+			break;
+		}
+	case VIDIOC_G_PRIORITY:
+		{
+			enum v4l2_priority *p = arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_G_PRIORITY ioctl");
+			*p = v4l2_prio_max(&vpfe->prio);
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_G_PRIORITY ioctl");
+			break;
+		}
+	case VIDIOC_S_PRIORITY:
+		{
+			enum v4l2_priority *p = arg;
+			dev_dbg(vpfe_dev, "\nStarting VIDIOC_S_PRIORITY ioctl");
+			ret = v4l2_prio_change(&vpfe->prio, &fh->prio, *p);
+			dev_dbg(vpfe_dev, "\nEnd of VIDIOC_S_PRIORITY ioctl");
+			break;
+		}
+
+	case VIDIOC_REQBUFS:
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_REQBUFS ioctl");
+		down_interruptible(&vpfe->lock);
+		if (vpfe->io_usrs != 0) {
+			ret = -EBUSY;
+			break;
+		}
+		videobuf_queue_init(&vpfe->bufqueue, &video_qops, NULL,
+				    &vpfe->irqlock,
+				    V4L2_BUF_TYPE_VIDEO_CAPTURE,
+				    vpfe->field,
+				    sizeof(struct videobuf_buffer), fh);
+
+		videobuf_set_buftype(&vpfe->bufqueue, VIDEOBUF_BUF_LINEAR);
+
+		fh->io_allowed = TRUE;
+		vpfe->io_usrs = 1;
+		INIT_LIST_HEAD(&vpfe->dma_queue);
+		ret = videobuf_reqbufs(&vpfe->bufqueue, arg);
+		up(&vpfe->lock);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_REQBUFS ioctl");
+		break;
+	case VIDIOC_QUERYBUF:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_QUERYBUF ioctl");
+		ret = videobuf_querybuf(&vpfe->bufqueue, arg);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QUERYBUF ioctl");
+		break;
+	case VIDIOC_QBUF:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_QBUF ioctl");
+		if (!fh->io_allowed) {
+			dev_dbg(vpfe_dev, "\nfh->io_allowed");
+			ret = -EACCES;
+		} else {
+			dev_dbg(vpfe_dev, "\n else of fh->io_allowed");
+			ret = videobuf_qbuf(&vpfe->bufqueue, arg);
+		}
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_QBUF ioctl");
+		break;
+
+	case VIDIOC_DQBUF:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_DQBUF ioctl");
+		if (!fh->io_allowed)
+			ret = -EACCES;
+		else
+			ret = videobuf_dqbuf(&vpfe->bufqueue, arg, 0);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_DQBUF ioctl");
+		break;
+
+	case VIDIOC_STREAMON:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_STREAMON ioctl");
+		if (!fh->io_allowed) {
+			ret = -EACCES;
+			break;
+		}
+		if (vpfe->started) {
+			ret = -EBUSY;
+			break;
+		}
+		ret = videobuf_streamon(&vpfe->bufqueue);
+		if (ret)
+			break;
+
+		down_interruptible(&vpfe->lock);
+		/* get the current and next frame buffers */
+		/* we expect at least one buffer is in driver at this point */
+		/* if not, error is returned */
+		if (list_empty(&vpfe->dma_queue)) {
+			ret = -EIO;
+			break;
+		}
+		dev_dbg(vpfe_dev, "cur frame %x.\n",
+			(unsigned int)vpfe->dma_queue.next);
+		vpfe->nextFrm = vpfe->curFrm =
+		    list_entry(vpfe->dma_queue.next,
+			       struct videobuf_buffer, queue);
+		/* remove the buffer from the queue */
+		list_del(&vpfe->curFrm->queue);
+		vpfe->curFrm->state = STATE_ACTIVE;
+
+		if (device_type == TVP5146) {
+			/* sense the current video input standard */
+			tvp5146_ctrl(TVP5146_CONFIG, &vpfe->tvp5146_params);
+			frm_format = ccdc_get_frame_format(CCDC_YCBCR);
+			ccdc_get_image_window(CCDC_YCBCR, &image_window);
+			/* configure the ccdc and resizer as needed   */
+			/* start capture by enabling CCDC and resizer */
+			ccdc_config_ycbcr();
+		} else {
+			frm_format = ccdc_get_frame_format(CCDC_YCBCR);
+			frm_format = ccdc_get_frame_format(CCDC_RAW);
+			ccdc_get_image_window(CCDC_RAW, &image_window);
+			/* configure the ccdc and resizer as needed   */
+			/* start capture by enabling CCDC and resizer */
+			ccdc_config_raw();
+		}
+
+		/* setup the memory address for the frame buffer */
+		ccdc_setfbaddr(((unsigned long)(vpfe->curFrm->boff)));
+		/* enable CCDC */
+		vpfe->field_id = 0;
+		vpfe->started = TRUE;
+		vpfe->mode_changed = FALSE;
+		vpfe->field_offset = (vpfe->vwin.height - 2) * vpfe->vwin.width;
+		ccdc_enable(TRUE);
+		up(&vpfe->lock);
+		dev_dbg(vpfe_dev, "started video streaming.\n");
+		break;
+	case VIDIOC_STREAMOFF:
+		dev_dbg(vpfe_dev, "\nStarting VIDIOC_STREAMOFF ioctl");
+		if (!fh->io_allowed) {
+			ret = -EACCES;
+			break;
+		}
+		if (!vpfe->started) {
+			ret = -EINVAL;
+			break;
+		}
+		/* disable CCDC */
+		down_interruptible(&vpfe->lock);
+		ccdc_enable(FALSE);
+		vpfe->started = FALSE;
+		up(&vpfe->lock);
+		ret = videobuf_streamoff(&vpfe->bufqueue);
+		dev_dbg(vpfe_dev, "\nEnd of VIDIOC_STREAMOFF ioctl");
+		break;
+
+	case VPFE_CMD_CONFIG_CCDC_YCBCR:
+		/* this can be used directly and bypass the V4L2 APIs */
+		{
+
+			if (vpfe->started) {
+				/* only allowed if streaming is not started */
+				ret = -EBUSY;
+				break;
+			}
+			down_interruptible(&vpfe->lock);
+			/* make sure the other v4l2 related fields
+			   have consistant settings */
+			ccdc_update_ycbcr_params(arg);
+			ccdc_get_image_window(CCDC_YCBCR, &vpfe->vwin);
+
+			if (ccdc_get_buf_type(CCDC_YCBCR) ==
+			    CCDC_BUFTYPE_FLD_INTERLEAVED)
+				vpfe->field = V4L2_FIELD_INTERLACED;
+			else if (ccdc_get_buf_type(CCDC_YCBCR) ==
+				 CCDC_BUFTYPE_FLD_SEPARATED)
+				vpfe->field = V4L2_FIELD_SEQ_TB;
+
+			if (ccdc_get_pix_order() == CCDC_PIXORDER_YCBYCR)
+				vpfe->pixelfmt = V4L2_PIX_FMT_YUYV;
+			else if (ccdc_get_pix_order() == CCDC_PIXORDER_CBYCRY)
+				vpfe->pixelfmt = V4L2_PIX_FMT_UYVY;
+
+			up(&vpfe->lock);
+			break;
+		}
+	case VPFE_CMD_CONFIG_CCDC_RAW:
+		/* This command is used to configure driver for CCDC Raw
+		 * mode parameters
+		 */
+		{
+			if (vpfe->started) {
+				/* only allowed if streaming is not started */
+				ret = -EBUSY;
+				break;
+			}
+
+			if (validate_ccdc_param((ccdc_config_params_raw *) arg)
+			    == -1) {
+				dev_err(vpfe_dev,
+					"\nValidation of ccdc parameters failed \n");
+				return -EINVAL;
+			} else {
+				dev_err(vpfe_dev, "\n Validation pass\n");
+				if (ccdc_update_raw_params(arg) == -1) {
+					dev_err(vpfe_dev,
+						"\n ccdc parameters update failed \n");
+					return -EINVAL;
+				}
+			}
+			break;
+		}
+
+	case VPFE_CMD_CONFIG_TVP5146:
+		/* this can be used directly and bypass the V4L2 APIs */
+		{
+			/* the settings here must be consistant with that of
+			   the CCDC's,driver does not check the consistancy */
+			tvp5146_params *params = (tvp5146_params *) arg;
+			v4l2_std_id std = 0;
+			dev_dbg(vpfe_dev,
+				"\nStarting VPFE_CMD_CONFIG_TVP5146 ioctl");
+			if (vpfe->started) {
+				/* only allowed if streaming is not started */
+				ret = -EBUSY;
+				break;
+			}
+			down_interruptible(&vpfe->lock);
+			/* make sure the other v4l2 related fields have
+			 * consistant settings
+			 */
+			switch (params->mode & 0x7) {
+			case TVP5146_MODE_NTSC:
+				std = V4L2_STD_NTSC;
+				break;
+			case TVP5146_MODE_PAL:
+				std = V4L2_STD_PAL;
+				break;
+			case TVP5146_MODE_PAL_M:
+				std = V4L2_STD_PAL_M;
+				break;
+			case TVP5146_MODE_PAL_CN:
+				std = V4L2_STD_PAL_N;
+				break;
+			case TVP5146_MODE_SECAM:
+				std = V4L2_STD_SECAM;
+				break;
+			case TVP5146_MODE_PAL_60:
+				std = V4L2_STD_PAL_60;
+				break;
+			}
+			dev_dbg(vpfe_dev,
+				"\nVPFE_CMD_CONFIG_TVP5146:std = %d", (int)std);
+			if (params->mode & 0x8) {	/* square pixel mode */
+				std <<= 32;
+			}
+			/* auto-detection modes */
+			if (params->mode == TVP5146_MODE_AUTO) {
+				std = VPFE_STD_AUTO;
+			} else if (params->mode == TVP5146_MODE_AUTO_SQP) {
+				std = VPFE_STD_AUTO_SQP;
+			}
+
+			if (std & V4L2_STD_625_50) {
+				vpfe->bounds = pal_bounds;
+				vpfe->pixelaspect = pal_aspect;
+			} else if (std & V4L2_STD_525_60) {
+				vpfe->bounds = ntsc_bounds;
+				vpfe->pixelaspect = ntsc_aspect;
+			} else if (std & VPFE_STD_625_50_SQP) {
+				vpfe->bounds = palsp_bounds;
+				vpfe->pixelaspect = sp_aspect;
+			} else if (std & VPFE_STD_525_60_SQP) {
+				vpfe->bounds = ntscsp_bounds;
+				vpfe->pixelaspect = sp_aspect;
+			}
+			vpfe->std = std;
+			ret = tvp5146_ctrl(TVP5146_CONFIG, params);
+			dev_dbg(vpfe_dev,
+				"\nVPFE_CMD_CONFIG_TVP5146:ret = %d", (int)ret);
+			vpfe->tvp5146_params = *params;
+			up(&vpfe->lock);
+			dev_dbg(vpfe_dev,
+				"\nEnd VPFE_CMD_CONFIG_TVP5146 ioctl");
+			break;
+		}
+	case VPFE_CMD_S_MT9T001_PARAMS:
+		/* This command configures MT9T001 */
+		{
+			dev_dbg(vpfe_dev,
+				"\nStarting VPFE_CMD_S_MT9T001_PARAMS ioctl");
+			/* Call device control function to configure MT9T001 */
+			ret = vpfe->config_dev_fxn(MT9T001_SET_PARAMS, arg,
+						   vpfe->device_params);
+			dev_dbg(vpfe_dev,
+				"\nEnd VPFE_CMD_S_MT9T001_PARAMS ioctl");
+			break;
+		}
+	case VPFE_CMD_G_MT9T001_PARAMS:
+		/* This command returns MT9T001 configuration values to
+		 * application.
+		 */
+		{
+			dev_dbg(vpfe_dev,
+				"\nStarting VPFE_CMD_G_MT9T001_PARAMS ioctl");
+			/* Call device control function to get
+			 * MT9T001 configuration values
+			 */
+			ret = vpfe->config_dev_fxn(MT9T001_GET_PARAMS, arg,
+						   vpfe->device_params);
+			dev_dbg(vpfe_dev,
+				"\nEnd of VPFE_CMD_G_MT9T001_PARAMS ioctl");
+			break;
+		}
+	default:
+		dev_dbg(vpfe_dev, "\nDefault ioctl");
+		ret = -ENOIOCTLCMD;
+		break;
+	}			/* end switch(cmd) */
+	return ret;
+}
+
+/*
+ * ======== vpfe_ioctl ========
+ */
+static int vpfe_ioctl(struct inode *inode, struct file *file,
+		      unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	dev_dbg(vpfe_dev, "\nStarting of vpfe_ioctl...");
+	ret = video_usercopy(inode, file, cmd, arg, vpfe_doioctl);
+	dev_dbg(vpfe_dev, "\n(vpfe_ioctl) video_usercopy done ...");
+	if ((ret >= 0) && (cmd == VIDIOC_S_FMT || cmd == VIDIOC_TRY_FMT)) {
+		ret = video_usercopy(inode, file, VIDIOC_G_FMT,
+				     arg, vpfe_doioctl);
+	}
+	dev_dbg(vpfe_dev, "\nEnd of vpfe_ioctl...");
+	return ret;
+}
+
+/*
+ * ======== vpfe_mmap ========
+ */
+static int vpfe_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	dev_dbg(vpfe_dev, "\nStarting of vpfe_mmap...");
+	return videobuf_mmap_mapper(&vpfe_device.bufqueue, vma);
+}
+
+/*
+ * ======== vpfe_open ========
+ */
+ /* Creates a file handle for video object. Initialize itwith default value */
+static int vpfe_open(struct inode *inode, struct file *filep)
+{
+	int minor = iminor(inode);
+	vpfe_obj *vpfe = NULL;
+	vpfe_fh *fh = NULL;
+
+	dev_dbg(vpfe_dev, "vpfe: open minor=%d\n", minor);
+
+	/* check to make sure the minor numbers match */
+	if (vpfe_device.video_dev && vpfe_device.video_dev->minor == minor) {
+		vpfe = &vpfe_device;
+	} else {		/* device not found here */
+		return -ENODEV;
+	}
+
+	/* allocate per filehandle data */
+	if ((fh = kmalloc(sizeof(*fh), GFP_KERNEL)) == NULL) {
+		return -ENOMEM;
+	}
+	filep->private_data = fh;
+	fh->dev = vpfe;
+	fh->io_allowed = FALSE;
+	fh->prio = V4L2_PRIORITY_UNSET;
+	v4l2_prio_open(&vpfe->prio, &fh->prio);
+	vpfe->usrs++;
+	dev_dbg(vpfe_dev, "\nvpfe_open done ...");
+	return 0;
+}
+
+/*
+ * ======== vpfe_release ========
+ */
+ /* This function disables the CCDC, Deletes the buffer queue and frees
+  * the vpfe file handle.
+  */
+static int vpfe_release(struct inode *inode, struct file *filep)
+{
+	vpfe_fh *fh = filep->private_data;
+	vpfe_obj *vpfe = fh->dev;
+	dev_dbg(vpfe_dev, "\nStarting of vpfe_release...");
+	down_interruptible(&vpfe->lock);
+	if (fh->io_allowed) {
+		vpfe->io_usrs = 0;
+		ccdc_enable(FALSE);
+		vpfe->started = FALSE;
+		videobuf_queue_cancel(&vpfe->bufqueue);
+		videobuf_mmap_free(&vpfe->bufqueue);
+		vpfe->numbuffers = VPFE_DEFNUM_FBUFS;
+	}
+	vpfe->usrs--;
+	v4l2_prio_close(&vpfe->prio, &fh->prio);
+	filep->private_data = NULL;
+	if (fh != NULL)
+		kfree(fh);
+	up(&vpfe->lock);
+	dev_dbg(vpfe_dev, "\nEnd of vpfe_release...");
+	return 0;
+}
+
+static struct file_operations vpfe_fops = {
+	.owner = THIS_MODULE,
+	.open = vpfe_open,
+	.release = vpfe_release,
+	.ioctl = vpfe_ioctl,
+	.mmap = vpfe_mmap
+};
+
+static struct video_device vpfe_video_template = {
+	.name = "vpfe",
+	.type = VID_TYPE_CAPTURE | VID_TYPE_CLIPPING | VID_TYPE_SCALES,
+	.hardware = 0,
+	.fops = &vpfe_fops,
+	.minor = -1,
+};
+
+static void vpfe_platform_release(struct device *device)
+{
+	/* This is called when the reference count goes to zero. */
+}
+
+/*
+ * ======== vpfe_probe ========
+ */
+ /* This function will allocate video device initialize and
+  * registers the device
+  */
+static int __init vpfe_probe(struct device *device)
+{
+	struct video_device *vfd;
+	vpfe_obj *vpfe = &vpfe_device;
+	vpfe_dev = device;
+	dev_dbg(vpfe_dev, "\nStarting of vpfe_probe...");
+	/* alloc video device */
+	if ((vfd = video_device_alloc()) == NULL) {
+		return -ENOMEM;
+	}
+	*vfd = vpfe_video_template;
+	vfd->dev = device;
+	vfd->release = video_device_release;
+
+	snprintf(vfd->name, sizeof(vfd->name),
+		 "DaVinci_VPFE_DRIVER_V%d.%d.%d",
+		 (VPFE_VERSION_CODE >> 16) & 0xff,
+		 (VPFE_VERSION_CODE >> 8) & 0xff, (VPFE_VERSION_CODE) & 0xff);
+
+	vpfe->video_dev = vfd;
+	vpfe->usrs = 0;
+	vpfe->io_usrs = 0;
+	vpfe->started = FALSE;
+	vpfe->latest_only = TRUE;
+
+	v4l2_prio_init(&vpfe->prio);
+	init_MUTEX(&vpfe->lock);
+
+	/* register video device */
+	dev_dbg(vpfe_dev, "trying to register vpfe device.\n");
+	dev_dbg(vpfe_dev, "vpfe=%x,vpfe->video_dev=%x\n", (int)vpfe,
+		(int)&vpfe->video_dev);
+	if (video_register_device(vpfe->video_dev, VFL_TYPE_GRABBER, -1) < 0) {
+		video_device_release(vpfe->video_dev);
+		vpfe->video_dev = NULL;
+		return -1;
+	}
+
+	dev_dbg(vpfe_dev, "DaVinci vpfe: driver version V%d.%d.%d loaded\n",
+		(VPFE_VERSION_CODE >> 16) & 0xff,
+		(VPFE_VERSION_CODE >> 8) & 0xff, (VPFE_VERSION_CODE) & 0xff);
+
+	dev_dbg(vpfe_dev, "vpfe: registered device video%d\n",
+		vpfe->video_dev->minor & 0x1f);
+
+	/* all done */
+	return 0;
+}
+
+/*
+ * ======== vpfe_remove ========
+ */
+static int vpfe_remove(struct device *device)
+{
+	/* un-register device */
+	dev_dbg(vpfe_dev, "\nUnregistering device...");
+	video_unregister_device(vpfe_device.video_dev);
+
+	return 0;
+}
+
+static struct device_driver vpfe_driver = {
+	.name = "vpfe",
+	.bus = &platform_bus_type,
+	.probe = vpfe_probe,
+	.remove = vpfe_remove,
+};
+
+static struct platform_device _vpfe_device = {
+	.name = "vpfe",
+	.id = 1,
+	.dev = {
+		.release = vpfe_platform_release,
+		}
+};
+
+/*
+ * ======== vpfe_init ========
+ */
+ /*This function allocates free pages and register the driver. Then reset the
+  * CCDC and configure capture device with default parameters
+  */
+static int vpfe_init(void)
+{
+	int i = 0;
+	int fbuf_size;
+	ccdc_frmfmt frame_format;
+	void *mem;
+	int ret = 0;
+
+	ccdc_init();
+
+	if (device_type == TVP5146) {
+		fbuf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
+		vpfe_device = vpfe_device_ycbcr;
+		frame_format = ccdc_get_frame_format(CCDC_YCBCR);
+	}
+
+	else if (device_type == MT9T001 || device_type == MT9T031) {
+		fbuf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
+		vpfe_device = vpfe_device_raw;
+		frame_format = ccdc_get_frame_format(CCDC_RAW);
+	} else {
+		return -1;
+	}
+	/* allocate memory at initialization time to guarentee availability */
+	for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
+		mem =
+		    (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+					     get_order(fbuf_size));
+		if (mem) {
+			unsigned long adr = (unsigned long)mem;
+			u32 size = PAGE_SIZE << (get_order(fbuf_size));
+			while (size > 0) {
+				/* make sure the frame buffers
+				   are never swapped out of memory */
+				SetPageReserved(virt_to_page(adr));
+				adr += PAGE_SIZE;
+				size -= PAGE_SIZE;
+			}
+			vpfe_device.fbuffers[i] = (u8 *) mem;
+		} else {
+			while (--i >= 0) {
+				free_reserved_pages((unsigned long)
+						    vpfe_device.
+						    fbuffers[i], fbuf_size);
+			}
+			dev_err(vpfe_dev,
+				"frame buffer memory allocation failed.\n");
+			return -ENOMEM;
+		}
+	}
+	if (driver_register(&vpfe_driver) != 0) {
+		dev_err(vpfe_dev, "driver registration failed\n");
+		return -1;
+	}
+	if (platform_device_register(&_vpfe_device) != 0) {
+		driver_unregister(&vpfe_driver);
+		dev_err(vpfe_dev, "device registration failed\n");
+		return -1;
+	}
+
+	ccdc_reset();
+
+	if (device_type == TVP5146) {
+		ret = tvp5146_ctrl(TVP5146_INIT, NULL);
+		if (ret >= 0) {
+			ret = tvp5146_ctrl(TVP5146_RESET, NULL);
+			/* configure the tvp5146 to default parameters */
+			ret |=
+			    tvp5146_ctrl(TVP5146_CONFIG,
+					 &vpfe_device.tvp5146_params);
+		}
+		if (ret < 0) {
+			tvp5146_ctrl(TVP5146_CLEANUP, NULL);
+		}
+	} else if (device_type == MT9T001 || device_type == MT9T031) {
+		/* enable video port in case of raw capture */
+		ccdc_enable_vport();
+		vpfe_device.config_dev_fxn = mt9t001_ctrl;
+		/* enable the i2c switch on the MT9T031 head board */
+		if (device_type == MT9T031)
+			vpfe_device.config_dev_fxn(MT9T001_ENABLE_I2C_SWITCH,
+						   NULL, NULL);
+		ret =
+		    vpfe_device.config_dev_fxn(MT9T001_INIT,
+					       &vpfe_device.std,
+					       &vpfe_device.device_params);
+	}
+
+	if (ret < 0) {
+		platform_device_unregister(&_vpfe_device);
+		driver_unregister(&vpfe_driver);
+		/* Free memory for all image buffers */
+		for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
+			free_reserved_pages((unsigned long)
+					    vpfe_device.fbuffers[i], fbuf_size);
+		}
+		return -1;
+	}
+
+	/* setup interrupt handling */
+	/* request VDINT1 if progressive format */
+	if (frame_format == CCDC_FRMFMT_PROGRESSIVE) {
+		ret = request_irq(IRQ_VDINT1, vdint1_isr, SA_INTERRUPT,
+				  "vpfe_capture", (void *)&vpfe_device);
+		if (ret < 0) {
+			platform_device_unregister(&_vpfe_device);
+			driver_unregister(&vpfe_driver);
+			/* Free memory for all image buffers */
+			for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
+				free_reserved_pages((unsigned long)
+						    vpfe_device.
+						    fbuffers[i], fbuf_size);
+			}
+			return -1;
+		}
+	}
+	ret = request_irq(IRQ_VDINT0, vpfe_isr, SA_INTERRUPT,
+			  "vpfe_capture", (void *)&vpfe_device);
+	if (ret < 0) {
+		platform_device_unregister(&_vpfe_device);
+		driver_unregister(&vpfe_driver);
+		/* Free memory for all image buffers */
+		for (i = 0; i < VPFE_DEFNUM_FBUFS; i++) {
+			free_reserved_pages((unsigned long)
+					    vpfe_device.fbuffers[i], fbuf_size);
+		}
+		free_irq(IRQ_VDINT1, &vpfe_device);
+		return -1;
+	}
+
+	dev_err(vpfe_dev, "DaVinci v4l2 capture driver V1.0 loaded\n");
+	return 0;
+}
+
+/*
+ * ======== vpfe_cleanup ========
+ */
+ /*This function unregisters the driver and free the allocated pages */
+static void vpfe_cleanup(void)
+{
+	int i = vpfe_device.numbuffers;
+	int buf_size;
+	ccdc_frmfmt frame_format;
+	//unsigned int *fpc_physaddr = NULL, *fpc_virtaddr = NULL;
+
+	if (device_type == TVP5146) {
+		tvp5146_ctrl(TVP5146_CLEANUP, NULL);
+		buf_size = VPFE_TVP5146_MAX_FBUF_SIZE;
+		frame_format = ccdc_get_frame_format(CCDC_YCBCR);
+	} else {
+		buf_size = VPFE_MT9T001_MAX_FBUF_SIZE;
+		/* Free mt9t001 object memory */
+		vpfe_device.config_dev_fxn(MT9T001_CLEANUP, NULL,
+					   vpfe_device.device_params);
+		frame_format = ccdc_get_frame_format(CCDC_RAW);
+	}
+
+	platform_device_unregister(&_vpfe_device);
+	driver_unregister(&vpfe_driver);
+	/* disable interrupt */
+	free_irq(IRQ_VDINT0, &vpfe_device);
+	/* Free VDINT1 if progressive format */
+	if (frame_format == CCDC_FRMFMT_PROGRESSIVE) {
+		free_irq(IRQ_VDINT1, &vpfe_device);
+	}
+
+	ccdc_cleanup();
+
+	/* Free memory for all image buffers */
+	while (--i >= 0) {
+		free_reserved_pages((unsigned long)vpfe_device.
+				    fbuffers[i], buf_size);
+	}
+}
+
+module_init(vpfe_init);
+module_exit(vpfe_cleanup);
Index: linux-2.6.18/drivers/media/video/davinci/mt9t001.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/mt9t001.c
@@ -0,0 +1,1343 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/videodev.h>
+#include <linux/device.h>
+#include <media/davinci/mt9t001.h>
+
+#define MT9T001_I2C_ENABLE 1
+/* i2c global variable for mt9t001*/
+static struct i2c_client mt9t001_i2c_client;
+static struct i2c_driver mt9t001_i2c_driver;
+static int mt9t001_i2c_registration = 0;
+struct device *mt9t001_i2c_dev;
+static int CONFIG_PCA9543A = 0;
+
+/*	Function prototype*/
+int mt9t001_ctrl(unsigned int cmd, void *arg, void *params);
+static int mt9t001_init(void *arg, void **params);
+static int mt9t001_cleanup(void *params);
+static int mt9t001_configpca9543a(void);
+static int mt9t001_setstd(void *arg, void *params);
+static int mt9t001_setformat(struct mt9t001_format_params *mt9tformats);
+static int mt9t001_getformat(struct mt9t001_format_params *mt9tformats);
+static int mt9t001_queryctrl(void *arg);
+static int mt9t001_setgain(int arg);
+static int mt9t001_getgain(int *arg);
+static int mt9t001_setparams(void *arg);
+static int mt9t001_getparams(void *arg);
+
+/*i2c function proto types*/
+static int i2c_read_reg(struct i2c_client *, unsigned char,
+			unsigned short *, bool);
+static int i2c_write_reg(struct i2c_client *, unsigned char,
+			 unsigned short, bool);
+static int _i2c_attach_client(struct i2c_client *, struct i2c_driver *,
+			      struct i2c_adapter *, int);
+static int _i2c_detach_client(struct i2c_client *);
+static int mt9t001_i2c_probe_adapter(struct i2c_adapter *);
+static int mt9t001_i2c_init(void);
+void mt9t001_i2c_cleanup(void);
+
+/* Parameters for  various format supported  */
+/*Format  is
+{
+	NUMBER OF PIXELS PER LINE, NUMBER OF LINES,
+	HRIZONTAL BLANKING WIDTH, VERTICAL BLANKING WIDTH,
+	SHUTTER WIDTH, ROW ADDRESS MODE, COL ADDRESS MODE,
+	BLACK_LEVEL,PIXEL CLOCK CONTROL,
+	ROW START, COL START
+}
+*/
+
+const struct mt9t001_format_params MT9T001_VGA_30FPS =
+    { 1979, 1467, 21, 31, 822, 0x22, 0x22, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_VGA_60FPS =
+    { 1979, 1467, 21, 31, 582, 0x12, 0x12, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_SVGA_30FPS =
+    { 1639, 1239, 21, 31, 1042, 0x11, 0x11, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_SVGA_60FPS =
+    { 1639, 1239, 21, 31, 661, 0x01, 0x01, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_XGA_30FPS =
+    { 1039, 775, 100, 283, 783, 0x00, 0x00, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_480P_30FPS =
+    { 1471, 975, 350, 350, 898, 0x11, 0x11, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_480P_60FPS =
+    { 1471, 975, 52, 50, 480, 0x11, 0x11, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_576P_25FPS =
+    { 1471, 1167, 424, 450, 500, 0x11, 0x11, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_576P_50FPS =
+    { 1471, 1167, 84, 48, 480, 0x11, 0x11, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_720P_24FPS =
+    { 1299, 729, 300, 282, 568, 0x00, 0x00, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_720P_30FPS =
+    { 1299, 729, 22, 220, 568, 0x00, 0x00, 64, 0x8000, 0, 0 };
+const struct mt9t001_format_params MT9T001_1080P_18FPS =
+    { 1919, 1079, 108, 31, 1095, 0x00, 0x00, 64, 0x8000, 0, 0 };
+
+void mt9t001_readregs(void)
+{
+	unsigned short temp = 0;
+	int err = 0;
+	unsigned char regcnt;
+	/* Here, 0x64 is number of registers for MT9T001 */
+	for (regcnt = 0; regcnt < 0x64; regcnt++) {
+		err = i2c_read_reg(&mt9t001_i2c_client, regcnt,
+				   &temp, MT9T001_I2C_CONFIG);
+		if (err >= 0) {
+			dev_dbg(mt9t001_i2c_dev,
+				"\nread back 0x%x = 0x%x...", regcnt, temp);
+		}
+	}
+}
+
+/*
+ * ======== mt9t001_ctrl  ========
+ */
+
+/*This function will provide different control commands for MT9T001
+		configuration.*/
+int mt9t001_ctrl(unsigned int cmd, void *arg, void *params)
+{
+	int err = 0;
+	switch (cmd) {
+	case MT9T001_SET_PARAMS:
+		{
+
+			struct mt9t001_params *vpfe_mt9t001params =
+			    (struct mt9t001_params *)params;
+			struct mt9t001_params *user_mt9t001params =
+			    (struct mt9t001_params *)arg;
+
+			/* Update the global parameter of vpfe_obj */
+
+			if ((arg == NULL) || (params == NULL)) {
+				dev_err(mt9t001_i2c_dev, "Invalid argument for \
+							MT9T001_SET_PARAMS ");
+				return -1;
+			}
+
+			memcpy(vpfe_mt9t001params, user_mt9t001params,
+			       sizeof(struct mt9t001_params));
+
+			err = mt9t001_setparams(arg);
+			if (err < 0) {
+				dev_err(mt9t001_i2c_dev,
+					"\nMT9T001 set parameters fails...");
+				return err;
+			}
+			break;
+
+		}
+	case MT9T001_SET_STD:
+		{
+			err = mt9t001_setstd(arg, params);
+			if (err < 0) {
+				dev_err(mt9t001_i2c_dev,
+					"\nMT9T001 set standard fails...");
+				return err;
+			} else {
+				//mt9t001_readregs();
+			}
+			break;
+		}
+	case MT9T001_GET_PARAMS:
+		{
+
+			struct mt9t001_params *vpfe_mt9t001params =
+			    (struct mt9t001_params *)params;
+			struct mt9t001_params *user_mt9t001params =
+			    (struct mt9t001_params *)arg;
+
+			err = mt9t001_getparams(arg);
+			if (err < 0) {
+				dev_err(mt9t001_i2c_dev,
+					"\nMT9T001 get parameters  fails...");
+				return err;
+			}
+			/* Update the global parameter of vpfe_obj */
+			memcpy(vpfe_mt9t001params, user_mt9t001params,
+			       sizeof(struct mt9t001_params));
+			break;
+		}
+	case MT9T001_ENABLE_I2C_SWITCH:
+		/* enable the i2c switch on the MT9T031 head board */
+		CONFIG_PCA9543A = 1;
+		break;
+	case MT9T001_INIT:
+		{
+			err = mt9t001_init(arg, params);
+			if (err < 0) {
+				printk(KERN_ERR
+				       "\n Unable to initialize MT9T001...");
+				return err;
+			}
+			break;
+		}
+	case MT9T001_CLEANUP:
+		{
+			mt9t001_cleanup(params);
+
+			break;
+		}
+	case VIDIOC_S_CTRL:
+		{
+			struct v4l2_control *ctrl = arg;
+
+			if (ctrl->id == V4L2_CID_GAIN) {
+				err = mt9t001_setgain((int)ctrl->value);
+				if (err < 0) {
+					dev_err(mt9t001_i2c_dev,
+						"\n MT9T001 set gain fails...");
+					return err;
+				}
+			} else {
+				err = -EINVAL;
+			}
+			break;
+		}
+	case VIDIOC_G_CTRL:
+		{
+			struct v4l2_control *ctrl = arg;
+
+			if (ctrl->id == V4L2_CID_GAIN) {
+				err = mt9t001_getgain((int *)
+						      &(ctrl->value));
+				if (err < 0) {
+					dev_err(mt9t001_i2c_dev,
+						"\n MT9T001 get gain fails...");
+					return err;
+				}
+			} else {
+				err = -EINVAL;
+			}
+			break;
+		}
+	case VIDIOC_QUERYCTRL:
+		{
+			err = mt9t001_queryctrl(arg);
+			break;
+		}
+	default:
+		{
+			dev_err(mt9t001_i2c_dev, "\n Undefined command");
+			return -1;
+		}
+
+	}
+	return err;
+}
+
+/*
+ * ======== mt9t001_init  ========
+ */
+/*	This function will set the video format standart*/
+static int mt9t001_init(void *arg, void **params)
+{
+	struct i2c_driver *driver = &mt9t001_i2c_driver;
+	struct mt9t001_params *temp_params = NULL;
+	int err = 0;
+
+#if MT9T001_I2C_ENABLE
+	/* Register MT9T001 I2C client */
+	err = i2c_add_driver(driver);
+	if (err) {
+		printk(KERN_ERR "Failed to register MT9T001 I2C client.\n");
+		return -1;
+	}
+	mt9t001_i2c_registration = MT9T001_I2C_REGISTERED;
+#endif
+	temp_params = kmalloc(sizeof(struct mt9t001_params), GFP_KERNEL);
+	if (temp_params == NULL) {
+		printk(KERN_ERR "\n Unable to allocate memory...");
+		return -1;
+	}
+	(*params) = temp_params;
+	/* enable path from mt9t001 to */
+	err |= i2c_write_reg(&mt9t001_i2c_client, ECP_REGADDR,
+			     ECP_REGVAL, ECP_I2C_CONFIG);
+	if (CONFIG_PCA9543A)
+		mt9t001_configpca9543a();
+	/*Configure the MT9T001 in normalpower up mode */
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_ROW_START,
+			     MT9T001_ROW_START_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_COL_START,
+			     MT9T001_COL_START_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_WIDTH,
+			     MT9T001_WIDTH_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_HEIGHT,
+			     MT9T001_HEIGHT_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_HBLANK,
+			     MT9T001_HBLANK_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_VBLANK,
+			     MT9T001_VBLANK_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_OUTPUT_CTRL,
+			     MT9T001_OUTPUT_CTRL_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |=
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH_UPPER,
+			  MT9T001_SHUTTER_WIDTH_UPPER_DEFAULT,
+			  MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH,
+			     MT9T001_SHUTTER_WIDTH_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_PIXEL_CLK_CTRL,
+			     MT9T001_PIXEL_CLK_CTRL_DEFAULT,
+			     MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RESTART,
+			     MT9T001_RESTART_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_DELAY,
+			     MT9T001_SHUTTER_DELAY_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_READ_MODE1,
+			     MT9T001_READ_MODE1_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_READ_MODE2,
+			     MT9T001_READ_MODE2_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_READ_MODE3,
+			     MT9T001_READ_MODE3_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_ROW_ADDR_MODE,
+			     MT9T001_ROW_ADDR_MODE_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_COL_ADDR_MODE,
+			     MT9T001_COL_ADDR_MODE_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN1_GAIN,
+			     MT9T001_GREEN1_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLUE_GAIN,
+			     MT9T001_BLUE_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RED_GAIN,
+			     MT9T001_RED_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN2_GAIN,
+			     MT9T001_GREEN2_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GLOBAL_GAIN,
+			     MT9T001_GLOBAL_GAIN_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLACK_LEVEL,
+			     MT9T001_BLACK_LEVEL_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_CAL_COARSE,
+			     MT9T001_CAL_COARSE_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_CAL_TARGET,
+			     MT9T001_CAL_TARGET_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN1_OFFSET,
+			     MT9T001_GREEN1_OFFSET_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN2_OFFSET,
+			     MT9T001_GREEN2_OFFSET_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RED_OFFSET,
+			     MT9T001_RED_OFFSET_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLUE_OFFSET,
+			     MT9T001_BLUE_OFFSET_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLK_LVL_CALIB,
+			     MT9T001_BLK_LVL_CALIB_DEFAULT, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_CHIP_ENABLE_SYNC,
+			     MT9T001_CHIP_ENABLE_SYNC_DEFAULT,
+			     MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RESET,
+			     MT9T001_RESET_ENABLE, MT9T001_I2C_CONFIG);
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_RESET,
+			     MT9T001_RESET_DISABLE, MT9T001_I2C_CONFIG);
+	/* delay applying changes  */
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_OUTPUT_CTRL,
+			     MT9T001_HALT_MODE, MT9T001_I2C_CONFIG);
+
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_PIXEL_CLK_CTRL,
+			     MT9T001_INVERT_PIXEL_CLK, MT9T001_I2C_CONFIG);
+
+	/*Configure the MT9T001 in normalpower up mode */
+	err |= i2c_write_reg(&mt9t001_i2c_client, MT9T001_OUTPUT_CTRL,
+			     MT9T001_NORMAL_OPERATION_MODE, MT9T001_I2C_CONFIG);
+
+	if (err < 0) {
+		mt9t001_cleanup((*params));
+	} else {
+		/* Configure for default video standard */
+		err = mt9t001_setstd(arg, (*params));
+
+		if (err < 0) {
+			mt9t001_cleanup(params);
+		}
+	}
+	return err;
+}
+
+static int mt9t001_getformat(struct mt9t001_format_params *mt9tformats)
+{
+	int err = 0;
+	unsigned short val = 0;
+
+	/*Read the height width and blanking information required
+	   for particular format */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_HEIGHT,
+			   &mt9tformats->row_size, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...height");
+		return err;
+	}
+
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_WIDTH,
+			   &mt9tformats->col_size, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...width");
+		return err;
+	}
+
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_HBLANK,
+			   &mt9tformats->h_blank, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...hblk");
+		return err;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_VBLANK,
+			   &mt9tformats->v_blank, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...vblk");
+		return err;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...shutterwidth");
+		return err;
+	}
+	mt9tformats->shutter_width = val & MT9T001_SHUTTER_WIDTH_LOWER_MASK;
+
+	err =
+	    i2c_read_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH_UPPER,
+			 &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...upper");
+		return err;
+	}
+	mt9tformats->shutter_width |= ((val & MT9T001_SHUTTER_WIDTH_UPPER_MASK)
+				       << MT9T001_SHUTTER_WIDTH_UPPER_SHIFT);
+
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_ROW_ADDR_MODE,
+			   &mt9tformats->row_addr_mode, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...addrmoderow");
+		return err;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_COL_ADDR_MODE,
+			   &mt9tformats->col_addr_mode, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...addrmodecol");
+		return err;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_BLACK_LEVEL,
+			   &mt9tformats->black_level, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...black_level");
+		return err;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_ROW_START,
+			   &mt9tformats->row_start, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...rowstart");
+		return err;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_COL_START,
+			   &mt9tformats->col_start, MT9T001_I2C_CONFIG);
+
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...colstart");
+		return err;
+	}
+
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_PIXEL_CLK_CTRL,
+			   &mt9tformats->pixel_clk_control, MT9T001_I2C_CONFIG);
+
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...clkctrl");
+		return err;
+	}
+	return err;
+}
+
+static int mt9t001_setformat(struct mt9t001_format_params *mt9tformats)
+{
+	int err = 0;
+
+	/*Write the height width and blanking information required
+	   for particular format */
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_HEIGHT,
+			    mt9tformats->row_size, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...height");
+		return err;
+	}
+
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_WIDTH,
+			    mt9tformats->col_size, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...width");
+		return err;
+	}
+	/* Configure for default video standard */
+
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_HBLANK,
+			    mt9tformats->h_blank, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...hblk");
+		return err;
+	}
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_VBLANK,
+			    mt9tformats->v_blank, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...vblk");
+		return err;
+	}
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH,
+			    (unsigned short)(mt9tformats->
+					     shutter_width &
+					     MT9T001_SHUTTER_WIDTH_LOWER_MASK),
+			    MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...shutterwidth");
+		return err;
+	}
+
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_SHUTTER_WIDTH_UPPER,
+			  (unsigned short)(mt9tformats->
+					   shutter_width >>
+					   MT9T001_SHUTTER_WIDTH_UPPER_SHIFT),
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...upper");
+		return err;
+	}
+
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_ROW_ADDR_MODE,
+			    mt9tformats->row_addr_mode, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...addrmoderow");
+		return err;
+	}
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_COL_ADDR_MODE,
+			    mt9tformats->col_addr_mode, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...addrmodecol");
+		return err;
+	}
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLACK_LEVEL,
+			    mt9tformats->black_level, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...black_level");
+		return err;
+	}
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_ROW_START,
+			    mt9tformats->row_start, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...rowstart");
+		return err;
+	}
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_COL_START,
+			    mt9tformats->col_start, MT9T001_I2C_CONFIG);
+
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...colstart");
+		return err;
+	}
+
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_PIXEL_CLK_CTRL,
+			    mt9tformats->pixel_clk_control, MT9T001_I2C_CONFIG);
+
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...clkctrl");
+		return err;
+	}
+	/* applying changes  */
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_OUTPUT_CTRL,
+			    MT9T001_NORMAL_OPERATION_MODE, MT9T001_I2C_CONFIG);
+
+	if (err < 0) {
+		printk(KERN_ERR "\n I2C write fails...outputctrl");
+		return err;
+	}
+
+	return err;
+}
+
+/*
+ * ======== configPCA9543A  ========
+ */
+/*	This function will configure PCA9543 control register*/
+static int mt9t001_configpca9543a()
+{
+	int err = 0;
+	/* enable path from mt9t001 to */
+	err |= i2c_write_reg(&mt9t001_i2c_client, ECP_REGADDR,
+			     ECP_REGVAL, ECP_I2C_CONFIG);
+
+	/* Configure PCA9543A, here discard register address */
+	err = i2c_write_reg(&mt9t001_i2c_client, 0,
+			    PCA9543A_REGVAL, PCA9543A_I2C_CONFIG);
+	return err;
+}
+
+/*
+ * ======== mt9t001_cleanup  ========
+ */
+
+/*This function will free the memory allocated for mt9t001_params*/
+static int mt9t001_cleanup(void *params)
+{
+	struct i2c_driver *driver = &mt9t001_i2c_driver;
+	struct mt9t001_params *temp_params = (struct mt9t001_params *)params;
+	if (temp_params != NULL)
+		kfree(temp_params);
+	params = NULL;
+#if MT9T001_I2C_ENABLE
+	if (mt9t001_i2c_registration) {
+		i2c_detach_client(&mt9t001_i2c_client);
+		i2c_del_driver(driver);
+		mt9t001_i2c_client.adapter = NULL;
+		mt9t001_i2c_registration = MT9T001_I2C_UNREGISTERED;
+	}
+#endif
+	return 0;
+}
+
+/*
+ * ======== mt9t001_setstd  ========
+ */
+
+/*	Function to set the video frame format*/
+static int mt9t001_setstd(void *arg, void *params)
+{
+	v4l2_std_id mode = *(v4l2_std_id *) arg;
+	struct mt9t001_format_params mt9tformats;
+	int err = 0;
+
+	/* Select configuration parameters as per video mode  */
+	if (mode == MT9T001_MODE_VGA_30FPS) {
+		mt9tformats = MT9T001_VGA_30FPS;
+	} else if (mode == MT9T001_MODE_VGA_60FPS) {
+		mt9tformats = MT9T001_VGA_60FPS;
+	} else if (mode == MT9T001_MODE_SVGA_30FPS) {
+		mt9tformats = MT9T001_SVGA_30FPS;
+	} else if (mode == MT9T001_MODE_SVGA_60FPS) {
+		mt9tformats = MT9T001_SVGA_60FPS;
+	} else if (mode == MT9T001_MODE_XGA_30FPS) {
+		mt9tformats = MT9T001_XGA_30FPS;
+	} else if (mode == MT9T001_MODE_480p_30FPS) {
+		mt9tformats = MT9T001_480P_30FPS;
+	} else if (mode == MT9T001_MODE_480p_60FPS) {
+		mt9tformats = MT9T001_480P_60FPS;
+	} else if (mode == MT9T001_MODE_576p_25FPS) {
+		mt9tformats = MT9T001_576P_25FPS;
+	} else if (mode == MT9T001_MODE_576p_50FPS) {
+		mt9tformats = MT9T001_576P_50FPS;
+	} else if (mode == MT9T001_MODE_720p_24FPS) {
+		mt9tformats = MT9T001_720P_24FPS;
+	} else if (mode == MT9T001_MODE_720p_30FPS) {
+		mt9tformats = MT9T001_720P_30FPS;
+	} else if (mode == MT9T001_MODE_1080p_18FPS) {
+		mt9tformats = MT9T001_1080P_18FPS;
+	} else {
+		printk(KERN_ERR "\n Invalid frame format");
+		return -1;
+	}
+
+	err = mt9t001_setformat(&mt9tformats);
+
+	return err;
+
+}
+
+/*
+ * ======== mt9t001_setparams  ========
+ */
+
+/* This function will configure MT9T001 for bayer pattern capture.*/
+static int mt9t001_setparams(void *arg)
+{
+	/*variable to store the return value of i2c read, write function */
+	int err = 0;
+	struct mt9t001_params *mt9t001params = (struct mt9t001_params *)arg;
+	unsigned short val;
+	if (arg == NULL) {
+		dev_err(mt9t001_i2c_dev, "Invalid argument in config MT9T001");
+		return -1;
+	}
+	/* set video format related parameters */
+	err = mt9t001_setformat(&mt9t001params->format);
+
+	/*Write the gain information */
+	val = (unsigned short)(mt9t001params->rgb_gain.green1_analog_gain
+			       & MT9T001_ANALOG_GAIN_MASK);
+
+	val |= ((mt9t001params->rgb_gain.green1_digital_gain
+		 << MT9T001_DIGITAL_GAIN_SHIFT) & MT9T001_DIGITAL_GAIN_MASK);
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN1_GAIN, val,
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = (unsigned short)(mt9t001params->rgb_gain.red_analog_gain)
+	    & MT9T001_ANALOG_GAIN_MASK;
+	val |= (((mt9t001params->rgb_gain.red_digital_gain)
+		 << MT9T001_DIGITAL_GAIN_SHIFT)
+		& MT9T001_DIGITAL_GAIN_MASK);
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_RED_GAIN,
+			    val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = (unsigned short)(mt9t001params->rgb_gain.blue_analog_gain)
+	    & MT9T001_ANALOG_GAIN_MASK;
+	val |= (((mt9t001params->rgb_gain.blue_digital_gain)
+		 << MT9T001_DIGITAL_GAIN_SHIFT)
+		& MT9T001_DIGITAL_GAIN_MASK);
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLUE_GAIN,
+			    val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = (unsigned short)((mt9t001params->rgb_gain.green2_analog_gain)
+			       << MT9T001_ANALOG_GAIN_SHIFT) &
+	    MT9T001_ANALOG_GAIN_MASK;
+	val |= (((mt9t001params->rgb_gain.green2_digital_gain)
+		 << MT9T001_DIGITAL_GAIN_SHIFT) & MT9T001_DIGITAL_GAIN_MASK);
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN2_GAIN, val,
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	/*Write the offset value in register */
+
+	val = mt9t001params->black_calib.green1_offset
+	    & MT9T001_GREEN1_OFFSET_MASK;
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN1_OFFSET,
+			    val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = mt9t001params->black_calib.green2_offset
+	    & MT9T001_GREEN2_OFFSET_MASK;
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_GREEN2_OFFSET,
+			    val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = mt9t001params->black_calib.red_offset & MT9T001_RED_OFFSET_MASK;
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_RED_OFFSET, val,
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = mt9t001params->black_calib.blue_offset & MT9T001_BLUE_OFFSET_MASK;
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLUE_OFFSET, val,
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	/*Write other black caliberation information */
+
+	val = (unsigned short)(mt9t001params->black_calib.manual_override)
+	    & MT9T001_MANUAL_OVERRIDE_MASK;
+	val |= ((mt9t001params->black_calib.disable_calibration)
+		<< MT9T001_DISABLE_CALLIBERATION_SHIFT)
+	    & MT9T001_DISABLE_CALLIBERATION_MASK;
+	val |= ((mt9t001params->black_calib.recalculate_black_level)
+		<< MT9T001_RECAL_BLACK_LEVEL_SHIFT)
+	    & MT9T001_RECAL_BLACK_LEVEL_MASK;
+	val |= ((mt9t001params->black_calib.lock_red_blue_calibration)
+		<< MT9T001_LOCK_RB_CALIBRATION_SHIFT)
+	    & MT9T001_LOCK_RB_CALLIBERATION_MASK;
+	val |= ((mt9t001params->black_calib.lock_green_calibration)
+		<< MT9T001_LOCK_GREEN_CALIBRATION_SHIFT)
+	    & MT9T001_LOCK_GREEN_CALLIBERATION_MASK;
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_BLK_LVL_CALIB,
+			    val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	/*Write Thresholds Value */
+
+	val = (unsigned short)mt9t001params->black_calib.low_coarse_thrld
+	    & MT9T001_LOW_COARSE_THELD_MASK;
+	val |= (mt9t001params->black_calib.high_coarse_thrld
+		<< MT9T001_HIGH_COARSE_THELD_SHIFT) &
+	    MT9T001_HIGH_COARSE_THELD_MASK;
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_CAL_COARSE, val,
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	val = (unsigned short)mt9t001params->black_calib.low_target_thrld
+	    & MT9T001_LOW_TARGET_THELD_MASK;
+	val |= (mt9t001params->black_calib.high_target_thrld
+		<< MT9T001_HIGH_TARGET_THELD_SHIFT)
+	    & MT9T001_HIGH_TARGET_THELD_MASK;
+	err = i2c_write_reg(&mt9t001_i2c_client, MT9T001_CAL_TARGET,
+			    val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+
+	dev_dbg(mt9t001_i2c_dev, "\nEnd of configMT9T001...");
+	return 0;
+
+}
+
+/*
+ * ======== queryctrl ========
+ */
+ /* This function will return parameter values for control command passed */
+static int mt9t001_queryctrl(void *arg)
+{
+	struct v4l2_queryctrl *queryctrl = arg;
+	int ret = 0;
+	int id = queryctrl->id;
+	dev_dbg(mt9t001_i2c_dev, "\nStarting mt9t001_queryctrl...");
+	if (queryctrl == NULL) {
+		dev_err(mt9t001_i2c_dev,
+			"\n Invalid argument in query control");
+		return -1;
+	}
+
+	memset(queryctrl, 0, sizeof(*queryctrl));
+	queryctrl->id = id;
+	switch (id) {
+	case V4L2_CID_GAIN:
+		strcpy(queryctrl->name, "GAIN");
+		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
+		queryctrl->minimum = MT9T001_GAIN_MINVAL;
+		queryctrl->maximum = MT9T001_GAIN_MAXVAL;
+		queryctrl->step = MT9T001_GAIN_STEP;
+		queryctrl->default_value = MT9T001_GAIN_DEFAULTVAL;
+		break;
+	default:
+		if (id < V4L2_CID_LASTP1)
+			queryctrl->flags = V4L2_CTRL_FLAG_DISABLED;
+		else
+			ret = -EINVAL;
+		break;
+	}			/* end switch (id) */
+	dev_dbg(mt9t001_i2c_dev, "\nEnd of mt9t001_queryctrl...");
+	return ret;
+}
+
+/*
+ * ======== mt9t001_setgain  ========
+ */
+
+/*	This function will set the global gain of MT9T001*/
+static int mt9t001_setgain(int arg)
+{
+
+	unsigned short gain = (unsigned short)arg;
+	int err = 0;
+	dev_dbg(mt9t001_i2c_dev,
+		"\nStarting mt9t001_setgain with gain = %d...", (int)gain);
+	err =
+	    i2c_write_reg(&mt9t001_i2c_client, MT9T001_GLOBAL_GAIN, gain,
+			  MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C write fails...");
+		return err;
+	}
+	dev_dbg(mt9t001_i2c_dev, "\nEnd of mt9t001_setgain...");
+	return err;
+}
+
+/*
+ * ======== mt9t001_getgain  ========
+ */
+
+/*	This function will get the global gain of MT9T001*/
+static int mt9t001_getgain(int *arg)
+{
+	unsigned short gain;
+	int err = 0;
+	dev_dbg(mt9t001_i2c_dev, "\nStarting mt9t001_getgain...");
+	if (arg == NULL) {
+		dev_err(mt9t001_i2c_dev,
+			"\nInvalid argument pointer in get gain function");
+		return -1;
+	}
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GLOBAL_GAIN,
+			   &gain, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C reads fails...");
+		return err;
+	}
+	*arg = gain;
+	dev_dbg(mt9t001_i2c_dev, "\nEnd of mt9t001_getgain...");
+	return err;
+}
+
+/*
+ * ======== mt9t001_getparams  ========
+ */
+
+/*This function will get MT9T001 configuration values.*/
+
+static int mt9t001_getparams(void *arg)
+{
+
+	struct mt9t001_params *params = (struct mt9t001_params *)arg;
+	unsigned short val;
+	int err = 0;
+	dev_dbg(mt9t001_i2c_dev, "\nStarting mt9t001_getparams");
+
+	/* get video format related parameters */
+	err = mt9t001_getformat(&params->format);
+
+	if (err < 0) {
+		return err;
+	}
+	/*      Read green1 gain */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GREEN1_GAIN,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->rgb_gain.green1_analog_gain = val & MT9T001_ANALOG_GAIN_MASK;
+	params->rgb_gain.green1_digital_gain =
+	    (val & MT9T001_DIGITAL_GAIN_MASK) >> MT9T001_DIGITAL_GAIN_SHIFT;
+
+	/*      Read blue gain */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_BLUE_GAIN,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->rgb_gain.blue_analog_gain = val & MT9T001_ANALOG_GAIN_MASK;
+	params->rgb_gain.blue_digital_gain =
+	    (val & MT9T001_DIGITAL_GAIN_MASK) >> MT9T001_DIGITAL_GAIN_SHIFT;
+
+	/*      Read red gain */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_RED_GAIN,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->rgb_gain.red_analog_gain = val & MT9T001_ANALOG_GAIN_MASK;
+	params->rgb_gain.red_digital_gain =
+	    (val & MT9T001_DIGITAL_GAIN_MASK) >> MT9T001_DIGITAL_GAIN_SHIFT;
+
+	/*      Read green2 gain */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GREEN2_GAIN,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->rgb_gain.green2_analog_gain = val & MT9T001_ANALOG_GAIN_MASK;
+	params->rgb_gain.green2_digital_gain =
+	    (val & MT9T001_DIGITAL_GAIN_MASK) >> MT9T001_DIGITAL_GAIN_SHIFT;
+
+	/*      Read green1 offset */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GREEN1_OFFSET,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.green1_offset = val & MT9T001_GREEN1_OFFSET_MASK;
+
+	/*      Read green2 offset */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_GREEN2_OFFSET,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.green2_offset = val & MT9T001_GREEN2_OFFSET_MASK;
+
+	/*      Read red offset */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_RED_OFFSET,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.red_offset = val & MT9T001_RED_OFFSET_MASK;
+
+	/*      Read blue offset */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_BLUE_OFFSET,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.blue_offset = val & MT9T001_BLUE_OFFSET_MASK;
+
+	/*      Read Black level caliberation information */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_BLK_LVL_CALIB,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.manual_override =
+	    val & MT9T001_MANUAL_OVERRIDE_MASK;
+	params->black_calib.disable_calibration =
+	    (val & MT9T001_DISABLE_CALLIBERATION_MASK)
+	    >> MT9T001_DISABLE_CALLIBERATION_SHIFT;
+	params->black_calib.recalculate_black_level =
+	    (val & MT9T001_RECAL_BLACK_LEVEL_MASK)
+	    >> MT9T001_RECAL_BLACK_LEVEL_SHIFT;
+	params->black_calib.lock_red_blue_calibration =
+	    (val & MT9T001_LOCK_RB_CALLIBERATION_MASK)
+	    >> MT9T001_LOCK_RB_CALIBRATION_SHIFT;
+	params->black_calib.lock_green_calibration =
+	    (val & MT9T001_LOCK_GREEN_CALLIBERATION_MASK)
+	    >> MT9T001_LOCK_GREEN_CALIBRATION_SHIFT;
+
+	/*      Read Black Level Caliberation Coarse Threshold Value */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_CAL_COARSE,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.low_coarse_thrld = val
+	    & MT9T001_LOW_COARSE_THELD_MASK;
+	params->black_calib.high_coarse_thrld =
+	    (val & MT9T001_HIGH_COARSE_THELD_MASK)
+	    >> MT9T001_HIGH_COARSE_THELD_SHIFT;
+
+	/*      Read Black Level Caliberation Target Threshold Value */
+	err = i2c_read_reg(&mt9t001_i2c_client, MT9T001_CAL_TARGET,
+			   &val, MT9T001_I2C_CONFIG);
+	if (err < 0) {
+		dev_err(mt9t001_i2c_dev, "\n I2C read fails...");
+		return err;
+	}
+	params->black_calib.low_target_thrld = val
+	    & MT9T001_LOW_TARGET_THELD_MASK;
+	params->black_calib.high_target_thrld =
+	    (val & MT9T001_HIGH_COARSE_THELD_MASK)
+	    >> MT9T001_HIGH_COARSE_THELD_SHIFT;
+
+	dev_dbg(mt9t001_i2c_dev, "\nEnd of getparamsMT9T001...");
+	return 0;
+}
+
+/*
+ * ======== i2c_read_reg  ========
+ */
+
+/*This function is used to read value from register for i2c client. */
+
+static int i2c_read_reg(struct i2c_client *client, unsigned char reg,
+			unsigned short *val, bool configdev)
+{
+	int err = 0;
+#ifdef MT9T001_I2C_ENABLE
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else if (configdev == ECP_I2C_CONFIG) {
+		msg->addr = ECP_I2C_ADDR;
+		msg->flags = 0;
+		msg->len = I2C_ONE_BYTE_TRANSFER;
+		msg->buf = data;
+		data[0] = reg;
+
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			msg->flags = I2C_M_RD;
+			msg->len = I2C_ONE_BYTE_TRANSFER;	/* 1 byte read */
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				*val = data[0];
+			} else {
+				dev_err(mt9t001_i2c_dev,
+					"\n ERROR in ECP control register read\n");
+
+			}
+		} else {
+			dev_err(mt9t001_i2c_dev,
+				"\n ERROR in ECP control register read\n");
+		}
+
+	} else if (configdev == MT9T001_I2C_CONFIG) {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = I2C_ONE_BYTE_TRANSFER;
+		msg->buf = data;
+		data[0] = reg;
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			msg->flags = I2C_M_RD;
+			msg->len = I2C_TWO_BYTE_TRANSFER;	/* 2 byte read */
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				*val = ((data[0] & I2C_TXRX_DATA_MASK)
+					<< I2C_TXRX_DATA_SHIFT)
+				    | (data[1] & I2C_TXRX_DATA_MASK);
+			}
+		}
+	}
+#endif
+	return err;
+}
+
+/*
+ * ======== i2c_write_reg  ========
+ */
+/*This function is used to write value into register for i2c client. */
+static int i2c_write_reg(struct i2c_client *client, unsigned char reg,
+			 unsigned short val, bool configdev)
+{
+	int err = 0;
+	int trycnt = 0;
+	unsigned short readval = 0;
+
+#ifdef MT9T001_I2C_ENABLE
+
+	struct i2c_msg msg[1];
+	unsigned char data[3];
+	err = -1;
+	while ((err < 0) && (trycnt < 5)) {
+		trycnt++;
+		if (!client->adapter) {
+			err = -ENODEV;
+		} else if (configdev == ECP_I2C_CONFIG) {
+			/* if device is ECP then discard reg value
+			 * and set ECP I2C address
+			 */
+			msg->addr = ECP_I2C_ADDR;
+			msg->flags = 0;
+			msg->len = I2C_TWO_BYTE_TRANSFER;
+			msg->buf = data;
+			data[0] = (unsigned char)(reg & I2C_TXRX_DATA_MASK);
+			data[1] = (unsigned char)(val & I2C_TXRX_DATA_MASK);
+
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err < 0) {
+				printk(KERN_INFO
+				       "\n ERROR in ECP  register write\n");
+			}
+		} else if (configdev == PCA9543A_I2C_CONFIG) {
+			/* if device is ECP then discard reg value
+			 * and set ECP I2C address
+			 */
+			msg->addr = PCA9543A_I2C_ADDR;
+			msg->flags = 0;
+			msg->len = I2C_ONE_BYTE_TRANSFER;
+			msg->buf = data;
+			data[0] = (unsigned char)(val & I2C_TXRX_DATA_MASK);
+
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err < 0) {
+				printk(KERN_INFO
+				       "\n ERROR in PCA543a  register write\n");
+			}
+		} else if (configdev == MT9T001_I2C_CONFIG) {
+			msg->addr = client->addr;
+			msg->flags = 0;
+			msg->len = I2C_THREE_BYTE_TRANSFER;
+			msg->buf = data;
+			data[0] = reg;
+			data[1] = (val & I2C_TXRX_DATA_MASK_UPPER) >>
+			    I2C_TXRX_DATA_SHIFT;
+			data[2] = (val & I2C_TXRX_DATA_MASK);
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				err =
+				    i2c_read_reg(&mt9t001_i2c_client, reg,
+						 &readval, MT9T001_I2C_CONFIG);
+				if ((err >= 0) && (val != readval)) {
+					printk
+					    (KERN_INFO
+					     "\n ERROR: i2c readback failed, val = %d, readval = %d, reg = %d\n",
+					     val, readval, reg);
+				}
+				readval = 0;
+			}
+		}
+	}
+#endif
+	if (err < 0) {
+		printk(KERN_INFO "\n I2C write failed");
+	}
+	return err;
+}
+
+/*
+ * ======== _i2c_attach_client  ========
+ */
+/* This function is used to attach i2c client */
+static int _i2c_attach_client(struct i2c_client *client,
+			      struct i2c_driver *driver,
+			      struct i2c_adapter *adap, int addr)
+{
+	int err = 0;
+#ifdef MT9T001_I2C_ENABLE
+	if (client->adapter) {
+		err = -EBUSY;	/* our client is already attached */
+	} else {
+		client->addr = addr;
+		client->driver = driver;
+		client->adapter = adap;
+
+		err = i2c_attach_client(client);
+		if (err) {
+			client->adapter = NULL;
+		}
+	}
+#endif
+	return err;
+}
+
+/*
+ * ======== _i2c_detach_client  ========
+ */
+/* This function is used to detach i2c client */
+static int _i2c_detach_client(struct i2c_client *client)
+{
+	int err = 0;
+#ifdef MT9T001_I2C_ENABLE
+	if (!client->adapter) {
+		return -ENODEV;	/* our client isn't attached */
+	} else {
+		err = i2c_detach_client(client);
+		client->adapter = NULL;
+	}
+#endif
+	return err;
+}
+
+/*
+ * ======== mt9t001_i2c_probe_adapter  ========
+ */
+
+/*This function is used to probe adapter for i2c_client. It returns
+    0 if i2c_client is attached to adapter and error code on failure.*/
+static int mt9t001_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	mt9t001_i2c_dev = &(adap->dev);
+	return _i2c_attach_client(&mt9t001_i2c_client, &mt9t001_i2c_driver,
+				  adap, MT9T001_I2C_ADDR);
+}
+
+/*
+ * ======== mt9t001_i2c_init  ========
+ */
+
+/*	This function is used to initialize the i2c*/
+static int mt9t001_i2c_init(void)
+{
+	int err = 0;
+#ifdef MT9T001_I2C_ENABLE
+	struct i2c_driver *driver = &mt9t001_i2c_driver;
+
+	driver->driver.name = "MT9T001 CMOS sensor I2C driver";
+	driver->id = I2C_DRIVERID_MISC;
+	driver->attach_adapter = mt9t001_i2c_probe_adapter;
+	driver->detach_client = _i2c_detach_client;
+#endif
+	return err;
+}
+
+/*
+ * ======== mt9t001_i2c_cleanup  ========
+ */
+
+void mt9t001_i2c_cleanup(void)
+{
+#ifdef MT9T001_I2C_ENABLE
+	struct i2c_driver *driver = &mt9t001_i2c_driver;
+
+	if (mt9t001_i2c_registration) {
+		i2c_detach_client(&mt9t001_i2c_client);
+		i2c_del_driver(driver);
+		mt9t001_i2c_client.adapter = NULL;
+		mt9t001_i2c_registration = MT9T001_I2C_UNREGISTERED;
+	}
+#endif
+}
+
+module_init(mt9t001_i2c_init);
+module_exit(mt9t001_i2c_cleanup);
+
+EXPORT_SYMBOL(mt9t001_ctrl);
+MODULE_LICENSE("GPL");
+
+/**********************************************************************/
+/* End of file                                                        */
+/**********************************************************************/
Index: linux-2.6.18/drivers/media/video/davinci/tvp5146.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/tvp5146.c
@@ -0,0 +1,819 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* tvp5146.c */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/videodev.h>
+#include <linux/device.h>
+#include <media/davinci/tvp5146.h>
+
+static struct i2c_client tvp5146_i2c_client;
+static struct i2c_driver tvp5146_i2c_driver;
+static int tvp5146_i2c_registration = 0;
+struct device *tvp5146_i2c_dev;
+
+static int i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val);
+static int i2c_write_reg(struct i2c_client *client, u8 reg, u8 val);
+
+static int configtvp5146(void *arg);
+static int clrtvp5146lostlock(void);
+static int enabletvp5146agc(int arg);
+static int getctrl(void *arg);
+static int gettvp5146status(void *arg);
+static int powerdowntvp5146(int powerdownenable);
+static int queryctrl(void *arg);
+static int resettvp5146(void);
+static int setctrl(void *arg);
+static int settvp5146amuxmode(int mode);
+static int settvp5146brightness(int arg);
+static int settvp5146contrast(int arg);
+static int settvp5146hue(int arg);
+static int settvp5146saturation(int arg);
+static int settvp5146std(int arg);
+static int setup656sync(tvp5146_params * tvp5146params);
+static int enable_ccdc2tvp5146(struct i2c_client *client);
+
+#define IS_DM355 (1)
+
+/*
+ * ======== tvp5146_init  ========
+ */
+/* This function is used initialize TVP5146 i2c client */
+static int tvp5146_init(void)
+{
+	int err;
+	struct i2c_driver *driver = &tvp5146_i2c_driver;
+
+	err = i2c_add_driver(driver);
+	if (err) {
+		printk(KERN_ERR "Failed to register TVP5146 I2C client.\n");
+	} else {
+		tvp5146_i2c_registration = TVP5146_I2C_REGISTERED;
+	}
+	if (IS_DM355)
+		enable_ccdc2tvp5146(&tvp5146_i2c_client);
+	return err;
+}
+
+/*
+ * ======== tvp5146_cleanup  ========
+ */
+/* This function is used detach TVP5146 i2c client */
+static void tvp5146_cleanup(void)
+{
+	struct i2c_driver *driver = &tvp5146_i2c_driver;
+	if (tvp5146_i2c_registration) {
+		i2c_detach_client(&tvp5146_i2c_client);
+		i2c_del_driver(driver);
+		tvp5146_i2c_client.adapter = NULL;
+		tvp5146_i2c_registration = TVP5146_I2C_UNREGISTERED;
+	}
+}
+
+/*
+ * ======== configtvp5146 ========
+ */
+/*This function will configure TVP5146 as per arguments passed*/
+static int configtvp5146(void *arg)
+{
+	tvp5146_params *tvp5146params = (tvp5146_params *) arg;
+	int ret = 0;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting configtvp5146...");
+	ret |= setup656sync(tvp5146params);
+	ret |= settvp5146amuxmode(tvp5146params->amuxmode);
+	ret |= settvp5146std(tvp5146params->mode);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of configtvp5146...");
+	return ret;
+}
+
+/*
+ * ======== clrtvp5146lostlock  ========
+ */
+ /*This function is used to clear lost lock bit in TVP5146 register. */
+static int clrtvp5146lostlock(void)
+{
+	int ret = 0;
+	u8 clr = 1;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting clrtvp5146lostlock...");
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x39, clr);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd clrtvp5146lostlock...");
+	return ret;
+}
+
+/*
+ * ========  enabletvp5146agc ========
+ */
+ /* This function is used to enable automatic gain control in TVP5146 */
+static int enabletvp5146agc(int arg)
+{
+	int ret = 0;
+	int agc;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting enabletvp5146agc...");
+	if (arg == TRUE) {
+		agc = 0xF;
+	} else {
+		agc = 0xC;
+	}
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x01, agc);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd enabletvp5146agc...");
+	return ret;
+}
+
+/*
+ * ========  gettvpctrl ========
+ */
+ /* This function is used to get control value for different control commands */
+static int getctrl(void *arg)
+{
+	struct v4l2_control *ctrl = arg;
+	int ret = 0;
+	u8 value;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting getctrl of TVP5146...");
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		ret = i2c_read_reg(&tvp5146_i2c_client, 0x09, &value);
+		ctrl->value = value;
+		break;
+	case V4L2_CID_CONTRAST:
+		ret = i2c_read_reg(&tvp5146_i2c_client, 0x0A, &value);
+		ctrl->value = value;
+		break;
+	case V4L2_CID_SATURATION:
+		ret = i2c_read_reg(&tvp5146_i2c_client, 0x0B, &value);
+		ctrl->value = value;
+		break;
+	case V4L2_CID_HUE:
+		ret = i2c_read_reg(&tvp5146_i2c_client, 0x0C, &value);
+		ctrl->value = value;
+		break;
+	case V4L2_CID_AUTOGAIN:
+		ret = i2c_read_reg(&tvp5146_i2c_client, 0x01, &value);
+		if ((value & 0x3) == 3) {
+			ctrl->value = TRUE;
+		} else {
+			ctrl->value = FALSE;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of getctrl...");
+	return ret;
+}
+
+/*
+ * ========  gettvp5146std ========
+ */
+ /* This function returns detected TVP5146 input standard */
+static int gettvp5146std(tvp5146_mode * mode)
+{
+	int ret = 0;
+	u8 output1;
+	u8 std;
+	u8 lock_status;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting of gettvp5146std...");
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x2, &std);
+	std &= 0x7;
+	if (std == TVP5146_MODE_AUTO) {
+		ret |= i2c_read_reg(&tvp5146_i2c_client, 0x3F, &std);
+	}
+	std &= 0x7;
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x33, &output1);
+	*mode = std | ((output1 & 0x80) >> 4);	/* square pixel status */
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x3A, &lock_status);
+	if ((lock_status & 0xe) != 0xe) {
+		/* not quite locked */
+		ret = -EAGAIN;
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of gettvp5146std...");
+	return ret;
+}
+
+/*
+ * ========  gettvp5146status ========
+ */
+ /* This function gets TVP5146 configuration values */
+static int gettvp5146status(void *arg)
+{
+	int ret = 0;
+	tvp5146_status *status = (tvp5146_status *) arg;
+	u8 agc, brightness, contrast, hue, saturation;
+	u8 status_byte;
+	u8 std;
+	u8 output1;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting gettvp5146status...");
+	ret = i2c_read_reg(&tvp5146_i2c_client, 0x01, &agc);
+	if ((agc & 0x3) == 3) {
+		status->agc_enable = TRUE;
+	} else {
+		status->agc_enable = FALSE;
+	}
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x09, &brightness);
+	status->brightness = brightness;
+
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x0A, &contrast);
+	status->contrast = contrast;
+
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x0B, &saturation);
+	status->saturation = saturation;
+
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x0C, &hue);
+	status->hue = hue;
+
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x3A, &status_byte);
+	status->field_rate = (status_byte & 0x20) ? 50 : 60;
+	status->lost_lock = (status_byte & 0x10) >> 4;
+	status->csubc_lock = (status_byte & 0x8) >> 3;
+	status->v_lock = (status_byte & 0x4) >> 2;
+	status->h_lock = (status_byte & 0x2) >> 1;
+
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x3F, &std);
+	ret |= i2c_read_reg(&tvp5146_i2c_client, 0x33, &output1);
+	if (std | 0x80) {	/* auto switch mode */
+		status->video_std = TVP5146_MODE_AUTO;
+	} else {
+		status->video_std = std;
+	}
+	status->video_std |= ((output1 & 0x80) >> 4);	/* square pixel status */
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of gettvp5146status...");
+	return ret;
+}
+
+/*
+ * ======== powerdowntvp5146 ========
+ */
+ /* This function will put TVP5146 in power down/up mode */
+static int powerdowntvp5146(int powerdownenable)
+{
+	u8 powerdownsettings = 0x01;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting powerdowntvp5146...");
+	/*Put _tvp5146 in power down mode */
+	if (!powerdownenable) {
+		powerdownsettings = 0x00;
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of powerdowntvp5146...");
+	return i2c_write_reg(&tvp5146_i2c_client, 0x03, powerdownsettings);
+}
+
+/*
+ * ======== resettvp5146========
+ */
+  /* This function will configure TVP5146 with default values */
+static int resettvp5146(void)
+{
+	tvp5146_params tvp5146params = { 0 };
+	dev_dbg(tvp5146_i2c_dev, "\nStarting resettvp5146...");
+
+	tvp5146params.enablebt656sync = TRUE;
+	tvp5146params.data_width = TVP5146_WIDTH_8BIT;
+
+	setup656sync(&tvp5146params);
+
+	settvp5146amuxmode(TVP5146_AMUX_COMPOSITE);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of resettvp5146...");
+	return powerdowntvp5146(FALSE);
+}
+
+/*
+ * ======== queryctrl ========
+ */
+  /* This function will return parameter values for control command passed */
+static int queryctrl(void *arg)
+{
+	struct v4l2_queryctrl *queryctrl = arg;
+	int ret = 0;
+	int id = queryctrl->id;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting queryctrl...");
+	memset(queryctrl, 0, sizeof(*queryctrl));
+	queryctrl->id = id;
+	switch (id) {
+	case V4L2_CID_BRIGHTNESS:
+		strcpy(queryctrl->name, "BRIGHTNESS");
+		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
+		queryctrl->minimum = 0;
+		queryctrl->maximum = 255;
+		queryctrl->step = 1;
+		queryctrl->default_value = 128;
+		break;
+	case V4L2_CID_CONTRAST:
+		strcpy(queryctrl->name, "CONTRAST");
+		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
+		queryctrl->minimum = 0;
+		queryctrl->maximum = 255;
+		queryctrl->step = 1;
+		queryctrl->default_value = 128;
+		break;
+
+	case V4L2_CID_SATURATION:
+		strcpy(queryctrl->name, "SATURATION");
+		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
+		queryctrl->minimum = 0;
+		queryctrl->maximum = 255;
+		queryctrl->step = 1;
+		queryctrl->default_value = 128;
+		break;
+	case V4L2_CID_HUE:
+		strcpy(queryctrl->name, "HUE");
+		queryctrl->type = V4L2_CTRL_TYPE_INTEGER;
+		queryctrl->minimum = -128;	/* -180 DEGREE */
+		queryctrl->maximum = 127;	/* 180  DEGREE */
+		queryctrl->step = 1;
+		queryctrl->default_value = 0;	/* 0 DEGREE */
+		break;
+
+	case V4L2_CID_AUTOGAIN:
+		strcpy(queryctrl->name, "Automatic Gain Control");
+		queryctrl->type = V4L2_CTRL_TYPE_BOOLEAN;
+		queryctrl->minimum = 0;
+		queryctrl->maximum = 1;
+		queryctrl->step = 1;
+		queryctrl->default_value = 1;
+		break;
+	default:
+		if (id < V4L2_CID_LASTP1)
+			queryctrl->flags = V4L2_CTRL_FLAG_DISABLED;
+		else
+			ret = -EINVAL;
+		break;
+	}			/* end switch (id) */
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of queryctrl...");
+	return ret;
+}
+
+/*
+ * ======== setctrl ========
+ */
+  /* This function will set parameter values for control command passed */
+static int setctrl(void *arg)
+{
+	struct v4l2_control *ctrl = arg;
+	int ret = 0;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting setctrl...");
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		ret = settvp5146brightness(ctrl->value);
+		break;
+	case V4L2_CID_CONTRAST:
+		ret = settvp5146contrast(ctrl->value);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = settvp5146saturation(ctrl->value);
+		break;
+	case V4L2_CID_HUE:
+		ret = settvp5146hue(ctrl->value);
+		break;
+	case V4L2_CID_AUTOGAIN:
+		ret = enabletvp5146agc(ctrl->value);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of setctrl...");
+	return ret;
+}
+
+/*
+ * ======== settvp5146amuxmode ========
+ */
+ /* This function is used to configure analog interface */
+static int settvp5146amuxmode(int arg)
+{
+	u8 input_sel;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146amuxmode...");
+	if (arg == TVP5146_AMUX_COMPOSITE) {	/* composite */
+		input_sel = 0x05;
+	} else if (arg == TVP5146_AMUX_SVIDEO) {	/* s-video */
+		input_sel = 0x46;
+	} else {
+		return -EINVAL;
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146amuxmode...");
+	return i2c_write_reg(&tvp5146_i2c_client, 0x00, input_sel);
+}
+
+/*
+ * ======== settvp5146brightness ========
+ */
+ /* This function is used to configure brightness */
+static int settvp5146brightness(int arg)
+{
+	int ret = 0;
+	u8 brightness = (u8) arg;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146brightness...");
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x09, brightness);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146brightness...");
+	return ret;
+}
+
+/*
+* ======== settvp5146contrast ========
+*/
+ /* This function is used to configure contrast */
+static int settvp5146contrast(int arg)
+{
+	int ret = 0;
+	u8 contrast = (u8) arg;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146contrast...");
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x0A, contrast);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146contrast...");
+	return ret;
+}
+
+/*
+* ======== settvp5146hue ========
+*/
+ /* This function is used to configure hue value */
+static int settvp5146hue(int arg)
+{
+	int ret = 0;
+	u8 hue = (u8) arg;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146hue...");
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x0C, hue);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146hue...");
+	return ret;
+}
+
+/*
+* ======== settvp5146saturation ========
+*/
+ /* This function is used to configure saturation value */
+static int settvp5146saturation(int arg)
+{
+	int ret = 0;
+	u8 saturation = (u8) arg;
+	dev_dbg(tvp5146_i2c_dev, "\nStarting settvp5146saturation...");
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x0B, saturation);
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146saturation...");
+	return ret;
+}
+
+/*
+* ======== settvp5146std ========
+*/
+/* This function is used to configure TVP5146 for video standard passed
+  *by application
+  */
+static int settvp5146std(int arg)
+{
+	int ret = 0;
+	u8 std = (u8) arg & 0x7;	/* the 4th-bit is for squre pixel sampling */
+	u8 output1;
+	dev_dbg(tvp5146_i2c_dev, "\nStart settvp5146std...");
+	/* setup the sampling rate: 601 or square pixel */
+	dev_dbg(tvp5146_i2c_dev, "reading i2c registers.\n");
+	ret = i2c_read_reg(&tvp5146_i2c_client, 0x33, &output1);
+	output1 |= ((arg & 0x8) << 4);
+	ret = i2c_write_reg(&tvp5146_i2c_client, 0x33, output1);
+
+	/* setup the video standard */
+	ret |= i2c_write_reg(&tvp5146_i2c_client, 0x02, std);
+	/* if autoswitch mode, enable all modes for autoswitch */
+	if (std == TVP5146_MODE_AUTO) {
+		u8 mask = 0x3F;	/* enable autoswitch for  all standards */
+		ret = i2c_write_reg(&tvp5146_i2c_client, 0x04, mask);
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of settvp5146std...");
+	return ret;
+}
+
+/*
+ * ======== setup656sync ========
+ */
+ /* This function will configure TVP5146 output data formatting */
+static int setup656sync(tvp5146_params * tvp5146params)
+{
+	int output1, output2, output3, output4;
+	int output5, output6;
+	int ret = 0;
+
+	dev_dbg(tvp5146_i2c_dev, "\nStarting setup656sync...");
+	if ((tvp5146params->enablebt656sync)
+	    && (tvp5146params->data_width == TVP5146_WIDTH_8BIT)) {
+		/* Configuration for 8-bit BT656 mode */
+		output1 = 0x40;
+		output4 = 0xFF;
+		output5 = 0x4;
+		output6 = 0;
+		ret |=
+		    i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT5,
+				  output5);
+		ret |=
+		    i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT6,
+				  output6);
+	} else if ((!tvp5146params->enablebt656sync)
+		   && (tvp5146params->data_width == TVP5146_WIDTH_8BIT)) {
+
+		/* Configuration for 8-bit seperate sync mode */
+		output1 = 0x43;
+		output4 = 0xAF;
+		output5 = 0x4;
+		output6 = 0x1E;
+		ret |=
+		    i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT5,
+				  output5);
+		ret |=
+		    i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT6,
+				  output6);
+	} else if ((!tvp5146params->enablebt656sync)
+		   && (tvp5146params->data_width == TVP5146_WIDTH_16BIT)) {
+
+		/* Configuration for 16-bit seperate sync mode */
+		output1 = 0x41;
+		output4 = 0xAF;
+	} else {
+		return -EINVAL;
+	}
+
+	output2 = 0x11;		/* enable clock, enable Y[9:0] */
+	output3 = 0x0;
+
+	ret |= i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT1, output1);
+	ret |= i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT2, output2);
+	ret |= i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT3, output3);
+	ret |= i2c_write_reg(&tvp5146_i2c_client, TVP5146_OUTPUT4, output4);
+
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of setup656sync...");
+
+	return ret;
+}
+
+/*
+ * ======== tvp5146_ctrl ========
+ */
+ /* This function handles all TVP5146 control commands */
+int tvp5146_ctrl(tvp5146_cmd cmd, void *arg)
+{
+	int ret = 0;
+	dev_dbg(tvp5146_i2c_dev,
+		"\nStarting tvp5146_ctrl with %d command...", cmd);
+	switch (cmd) {
+	case TVP5146_CONFIG:
+		ret = configtvp5146(arg);
+		break;
+	case TVP5146_RESET:
+		ret = resettvp5146();
+		break;
+	case TVP5146_POWERDOWN:
+		ret = powerdowntvp5146(*(int *)arg);
+		break;
+	case TVP5146_SET_AMUXMODE:
+		ret = settvp5146amuxmode(*(int *)arg);
+		break;
+	case TVP5146_SET_BRIGHTNESS:
+		ret = settvp5146brightness(*(int *)arg);
+		break;
+	case TVP5146_SET_CONTRAST:
+		ret = settvp5146contrast(*(int *)arg);
+		break;
+	case TVP5146_SET_HUE:
+		ret = settvp5146hue(*(int *)arg);
+		break;
+	case TVP5146_SET_SATURATION:
+		ret = settvp5146saturation(*(int *)arg);
+		break;
+	case TVP5146_SET_AGC:
+		ret = enabletvp5146agc(*(int *)arg);
+		break;
+	case TVP5146_SET_VIDEOSTD:
+		ret = settvp5146std(*(int *)arg);
+		break;
+	case TVP5146_CLR_LOSTLOCK:
+		ret = clrtvp5146lostlock();
+		break;
+	case TVP5146_GET_STATUS:
+		ret = gettvp5146status(arg);
+		break;
+	case TVP5146_GET_STD:
+		ret = gettvp5146std(arg);
+		break;
+	case VIDIOC_QUERYCTRL:
+		ret = queryctrl(arg);
+		break;
+	case VIDIOC_G_CTRL:
+		ret = getctrl(arg);
+		break;
+	case VIDIOC_S_CTRL:
+		ret = setctrl(arg);
+		break;
+	case TVP5146_INIT:
+		ret = tvp5146_init();
+		break;
+	case TVP5146_CLEANUP:
+		tvp5146_cleanup();
+		break;
+	default:
+		ret = -EINVAL;
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of tvp5146_ctrl...");
+	return ret;
+}
+
+/*
+ * ======== i2c_read_reg  ========
+ */
+/*This function is used to read value from register for i2c client. */
+static int i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[1];
+	dev_dbg(tvp5146_i2c_dev, "\nStarting tvp5146 i2c read...");
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 1;
+		msg->buf = data;
+		data[0] = reg;
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0) {
+			msg->flags = I2C_M_RD;
+			err = i2c_transfer(client->adapter, msg, 1);
+			if (err >= 0) {
+				*val = data[0];
+			}
+		}
+	}
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of tvp5146 i2c read...");
+	return err;
+}
+
+/*
+ * ======== i2c_write_reg  ========
+ */
+/*This function is used to write value into register for i2c client. */
+static int i2c_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	dev_dbg(tvp5146_i2c_dev, "\nEnd of tvp5146 i2c write...");
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = reg;
+		data[1] = val;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+	dev_dbg(tvp5146_i2c_dev, " i2c data write \n");
+
+	return err;
+}
+
+/*This function is used to write value into register for i2c client. */
+static int enable_ccdc2tvp5146(struct i2c_client *client)
+{
+	int err = 0;
+
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+		msg->addr = 0x25;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = 0x8;
+		data[1] = 0x0;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+	dev_dbg(tvp5146_i2c_dev, " i2c data write \n");
+
+	return err;
+}
+
+/*
+ * ======== _i2c_attach_client  ========
+ */
+/* This function is used to attach i2c client */
+static int _i2c_attach_client(struct i2c_client *client,
+			      struct i2c_driver *driver,
+			      struct i2c_adapter *adap, int addr)
+{
+	int err = 0;
+
+	if (client->adapter) {
+		err = -EBUSY;	/* our client is already attached */
+	} else {
+		client->addr = addr;
+		client->driver = driver;
+		client->adapter = adap;
+
+		err = i2c_attach_client(client);
+		if (err) {
+			client->adapter = NULL;
+		}
+	}
+	return err;
+}
+
+/*
+ * ======== _i2c_detach_client  ========
+ */
+/* This function is used to detach i2c client */
+static int _i2c_detach_client(struct i2c_client *client)
+{
+	int err = 0;
+
+	if (!client->adapter) {
+		return -ENODEV;	/* our client isn't attached */
+	} else {
+		err = i2c_detach_client(client);
+		client->adapter = NULL;
+	}
+	return err;
+}
+
+/*
+ * ======== tvp5146_i2c_probe_adapter  ========
+ */
+/* This function is used to probe i2c adapter */
+static int tvp5146_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	tvp5146_i2c_dev = &(adap->dev);
+	return _i2c_attach_client(&tvp5146_i2c_client, &tvp5146_i2c_driver,
+				  adap, TVP5146_I2C_ADDR);
+}
+
+/*
+ * ======== tvp5146_i2c_init  ========
+ */
+/* This function is used initialize TVP5146 i2c client */
+static int tvp5146_i2c_init(void)
+{
+	int err = 0;
+	struct i2c_driver *driver = &tvp5146_i2c_driver;
+
+	driver->driver.name = "TVP5146 Video Decoder I2C driver";
+	driver->id = I2C_DRIVERID_MISC;
+	driver->attach_adapter = tvp5146_i2c_probe_adapter;
+	driver->detach_client = _i2c_detach_client;
+
+	return err;
+}
+
+/*
+ * ======== tvp5146_i2c_cleanup  ========
+ */
+/* This function is used detach TVP5146 i2c client */
+static void tvp5146_i2c_cleanup(void)
+{
+	struct i2c_driver *driver = &tvp5146_i2c_driver;
+
+	if (tvp5146_i2c_registration) {
+		i2c_detach_client(&tvp5146_i2c_client);
+		i2c_del_driver(driver);
+		tvp5146_i2c_client.adapter = NULL;
+		tvp5146_i2c_registration = TVP5146_I2C_UNREGISTERED;
+	}
+}
+
+module_init(tvp5146_i2c_init);
+module_exit(tvp5146_i2c_cleanup);
+
+EXPORT_SYMBOL(tvp5146_ctrl);
+MODULE_LICENSE("GPL");
+
+/**************************************************************************/
+/* End of file                                                            */
+/**************************************************************************/
Index: linux-2.6.18/include/media/davinci/ccdc_dm355.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/ccdc_dm355.h
@@ -0,0 +1,869 @@
+/*
+ *
+ * Copyright (C) 2005 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* ccdc_davinci.h */
+
+#ifndef CCDC_DM355_H
+#define CCDC_DM355_H
+
+#ifdef __KERNEL__
+#include <asm/io.h>
+#endif
+#include <linux/videodev.h>
+
+#define TRUE 1
+#define FALSE 0
+
+/* Define to enable/disable video port */
+#define VIDEO_PORT_ENABLE	(1)
+
+typedef enum ccdc_pixfmt {
+	CCDC_PIXFMT_RAW = 0,
+	CCDC_PIXFMT_YCBCR_16BIT = 1,
+	CCDC_PIXFMT_YCBCR_8BIT = 2
+} ccdc_pixfmt;
+
+typedef enum ccdc_frmfmt {
+	CCDC_FRMFMT_PROGRESSIVE = 0,
+	CCDC_FRMFMT_INTERLACED = 1
+} ccdc_frmfmt;
+
+typedef enum ccdc_pinpol {
+	CCDC_PINPOL_POSITIVE = 0,
+	CCDC_PINPOL_NEGATIVE = 1
+} ccdc_pinpol;
+
+/* PIXEL ORDER IN MEMORY from LSB to MSB */
+/* only applicable for 8-bit input mode  */
+typedef enum ccdc_pixorder {
+	CCDC_PIXORDER_CBYCRY = 1,
+	CCDC_PIXORDER_YCBYCR = 0
+} ccdc_pixorder;
+
+typedef enum ccdc_buftype {
+	CCDC_BUFTYPE_FLD_INTERLEAVED,
+	CCDC_BUFTYPE_FLD_SEPARATED
+} ccdc_buftype;
+
+/* enum for No of pixel per line to be avg. in Black Clamping*/
+enum sample_length {
+	_1PIXELS = 0,
+	_2PIXELS,
+	_4PIXELS,
+	_8PIXELS,
+	_16PIXELS
+};
+
+#define FP_NUM_BYTES					(4)
+/* Define for extra pixel/line and extra lines/frame */
+#define NUM_EXTRAPIXELS	    0
+#define NUM_EXTRALINES		0
+
+/* settings for commonly used video formats */
+#define VPFE_WIN_NTSC    {0,0,720,480}
+#define VPFE_WIN_PAL     {0,0,720,576}
+#define VPFE_WIN_NTSC_SP {0,0,640,480}	/* ntsc square pixel */
+#define VPFE_WIN_PAL_SP  {0,0,768,576}	/* pal square pixel */
+#define VPFE_WIN_CIF     {0,0,352,288}
+#define VPFE_WIN_QCIF    {0,0,176,144}
+#define VPFE_WIN_QVGA    {0,0,320,240}
+#define VPFE_WIN_SIF     {0,0,352,240}
+
+#define VPFE_WIN_VGA	{0,0,(640 + NUM_EXTRAPIXELS),(480 + NUM_EXTRALINES)}
+#define VPFE_WIN_SVGA 	{0,0,(800 + NUM_EXTRAPIXELS),(600 + NUM_EXTRALINES)}
+#define VPFE_WIN_XGA	{0,0,(1024+ NUM_EXTRAPIXELS),(768 + NUM_EXTRALINES)}
+#define VPFE_WIN_480p	{0,0,(720 + NUM_EXTRAPIXELS),(480 + NUM_EXTRALINES)}
+#define VPFE_WIN_576p	{0,0,(720 + NUM_EXTRAPIXELS),(576 + NUM_EXTRALINES)}
+#define VPFE_WIN_720p 	{0,0,(1280+ NUM_EXTRAPIXELS),(720 + NUM_EXTRALINES)}
+#define VPFE_WIN_1080p 	{0,0,(1920),(1080)}
+
+/* enum for No of lines in Black Clamping */
+enum sample_line {
+	_1LINES = 0,
+	_2LINES,
+	_4LINES,
+	_8LINES,
+	_16LINES
+};
+
+enum hw_frame {
+	CCDC_RAW,
+	CCDC_YCBCR
+};
+
+/* enum for Alaw gama width */
+enum gama_width {
+	BITS_13_4 = 0,
+	BITS_12_3,
+	BITS_11_2,
+	BITS_10_1,
+	BITS_09_0
+};
+
+enum ccdc_datasft {
+	NO_SHIFT = 0,
+	_1BIT,
+	_2BIT,
+	_3BIT,
+	_4BIT,
+	_5BIT,
+	_6BIT
+};
+
+enum data_size {
+	_16BITS = 0,
+	_15BITS,
+	_14BITS,
+	_13BITS,
+	_12BITS,
+	_11BITS,
+	_10BITS,
+	_8BITS
+};
+enum ccdc_mfilt1 {
+	NO_MEDIAN_FILTER1 = 0,
+	AVERAGE_FILTER1,
+	MEDIAN_FILTER1
+};
+
+enum ccdc_mfilt2 {
+	NO_MEDIAN_FILTER2 = 0,
+	AVERAGE_FILTER2,
+	MEDIAN_FILTER2
+};
+
+typedef struct v4l2_rect ccdc_imgwin;
+
+/* structure for ALaw */
+struct a_law {
+	unsigned char b_alaw_enable;	/* Enable/disable A-Law */
+	enum gama_width gama_wd;	/*Gama Width Input */
+};
+
+/* structure for Black Clamping */
+struct black_clamp {
+	unsigned char b_clamp_enable;
+	enum sample_length sample_pixel; /* only if bClampEnable is TRUE */
+	enum sample_line sample_ln;	/* only if bClampEnable is TRUE */
+	unsigned short start_pixel;	/* only if bClampEnable is TRUE */
+	unsigned short sgain;	/* only if bClampEnable is TRUE */
+	unsigned short dc_sub;	/* only if bClampEnable is FALSE */
+};
+
+/* structure for Black Level Compensation */
+struct black_compensation {
+	unsigned char r_comp; /* Constant value to subtract from Red component */
+	unsigned char gr_comp;/* Constant value to subtract from Gr component */
+	unsigned char b_comp; /* Constant value to subtract from Blue component */
+	unsigned char gb_comp;/* Constant value to subtract from Gb component */
+};
+
+/*structures for lens shading correction*/
+
+/*gain factor modes*/
+typedef enum GfMode {
+	u8q8_interpol = 0,
+	u16q14_interpol,
+	reserved,
+	u16q14
+} GfMode;
+
+typedef enum gf_table_sel {
+	table1 = 0,
+	table2,
+	table3
+} gf_table_sel;
+
+/*LSC configuration structure*/
+typedef struct LscCfg {
+	GfMode gfmode;
+	int gf_table_scaling_fact;
+	int gf_table_interval;
+	gf_table_sel epel;
+	gf_table_sel opel;
+	gf_table_sel epol;
+	gf_table_sel opol;
+} LscCfg;
+
+typedef struct float_ccdc {
+	unsigned int int_no;
+	unsigned int frac_no;
+} float_ccdc;
+
+/*Main structure for lens shading correction*/
+struct lens_shading_corr {
+	unsigned char lsc_enable;
+	LscCfg lsc_config;
+	unsigned int lens_center_horz;
+	unsigned int lens_center_vert;
+	float_ccdc horz_left_coef;
+	float_ccdc horz_right_coef;
+	float_ccdc ver_low_coef;
+	float_ccdc ver_up_coef;
+	float_ccdc gf_table1[256];	/*int_no will be always 0 since it is u8q8 */
+	float_ccdc gf_table2[128];
+	float_ccdc gf_table3[128];
+};
+
+/*structure for color space converter*/
+struct color_space_converter {
+	unsigned char csc_enable;
+	int csc_dec_coeff[16];
+	int csc_frac_coeff[16];
+};
+
+/*supporting structures for data formatter*/
+
+typedef enum FmtMode {
+	split = 0,
+	combine,
+	line_alt_mode
+} FmtMode;
+
+typedef enum LNum {
+	_1line = 0,
+	_2lines,
+	_3lines,
+	_4lines
+} LNum;
+
+typedef enum Line {
+	_1stline = 0,
+	_2ndline,
+	_3rdline,
+	_4thline
+} Line;
+
+typedef struct FmtpLen {
+	unsigned int plen0;
+	unsigned int plen1;
+	unsigned int plen2;
+	unsigned int plen3;
+} FmtpLen_s;
+
+typedef struct FmtCfg {
+	FmtMode fmtmode;
+	LNum lnum;
+	unsigned int addrinc;
+} FmtCfg_s;
+
+typedef struct FmtAddr_Ptr {
+	unsigned int init;
+	Line line;
+} fmtaddr_ptr_s;
+
+typedef struct FmtPgm_AP {
+	unsigned int pgm_aptr;
+	unsigned char pgmupdt;
+} fmtpgm_ap_s;
+
+/*Main Structure for data formatter*/
+struct data_formatter {
+	unsigned char fmt_enable;
+	FmtCfg_s fmtcfg;
+	FmtpLen_s fmtplen;
+	unsigned int fmtsph;
+	unsigned int fmtlnh;
+	unsigned int fmtslv;
+	unsigned int fmtlnv;
+	unsigned int fmtrlen;
+	unsigned int fmthcnt;
+	fmtaddr_ptr_s fmtaddr_ptr[8];
+	unsigned char pgm_en[32];
+	fmtpgm_ap_s fmtpgm_ap[32];
+};
+
+/*Structures for Vertical Defect Correction*/
+typedef enum VdfCsl {
+	normal = 0,
+	horz_interpol_sat,
+	horz_interpol
+} VdfCsl;
+
+typedef enum VdfCuda {
+	whole_line_correct = 0,
+	upper_disable
+} VdfCuda;
+
+typedef enum DfcMwr {
+	write_complete = 0,
+	write_reg
+} DfcMwr;
+
+typedef enum DfcMrd {
+	read_complete = 0,
+	read_reg
+} DfcMrd;
+
+typedef enum DfcMaRst {
+	incr_addr = 0,
+	clr_addr
+} DfcMaRst;
+
+typedef enum DfcmClr {
+	clear_complete = 0,
+	clear
+} DfcmClr;
+
+struct dft_corr_ctl_s {
+	VdfCsl vdfcsl;
+	VdfCuda vdfcuda;
+	unsigned int vdflsft;
+};
+
+struct dft_corr_mem_ctl_s {
+	DfcMwr dfcmwr;
+	DfcMrd dfcmrd;
+	DfcMaRst dfcmarst;
+	DfcmClr dfcmclr;
+};
+
+/*Main Structure for vertical defect correction*/
+/*Vertical defect correction can correct upto 16 defects*/
+/*if defects less than 16 then pad the rest with 0*/
+struct vertical_dft_s {
+	unsigned char ver_dft_en;
+	unsigned char gen_dft_en;
+	unsigned int saturation_ctl;
+	struct dft_corr_ctl_s dft_corr_ctl;
+	struct dft_corr_mem_ctl_s dft_corr_mem_ctl;
+	unsigned int dft_corr_horz[16];
+	unsigned int dft_corr_vert[16];
+	unsigned int dft_corr_sub1[16];
+	unsigned int dft_corr_sub2[16];
+	unsigned int dft_corr_sub3[16];
+};
+
+struct data_offset {
+	unsigned char horz_offset;
+	unsigned char vert_offset;
+};
+
+/* Structure for CCDC configuration parameters for raw capture mode passed
+ * by application
+ */
+typedef struct ccdc_config_params_raw {
+	ccdc_pixfmt pix_fmt;	/* pixel format */
+	ccdc_frmfmt frm_fmt;	/* progressive or interlaced frame */
+	ccdc_imgwin win;	/* video window */
+	ccdc_pinpol fid_pol;	/* field id polarity */
+	ccdc_pinpol vd_pol;	/* vertical sync polarity */
+	ccdc_pinpol hd_pol;	/* horizontal sync polarity */
+	ccdc_buftype buf_type;	/* interleaved or separated fields */
+
+	enum ccdc_datasft datasft;	/*data shift to be applied before storing */
+	enum ccdc_mfilt1 mfilt1;	/*median filter for sdram */
+	enum ccdc_mfilt2 mfilt2;	/*median filter for ipipe */
+	unsigned char lpf_enable;	/*low pass filter enable/disable */
+	unsigned char horz_flip_enable;
+	unsigned int ccdc_offset;	/*offset value to be applied to data */
+	/*Range is 0 to 1023 */
+	int med_filt_thres;	/*Threshold of median filter */
+	unsigned char image_invert_enable;	/* enable to store the image in inverse
+					   order in memory(bottom to top) */
+	enum data_size data_sz;	/* data size value from 8 to 16 bits */
+	struct data_offset data_offset_s;	/*horz and vertical data offset */
+	struct a_law alaw;	/* Structure for Optional A-Law */
+	struct black_clamp blk_clamp;	/* Structure for Optical Black Clamp */
+	struct black_compensation blk_comp;	/* Structure for
+						   Black Compensation */
+	struct vertical_dft_s vertical_dft;	/*struture for vertical Defect Correction
+						   Module Configuration */
+	struct lens_shading_corr lens_sh_corr;	/*structure for lens shading Correction
+						   Module Configuration */
+	struct data_formatter data_formatter_r;	/*structure for data formatter
+						   Module Configuration */
+	struct color_space_converter color_space_con;	/*structure for color space converter
+							   Module Configuration */
+} ccdc_config_params_raw;
+
+#define VPFE_CMD_CONFIG_CCDC_YCBCR \
+			_IOW('V',BASE_VIDIOC_PRIVATE + 1,ccdc_params_ycbcr)
+#define VPFE_CMD_CONFIG_CCDC_RAW \
+			_IOW('V',BASE_VIDIOC_PRIVATE + 4,ccdc_config_params_raw)
+
+#ifdef __KERNEL__
+
+/* Structure for CCDC configuration parameters for raw capture mode */
+typedef struct ccdc_params_raw {
+
+	ccdc_pixfmt pix_fmt;	/* pixel format */
+	ccdc_frmfmt frm_fmt;	/* progressive or interlaced frame */
+	ccdc_imgwin win;	/* video window */
+	ccdc_pinpol fid_pol;	/* field id polarity */
+	ccdc_pinpol vd_pol;	/* vertical sync polarity */
+	ccdc_pinpol hd_pol;	/* horizontal sync polarity */
+	ccdc_buftype buf_type;	/* interleaved or separated fields */
+
+	enum ccdc_datasft datasft;	/*data shift to be applied before storing */
+	enum ccdc_mfilt1 mfilt1;	/*median filter for sdram */
+	enum ccdc_mfilt2 mfilt2;	/*median filter for ipipe */
+	bool lpf_enable;	/*low pass filter enable/disable */
+	bool horz_flip_enable;
+	unsigned int ccdc_offset;	/*offset value to be applied to data */
+	/*Range is 0 to 1023 */
+	int med_filt_thres;	/*Threshold of median filter */
+	bool image_invert_enable;	/* enable to store the image in inverse
+					   order in memory(bottom to top) */
+	enum data_size data_sz;	/* data size value from 8 to 16 bits */
+	struct a_law alaw;	/* Structure for Optional A-Law */
+	struct data_offset data_offset_s;	/*horz and vertical data offset */
+	struct black_clamp blk_clamp;	/* Structure for Optical Black Clamp */
+	struct black_compensation blk_comp;	/* Structure for
+						   Black Compensation */
+	struct vertical_dft_s vertical_dft;	/*struture for vertical Defect Correction
+						   Module Configuration */
+	struct lens_shading_corr lens_sh_corr;	/*structure for lens shading Correction
+						   Module Configuration */
+	struct data_formatter data_formatter_r;	/*structure for data formatter
+						   Module Configuration */
+	struct color_space_converter color_space_con;	/*structure for color space converter
+							   Module Configuration */
+
+} ccdc_params_raw;
+
+typedef struct ccdc_params_ycbcr {
+	ccdc_pixfmt pix_fmt;	/* pixel format */
+	ccdc_frmfmt frm_fmt;	/* progressive or interlaced frame */
+	ccdc_imgwin win;	/* video window */
+	ccdc_pinpol fid_pol;	/* field id polarity */
+	ccdc_pinpol vd_pol;	/* vertical sync polarity */
+	ccdc_pinpol hd_pol;	/* horizontal sync polarity */
+	int bt656_enable;	/* enable BT.656 embedded sync mode */
+	ccdc_pixorder pix_order;	/* cb:y:cr:y or y:cb:y:cr in memory */
+	ccdc_buftype buf_type;	/* interleaved or separated fields  */
+
+} ccdc_params_ycbcr;
+
+extern ccdc_params_raw ccdc_hw_params_raw;
+extern ccdc_params_ycbcr ccdc_hw_params_ycbcr;
+
+static inline enum data_size ccdc_raw_data_size(void)
+{
+	return ccdc_hw_params_raw.data_sz;
+}
+
+static inline bool ccdc_alaw_enable(void)
+{
+	return ccdc_hw_params_raw.alaw.b_alaw_enable;
+}
+
+static inline void ccdc_set_frame_format(enum hw_frame frame_type,
+					 ccdc_frmfmt frame_format)
+{
+	if (frame_type == CCDC_YCBCR)
+		ccdc_hw_params_ycbcr.frm_fmt = frame_format;
+	else
+		ccdc_hw_params_raw.frm_fmt = frame_format;
+}
+
+static inline ccdc_frmfmt ccdc_get_frame_format(enum hw_frame frame_type)
+{
+	if (frame_type == CCDC_YCBCR)
+		return ccdc_hw_params_ycbcr.frm_fmt;
+	else
+		return ccdc_hw_params_raw.frm_fmt;
+}
+
+static inline void ccdc_set_buf_type(enum hw_frame frame_type,
+				     ccdc_buftype buf_type)
+{
+	if (frame_type == CCDC_YCBCR)
+		ccdc_hw_params_ycbcr.buf_type = buf_type;
+	else
+		ccdc_hw_params_raw.buf_type = buf_type;
+}
+
+static inline ccdc_buftype ccdc_get_buf_type(enum hw_frame frame_type)
+{
+	if (frame_type == CCDC_YCBCR)
+		return ccdc_hw_params_ycbcr.buf_type;
+	else
+		return ccdc_hw_params_raw.buf_type;
+}
+
+static inline void ccdc_get_image_window(enum hw_frame frame_type,
+					 ccdc_imgwin * win)
+{
+	if (frame_type == CCDC_YCBCR)
+		*win = ccdc_hw_params_ycbcr.win;
+	else
+		*win = ccdc_hw_params_raw.win;
+}
+
+static inline void ccdc_set_image_window(enum hw_frame frame_type,
+					 ccdc_imgwin win)
+{
+	if (frame_type == CCDC_YCBCR)
+		ccdc_hw_params_ycbcr.win = win;
+	else
+		ccdc_hw_params_raw.win = win;
+}
+
+static inline void ccdc_set_pix_order(ccdc_pixorder order)
+{
+	ccdc_hw_params_ycbcr.pix_order = order;
+}
+static inline ccdc_pixorder ccdc_get_pix_order(void)
+{
+	return ccdc_hw_params_ycbcr.pix_order;
+}
+
+/**************************************************************************\
+* Register OFFSET Definitions
+\**************************************************************************/
+#define SYNCEN				0x00
+#define MODESET				0x04
+#define HDWIDTH				0x08
+#define VDWIDTH				0x0c
+#define PPLN				0x10
+#define LPFR				0x14
+#define SPH				0x18
+#define NPH				0x1c
+#define SLV0				0x20
+#define SLV1				0x24
+#define NLV				0x28
+#define CULH				0x2c
+#define CULV				0x30
+#define HSIZE				0x34
+#define SDOFST				0x38
+#define STADRH				0x3c
+#define STADRL				0x40
+#define CLAMP				0x44
+#define DCSUB				0x48
+#define COLPTN				0x4c
+#define BLKCMP0				0x50
+#define BLKCMP1				0x54
+#define MEDFILT				0x58
+#define RYEGAIN				0x5c
+#define GRCYGAIN			0x60
+#define GBGGAIN				0x64
+#define BMGGAIN				0x68
+#define OFFSET				0x6c
+#define OUTCLIP				0x70
+#define VDINT0				0x74
+#define VDINT1				0x78
+#define RSV0				0x7c
+#define GAMMAWD				0x80
+#define REC656IF			0x84
+#define CCDCFG				0x88
+#define FMTCFG				0x8c
+#define FMTPLEN				0x90
+#define FMTSPH				0x94
+#define FMTLNH				0x98
+#define FMTSLV				0x9c
+#define FMTLNV				0xa0
+#define FMTRLEN				0xa4
+#define FMTHCNT				0xa8
+#define FMT_ADDR_PTR_B			0xac
+#define FMT_ADDR_PTR(i)			(FMT_ADDR_PTR_B + (i*4))
+#define FMTPGM_VF0			0xcc
+#define FMTPGM_VF1			0xd0
+#define FMTPGM_AP0			0xd4
+#define FMTPGM_AP1			0xd8
+#define FMTPGM_AP2			0xdc
+#define FMTPGM_AP3                      0xe0
+#define FMTPGM_AP4                      0xe4
+#define FMTPGM_AP5                      0xe8
+#define FMTPGM_AP6                      0xec
+#define FMTPGM_AP7                      0xf0
+#define LSCCFG1                         0xf4
+#define LSCCFG2                         0xf8
+#define LSCH0                           0xfc
+#define LSCV0                           0x100
+#define LSCKH                           0x104
+#define LSCKV                           0x108
+#define LSCMEMCTL                       0x10c
+#define LSCMEMD                         0x110
+#define LSCMEMQ                         0x114
+#define DFCCTL                          0x118
+#define DFCVSAT                         0x11c
+#define DFCMEMCTL                       0x120
+#define DFCMEM0                         0x124
+#define DFCMEM1                         0x128
+#define DFCMEM2                         0x12c
+#define DFCMEM3                         0x130
+#define DFCMEM4                         0x134
+#define CSCCTL                          0x138
+#define CSCM0                           0x13c
+#define CSCM1                           0x140
+#define CSCM2                           0x144
+#define CSCM3                           0x148
+#define CSCM4                           0x14c
+#define CSCM5                           0x150
+#define CSCM6                           0x154
+#define CSCM7                           0x158
+#define DATAOFST			0x15c
+
+#define CCDC_IOBASE_VADDR               IO_ADDRESS(0x01c70600)
+
+#define regw(val, reg)    		outl(val, (reg)+CCDC_IOBASE_VADDR)
+#define regr(reg)         		inl((reg)+CCDC_IOBASE_VADDR)
+
+#define VPSS_BL_IOBASE_VADDR		IO_ADDRESS(0x01c70000)
+#define regw_bl(val, reg)    		outl(val, (reg)+VPSS_BL_IOBASE_VADDR)
+#define regr_bl(reg)         		inl((reg)+VPSS_BL_IOBASE_VADDR)
+
+#define VPSS_VPSSCLK_BASE		IO_ADDRESS(0x01c70000)
+#define regw_clk(val, reg)		outl(val, (reg)+VPSS_VPSSCLK_BASE)
+#define regr_clk(reg)                   inl((reg)+VPSS_VPSSCLK_BASE)
+
+#define CLKCTRL				(0x04)
+
+#define INTSTAT				(0x80C)
+#define INTSEL				(0x810)
+#define	EVTSEL				(0x814)
+#define MEMCTRL				(0x818)
+#define CCDCMUX				(0x81C)
+
+/**************************************************************
+*	Define for various register bit mask and shifts for CCDC
+*
+**************************************************************/
+#define CCDC_RAW_IP_MODE			(0x00)
+#define CCDC_VDHDOUT_INPUT			(0x00)
+#define CCDC_YCINSWP_RAW			(0x00 << 4)
+#define CCDC_EXWEN_DISABLE 			(0x00)
+#define CCDC_DATAPOL_NORMAL			(0x00)
+#define CCDC_CCDCFG_FIDMD_LATCH_VSYNC		(0x00)
+#define CCDC_CCDCFG_WENLOG_AND			(0x00)
+#define CCDC_CCDCFG_TRGSEL_WEN                  (0x00)
+#define CCDC_CCDCFG_EXTRG_DISABLE               (0x00)
+#define CCDC_CFA_MOSAIC				(0x00)
+
+#define CCDC_VDC_DFCVSAT_MASK			(0x3fff)
+#define CCDC_DATAOFST_MASK			(0x0ff)
+#define CCDC_DATAOFST_H_SHIFT			(0)
+#define CCDC_DATAOFST_V_SHIFT			(8)
+#define CCDC_GAMMAWD_CFA_MASK			(0x01)
+#define CCDC_GAMMAWD_CFA_SHIFT			(5)
+#define CCDC_FID_POL_MASK			(0x01)
+#define CCDC_FID_POL_SHIFT			(4)
+#define CCDC_HD_POL_MASK			(0x01)
+#define CCDC_HD_POL_SHIFT			(3)
+#define CCDC_VD_POL_MASK			(0x01)
+#define CCDC_VD_POL_SHIFT			(2)
+#define CCDC_FRM_FMT_MASK			(0x01)
+#define CCDC_FRM_FMT_SHIFT			(7  )
+#define CCDC_DATA_SZ_MASK			(0x07)
+#define CCDC_DATA_SZ_SHIFT			(8)
+#define CCDC_VDHDOUT_MASK                       (0x01)
+#define CCDC_VDHDOUT_SHIFT                      (0)
+#define CCDC_EXWEN_MASK				(0x01)
+#define CCDC_EXWEN_SHIFT			(5)
+#define CCDC_RAW_INPUT_MASK                     (0x03)
+#define CCDC_RAW_INPUT_SHIFT                    (12)
+#define CCDC_PIX_FMT_MASK			(0x03)
+#define CCDC_PIX_FMT_SHIFT			(12)
+#define CCDC_DATAPOL_MASK			(0x01)
+#define CCDC_DATAPOL_SHIFT			(6)
+#define CCDC_WEN_ENABLE				(0x01 << 1)
+#define CCDC_VDHDEN_ENABLE			(0x01 << 16)
+#define CCDC_LPF_ENABLE				(0x01 << 14)
+#define CCDC_ALAW_ENABLE			(0x01)
+#define CCDC_ALAW_GAMA_WD_MASK			(0x07)
+
+#define CCDC_FMTCFG_FMTMODE_MASK 		(0x03)
+#define CCDC_FMTCFG_FMTMODE_SHIFT		(1)
+#define CCDC_FMTCFG_LNUM_MASK			(0x03)
+#define CCDC_FMTCFG_LNUM_SHIFT			(4)
+#define CCDC_FMTCFG_ADDRINC_MASK		(0x07)
+#define CCDC_FMTCFG_ADDRINC_SHIFT		(8)
+
+#define CCDC_CCDCFG_FIDMD_SHIFT			(6)
+#define	CCDC_CCDCFG_WENLOG_SHIFT		(8)
+#define CCDC_CCDCFG_TRGSEL_SHIFT                (9)
+#define CCDC_CCDCFG_EXTRG_SHIFT                 (10)
+#define CCDC_CCDCFG_MSBINVI_SHIFT               (13)
+
+#define CCDC_HSIZE_FLIP_SHIFT			(12)
+#define CCDC_HSIZE_FLIP_MASK			(0x01)
+
+#define START_PX_HOR_MASK			(0x7FFF)
+#define NUM_PX_HOR_MASK				(0x7FFF)
+#define START_VER_ONE_MASK			(0x7FFF)
+#define START_VER_TWO_MASK			(0x7FFF)
+#define NUM_LINES_VER				(0x7FFF)
+
+#define CCDC_BLK_CLAMP_ENABLE			(0x01 << 15)
+#define CCDC_BLK_SGAIN_MASK			(0x1F )
+#define CCDC_BLK_ST_PXL_MASK			(0x1FFF)
+#define CCDC_BLK_SAMPLE_LN_MASK			(0x03)
+#define CCDC_BLK_SAMPLE_LN_SHIFT		(13)
+
+#define CCDC_NUM_LINE_CALC_MASK			(0x03)
+#define CCDC_NUM_LINE_CALC_SHIFT		(14)
+
+#define CCDC_BLK_DC_SUB_MASK			(0x03FFF)
+#define CCDC_BLK_COMP_MASK			(0x000000FF)
+#define CCDC_BLK_COMP_GB_COMP_SHIFT		(8)
+#define CCDC_BLK_COMP_GR_COMP_SHIFT		(0)
+#define CCDC_BLK_COMP_R_COMP_SHIFT		(8)
+#define CCDC_LATCH_ON_VSYNC_DISABLE		(0x01 << 15)
+#define CCDC_LATCH_ON_VSYNC_ENABLE		(0x00 << 15)
+#define CCDC_FPC_ENABLE				(0x01 << 15)
+#define CCDC_FPC_FPC_NUM_MASK 			(0x7FFF)
+#define CCDC_DATA_PACK_ENABLE			(0x01<<11)
+#define CCDC_FMT_HORZ_FMTLNH_MASK		(0x1FFF)
+#define CCDC_FMT_HORZ_FMTSPH_MASK		(0x1FFF)
+#define CCDC_FMT_HORZ_FMTSPH_SHIFT		(16 )
+#define CCDC_FMT_VERT_FMTLNV_MASK		(0x1FFF)
+#define CCDC_FMT_VERT_FMTSLV_MASK		(0x1FFF)
+#define CCDC_FMT_VERT_FMTSLV_SHIFT		(16 )
+#define CCDC_VP_OUT_VERT_NUM_MASK		(0x3FFF)
+#define CCDC_VP_OUT_VERT_NUM_SHIFT		(17)
+#define CCDC_VP_OUT_HORZ_NUM_MASK		(0x1FFF)
+#define CCDC_VP_OUT_HORZ_NUM_SHIFT		(4)
+#define CCDC_VP_OUT_HORZ_ST_MASK		(0x000F)
+
+#define CCDC_CSC_COEFF_SHIFT			(8)
+#define CCDC_CSC_COEFF_DEC_MASK			(0x0007)
+#define CCDC_CSC_COEFF_FRAC_MASK		(0x001F)
+#define CCDC_CSC_DEC_SHIFT			(5)
+#define CCDC_CSC_ENABLE                         (0x01)
+#define CCDC_MFILT1_SHIFT			(10)
+#define CCDC_MFILT2_SHIFT			(8)
+#define CCDC_LPF_MASK				(0x01)
+#define CCDC_LPF_SHIFT				(14)
+#define CCDC_OFFSET_MASK			(0x3FF)
+#define CCDC_DATASFT_MASK			(0x07)
+#define CCDC_DATASFT_SHIFT			(8)
+#define CCDC_DF_ENABLE				(0x01)
+
+#define CCDC_FMTPLEN_P0_MASK			(0x000F)
+#define CCDC_FMTPLEN_P1_MASK			(0x000F)
+#define CCDC_FMTPLEN_P2_MASK			(0x0007)
+#define CCDC_FMTPLEN_P3_MASK			(0x0007)
+#define CCDC_FMTPLEN_P0_SHIFT			(0)
+#define CCDC_FMTPLEN_P1_SHIFT			(4)
+#define CCDC_FMTPLEN_P2_SHIFT			(8)
+#define CCDC_FMTPLEN_P3_SHIFT			(12)
+
+#define CCDC_FMTSPH_MASK			(0x01FFF)
+#define CCDC_FMTLNH_MASK                        (0x01FFF)
+#define CCDC_FMTSLV_MASK                        (0x01FFF)
+#define CCDC_FMTLNV_MASK                        (0x07FFF)
+#define CCDC_FMTRLEN_MASK                       (0x01FFF)
+#define CCDC_FMTHCNT_MASK                       (0x01FFF)
+
+#define CCDC_ADP_INIT_MASK			(0x01FFF)
+#define CCDC_ADP_LINE_SHIFT			(13)
+#define CCDC_ADP_LINE_MASK			(0x0003)
+#define CCDC_FMTPGN_APTR_MASK			(0x0007)
+
+#define CCDC_DFCCTL_GDFCEN_MASK			(0x01)
+#define CCDC_DFCCTL_VDFCEN_MASK			(0x01)
+#define CCDC_DFCCTL_VDFCEN_SHIFT		(4)
+#define CCDC_DFCCTL_VDFCSL_MASK			(0x03)
+#define CCDC_DFCCTL_VDFCSL_SHIFT		(5)
+#define CCDC_DFCCTL_VDFCUDA_MASK		(0x01)
+#define CCDC_DFCCTL_VDFCUDA_SHIFT		(7)
+#define CCDC_DFCCTL_VDFLSFT_MASK                (0x03)
+#define CCDC_DFCCTL_VDFLSFT_SHIFT               (8)
+#define CCDC_DFCMEMCTL_DFCMARST_MASK		(0x01)
+#define CCDC_DFCMEMCTL_DFCMARST_SHIFT		(2)
+#define CCDC_DFCMEMCTL_DFCMWR_MASK		(0x01)
+#define CCDC_DFCMEMCTL_DFCMWR_SHIFT		(0)
+
+#define CCDC_LSCCFG_GFTSF_MASK			(0x07)
+#define CCDC_LSCCFG_GFTSF_SHIFT			(1)
+#define CCDC_LSCCFG_GFTINV_MASK                 (0x0f)
+#define CCDC_LSCCFG_GFTINV_SHIFT                (4)
+#define CCDC_LSC_GFTABLE_SEL_MASK		(0x03)
+#define CCDC_LSC_GFTABLE_EPEL_SHIFT		(8)
+#define CCDC_LSC_GFTABLE_OPEL_SHIFT		(10)
+#define CCDC_LSC_GFTABLE_EPOL_SHIFT		(12)
+#define CCDC_LSC_GFTABLE_OPOL_SHIFT		(14)
+#define CCDC_LSC_GFMODE_MASK			(0x03)
+#define CCDC_LSC_GFMODE_SHIFT			(4)
+#define CCDC_LSC_DISABLE			(0)
+#define CCDC_LSC_ENABLE				(1)
+#define CCDC_LSC_TABLE1_SLC			(0)
+#define CCDC_LSC_TABLE2_SLC			(1)
+#define CCDC_LSC_TABLE3_SLC			(2)
+#define CCDC_LSC_MEMADDR_RESET			(1<<2)
+#define CCDC_LSC_MEMADDR_INCR                   (0<<2)
+#define CCDC_LSC_FRAC_MASK_T1			(0xFF)
+#define CCDC_LSC_INT_MASK			(0x03)
+#define CCDC_LSC_FRAC_MASK                      (0x3FFF)
+#define CCDC_LSC_CENTRE_MASK			(0x3FFF)
+#define CCDC_LSC_COEF_MASK			(0x0ff)
+#define  CCDC_LSC_COEFL_SHIFT			(0)
+#define CCDC_LSC_COEFU_SHIFT			(8)
+
+extern void ccdc_reset(void);
+extern void ccdc_init(void);
+extern void ccdc_cleanup(void);
+extern void ccdc_setwin(ccdc_imgwin * image_win, ccdc_frmfmt frm_fmt, int ppc);
+void ccdc_config_raw(void);
+void ccdc_config_ycbcr(void);
+int validate_ccdc_param(ccdc_config_params_raw * ccdcparam);
+int ccdc_update_ycbcr_params(void *);
+int ccdc_update_raw_params(void *);
+static inline void ccdc_enable_vport(void)
+{
+	/* Do nothing for DM355 */
+}
+
+static inline int ccdc_sbl_reset(void)
+{
+	return 0;
+}
+
+/* inline functions that must be fast because they are called frequently */
+static inline void ccdc_enable(int flag)
+{
+	if (flag)
+		flag = 3;
+	else
+		flag = 0;
+	regw(flag, SYNCEN);
+}
+
+/*
+static inline void sdramop_enable(int flag){
+        unsigned int temp;
+	temp = regr(SYNCEN);
+	temp |= (flag & 0x01)<<1;
+	regw(temp, SYNCEN);
+}
+*/
+static inline void ccdc_setfbaddr(unsigned long paddr)
+{
+	regw((paddr >> 21) & 0x007f, STADRH);
+	regw((paddr >> 5) & 0x0ffff, STADRL);
+}
+
+static inline int ccdc_getfid(void)
+{
+	int fid = (regr(MODESET) >> 15) & 0x1;
+	return fid;
+}
+
+/*
+static inline int ccdc_sbl_reset(void)
+{
+	int sb_reset;
+	sb_reset = regr_sb(4);
+	regw_sb((sb_reset & 0xFF7FFFFF), 4);
+	return sb_reset;
+}*/
+
+#endif
+
+#endif				/* CCDC_DM355_H */
Index: linux-2.6.18/include/media/davinci/mt9t001.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/mt9t001.h
@@ -0,0 +1,276 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*mt9t001.h*/
+
+#ifndef	MT9T001_H
+#define	MT9T001_H
+
+/*********************************
+ * Defines and Macros and globals
+ ********************************/
+
+#ifdef	TRUE
+#undef	TRUE
+#endif
+
+#ifdef	FALSE
+#undef	FALSE
+#endif
+
+#define	TRUE 	1
+#define	FALSE	0
+
+#ifdef DEBUG
+#undef DEBUG
+#endif
+
+#define DEBUG
+
+#ifdef __KERNEL__
+
+extern int mt9t001_ctrl(unsigned int cmd, void *arg, void *params);
+
+/* defines for extra pixels/line added */
+#define MT9T001_EXTRAPIXELS 16
+#define MT9T001_EXTRALINES	  8
+
+/* Definitions to access the various sensor registers */
+#define MT9T001_CHIP_VERSION			(0x00)
+#define MT9T001_ROW_START			(0x01)
+#define MT9T001_COL_START			(0x02)
+#define MT9T001_HEIGHT				(0x03)
+#define MT9T001_WIDTH				(0x04)
+#define MT9T001_HBLANK				(0x05)
+#define MT9T001_VBLANK				(0x06)
+#define MT9T001_OUTPUT_CTRL			(0x07)
+#define MT9T001_SHUTTER_WIDTH_UPPER		(0x08)
+#define MT9T001_SHUTTER_WIDTH			(0x09)
+#define MT9T001_PIXEL_CLK_CTRL			(0x0A)
+#define MT9T001_RESTART				(0x0B)
+#define MT9T001_SHUTTER_DELAY			(0x0C)
+#define MT9T001_RESET				(0x0D)
+#define MT9T001_READ_MODE1			(0x1E)
+#define MT9T001_READ_MODE2			(0x20)
+#define MT9T001_READ_MODE3			(0x21)
+#define MT9T001_ROW_ADDR_MODE			(0x22)
+#define MT9T001_COL_ADDR_MODE			(0x23)
+#define MT9T001_RESERVED_27_REG                 (0x27)
+#define MT9T001_GREEN1_GAIN			(0x2B)
+#define MT9T001_BLUE_GAIN			(0x2C)
+#define MT9T001_RED_GAIN			(0x2D)
+#define MT9T001_GREEN2_GAIN			(0x2E)
+#define MT9T001_GLOBAL_GAIN			(0x35)
+#define MT9T001_BLACK_LEVEL			(0x49)
+#define MT9T001_ROW_BLK_DEF_OFFSET		(0x4B)
+#define MT9T001_RESERVED_4E_REG                 (0x4e)
+#define MT9T001_RESERVED_50_REG                 (0x50)
+#define MT9T001_RESERVED_51_REG                 (0x51)
+#define MT9T001_RESERVED_52_REG                 (0x52)
+#define MT9T001_RESERVED_53_REG                 (0x53)
+#define MT9T001_CAL_COARSE			(0x5D)
+#define MT9T001_CAL_TARGET			(0x5F)
+#define MT9T001_GREEN1_OFFSET			(0x60)
+#define MT9T001_GREEN2_OFFSET			(0x61)
+#define MT9T001_BLK_LVL_CALIB			(0x62)
+#define MT9T001_RED_OFFSET			(0x63)
+#define MT9T001_BLUE_OFFSET			(0x64)
+#define MT9T001_CHIP_ENABLE_SYNC		(0xF8)
+#define MT9T001_CHIP_VERSION_END		(0xFF)
+
+/* Define Shift and Mask for gain register*/
+
+#define	MT9T001_ANALOG_GAIN_SHIFT	(0x0000)
+#define	MT9T001_DIGITAL_GAIN_SHIFT	(8)
+#define	MT9T001_ANALOG_GAIN_MASK	(0x007F)
+#define	MT9T001_DIGITAL_GAIN_MASK	(0x7F00)
+
+/* Define Shift and Mask for black level caliberation register*/
+
+#define	MT9T001_MANUAL_OVERRIDE_MASK		(0x0001)
+#define	MT9T001_DISABLE_CALLIBERATION_SHIFT	(1)
+#define	MT9T001_DISABLE_CALLIBERATION_MASK	(0x0002)
+#define	MT9T001_RECAL_BLACK_LEVEL_SHIFT		(12)
+#define	MT9T001_RECAL_BLACK_LEVEL_MASK		(0x1000)
+#define	MT9T001_LOCK_RB_CALIBRATION_SHIFT	(13)
+#define	MT9T001_LOCK_RB_CALLIBERATION_MASK	(0x2000)
+#define	MT9T001_LOCK_GREEN_CALIBRATION_SHIFT	(14)
+#define	MT9T001_LOCK_GREEN_CALLIBERATION_MASK	(0x4000)
+#define	MT9T001_LOW_COARSE_THELD_MASK		(0x007F)
+#define	MT9T001_HIGH_COARSE_THELD_SHIFT		(8)
+#define	MT9T001_HIGH_COARSE_THELD_MASK		(0x7F00)
+#define	MT9T001_LOW_TARGET_THELD_MASK		(0x007F)
+#define	MT9T001_HIGH_TARGET_THELD_SHIFT		(8)
+#define	MT9T001_HIGH_TARGET_THELD_MASK		(0x7F00)
+#define	MT9T001_SHUTTER_WIDTH_LOWER_MASK	(0xFFFF)
+#define	MT9T001_SHUTTER_WIDTH_UPPER_SHIFT	(16)
+#define	MT9T001_SHUTTER_WIDTH_UPPER_MASK	(0xFFFF)
+#define	MT9T001_ROW_START_MASK			(0x07FF)
+#define	MT9T001_COL_START_MASK			(0x0FFF)
+#define	 MT9T001_GREEN1_OFFSET_MASK 		(0x01FF)
+#define	 MT9T001_GREEN2_OFFSET_MASK 		(0x01FF)
+#define	 MT9T001_RED_OFFSET_MASK 		(0x01FF)
+#define	 MT9T001_BLUE_OFFSET_MASK 		(0x01FF)
+
+/* defines for MT9T001 register values */
+#define	MT9T001_NORMAL_OPERATION_MODE		(0x0002)
+#define	MT9T001_HALT_MODE			(0x0003)
+#define MT9T001_RESET_ENABLE			(0x0001)
+#define MT9T001_RESET_DISABLE			(0x0000)
+#define	MT9T001_INVERT_PIXEL_CLK		(0x8000)
+#define MT9T001_GAIN_MINVAL			(0)
+#define MT9T001_GAIN_MAXVAL			(128)
+#define MT9T001_GAIN_STEP			(1)
+#define MT9T001_GAIN_DEFAULTVAL			(8)
+
+/* Default values for MT9T001 registers */
+#define MT9T001_ROW_START_DEFAULT		(0x14)
+#define MT9T001_COL_START_DEFAULT		(0x20)
+#define MT9T001_HEIGHT_DEFAULT			(0x5FF)
+#define MT9T001_WIDTH_DEFAULT			(0x7FF)
+#define MT9T001_HBLANK_DEFAULT			(0x8E)
+#define MT9T001_VBLANK_DEFAULT			(0x19)
+#define MT9T001_OUTPUT_CTRL_DEFAULT		(0x02)
+#define MT9T001_SHUTTER_WIDTH_UPPER_DEFAULT	(0x0)
+#define MT9T001_SHUTTER_WIDTH_DEFAULT		(0x619)
+#define MT9T001_PIXEL_CLK_CTRL_DEFAULT		(0x0)
+#define MT9T001_RESTART_DEFAULT			(0x0)
+#define MT9T001_SHUTTER_DELAY_DEFAULT		(0x0)
+#define MT9T001_READ_MODE1_DEFAULT		(0xC040)
+#define MT9T001_READ_MODE2_DEFAULT		(0x0)
+#define MT9T001_READ_MODE3_DEFAULT		(0x0)
+#define MT9T001_ROW_ADDR_MODE_DEFAULT		(0x0)
+#define MT9T001_COL_ADDR_MODE_DEFAULT		(0x0)
+#define MT9T001_GREEN1_GAIN_DEFAULT		(0x08)
+#define MT9T001_BLUE_GAIN_DEFAULT		(0x08)
+#define MT9T001_RED_GAIN_DEFAULT		(0x08)
+#define MT9T001_GREEN2_GAIN_DEFAULT		(0x08)
+#define MT9T001_GLOBAL_GAIN_DEFAULT		(0x08)
+#define MT9T001_BLACK_LEVEL_DEFAULT		(0xA8)
+#define MT9T001_CAL_COARSE_DEFAULT		(0x2D13)
+#define MT9T001_CAL_TARGET_DEFAULT		(0x231D)
+#define MT9T001_GREEN1_OFFSET_DEFAULT		(0x20)
+#define MT9T001_GREEN2_OFFSET_DEFAULT		(0x20)
+#define MT9T001_BLK_LVL_CALIB_DEFAULT		(0x0)
+#define MT9T001_RED_OFFSET_DEFAULT		(0x20)
+#define MT9T001_BLUE_OFFSET_DEFAULT		(0x20)
+#define MT9T001_CHIP_ENABLE_SYNC_DEFAULT	(0x01)
+
+#define MT9T001_I2C_REGISTERED			(1)
+#define MT9T001_I2C_UNREGISTERED		(0)
+
+/*	Defines for mt9t001_ctrl() functions command*/
+
+#define	MT9T001_SET_PARAMS	1
+#define	MT9T001_GET_PARAMS	2
+#define	MT9T001_SET_GAIN	3
+#define	MT9T001_SET_STD		4
+#define	MT9T001_INIT		5
+#define	MT9T001_CLEANUP		6
+#define MT9T001_ENABLE_I2C_SWITCH 7
+
+/* define for various video format supported by MT9T001 driver */
+/* Here all mode defines will be assigned values of v4l2 mode defines */
+#define	MT9T001_MODE_VGA_30FPS  	(10)
+#define	MT9T001_MODE_VGA_60FPS		(11)
+#define	MT9T001_MODE_SVGA_30FPS		(12)
+#define	MT9T001_MODE_SVGA_60FPS		(13)
+#define	MT9T001_MODE_XGA_30FPS		(14)
+#define	MT9T001_MODE_480p_30FPS		(15)
+#define	MT9T001_MODE_480p_60FPS		(16)
+#define	MT9T001_MODE_576p_25FPS		(17)
+#define	MT9T001_MODE_576p_50FPS		(18)
+#define	MT9T001_MODE_720p_24FPS		(19)
+#define	MT9T001_MODE_720p_30FPS		(20)
+#define	MT9T001_MODE_1080p_18FPS	(21)
+
+/*i2c adress for MT9T001*/
+#define MT9T001_I2C_ADDR  		(0xBA >>1)
+
+/*i2c adress for ECP*/
+#define ECP_I2C_ADDR  			(0x25)
+#define ECP_I2C_CONFIG			(2)
+#define ECP_REGADDR			(0x08)
+#define ECP_REGVAL			(0x80)
+#define ECP_RSTADDR			(0x02)
+
+/*i2c adress for PCA9543A*/
+#define PCA9543A_I2C_ADDR  		(0x73)
+#define PCA9543A_I2C_CONFIG		(0)
+#define PCA9543A_REGVAL			(0x01)
+
+#define MT9T001_I2C_CONFIG		(1)
+#define I2C_ONE_BYTE_TRANSFER		(1)
+#define I2C_TWO_BYTE_TRANSFER		(2)
+#define I2C_THREE_BYTE_TRANSFER		(3)
+#define I2C_TXRX_DATA_MASK		(0x00FF)
+#define I2C_TXRX_DATA_MASK_UPPER	(0xFF00)
+#define I2C_TXRX_DATA_SHIFT		(8)
+
+#endif				/* endif of __KERNEL__ */
+
+/* Structure containing video standard dependent settings */
+struct mt9t001_format_params {
+	unsigned short col_size;	/* width */
+	unsigned short row_size;	/* Height */
+	unsigned short h_blank;
+	unsigned short v_blank;
+	unsigned int shutter_width;
+	unsigned short row_addr_mode;
+	unsigned short col_addr_mode;
+	unsigned short black_level;
+	unsigned short pixel_clk_control;
+	unsigned short row_start;
+	unsigned short col_start;
+};
+
+/* Structure for gain settings */
+struct mt9t001_rgb_gain {
+	unsigned char green1_analog_gain;
+	unsigned char red_analog_gain;
+	unsigned char blue_analog_gain;
+	unsigned char green2_analog_gain;
+	unsigned char green1_digital_gain;
+	unsigned char red_digital_gain;
+	unsigned char blue_digital_gain;
+	unsigned char green2_digital_gain;
+};
+/* structure for black level calibration setttings*/
+struct mt9t001_black_level_calibration {
+	unsigned char manual_override;
+	unsigned char disable_calibration;
+	unsigned char recalculate_black_level;
+	unsigned char lock_red_blue_calibration;
+	unsigned char lock_green_calibration;
+	unsigned char low_coarse_thrld;
+	unsigned char high_coarse_thrld;
+	unsigned char low_target_thrld;
+	unsigned char high_target_thrld;
+	unsigned short green1_offset;
+	unsigned short green2_offset;
+	unsigned short red_offset;
+	unsigned short blue_offset;
+};
+
+/* structure for MT9T001 configuration setttings passed by application*/
+struct mt9t001_params {
+	struct mt9t001_format_params format;
+	struct mt9t001_rgb_gain rgb_gain;
+	struct mt9t001_black_level_calibration black_calib;
+};
+
+#endif				/*for  ifndef MT9T001 */
Index: linux-2.6.18/include/media/davinci/tvp5146.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/tvp5146.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* tvp5146.h file */
+
+#ifndef TVP5146_H
+#define TVP5146_H
+
+#ifdef TRUE
+#undef TRUE
+#endif
+#ifdef FALSE
+#undef FALSE
+#endif
+
+#define TRUE 1
+#define FALSE 0
+
+/* analog muxing mode */
+#define    TVP5146_AMUX_COMPOSITE  0
+#define    TVP5146_AMUX_SVIDEO     1
+
+typedef enum {
+	TVP5146_MODE_INV = -1,
+	TVP5146_MODE_AUTO = 0,	/* autoswitch mode (default)   */
+	TVP5146_MODE_NTSC = 1,	/* (M, J) NTSC      525-line   */
+	TVP5146_MODE_PAL = 2,	/* (B, D, G, H, I, N) PAL      */
+	TVP5146_MODE_PAL_M = 3,	/* (M) PAL          525-line   */
+	TVP5146_MODE_PAL_CN = 4,	/* (Combination-N) PAL         */
+	TVP5146_MODE_NTSC_443 = 5,	/* NTSC 4.43        525-line   */
+	TVP5146_MODE_SECAM = 6,	/* SECAM                       */
+	TVP5146_MODE_PAL_60 = 7,	/* PAL 60          525-line    */
+	TVP5146_MODE_AUTO_SQP = 8,	/* autoswitch mode (default)   */
+	TVP5146_MODE_NTSC_SQP = 9,	/* (M, J) NTSC      525-line   */
+	TVP5146_MODE_PAL_SQP = 0xA,	/* (B, D, G, H, I, N) PAL      */
+	TVP5146_MODE_PAL_M_SQP = 0xB,	/* (M) PAL          525-line   */
+	TVP5146_MODE_PAL_CN_SQP = 0xC,	/* (Combination-N) PAL         */
+	TVP5146_MODE_NTSC_443_SQP = 0xD,	/* NTSC 4.43 525-line   */
+	TVP5146_MODE_SECAM_SQP = 0xE,	/* SECAM                       */
+	TVP5146_MODE_PAL_60_SQP = 0xF,	/* PAL 60          525-line    */
+} tvp5146_mode;
+
+ /* Enum for TVP5146 output data width */
+typedef enum tvp5146_datawidth {
+	TVP5146_WIDTH_16BIT,
+	TVP5146_WIDTH_8BIT
+} tvp5146_datawidth_t;
+
+typedef struct {
+	tvp5146_mode mode;
+	int amuxmode;
+	int enablebt656sync;
+	tvp5146_datawidth_t data_width;
+} tvp5146_params;
+
+#ifdef __KERNEL__
+
+typedef struct {
+	int agc_enable;
+	tvp5146_mode video_std;
+	int brightness;
+	int contrast;
+	int saturation;
+	int hue;
+	int field_rate;		/* 50 or 60 in Hz */
+	int lost_lock;
+	int csubc_lock;
+	int v_lock;
+	int h_lock;
+} tvp5146_status;
+
+typedef unsigned int tvp5146_cmd;
+
+/* commands for setup the decoder */
+#define TVP5146_SET_AMUXMODE        4
+#define TVP5146_SET_BRIGHTNESS      5
+#define TVP5146_SET_CONTRAST        6
+#define TVP5146_SET_HUE             7
+#define TVP5146_SET_SATURATION      8
+#define TVP5146_SET_AGC             9
+#define TVP5146_SET_VIDEOSTD        10
+#define TVP5146_CLR_LOSTLOCK        11
+#define TVP5146_CONFIG              12
+#define TVP5146_RESET               13
+#define TVP5146_POWERDOWN           14
+
+#define TVP5146_GET_STATUS          15
+#define TVP5146_GET_STD             16
+#define TVP5146_INIT                17
+#define TVP5146_CLEANUP             18
+
+#define TVP5146_I2C_ADDR (0xBA >> 1)
+
+/* Defines for TVP5146 register address */
+#define TVP5146_OUTPUT1                 	(0x33)
+#define TVP5146_OUTPUT2                 	(0x34)
+#define TVP5146_OUTPUT3				(0x35)
+#define TVP5146_OUTPUT4				(0x36)
+#define TVP5146_OUTPUT5				(0x37)
+#define TVP5146_OUTPUT6				(0x38)
+
+#define TVP5146_I2C_REGISTERED			(1)
+#define TVP5146_I2C_UNREGISTERED		(0)
+
+extern int tvp5146_ctrl(tvp5146_cmd cmd, void *arg);
+
+#endif
+#endif
Index: linux-2.6.18/include/media/davinci/davinci_vpfe.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/davinci_vpfe.h
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davinci_vpfe.h */
+
+#ifndef DAVINCI_VPFE_H
+#define DAVINCI_VPFE_H
+
+#include <linux/videodev.h>
+#include <media/davinci/tvp5146.h>
+#include <media/davinci/mt9t001.h>
+
+/* vpfe specific video standards */
+#define VPFE_STD_625_50_SQP ((V4L2_STD_625_50)<<32)
+#define VPFE_STD_525_60_SQP ((V4L2_STD_525_60)<<32)
+#define VPFE_STD_AUTO ((v4l2_std_id)(0x1000000000000000ULL))
+#define VPFE_STD_AUTO_SQP ((v4l2_std_id)(0x2000000000000000ULL))
+
+#define VPFE_CMD_LATEST_FRM_ONLY \
+			_IOW('V',BASE_VIDIOC_PRIVATE + 2,int)
+#define VPFE_CMD_CONFIG_TVP5146 \
+			_IOW('V',BASE_VIDIOC_PRIVATE + 3,tvp5146_params)
+#define VPFE_CMD_S_MT9T001_PARAMS \
+			_IOW('V',BASE_VIDIOC_PRIVATE + 5,struct mt9t001_params)
+#define VPFE_CMD_G_MT9T001_PARAMS \
+			_IOR('V',BASE_VIDIOC_PRIVATE + 6,struct mt9t001_params)
+
+/* V4L2 defines added for new standards,
+					  these will be moved to videodev2.h */
+#define V4L2_STD_MT9T001_VGA_30FPS	(10)
+#define V4L2_STD_MT9T001_VGA_60FPS	(11)
+#define V4L2_STD_MT9T001_SVGA_30FPS	(12)
+#define V4L2_STD_MT9T001_SVGA_60FPS	(13)
+#define V4L2_STD_MT9T001_XGA_30FPS	(14)
+#define V4L2_STD_MT9T001_480p_30FPS	(15)
+#define V4L2_STD_MT9T001_480p_60FPS	(16)
+#define V4L2_STD_MT9T001_576p_25FPS	(17)
+#define V4L2_STD_MT9T001_576p_50FPS	(18)
+#define V4L2_STD_MT9T001_720p_24FPS	(19)
+#define V4L2_STD_MT9T001_720p_30FPS	(20)
+#define V4L2_STD_MT9T001_1080p_18FPS	(21)
+
+/* Define for device type to be passed in init */
+#define 	MT9T001	0
+#define		TVP5146	1
+#define 	MT9T031	2
+
+#ifdef __KERNEL__
+
+#include <media/v4l2-dev.h>
+#include <media/video-buf.h>
+
+#define VPFE_MAJOR_RELEASE 0
+#define VPFE_MINOR_RELEASE 0
+#define VPFE_BUILD         1
+
+#define VPFE_VERSION_CODE \
+     (VPFE_MAJOR_RELEASE<<16)  | (VPFE_MINOR_RELEASE<<8) | VPFE_BUILD
+
+/* By default, the driver is setup for auto-swich mode */
+#define VPFE_DEFAULT_STD VPFE_STD_AUTO
+
+#define VPFE_PIXELASPECT_NTSC 		{11, 10}
+#define VPFE_PIXELASPECT_PAL  		{54, 59}
+#define VPFE_PIXELASPECT_NTSC_SP    	{1, 1}
+#define VPFE_PIXELASPECT_PAL_SP     	{1, 1}
+#define VPFE_PIXELASPECT_DEFAULT    	{1, 1}
+
+/* Buffer size defines for TVP5146 and MT9T001 */
+#define VPFE_TVP5146_MAX_FRAME_WIDTH      768	/* for PAL Sqpixel mode */
+#define VPFE_TVP5146_MAX_FRAME_HEIGHT     576	/* for PAL              */
+/* 4:2:2 data */
+#define VPFE_TVP5146_MAX_FBUF_SIZE      \
+		 (VPFE_TVP5146_MAX_FRAME_WIDTH*VPFE_TVP5146_MAX_FRAME_HEIGHT*2)
+
+#define VPFE_MT9T001_MAX_FRAME_WIDTH     (1920)
+#define VPFE_MT9T001_MAX_FRAME_HEIGHT    (1080)
+/* 2 BYTE FOR EACH PIXEL */
+#define VPFE_MT9T001_MAX_FBUF_SIZE       \
+		(VPFE_MT9T001_MAX_FRAME_WIDTH*VPFE_MT9T001_MAX_FRAME_HEIGHT*2)
+
+/* frame buffers allocate at driver initialization time */
+#define VPFE_DEFNUM_FBUFS             3
+
+/* Defines for number of lines for all formats */
+#define FMT_VGA_NUMLINES				(480 + NUM_EXTRALINES)
+#define FMT_SVGA_NUMLINES				(600 + NUM_EXTRALINES)
+#define FMT_XGA_NUMLINES				(768 + NUM_EXTRALINES)
+#define FMT_480p_NUMLINES				(480 + NUM_EXTRALINES)
+#define FMT_576p_NUMLINES				(576 + NUM_EXTRALINES)
+#define FMT_720p_NUMLINES				(720 + NUM_EXTRALINES)
+#define FMT_1080i_NUMLINES				(1080)
+
+/* Defines for FPS values */
+#define FPS_18_NUMERATOR				(1)
+#define FPS_18_DENOMIRATOR				(18)
+#define FPS_24_NUMERATOR				(1)
+#define FPS_24_DENOMIRATOR  				(24)
+#define FPS_25_NUMERATOR				(1)
+#define FPS_25_DENOMIRATOR  				(25)
+#define FPS_30_NUMERATOR				(1)
+#define FPS_30_DENOMIRATOR  				(30)
+#define FPS_50_NUMERATOR    				(1)
+#define FPS_50_DENOMIRATOR  				(50)
+#define FPS_60_NUMERATOR    				(1)
+#define FPS_60_DENOMIRATOR  				(60)
+
+/* Device configuration function pointer */
+typedef int (*device_cfg_fxn) (unsigned int cmd, void *arg, void *params);
+
+typedef struct vpfe_obj {
+	struct video_device *video_dev;
+	struct videobuf_queue bufqueue;	/* queue with frame buffers      */
+	struct list_head dma_queue;
+	u32 latest_only;	/* indicate whether to return the most */
+	/* recent captured buffers only        */
+	u32 usrs;
+	u32 io_usrs;
+	struct v4l2_prio_state prio;
+	v4l2_std_id std;
+	struct v4l2_rect vwin;
+	struct v4l2_rect bounds;
+	struct v4l2_fract pixelaspect;
+	spinlock_t irqlock;
+	struct semaphore lock;
+	enum v4l2_field field;
+	u32 pixelfmt;
+	u32 numbuffers;
+	u8 *fbuffers[VIDEO_MAX_FRAME];
+	struct videobuf_buffer *curFrm;
+	struct videobuf_buffer *nextFrm;
+	int field_id;
+	int mode_changed;
+	int started;
+	int field_offset;
+	unsigned char capture_device;	/*set in vpfe_init()
+					   (1=TVP5146, 0=MT9T001) */
+	tvp5146_params tvp5146_params;
+	void *device_params;	/*Pointer for video device. (MT9T001) */
+	//ccdc_params_raw ccdc_params_raw;      /*Object for CCDC raw mode */
+	//ccdc_params_ycbcr ccdc_params_ycbcr;  /*Object for CCDC ycbcr mode */
+	device_cfg_fxn config_dev_fxn;	/*where,typedef int(*deviceCfg_Fxn)
+					   (Uns cmd, void *arg, void *params); */
+
+} vpfe_obj;
+
+/* file handle */
+typedef struct vpfe_fh {
+	struct vpfe_obj *dev;
+	int io_allowed;
+	enum v4l2_priority prio;
+} vpfe_fh;
+#endif
+
+#endif				/* DAVINCI_VPFE_H */
Index: linux-2.6.18/mvl_patches/pro50-1582.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-1582.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1582);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

