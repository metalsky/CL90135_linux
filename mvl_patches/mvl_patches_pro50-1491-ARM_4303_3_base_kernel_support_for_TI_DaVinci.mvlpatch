#! /usr/bin/env bash
# Patch: -ARM_4303_3_base_kernel_support_for_TI_DaVinci
# Date: Fri Sep 19 13:54:52 2008
# MR: 23591
# Type: Integration
# Disposition: Backport from 2.6.22-rc1
# Adjustment:
# arch/arm/Kconfig - change to apply cleanly
# arch/arm/Makefile - change to apply cleanly
# arch/arm/mm/Kconfig - change to apply cleanly
# 
# From 7c6337e225364870e9bf02a3ae277d9fdea483f8 Mon Sep 17 00:00:00 2001
# From: Kevin Hilman <khilman@mvista.com>
# Date: Mon, 30 Apr 2007 19:37:19 +0100
# Subject: [PATCH] [ARM] 4303/3: base kernel support for TI DaVinci
# 
# Add base kernel support for the TI DaVinci platform.
# 
# This patch only includes interrupts, timers, CPU identification,
# serial support and basic power and sleep controller init.  More
# drivers to come.
# 
# Signed-off-by: Kevin Hilman <khilman@mvista.com>
# Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

PATCHNUM=1491
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
MR: 23591
Type: Integration
Disposition: Backport from 2.6.22-rc1
Adjustment:
arch/arm/Kconfig - change to apply cleanly
arch/arm/Makefile - change to apply cleanly
arch/arm/mm/Kconfig - change to apply cleanly

From 7c6337e225364870e9bf02a3ae277d9fdea483f8 Mon Sep 17 00:00:00 2001
From: Kevin Hilman <khilman@mvista.com>
Date: Mon, 30 Apr 2007 19:37:19 +0100
Subject: [PATCH] [ARM] 4303/3: base kernel support for TI DaVinci

Add base kernel support for the TI DaVinci platform.

This patch only includes interrupts, timers, CPU identification,
serial support and basic power and sleep controller init.  More
drivers to come.

Signed-off-by: Kevin Hilman <khilman@mvista.com>
Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
Index: linux-2.6.18/arch/arm/Kconfig
===================================================================
--- linux-2.6.18.orig/arch/arm/Kconfig
+++ linux-2.6.18/arch/arm/Kconfig
@@ -338,6 +338,13 @@ config ARCH_OMAP
 	help
 	  Support for TI's OMAP platform (OMAP1 and OMAP2).
 
+config ARCH_DAVINCI
+	bool "TI DaVinci"
+	select GENERIC_TIME
+	select GENERIC_CLOCKEVENTS
+	help
+	  Support for TI's DaVinci platform.
+
 endchoice
 
 source "arch/arm/mach-clps711x/Kconfig"
@@ -386,6 +393,8 @@ source "arch/arm/mach-at91rm9200/Kconfig
 
 source "arch/arm/mach-netx/Kconfig"
 
+source "arch/arm/mach-davinci/Kconfig"
+
 # Definitions to make life easier
 config ARCH_ACORN
 	bool
@@ -596,7 +605,7 @@ config LEDS
 		   ARCH_LUBBOCK || MACH_MAINSTONE || ARCH_NETWINDER || \
 		   ARCH_OMAP || ARCH_P720T || ARCH_PXA_IDP || \
 		   ARCH_SA1100 || ARCH_SHARK || ARCH_VERSATILE || \
-		   ARCH_AT91RM9200 || MACH_TRIZEPS4
+		   ARCH_AT91RM9200 || MACH_TRIZEPS4 || ARCH_DAVINCI
 	help
 	  If you say Y here, the LEDs on your machine will be used
 	  to provide useful information about your current system status.
Index: linux-2.6.18/arch/arm/Makefile
===================================================================
--- linux-2.6.18.orig/arch/arm/Makefile
+++ linux-2.6.18/arch/arm/Makefile
@@ -124,6 +124,7 @@ endif
  machine-$(CONFIG_ARCH_NETX)       := netx
   incdir-$(CONFIG_ARCH_MXC)        := mxc
  machine-$(CONFIG_ARCH_MX2)        := mx2
+ machine-$(CONFIG_ARCH_DAVINCI)	   := davinci
 
 ifeq ($(CONFIG_ARCH_EBSA110),y)
 # This is what happens if you forget the IOCS16 line.
Index: linux-2.6.18/arch/arm/mach-davinci/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-davinci/Kconfig
@@ -0,0 +1,23 @@
+if ARCH_DAVINCI
+
+menu "TI DaVinci Implementations"
+
+comment "DaVinci Core Type"
+
+config ARCH_DAVINCI644x
+	default y
+	bool "DaVinci 644x based system"
+
+comment "DaVinci Board Type"
+
+config MACH_DAVINCI_EVM
+	bool "TI DaVinci EVM"
+	default y
+	depends on ARCH_DAVINCI644x
+	help
+	  Configure this option to specify the whether the board used
+	  for development is a DaVinci EVM
+
+endmenu
+
+endif
Index: linux-2.6.18/arch/arm/mach-davinci/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-davinci/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the linux kernel.
+#
+#
+
+# Common objects
+obj-y 			:= time.o irq.o serial.o io.o id.o psc.o
+
+# Board specific
+obj-$(CONFIG_MACH_DAVINCI_EVM)  += board-evm.o
Index: linux-2.6.18/arch/arm/mach-davinci/Makefile.boot
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-davinci/Makefile.boot
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x80008000
+params_phys-y	:= 0x80000100
+initrd_phys-y	:= 0x80800000
Index: linux-2.6.18/arch/arm/mach-davinci/board-evm.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-davinci/board-evm.c
@@ -0,0 +1,131 @@
+/*
+ * TI DaVinci EVM board support
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/physmap.h>
+
+#include <asm/setup.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+
+#include <asm/arch/common.h>
+
+/* other misc. init functions */
+void __init davinci_psc_init(void);
+void __init davinci_irq_init(void);
+void __init davinci_map_common_io(void);
+
+/* NOR Flash base address set to CS0 by default */
+#define NOR_FLASH_PHYS 0x02000000
+
+static struct mtd_partition davinci_evm_partitions[] = {
+	/* bootloader (U-Boot, etc) in first 4 sectors */
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 4 * SZ_64K,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	},
+	/* bootloader params in the next 1 sectors */
+	{
+		.name		= "params",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_64K,
+		.mask_flags	= 0,
+	},
+	/* kernel */
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_2M,
+		.mask_flags	= 0
+	},
+	/* file system */
+	{
+		.name		= "filesystem",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+		.mask_flags	= 0
+	}
+};
+
+static struct physmap_flash_data davinci_evm_flash_data = {
+	.width		= 2,
+	.parts		= davinci_evm_partitions,
+	.nr_parts	= ARRAY_SIZE(davinci_evm_partitions),
+};
+
+/* NOTE: CFI probe will correctly detect flash part as 32M, but EMIF
+ * limits addresses to 16M, so using addresses past 16M will wrap */
+static struct resource davinci_evm_flash_resource = {
+	.start		= NOR_FLASH_PHYS,
+	.end		= NOR_FLASH_PHYS + SZ_16M - 1,
+	.flags		= IORESOURCE_MEM,
+};
+
+static struct platform_device davinci_evm_flash_device = {
+	.name		= "physmap-flash",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &davinci_evm_flash_data,
+	},
+	.num_resources	= 1,
+	.resource	= &davinci_evm_flash_resource,
+};
+
+static struct platform_device *davinci_evm_devices[] __initdata = {
+	&davinci_evm_flash_device,
+};
+
+static void __init
+davinci_evm_map_io(void)
+{
+	davinci_map_common_io();
+}
+
+static __init void davinci_evm_init(void)
+{
+	davinci_psc_init();
+
+#if defined(CONFIG_BLK_DEV_DAVINCI) || defined(CONFIG_BLK_DEV_DAVINCI_MODULE)
+	printk(KERN_WARNING "WARNING: both IDE and NOR flash are enabled, "
+	       "but share pins.\n\t Disable IDE for NOR support.\n");
+#endif
+
+	platform_add_devices(davinci_evm_devices,
+			     ARRAY_SIZE(davinci_evm_devices));
+}
+
+static __init void davinci_evm_irq_init(void)
+{
+	davinci_irq_init();
+}
+
+MACHINE_START(DAVINCI_EVM, "DaVinci EVM")
+	/* Maintainer: MontaVista Software <source@mvista.com> */
+	.phys_io      = IO_PHYS,
+	.io_pg_offst  = (io_p2v(IO_PHYS) >> 18) & 0xfffc,
+	.boot_params  = (DAVINCI_DDR_BASE + 0x100),
+	.map_io	      = davinci_evm_map_io,
+	.init_irq     = davinci_evm_irq_init,
+	.timer	      = &davinci_timer,
+	.init_machine = davinci_evm_init,
+MACHINE_END
Index: linux-2.6.18/arch/arm/mach-davinci/id.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-davinci/id.c
@@ -0,0 +1,94 @@
+/*
+ * Davinci CPU identification code
+ *
+ * Copyright (C) 2006 Komal Shah <komal_shah802003@yahoo.com>
+ *
+ * Derived from OMAP1 CPU identification code.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+
+#define JTAG_ID_BASE		0x01c40028
+
+struct davinci_id {
+	u8	variant;	/* JTAG ID bits 31:28 */
+	u16	part_no;	/* JTAG ID bits 27:12 */
+	u32	manufacturer;	/* JTAG ID bits 11:1 */
+	u32	type;		/* Cpu id bits [31:8], cpu class bits [7:0] */
+};
+
+/* Register values to detect the DaVinci version */
+static struct davinci_id davinci_ids[] __initdata = {
+	{
+		/* DM6446 */
+		.part_no      = 0xb700,
+		.variant      = 0x0,
+		.manufacturer = 0x017,
+		.type	      = 0x64460000,
+	},
+};
+
+/*
+ * Get Device Part No. from JTAG ID register
+ */
+static u16 __init davinci_get_part_no(void)
+{
+	u32 dev_id, part_no;
+
+	dev_id = davinci_readl(JTAG_ID_BASE);
+
+	part_no = ((dev_id >> 12) & 0xffff);
+
+	return part_no;
+}
+
+/*
+ * Get Device Revision from JTAG ID register
+ */
+static u8 __init davinci_get_variant(void)
+{
+	u32 variant;
+
+	variant = davinci_readl(JTAG_ID_BASE);
+
+	variant = (variant >> 28) & 0xf;
+
+	return variant;
+}
+
+void __init davinci_check_revision(void)
+{
+	int i;
+	u16 part_no;
+	u8 variant;
+
+	part_no = davinci_get_part_no();
+	variant = davinci_get_variant();
+
+	/* First check only the major version in a safe way */
+	for (i = 0; i < ARRAY_SIZE(davinci_ids); i++) {
+		if (part_no == (davinci_ids[i].part_no)) {
+			system_rev = davinci_ids[i].type;
+			break;
+		}
+	}
+
+	/* Check if we can find the dev revision */
+	for (i = 0; i < ARRAY_SIZE(davinci_ids); i++) {
+		if (part_no == davinci_ids[i].part_no &&
+		    variant == davinci_ids[i].variant) {
+			system_rev = davinci_ids[i].type;
+			break;
+		}
+	}
+
+	printk("DaVinci DM%04x variant 0x%x\n", system_rev >> 16, variant);
+}
Index: linux-2.6.18/arch/arm/mach-davinci/io.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-davinci/io.c
@@ -0,0 +1,51 @@
+/*
+ * DaVinci I/O mapping code
+ *
+ * Copyright (C) 2005-2006 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/tlb.h>
+#include <asm/io.h>
+#include <asm/memory.h>
+
+#include <asm/mach/map.h>
+
+extern void davinci_check_revision(void);
+
+/*
+ * The machine specific code may provide the extra mapping besides the
+ * default mapping provided here.
+ */
+static struct map_desc davinci_io_desc[] __initdata = {
+	{
+		.virtual	= IO_VIRT,
+		.pfn		= __phys_to_pfn(IO_PHYS),
+		.length		= IO_SIZE,
+		.type		= MT_DEVICE
+	},
+};
+
+void __init davinci_map_common_io(void)
+{
+	iotable_init(davinci_io_desc, ARRAY_SIZE(davinci_io_desc));
+
+	/* Normally devicemaps_init() would flush caches and tlb after
+	 * mdesc->map_io(), but we must also do it here because of the CPU
+	 * revision check below.
+	 */
+	local_flush_tlb_all();
+	flush_cache_all();
+
+	/* We want to check CPU revision early for cpu_is_xxxx() macros.
+	 * IO space mapping must be initialized before we can do that.
+	 */
+	davinci_check_revision();
+}
Index: linux-2.6.18/arch/arm/mach-davinci/irq.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-davinci/irq.c
@@ -0,0 +1,226 @@
+/*
+ * Interrupt handler for DaVinci boards.
+ *
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/irq.h>
+
+#define IRQ_BIT(irq)		((irq) & 0x1f)
+
+#define FIQ_REG0_OFFSET		0x0000
+#define FIQ_REG1_OFFSET		0x0004
+#define IRQ_REG0_OFFSET		0x0008
+#define IRQ_REG1_OFFSET		0x000C
+#define IRQ_ENT_REG0_OFFSET	0x0018
+#define IRQ_ENT_REG1_OFFSET	0x001C
+#define IRQ_INCTL_REG_OFFSET	0x0020
+#define IRQ_EABASE_REG_OFFSET	0x0024
+#define IRQ_INTPRI0_REG_OFFSET	0x0030
+#define IRQ_INTPRI7_REG_OFFSET	0x004C
+
+static inline unsigned int davinci_irq_readl(int offset)
+{
+	return davinci_readl(DAVINCI_ARM_INTC_BASE + offset);
+}
+
+static inline void davinci_irq_writel(unsigned long value, int offset)
+{
+	davinci_writel(value, DAVINCI_ARM_INTC_BASE + offset);
+}
+
+/* Disable interrupt */
+static void davinci_mask_irq(unsigned int irq)
+{
+	unsigned int mask;
+	u32 l;
+
+	mask = 1 << IRQ_BIT(irq);
+
+	if (irq > 31) {
+		l = davinci_irq_readl(IRQ_ENT_REG1_OFFSET);
+		l &= ~mask;
+		davinci_irq_writel(l, IRQ_ENT_REG1_OFFSET);
+	} else {
+		l = davinci_irq_readl(IRQ_ENT_REG0_OFFSET);
+		l &= ~mask;
+		davinci_irq_writel(l, IRQ_ENT_REG0_OFFSET);
+	}
+}
+
+/* Enable interrupt */
+static void davinci_unmask_irq(unsigned int irq)
+{
+	unsigned int mask;
+	u32 l;
+
+	mask = 1 << IRQ_BIT(irq);
+
+	if (irq > 31) {
+		l = davinci_irq_readl(IRQ_ENT_REG1_OFFSET);
+		l |= mask;
+		davinci_irq_writel(l, IRQ_ENT_REG1_OFFSET);
+	} else {
+		l = davinci_irq_readl(IRQ_ENT_REG0_OFFSET);
+		l |= mask;
+		davinci_irq_writel(l, IRQ_ENT_REG0_OFFSET);
+	}
+}
+
+/* EOI interrupt */
+static void davinci_ack_irq(unsigned int irq)
+{
+	unsigned int mask;
+
+	mask = 1 << IRQ_BIT(irq);
+
+	if (irq > 31)
+		davinci_irq_writel(mask, IRQ_REG1_OFFSET);
+	else
+		davinci_irq_writel(mask, IRQ_REG0_OFFSET);
+}
+
+static struct irq_chip davinci_irq_chip_0 = {
+	.name	= "AINTC",
+	.ack	= davinci_ack_irq,
+	.mask	= davinci_mask_irq,
+	.unmask = davinci_unmask_irq,
+};
+
+
+/* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
+static const u8 default_priorities[DAVINCI_N_AINTC_IRQ] __initdata = {
+	[IRQ_VDINT0]		= 2,
+	[IRQ_VDINT1]		= 6,
+	[IRQ_VDINT2]		= 6,
+	[IRQ_HISTINT]		= 6,
+	[IRQ_H3AINT]		= 6,
+	[IRQ_PRVUINT]		= 6,
+	[IRQ_RSZINT]		= 6,
+	[7]			= 7,
+	[IRQ_VENCINT]		= 6,
+	[IRQ_ASQINT]		= 6,
+	[IRQ_IMXINT]		= 6,
+	[IRQ_VLCDINT]		= 6,
+	[IRQ_USBINT]		= 4,
+	[IRQ_EMACINT]		= 4,
+	[14]			= 7,
+	[15]			= 7,
+	[IRQ_CCINT0]		= 5,	/* dma */
+	[IRQ_CCERRINT]		= 5,	/* dma */
+	[IRQ_TCERRINT0]		= 5,	/* dma */
+	[IRQ_TCERRINT]		= 5,	/* dma */
+	[IRQ_PSCIN]		= 7,
+	[21]			= 7,
+	[IRQ_IDE]		= 4,
+	[23]			= 7,
+	[IRQ_MBXINT]		= 7,
+	[IRQ_MBRINT]		= 7,
+	[IRQ_MMCINT]		= 7,
+	[IRQ_SDIOINT]		= 7,
+	[28]			= 7,
+	[IRQ_DDRINT]		= 7,
+	[IRQ_AEMIFINT]		= 7,
+	[IRQ_VLQINT]		= 4,
+	[IRQ_TINT0_TINT12]	= 2,	/* clockevent */
+	[IRQ_TINT0_TINT34]	= 2,	/* clocksource */
+	[IRQ_TINT1_TINT12]	= 7,	/* DSP timer */
+	[IRQ_TINT1_TINT34]	= 7,	/* system tick */
+	[IRQ_PWMINT0]		= 7,
+	[IRQ_PWMINT1]		= 7,
+	[IRQ_PWMINT2]		= 7,
+	[IRQ_I2C]		= 3,
+	[IRQ_UARTINT0]		= 3,
+	[IRQ_UARTINT1]		= 3,
+	[IRQ_UARTINT2]		= 3,
+	[IRQ_SPINT0]		= 3,
+	[IRQ_SPINT1]		= 3,
+	[45]			= 7,
+	[IRQ_DSP2ARM0]		= 4,
+	[IRQ_DSP2ARM1]		= 4,
+	[IRQ_GPIO0]		= 7,
+	[IRQ_GPIO1]		= 7,
+	[IRQ_GPIO2]		= 7,
+	[IRQ_GPIO3]		= 7,
+	[IRQ_GPIO4]		= 7,
+	[IRQ_GPIO5]		= 7,
+	[IRQ_GPIO6]		= 7,
+	[IRQ_GPIO7]		= 7,
+	[IRQ_GPIOBNK0]		= 7,
+	[IRQ_GPIOBNK1]		= 7,
+	[IRQ_GPIOBNK2]		= 7,
+	[IRQ_GPIOBNK3]		= 7,
+	[IRQ_GPIOBNK4]		= 7,
+	[IRQ_COMMTX]		= 7,
+	[IRQ_COMMRX]		= 7,
+	[IRQ_EMUINT]		= 7,
+};
+
+/* ARM Interrupt Controller Initialization */
+void __init davinci_irq_init(void)
+{
+	unsigned i;
+	const u8 *priority = default_priorities;
+
+	/* Clear all interrupt requests */
+	davinci_irq_writel(~0x0, FIQ_REG0_OFFSET);
+	davinci_irq_writel(~0x0, FIQ_REG1_OFFSET);
+	davinci_irq_writel(~0x0, IRQ_REG0_OFFSET);
+	davinci_irq_writel(~0x0, IRQ_REG1_OFFSET);
+
+	/* Disable all interrupts */
+	davinci_irq_writel(0x0, IRQ_ENT_REG0_OFFSET);
+	davinci_irq_writel(0x0, IRQ_ENT_REG1_OFFSET);
+
+	/* Interrupts disabled immediately, IRQ entry reflects all */
+	davinci_irq_writel(0x0, IRQ_INCTL_REG_OFFSET);
+
+	/* we don't use the hardware vector table, just its entry addresses */
+	davinci_irq_writel(0, IRQ_EABASE_REG_OFFSET);
+
+	/* Clear all interrupt requests */
+	davinci_irq_writel(~0x0, FIQ_REG0_OFFSET);
+	davinci_irq_writel(~0x0, FIQ_REG1_OFFSET);
+	davinci_irq_writel(~0x0, IRQ_REG0_OFFSET);
+	davinci_irq_writel(~0x0, IRQ_REG1_OFFSET);
+
+	for (i = IRQ_INTPRI0_REG_OFFSET; i <= IRQ_INTPRI7_REG_OFFSET; i += 4) {
+		unsigned	j;
+		u32		pri;
+
+		for (j = 0, pri = 0; j < 32; j += 4, priority++)
+			pri |= (*priority & 0x07) << j;
+		davinci_irq_writel(pri, i);
+	}
+
+	/* set up genirq dispatch for ARM INTC */
+	for (i = 0; i < DAVINCI_N_AINTC_IRQ; i++) {
+		set_irq_chip(i, &davinci_irq_chip_0);
+		set_irq_flags(i, IRQF_VALID | IRQF_PROBE);
+		if (i != IRQ_TINT1_TINT34)
+			set_irq_handler(i, handle_edge_irq);
+		else
+			set_irq_handler(i, handle_level_irq);
+	}
+}
Index: linux-2.6.18/arch/arm/mach-davinci/psc.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-davinci/psc.c
@@ -0,0 +1,113 @@
+/*
+ * TI DaVinci Power and Sleep Controller (PSC)
+ *
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/psc.h>
+
+#define PTCMD	     __REG(0x01C41120)
+#define PDSTAT	     __REG(0x01C41200)
+#define PDCTL1	     __REG(0x01C41304)
+#define EPCPR	     __REG(0x01C41070)
+#define PTSTAT	     __REG(0x01C41128)
+
+#define MDSTAT	     IO_ADDRESS(0x01C41800)
+#define MDCTL	     IO_ADDRESS(0x01C41A00)
+
+#define PINMUX0	     __REG(0x01c40000)
+#define PINMUX1	     __REG(0x01c40004)
+#define VDD3P3V_PWDN __REG(0x01C40048)
+
+static void davinci_psc_mux(unsigned int id)
+{
+	switch (id) {
+	case DAVINCI_LPSC_ATA:
+		PINMUX0 |= (1 << 17) | (1 << 16);
+		break;
+	case DAVINCI_LPSC_MMC_SD:
+		/* VDD power manupulations are done in U-Boot for CPMAC
+		 * so applies to MMC as well
+		 */
+		/*Set up the pull regiter for MMC */
+		VDD3P3V_PWDN = 0x0;
+		PINMUX1 &= (~(1 << 9));
+		break;
+	case DAVINCI_LPSC_I2C:
+		PINMUX1 |= (1 << 7);
+		break;
+	case DAVINCI_LPSC_McBSP:
+		PINMUX1 |= (1 << 10);
+		break;
+	default:
+		break;
+	}
+}
+
+/* Enable or disable a PSC domain */
+void davinci_psc_config(unsigned int domain, unsigned int id, char enable)
+{
+	volatile unsigned int *mdstat = (unsigned int *)((int)MDSTAT + 4 * id);
+	volatile unsigned int *mdctl = (unsigned int *)((int)MDCTL + 4 * id);
+
+	if (id < 0)
+		return;
+
+	if (enable)
+		*mdctl |= 0x00000003;	/* Enable Module */
+	else
+		*mdctl &= 0xFFFFFFF2;	/* Disable Module */
+
+	if ((PDSTAT & 0x00000001) == 0) {
+		PDCTL1 |= 0x1;
+		PTCMD = (1 << domain);
+		while ((((EPCPR >> domain) & 1) == 0));
+
+		PDCTL1 |= 0x100;
+		while (!(((PTSTAT >> domain) & 1) == 0));
+	} else {
+		PTCMD = (1 << domain);
+		while (!(((PTSTAT >> domain) & 1) == 0));
+	}
+
+	if (enable)
+		while (!((*mdstat & 0x0000001F) == 0x3));
+	else
+		while (!((*mdstat & 0x0000001F) == 0x2));
+
+	if (enable)
+		davinci_psc_mux(id);
+}
+
+void __init davinci_psc_init(void)
+{
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_VPSSMSTR, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_VPSSSLV, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPCC, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPTC0, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPTC1, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_GPIO, 1);
+
+	/* Turn on WatchDog timer LPSC.	 Needed for RESET to work */
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TIMER2, 1);
+}
Index: linux-2.6.18/arch/arm/mach-davinci/serial.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-davinci/serial.c
@@ -0,0 +1,96 @@
+/*
+ * TI DaVinci serial driver
+ *
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_reg.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/arch/serial.h>
+#include <asm/arch/irqs.h>
+
+#define UART_DAVINCI_PWREMU 0x0c
+
+static inline unsigned int davinci_serial_in(struct plat_serial8250_port *up,
+					  int offset)
+{
+	offset <<= up->regshift;
+	return (unsigned int)__raw_readb(up->membase + offset);
+}
+
+static inline void davinci_serial_outp(struct plat_serial8250_port *p,
+				       int offset, int value)
+{
+	offset <<= p->regshift;
+	__raw_writeb(value, p->membase + offset);
+}
+
+static struct plat_serial8250_port serial_platform_data[] = {
+	{
+		.membase	= (char *)IO_ADDRESS(DAVINCI_UART0_BASE),
+		.mapbase	= (unsigned long)DAVINCI_UART0_BASE,
+		.irq		= IRQ_UARTINT0,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= 27000000,
+	},
+	{
+		.flags		= 0
+	},
+};
+
+static struct platform_device serial_device = {
+	.name			= "serial8250",
+	.id			= PLAT8250_DEV_PLATFORM,
+	.dev			= {
+		.platform_data	= serial_platform_data,
+	},
+};
+
+static void __init davinci_serial_reset(struct plat_serial8250_port *p)
+{
+	/* reset both transmitter and receiver: bits 14,13 = UTRST, URRST */
+	unsigned int pwremu = 0;
+
+	davinci_serial_outp(p, UART_IER, 0);  /* disable all interrupts */
+
+	davinci_serial_outp(p, UART_DAVINCI_PWREMU, pwremu);
+	mdelay(10);
+
+	pwremu |= (0x3 << 13);
+	pwremu |= 0x1;
+	davinci_serial_outp(p, UART_DAVINCI_PWREMU, pwremu);
+}
+
+static int __init davinci_init(void)
+{
+	davinci_serial_reset(&serial_platform_data[0]);
+	return platform_device_register(&serial_device);
+}
+
+arch_initcall(davinci_init);
Index: linux-2.6.18/arch/arm/mach-davinci/time.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-davinci/time.c
@@ -0,0 +1,370 @@
+/*
+ * DaVinci timer subsystem
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/clocksource.h>
+#include <linux/clockchips.h>
+#include <linux/spinlock.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/time.h>
+#include <asm/errno.h>
+#include <asm/arch/io.h>
+
+static struct clock_event_device clockevent_davinci;
+
+#define DAVINCI_TIMER0_BASE (IO_PHYS + 0x21400)
+#define DAVINCI_TIMER1_BASE (IO_PHYS + 0x21800)
+#define DAVINCI_WDOG_BASE   (IO_PHYS + 0x21C00)
+
+enum {
+	T0_BOT = 0, T0_TOP, T1_BOT, T1_TOP, NUM_TIMERS,
+};
+
+#define IS_TIMER1(id)    (id & 0x2)
+#define IS_TIMER0(id)    (!IS_TIMER1(id))
+#define IS_TIMER_TOP(id) ((id & 0x1))
+#define IS_TIMER_BOT(id) (!IS_TIMER_TOP(id))
+
+static int timer_irqs[NUM_TIMERS] = {
+	IRQ_TINT0_TINT12,
+	IRQ_TINT0_TINT34,
+	IRQ_TINT1_TINT12,
+	IRQ_TINT1_TINT34,
+};
+
+/*
+ * This driver configures the 2 64-bit count-up timers as 4 independent
+ * 32-bit count-up timers used as follows:
+ *
+ * T0_BOT: Timer 0, bottom:  clockevent source for hrtimers
+ * T0_TOP: Timer 0, top   :  clocksource for generic timekeeping
+ * T1_BOT: Timer 1, bottom:  (used by DSP in TI DSPLink code)
+ * T1_TOP: Timer 1, top   :  <unused>
+ */
+#define TID_CLOCKEVENT  T0_BOT
+#define TID_CLOCKSOURCE T0_TOP
+
+/* Timer register offsets */
+#define PID12                        0x0
+#define TIM12                        0x10
+#define TIM34                        0x14
+#define PRD12                        0x18
+#define PRD34                        0x1c
+#define TCR                          0x20
+#define TGCR                         0x24
+#define WDTCR                        0x28
+
+/* Timer register bitfields */
+#define TCR_ENAMODE_DISABLE          0x0
+#define TCR_ENAMODE_ONESHOT          0x1
+#define TCR_ENAMODE_PERIODIC         0x2
+#define TCR_ENAMODE_MASK             0x3
+
+#define TGCR_TIMMODE_SHIFT           2
+#define TGCR_TIMMODE_64BIT_GP        0x0
+#define TGCR_TIMMODE_32BIT_UNCHAINED 0x1
+#define TGCR_TIMMODE_64BIT_WDOG      0x2
+#define TGCR_TIMMODE_32BIT_CHAINED   0x3
+
+#define TGCR_TIM12RS_SHIFT           0
+#define TGCR_TIM34RS_SHIFT           1
+#define TGCR_RESET                   0x0
+#define TGCR_UNRESET                 0x1
+#define TGCR_RESET_MASK              0x3
+
+#define WDTCR_WDEN_SHIFT             14
+#define WDTCR_WDEN_DISABLE           0x0
+#define WDTCR_WDEN_ENABLE            0x1
+#define WDTCR_WDKEY_SHIFT            16
+#define WDTCR_WDKEY_SEQ0             0xa5c6
+#define WDTCR_WDKEY_SEQ1             0xda7e
+
+struct timer_s {
+	char *name;
+	unsigned int id;
+	unsigned long period;
+	unsigned long opts;
+	unsigned long reg_base;
+	unsigned long tim_reg;
+	unsigned long prd_reg;
+	unsigned long enamode_shift;
+	struct irqaction irqaction;
+};
+static struct timer_s timers[];
+
+/* values for 'opts' field of struct timer_s */
+#define TIMER_OPTS_DISABLED   0x00
+#define TIMER_OPTS_ONESHOT    0x01
+#define TIMER_OPTS_PERIODIC   0x02
+
+static int timer32_config(struct timer_s *t)
+{
+	u32 tcr = davinci_readl(t->reg_base + TCR);
+
+	/* disable timer */
+	tcr &= ~(TCR_ENAMODE_MASK << t->enamode_shift);
+	davinci_writel(tcr, t->reg_base + TCR);
+
+	/* reset counter to zero, set new period */
+	davinci_writel(0, t->tim_reg);
+	davinci_writel(t->period, t->prd_reg);
+
+	/* Set enable mode */
+	if (t->opts & TIMER_OPTS_ONESHOT) {
+		tcr |= TCR_ENAMODE_ONESHOT << t->enamode_shift;
+	} else if (t->opts & TIMER_OPTS_PERIODIC) {
+		tcr |= TCR_ENAMODE_PERIODIC << t->enamode_shift;
+	}
+
+	davinci_writel(tcr, t->reg_base + TCR);
+	return 0;
+}
+
+static inline u32 timer32_read(struct timer_s *t)
+{
+	return davinci_readl(t->tim_reg);
+}
+
+static irqreturn_t timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct clock_event_device *evt = &clockevent_davinci;
+
+	evt->event_handler(regs);
+	return IRQ_HANDLED;
+}
+
+/* called when 32-bit counter wraps */
+static irqreturn_t freerun_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	return IRQ_HANDLED;
+}
+
+static struct timer_s timers[] = {
+	[TID_CLOCKEVENT] = {
+		.name      = "clockevent",
+		.opts      = TIMER_OPTS_DISABLED,
+		.irqaction = {
+			.flags   = IRQF_DISABLED | IRQF_TIMER,
+			.handler = timer_interrupt,
+		}
+	},
+	[TID_CLOCKSOURCE] = {
+		.name       = "free-run counter",
+		.period     = ~0,
+		.opts       = TIMER_OPTS_PERIODIC,
+		.irqaction = {
+			.flags   = IRQF_DISABLED | IRQF_TIMER,
+			.handler = freerun_interrupt,
+		}
+	},
+};
+
+static void __init timer_init(void)
+{
+	u32 bases[] = {DAVINCI_TIMER0_BASE, DAVINCI_TIMER1_BASE};
+	int i;
+
+	/* Global init of each 64-bit timer as a whole */
+	for(i=0; i<2; i++) {
+		u32 tgcr, base = bases[i];
+
+		/* Disabled, Internal clock source */
+		davinci_writel(0, base + TCR);
+
+		/* reset both timers, no pre-scaler for timer34 */
+		tgcr = 0;
+		davinci_writel(tgcr, base + TGCR);
+
+		/* Set both timers to unchained 32-bit */
+		tgcr = TGCR_TIMMODE_32BIT_UNCHAINED << TGCR_TIMMODE_SHIFT;
+		davinci_writel(tgcr, base + TGCR);
+
+		/* Unreset timers */
+		tgcr |= (TGCR_UNRESET << TGCR_TIM12RS_SHIFT) |
+			(TGCR_UNRESET << TGCR_TIM34RS_SHIFT);
+		davinci_writel(tgcr, base + TGCR);
+
+		/* Init both counters to zero */
+		davinci_writel(0, base + TIM12);
+		davinci_writel(0, base + TIM34);
+	}
+
+	/* Init of each timer as a 32-bit timer */
+	for (i=0; i< ARRAY_SIZE(timers); i++) {
+		struct timer_s *t = &timers[i];
+
+		if (t->name) {
+			t->id = i;
+			t->reg_base = (IS_TIMER1(t->id) ?
+			       DAVINCI_TIMER1_BASE : DAVINCI_TIMER0_BASE);
+
+			if (IS_TIMER_BOT(t->id)) {
+				t->enamode_shift = 6;
+				t->tim_reg = t->reg_base + TIM12;
+				t->prd_reg = t->reg_base + PRD12;
+			} else {
+				t->enamode_shift = 22;
+				t->tim_reg = t->reg_base + TIM34;
+				t->prd_reg = t->reg_base + PRD34;
+			}
+
+			/* Register interrupt */
+			t->irqaction.name = t->name;
+			t->irqaction.dev_id = (void *)t;
+			if (t->irqaction.handler != NULL) {
+				setup_irq(timer_irqs[t->id], &t->irqaction);
+			}
+
+			timer32_config(&timers[i]);
+		}
+	}
+}
+
+/*
+ * clocksource
+ */
+static cycle_t read_cycles(void)
+{
+	struct timer_s *t = &timers[TID_CLOCKSOURCE];
+
+	return (cycles_t)timer32_read(t);
+}
+
+static struct clocksource clocksource_davinci = {
+	.name		= "timer0_1",
+	.rating		= 300,
+	.read		= read_cycles,
+	.mask		= CLOCKSOURCE_MASK(32),
+	.shift		= 24,
+	.is_continuous	= 1,
+};
+
+/*
+ * clockevent
+ */
+static void davinci_set_next_event(unsigned long cycles,
+				  struct clock_event_device *evt)
+{
+	struct timer_s *t = &timers[TID_CLOCKEVENT];
+
+	t->period = cycles;
+	timer32_config(t);
+}
+
+static void davinci_set_mode(enum clock_event_mode mode,
+			     struct clock_event_device *evt)
+{
+	struct timer_s *t = &timers[TID_CLOCKEVENT];
+
+	switch (mode) {
+	case CLOCK_EVT_PERIODIC:
+		t->period = CLOCK_TICK_RATE / (HZ);
+		t->opts = TIMER_OPTS_PERIODIC;
+		timer32_config(t);
+		break;
+	case CLOCK_EVT_ONESHOT:
+		t->opts = TIMER_OPTS_ONESHOT;
+		break;
+	case CLOCK_EVT_SHUTDOWN:
+		t->opts = TIMER_OPTS_DISABLED;
+		break;
+	}
+}
+
+static struct clock_event_device clockevent_davinci = {
+	.name		= "timer0_0",
+	.capabilities	= CLOCK_CAP_NEXTEVT | CLOCK_CAP_TICK |
+			  CLOCK_CAP_UPDATE,
+	.shift		= 32,
+	.set_next_event	= davinci_set_next_event,
+	.set_mode	= davinci_set_mode,
+};
+
+
+static void __init davinci_timer_init(void)
+{
+	static char err[] __initdata = KERN_ERR
+		"%s: can't register clocksource!\n";
+
+	/* init timer hw */
+	timer_init();
+
+	/* setup clocksource */
+	clocksource_davinci.mult =
+		clocksource_khz2mult(CLOCK_TICK_RATE/1000,
+				     clocksource_davinci.shift);
+	if (clocksource_register(&clocksource_davinci))
+		printk(err, clocksource_davinci.name);
+
+	/* setup clockevent */
+	clockevent_davinci.mult = div_sc(CLOCK_TICK_RATE, NSEC_PER_SEC,
+					 clockevent_davinci.shift);
+	clockevent_davinci.max_delta_ns =
+		clockevent_delta2ns(0xfffffffe, &clockevent_davinci);
+	clockevent_davinci.min_delta_ns =
+		clockevent_delta2ns(1, &clockevent_davinci);
+
+	register_global_clockevent(&clockevent_davinci);
+}
+
+struct sys_timer davinci_timer = {
+	.init   = davinci_timer_init,
+};
+
+
+/* reset board using watchdog timer */
+void davinci_watchdog_reset(void) {
+	u32 tgcr, wdtcr, base = DAVINCI_WDOG_BASE;
+
+	/* disable, internal clock source */
+	davinci_writel(0, base + TCR);
+
+	/* reset timer, set mode to 64-bit watchdog, and unreset */
+	tgcr = 0;
+	davinci_writel(tgcr, base + TCR);
+	tgcr = TGCR_TIMMODE_64BIT_WDOG << TGCR_TIMMODE_SHIFT;
+	tgcr |= (TGCR_UNRESET << TGCR_TIM12RS_SHIFT) |
+		(TGCR_UNRESET << TGCR_TIM34RS_SHIFT);
+	davinci_writel(tgcr, base + TCR);
+
+	/* clear counter and period regs */
+	davinci_writel(0, base + TIM12);
+	davinci_writel(0, base + TIM34);
+	davinci_writel(0, base + PRD12);
+	davinci_writel(0, base + PRD34);
+
+	/* enable */
+	wdtcr = davinci_readl(base + WDTCR);
+	wdtcr |= WDTCR_WDEN_ENABLE << WDTCR_WDEN_SHIFT;
+	davinci_writel(wdtcr, base + WDTCR);
+
+	/* put watchdog in pre-active state */
+	wdtcr = (WDTCR_WDKEY_SEQ0 << WDTCR_WDKEY_SHIFT) |
+		(WDTCR_WDEN_ENABLE << WDTCR_WDEN_SHIFT);
+	davinci_writel(wdtcr, base + WDTCR);
+
+	/* put watchdog in active state */
+	wdtcr = (WDTCR_WDKEY_SEQ1 << WDTCR_WDKEY_SHIFT) |
+		(WDTCR_WDEN_ENABLE << WDTCR_WDEN_SHIFT);
+	davinci_writel(wdtcr, base + WDTCR);
+
+	/* write an invalid value to the WDKEY field to trigger
+	 * a watchdog reset */
+	wdtcr = 0x00004000;
+	davinci_writel(wdtcr, base + WDTCR);
+}
Index: linux-2.6.18/arch/arm/mm/Kconfig
===================================================================
--- linux-2.6.18.orig/arch/arm/mm/Kconfig
+++ linux-2.6.18/arch/arm/mm/Kconfig
@@ -171,8 +171,8 @@ config CPU_ARM925T
 # ARM926T
 config CPU_ARM926T
 	bool "Support ARM926T processor"
-	depends on ARCH_INTEGRATOR || ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || MACH_REALVIEW_EB || ARCH_PNX4008 || ARCH_NETX || CPU_S3C2412 || ARCH_AT91SAM9260 || ARCH_AT91SAM9261 || ARCH_MX2
-	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || ARCH_PNX4008 || ARCH_NETX || CPU_S3C2412 || ARCH_AT91SAM9260 || ARCH_AT91SAM9261 || ARCH_MX2
+	depends on ARCH_INTEGRATOR || ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || MACH_REALVIEW_EB || ARCH_PNX4008 || ARCH_NETX || CPU_S3C2412 || ARCH_AT91SAM9260 || ARCH_AT91SAM9261 || ARCH_MX2 || ARCH_DAVINCI
+	default y if ARCH_VERSATILE_PB || MACH_VERSATILE_AB || ARCH_OMAP730 || ARCH_OMAP16XX || ARCH_PNX4008 || ARCH_NETX || CPU_S3C2412 || ARCH_AT91SAM9260 || ARCH_AT91SAM9261 || ARCH_MX2 || ARCH_DAVINCI
 	select CPU_32v5
 	select CPU_ABRT_EV5TJ
 	select CPU_CACHE_VIVT
Index: linux-2.6.18/include/asm-arm/arch-davinci/common.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/common.h
@@ -0,0 +1,19 @@
+/*
+ * Header for code common to all DaVinci machines.
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef __ARCH_ARM_MACH_DAVINCI_COMMON_H
+#define __ARCH_ARM_MACH_DAVINCI_COMMON_H
+
+struct sys_timer;
+
+extern struct sys_timer davinci_timer;
+
+#endif /* __ARCH_ARM_MACH_DAVINCI_COMMON_H */
Index: linux-2.6.18/include/asm-arm/arch-davinci/debug-macro.S
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/debug-macro.S
@@ -0,0 +1,21 @@
+/*
+ * Debugging macro for DaVinci
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+		.macro addruart, rx
+		mrc	p15, 0, \rx, c1, c0
+		tst	\rx, #1			@ MMU enabled?
+		moveq	\rx, #0x01000000	@ physical base address
+		movne	\rx, #0xfe000000	@ virtual base
+		orr	\rx, \rx, #0x00c20000   @ UART 0
+		.endm
+
+#define UART_SHIFT	2
+#include <asm/hardware/debug-8250.S>
Index: linux-2.6.18/include/asm-arm/arch-davinci/dma.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/dma.h
@@ -0,0 +1,16 @@
+/*
+ * DaVinci DMA definitions
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#define MAX_DMA_ADDRESS			0xffffffff
+
+#endif /* __ASM_ARCH_DMA_H */
Index: linux-2.6.18/include/asm-arm/arch-davinci/entry-macro.S
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/entry-macro.S
@@ -0,0 +1,26 @@
+/*
+ * Low-level IRQ helper macros for TI DaVinci-based platforms
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <asm/arch/io.h>
+#include <asm/arch/irqs.h>
+
+		.macro	disable_fiq
+		.endm
+
+		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+		ldr \base, =IO_ADDRESS(DAVINCI_ARM_INTC_BASE)
+		ldr \tmp, [\base, #0x14]
+		mov \tmp, \tmp, lsr #2
+		sub \irqnr, \tmp, #1
+		cmp \tmp, #0
+		.endm
+
+		.macro	irq_prio_table
+		.endm
Index: linux-2.6.18/include/asm-arm/arch-davinci/hardware.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/hardware.h
@@ -0,0 +1,14 @@
+/*
+ * Common hardware definitions
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __ASM_ARCH_HARDWARE_H
+#define __ASM_ARCH_HARDWARE_H
+
+#endif /* __ASM_ARCH_HARDWARE_H */
Index: linux-2.6.18/include/asm-arm/arch-davinci/io.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/io.h
@@ -0,0 +1,79 @@
+/*
+ * DaVinci IO address definitions
+ *
+ * Copied from include/asm/arm/arch-omap/io.h
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __ASM_ARCH_IO_H
+#define __ASM_ARCH_IO_H
+
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*
+ * ----------------------------------------------------------------------------
+ * I/O mapping
+ * ----------------------------------------------------------------------------
+ */
+#define IO_PHYS		0x01c00000
+#define IO_OFFSET	0xfd000000 /* Virtual IO = 0xfec00000 */
+#define IO_SIZE		0x00400000
+#define IO_VIRT		(IO_PHYS + IO_OFFSET)
+#define io_p2v(pa)	((pa) + IO_OFFSET)
+#define io_v2p(va)	((va) - IO_OFFSET)
+#define IO_ADDRESS(x)	io_p2v(x)
+
+/*
+ * We don't actually have real ISA nor PCI buses, but there is so many
+ * drivers out there that might just work if we fake them...
+ */
+#define PCIO_BASE               0
+#define __io(a)			((void __iomem *)(PCIO_BASE + (a)))
+#define __mem_pci(a)		(a)
+#define __mem_isa(a)		(a)
+
+#ifndef __ASSEMBLER__
+
+/*
+ * Functions to access the DaVinci IO region
+ *
+ * NOTE: - Use davinci_read/write[bwl] for physical register addresses
+ *	 - Use __raw_read/write[bwl]() for virtual register addresses
+ *	 - Use IO_ADDRESS(phys_addr) to convert registers to virtual addresses
+ *	 - DO NOT use hardcoded virtual addresses to allow changing the
+ *	   IO address space again if needed
+ */
+#define davinci_readb(a)	(*(volatile unsigned char  *)IO_ADDRESS(a))
+#define davinci_readw(a)	(*(volatile unsigned short *)IO_ADDRESS(a))
+#define davinci_readl(a)	(*(volatile unsigned int   *)IO_ADDRESS(a))
+
+#define davinci_writeb(v,a)	(*(volatile unsigned char  *)IO_ADDRESS(a) = (v))
+#define davinci_writew(v,a)	(*(volatile unsigned short *)IO_ADDRESS(a) = (v))
+#define davinci_writel(v,a)	(*(volatile unsigned int   *)IO_ADDRESS(a) = (v))
+
+/* 16 bit uses LDRH/STRH, base +/- offset_8 */
+typedef struct { volatile u16 offset[256]; } __regbase16;
+#define __REGV16(vaddr)		((__regbase16 *)((vaddr)&~0xff)) \
+					->offset[((vaddr)&0xff)>>1]
+#define __REG16(paddr)          __REGV16(io_p2v(paddr))
+
+/* 8/32 bit uses LDR/STR, base +/- offset_12 */
+typedef struct { volatile u8 offset[4096]; } __regbase8;
+#define __REGV8(vaddr)		((__regbase8  *)((vaddr)&~4095)) \
+					->offset[((vaddr)&4095)>>0]
+#define __REG8(paddr)		__REGV8(io_p2v(paddr))
+
+typedef struct { volatile u32 offset[4096]; } __regbase32;
+#define __REGV32(vaddr)		((__regbase32 *)((vaddr)&~4095)) \
+					->offset[((vaddr)&4095)>>2]
+
+#define __REG(paddr)		__REGV32(io_p2v(paddr))
+#else
+
+#define __REG(x)	(*((volatile unsigned long *)io_p2v(x)))
+
+#endif /* __ASSEMBLER__ */
+#endif /* __ASM_ARCH_IO_H */
Index: linux-2.6.18/include/asm-arm/arch-davinci/irqs.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/irqs.h
@@ -0,0 +1,105 @@
+/*
+ * DaVinci interrupt controller definitions
+ *
+ *  Copyright (C) 2006 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#ifndef __ASM_ARCH_IRQS_H
+#define __ASM_ARCH_IRQS_H
+
+/* Base address */
+#define DAVINCI_ARM_INTC_BASE 0x01C48000
+
+/* Interrupt lines */
+#define IRQ_VDINT0       0
+#define IRQ_VDINT1       1
+#define IRQ_VDINT2       2
+#define IRQ_HISTINT      3
+#define IRQ_H3AINT       4
+#define IRQ_PRVUINT      5
+#define IRQ_RSZINT       6
+#define IRQ_VFOCINT      7
+#define IRQ_VENCINT      8
+#define IRQ_ASQINT       9
+#define IRQ_IMXINT       10
+#define IRQ_VLCDINT      11
+#define IRQ_USBINT       12
+#define IRQ_EMACINT      13
+
+#define IRQ_CCINT0       16
+#define IRQ_CCERRINT     17
+#define IRQ_TCERRINT0    18
+#define IRQ_TCERRINT     19
+#define IRQ_PSCIN        20
+
+#define IRQ_IDE          22
+#define IRQ_HPIINT       23
+#define IRQ_MBXINT       24
+#define IRQ_MBRINT       25
+#define IRQ_MMCINT       26
+#define IRQ_SDIOINT      27
+#define IRQ_MSINT        28
+#define IRQ_DDRINT       29
+#define IRQ_AEMIFINT     30
+#define IRQ_VLQINT       31
+#define IRQ_TINT0_TINT12 32
+#define IRQ_TINT0_TINT34 33
+#define IRQ_TINT1_TINT12 34
+#define IRQ_TINT1_TINT34 35
+#define IRQ_PWMINT0      36
+#define IRQ_PWMINT1      37
+#define IRQ_PWMINT2      38
+#define IRQ_I2C          39
+#define IRQ_UARTINT0     40
+#define IRQ_UARTINT1     41
+#define IRQ_UARTINT2     42
+#define IRQ_SPINT0       43
+#define IRQ_SPINT1       44
+
+#define IRQ_DSP2ARM0     46
+#define IRQ_DSP2ARM1     47
+#define IRQ_GPIO0        48
+#define IRQ_GPIO1        49
+#define IRQ_GPIO2        50
+#define IRQ_GPIO3        51
+#define IRQ_GPIO4        52
+#define IRQ_GPIO5        53
+#define IRQ_GPIO6        54
+#define IRQ_GPIO7        55
+#define IRQ_GPIOBNK0     56
+#define IRQ_GPIOBNK1     57
+#define IRQ_GPIOBNK2     58
+#define IRQ_GPIOBNK3     59
+#define IRQ_GPIOBNK4     60
+#define IRQ_COMMTX       61
+#define IRQ_COMMRX       62
+#define IRQ_EMUINT       63
+
+#define DAVINCI_N_AINTC_IRQ	64
+#define DAVINCI_N_GPIO		71
+
+#define NR_IRQS			(DAVINCI_N_AINTC_IRQ + DAVINCI_N_GPIO)
+
+#define ARCH_TIMER_IRQ IRQ_TINT1_TINT34
+
+#endif /* __ASM_ARCH_IRQS_H */
Index: linux-2.6.18/include/asm-arm/arch-davinci/memory.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/memory.h
@@ -0,0 +1,64 @@
+/*
+ * DaVinci memory space definitions
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __ASM_ARCH_MEMORY_H
+#define __ASM_ARCH_MEMORY_H
+
+/**************************************************************************
+ * Included Files
+ **************************************************************************/
+#include <asm/page.h>
+#include <asm/sizes.h>
+
+/**************************************************************************
+ * Definitions
+ **************************************************************************/
+#define DAVINCI_DDR_BASE    0x80000000
+#define DAVINCI_IRAM_BASE   0x00008000 /* ARM Internal RAM */
+
+#define PHYS_OFFSET DAVINCI_DDR_BASE
+
+/*
+ * Increase size of DMA-consistent memory region
+ */
+#define CONSISTENT_DMA_SIZE (14<<20)
+
+#ifndef __ASSEMBLY__
+/*
+ * Restrict DMA-able region to workaround silicon bug.  The bug
+ * restricts buffers available for DMA to video hardware to be
+ * below 128M
+ */
+static inline void
+__arch_adjust_zones(int node, unsigned long *size, unsigned long *holes)
+{
+	unsigned int sz = (128<<20) >> PAGE_SHIFT;
+
+	if (node != 0)
+		sz = 0;
+
+	size[1] = size[0] - sz;
+	size[0] = sz;
+}
+
+#define arch_adjust_zones(node, zone_size, holes) \
+        if ((meminfo.bank[0].size >> 20) > 128) __arch_adjust_zones(node, zone_size, holes)
+
+#define ISA_DMA_THRESHOLD	(PHYS_OFFSET + (128<<20) - 1)
+
+#endif
+
+/*
+ * Bus address is physical address
+ */
+#define __virt_to_bus(x)	__virt_to_phys(x)
+#define __bus_to_virt(x)	__phys_to_virt(x)
+
+#endif /* __ASM_ARCH_MEMORY_H */
Index: linux-2.6.18/include/asm-arm/arch-davinci/psc.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/psc.h
@@ -0,0 +1,76 @@
+/*
+ *  DaVinci Power & Sleep Controller (PSC) defines
+ *
+ *  Copyright (C) 2006 Texas Instruments.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#ifndef __ASM_ARCH_PSC_H
+#define __ASM_ARCH_PSC_H
+
+/* Power and Sleep Controller (PSC) Domains */
+#define DAVINCI_GPSC_ARMDOMAIN      0
+#define DAVINCI_GPSC_DSPDOMAIN      1
+
+#define DAVINCI_LPSC_VPSSMSTR       0
+#define DAVINCI_LPSC_VPSSSLV        1
+#define DAVINCI_LPSC_TPCC           2
+#define DAVINCI_LPSC_TPTC0          3
+#define DAVINCI_LPSC_TPTC1          4
+#define DAVINCI_LPSC_EMAC           5
+#define DAVINCI_LPSC_EMAC_WRAPPER   6
+#define DAVINCI_LPSC_MDIO           7
+#define DAVINCI_LPSC_IEEE1394       8
+#define DAVINCI_LPSC_USB            9
+#define DAVINCI_LPSC_ATA            10
+#define DAVINCI_LPSC_VLYNQ          11
+#define DAVINCI_LPSC_UHPI           12
+#define DAVINCI_LPSC_DDR_EMIF       13
+#define DAVINCI_LPSC_AEMIF          14
+#define DAVINCI_LPSC_MMC_SD         15
+#define DAVINCI_LPSC_MEMSTICK       16
+#define DAVINCI_LPSC_McBSP          17
+#define DAVINCI_LPSC_I2C            18
+#define DAVINCI_LPSC_UART0          19
+#define DAVINCI_LPSC_UART1          20
+#define DAVINCI_LPSC_UART2          21
+#define DAVINCI_LPSC_SPI            22
+#define DAVINCI_LPSC_PWM0           23
+#define DAVINCI_LPSC_PWM1           24
+#define DAVINCI_LPSC_PWM2           25
+#define DAVINCI_LPSC_GPIO           26
+#define DAVINCI_LPSC_TIMER0         27
+#define DAVINCI_LPSC_TIMER1         28
+#define DAVINCI_LPSC_TIMER2         29
+#define DAVINCI_LPSC_SYSTEM_SUBSYS  30
+#define DAVINCI_LPSC_ARM            31
+#define DAVINCI_LPSC_SCR2           32
+#define DAVINCI_LPSC_SCR3           33
+#define DAVINCI_LPSC_SCR4           34
+#define DAVINCI_LPSC_CROSSBAR       35
+#define DAVINCI_LPSC_CFG27          36
+#define DAVINCI_LPSC_CFG3           37
+#define DAVINCI_LPSC_CFG5           38
+#define DAVINCI_LPSC_GEM            39
+#define DAVINCI_LPSC_IMCOP          40
+
+#endif /* __ASM_ARCH_PSC_H */
Index: linux-2.6.18/include/asm-arm/arch-davinci/serial.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/serial.h
@@ -0,0 +1,20 @@
+/*
+ * DaVinci serial device definitions
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __ASM_ARCH_SERIAL_H
+#define __ASM_ARCH_SERIAL_H
+
+#include <asm/arch/io.h>
+
+#define DAVINCI_UART0_BASE   (IO_PHYS + 0x20000)
+#define DAVINCI_UART1_BASE   (IO_PHYS + 0x20400)
+#define DAVINCI_UART2_BASE   (IO_PHYS + 0x20800)
+
+#endif /* __ASM_ARCH_SERIAL_H */
Index: linux-2.6.18/include/asm-arm/arch-davinci/system.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/system.h
@@ -0,0 +1,29 @@
+/*
+ * DaVinci system defines
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __ASM_ARCH_SYSTEM_H
+#define __ASM_ARCH_SYSTEM_H
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+
+extern void davinci_watchdog_reset(void);
+
+static void arch_idle(void)
+{
+	cpu_do_idle();
+}
+
+static void arch_reset(char mode)
+{
+	davinci_watchdog_reset();
+}
+
+#endif /* __ASM_ARCH_SYSTEM_H */
Index: linux-2.6.18/include/asm-arm/arch-davinci/timex.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/timex.h
@@ -0,0 +1,17 @@
+/*
+ * DaVinci timer defines
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __ASM_ARCH_TIMEX_H
+#define __ASM_ARCH_TIMEX_H
+
+/* The source frequency for the timers is the 27MHz clock */
+#define CLOCK_TICK_RATE 27000000
+
+#endif /* __ASM_ARCH_TIMEX_H__ */
Index: linux-2.6.18/include/asm-arm/arch-davinci/uncompress.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/uncompress.h
@@ -0,0 +1,35 @@
+/*
+ * Serial port stubs for kernel decompress status messages
+ *
+ *  Author:     Anant Gole
+ * (C) Copyright (C) 2006, Texas Instruments, Inc
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/types.h>
+#include <linux/serial_reg.h>
+#include <asm/arch/serial.h>
+
+/* PORT_16C550A, in polled non-fifo mode */
+
+static void putc(char c)
+{
+	volatile u32 *uart = (volatile void *) DAVINCI_UART0_BASE;
+
+	while (!(uart[UART_LSR] & UART_LSR_THRE))
+		barrier();
+	uart[UART_TX] = c;
+}
+
+static inline void flush(void)
+{
+	volatile u32 *uart = (volatile void *) DAVINCI_UART0_BASE;
+	while (!(uart[UART_LSR] & UART_LSR_THRE))
+		barrier();
+}
+
+#define arch_decomp_setup()
+#define arch_decomp_wdog()
Index: linux-2.6.18/include/asm-arm/arch-davinci/vmalloc.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/asm-arm/arch-davinci/vmalloc.h
@@ -0,0 +1,15 @@
+/*
+ * DaVinci vmalloc definitions
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <asm/memory.h>
+#include <asm/arch/io.h>
+
+/* Allow vmalloc range until the IO virtual range minus a 2M "hole" */
+#define VMALLOC_END	  (IO_VIRT - (2<<20))
Index: linux-2.6.18/mvl_patches/pro50-1491.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-1491.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1491);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

