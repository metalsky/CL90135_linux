#! /usr/bin/env bash
# Patch: -pro_musb_hdrc_Search_and_replace_pBase_with_mbase
# Date: Fri Sep 19 14:06:55 2008
# From 2a4ae24beef4feb257284f329bf8f1855d0f0762 Mon Sep 17 00:00:00 2001
# From: Tony Lindgren <tony@atomide.com>
# Date: Mon, 13 Aug 2007 02:50:41 -0700
# Subject: [PATCH] musb_hdrc: Search and replace pBase with mbase
# 
# Search and replace pBase with mbase
# 
# Signed-off-by: Tony Lindgren <tony@atomide.com>
# (cherry picked from commit 6dd28da2e2424d06a160a23a9897dacd500ca1cf)

PATCHNUM=1663
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
From 2a4ae24beef4feb257284f329bf8f1855d0f0762 Mon Sep 17 00:00:00 2001
From: Tony Lindgren <tony@atomide.com>
Date: Mon, 13 Aug 2007 02:50:41 -0700
Subject: [PATCH] musb_hdrc: Search and replace pBase with mbase

Search and replace pBase with mbase

Signed-off-by: Tony Lindgren <tony@atomide.com>
(cherry picked from commit 6dd28da2e2424d06a160a23a9897dacd500ca1cf)
Index: linux-2.6.18/drivers/usb/musb/g_ep0.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/g_ep0.c
+++ linux-2.6.18/drivers/usb/musb/g_ep0.c
@@ -74,7 +74,7 @@ static int service_tx_status_request(
 	struct musb *musb,
 	const struct usb_ctrlrequest *pControlRequest)
 {
-	void __iomem	*pBase = musb->mregs;
+	void __iomem	*mbase = musb->mregs;
 	int handled = 1;
 	u8 bResult[2], bEnd = 0;
 	const u8 bRecip = pControlRequest->bRequestType & USB_RECIP_MASK;
@@ -127,14 +127,14 @@ static int service_tx_status_request(
 			break;
 		}
 
-		MGC_SelectEnd(pBase, bEnd);
+		MGC_SelectEnd(mbase, bEnd);
 		if (is_in)
 			tmp = musb_readw(regs, MGC_O_HDRC_TXCSR)
 						& MGC_M_TXCSR_P_SENDSTALL;
 		else
 			tmp = musb_readw(regs, MGC_O_HDRC_RXCSR)
 						& MGC_M_RXCSR_P_SENDSTALL;
-		MGC_SelectEnd(pBase, 0);
+		MGC_SelectEnd(mbase, 0);
 
 		bResult[0] = tmp ? 1 : 0;
 		} break;
@@ -205,12 +205,12 @@ static void musb_g_ep0_giveback(struct m
  */
 static inline void musb_try_b_hnp_enable(struct musb *musb)
 {
-	void __iomem	*pBase = musb->mregs;
+	void __iomem	*mbase = musb->mregs;
 	u8		devctl;
 
 	DBG(1, "HNP: Setting HR\n");
-	devctl = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
-	musb_writeb(pBase, MGC_O_HDRC_DEVCTL, devctl | MGC_M_DEVCTL_HR);
+	devctl = musb_readb(mbase, MGC_O_HDRC_DEVCTL);
+	musb_writeb(mbase, MGC_O_HDRC_DEVCTL, devctl | MGC_M_DEVCTL_HR);
 }
 
 /*
@@ -230,7 +230,7 @@ __releases(musb->Lock)
 __acquires(musb->Lock)
 {
 	int handled = -EINVAL;
-	void __iomem *pBase = musb->mregs;
+	void __iomem *mbase = musb->mregs;
 	const u8 bRecip = pControlRequest->bRequestType & USB_RECIP_MASK;
 
 	/* the gadget driver handles everything except what we MUST handle */
@@ -278,7 +278,7 @@ __acquires(musb->Lock)
 				spin_lock(&musb->Lock);
 
 				/* select ep0 again */
-				MGC_SelectEnd(pBase, 0);
+				MGC_SelectEnd(mbase, 0);
 				handled = 1;
 				} break;
 			default:
@@ -388,7 +388,7 @@ stall:
 				if (!musb_ep->desc)
 					break;
 
-				MGC_SelectEnd(pBase, bEnd);
+				MGC_SelectEnd(mbase, bEnd);
 				if (is_in) {
 					csr = musb_readw(regs,
 							MGC_O_HDRC_TXCSR);
@@ -411,7 +411,7 @@ stall:
 				}
 
 				/* select ep0 again */
-				MGC_SelectEnd(pBase, 0);
+				MGC_SelectEnd(mbase, 0);
 				handled = 1;
 				} break;
 
@@ -600,17 +600,17 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 {
 	u16		wCsrVal;
 	u16		wCount;
-	void __iomem	*pBase = musb->mregs;
+	void __iomem	*mbase = musb->mregs;
 	void __iomem	*regs = musb->aLocalEnd[0].regs;
 	irqreturn_t	retval = IRQ_NONE;
 
-	MGC_SelectEnd(pBase, 0);	/* select ep0 */
+	MGC_SelectEnd(mbase, 0);	/* select ep0 */
 	wCsrVal = musb_readw(regs, MGC_O_HDRC_CSR0);
 	wCount = musb_readb(regs, MGC_O_HDRC_COUNT0);
 
 	DBG(4, "csr %04x, count %d, myaddr %d, ep0stage %s\n",
 			wCsrVal, wCount,
-			musb_readb(pBase, MGC_O_HDRC_FADDR),
+			musb_readb(mbase, MGC_O_HDRC_FADDR),
 			decode_ep0stage(musb->ep0_state));
 
 	/* I sent a stall.. need to acknowledge it now.. */
@@ -663,7 +663,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 		 */
 		if (musb->bSetAddress) {
 			musb->bSetAddress = FALSE;
-			musb_writeb(pBase, MGC_O_HDRC_FADDR, musb->bAddress);
+			musb_writeb(mbase, MGC_O_HDRC_FADDR, musb->bAddress);
 		}
 
 		/* enter test mode if needed (exit by reset) */
@@ -673,7 +673,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 			if (MGC_M_TEST_PACKET == musb->bTestModeValue)
 				musb_load_testpacket(musb);
 
-			musb_writeb(pBase, MGC_O_HDRC_TESTMODE,
+			musb_writeb(mbase, MGC_O_HDRC_TESTMODE,
 					musb->bTestModeValue);
 		}
 		/* FALLTHROUGH */
@@ -710,7 +710,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 				printk(KERN_NOTICE "%s: peripheral reset "
 						"irq lost!\n",
 						musb_driver_name);
-				power = musb_readb(pBase, MGC_O_HDRC_POWER);
+				power = musb_readb(mbase, MGC_O_HDRC_POWER);
 				musb->g.speed = (power & MGC_M_POWER_HSMODE)
 					? USB_SPEED_HIGH : USB_SPEED_FULL;
 
@@ -769,7 +769,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 
 			handled = forward_to_driver(musb, &setup);
 			if (handled < 0) {
-				MGC_SelectEnd(pBase, 0);
+				MGC_SelectEnd(mbase, 0);
 stall:
 				DBG(3, "stall (%d)\n", handled);
 				musb->ackpend |= MGC_M_CSR0_P_SENDSTALL;
Index: linux-2.6.18/drivers/usb/musb/musb_gadget.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_gadget.c
+++ linux-2.6.18/drivers/usb/musb/musb_gadget.c
@@ -406,12 +406,12 @@ void musb_g_tx(struct musb *musb, u8 bEn
 {
 	u16			wCsrVal;
 	struct usb_request	*pRequest;
-	u8 __iomem		*pBase = musb->mregs;
+	u8 __iomem		*mbase = musb->mregs;
 	struct musb_ep		*musb_ep = &musb->aLocalEnd[bEnd].ep_in;
 	void __iomem		*epio = musb->aLocalEnd[bEnd].regs;
 	struct dma_channel	*dma;
 
-	MGC_SelectEnd(pBase, bEnd);
+	MGC_SelectEnd(mbase, bEnd);
 	pRequest = next_request(musb_ep);
 
 	wCsrVal = musb_readw(epio, MGC_O_HDRC_TXCSR);
@@ -514,7 +514,7 @@ void musb_g_tx(struct musb *musb, u8 bEn
 				 * REVISIT for double buffering...
 				 * FIXME revisit for stalls too...
 				 */
-				MGC_SelectEnd(pBase, bEnd);
+				MGC_SelectEnd(mbase, bEnd);
 				wCsrVal = musb_readw(epio, MGC_O_HDRC_TXCSR);
 				if (wCsrVal & MGC_M_TXCSR_FIFONOTEMPTY)
 					break;
@@ -736,12 +736,12 @@ void musb_g_rx(struct musb *musb, u8 bEn
 {
 	u16			wCsrVal;
 	struct usb_request	*pRequest;
-	void __iomem		*pBase = musb->mregs;
+	void __iomem		*mbase = musb->mregs;
 	struct musb_ep		*musb_ep = &musb->aLocalEnd[bEnd].ep_out;
 	void __iomem		*epio = musb->aLocalEnd[bEnd].regs;
 	struct dma_channel	*dma;
 
-	MGC_SelectEnd(pBase, bEnd);
+	MGC_SelectEnd(mbase, bEnd);
 
 	pRequest = next_request(musb_ep);
 
@@ -826,7 +826,7 @@ void musb_g_rx(struct musb *musb, u8 bEn
 			goto done;
 
 		/* don't start more i/o till the stall clears */
-		MGC_SelectEnd(pBase, bEnd);
+		MGC_SelectEnd(mbase, bEnd);
 		wCsrVal = musb_readw(epio, MGC_O_HDRC_RXCSR);
 		if (wCsrVal & MGC_M_RXCSR_P_SENDSTALL)
 			goto done;
@@ -855,7 +855,7 @@ static int musb_gadget_enable(struct usb
 	struct musb_hw_ep	*hw_ep;
 	void __iomem		*regs;
 	struct musb		*musb;
-	void __iomem	*pBase;
+	void __iomem	*mbase;
 	u8		bEnd;
 	u16		csr;
 	unsigned	tmp;
@@ -868,7 +868,7 @@ static int musb_gadget_enable(struct usb
 	hw_ep = musb_ep->hw_ep;
 	regs = hw_ep->regs;
 	musb = musb_ep->musb;
-	pBase = musb->mregs;
+	mbase = musb->mregs;
 	bEnd = musb_ep->bEndNumber;
 
 	spin_lock_irqsave(&musb->Lock, flags);
@@ -892,9 +892,9 @@ static int musb_gadget_enable(struct usb
 	/* enable the interrupts for the endpoint, set the endpoint
 	 * packet size (or fail), set the mode, clear the fifo
 	 */
-	MGC_SelectEnd(pBase, bEnd);
+	MGC_SelectEnd(mbase, bEnd);
 	if (desc->bEndpointAddress & USB_DIR_IN) {
-		u16 wIntrTxE = musb_readw(pBase, MGC_O_HDRC_INTRTXE);
+		u16 wIntrTxE = musb_readw(mbase, MGC_O_HDRC_INTRTXE);
 
 		if (hw_ep->bIsSharedFifo)
 			musb_ep->is_in = 1;
@@ -904,7 +904,7 @@ static int musb_gadget_enable(struct usb
 			goto fail;
 
 		wIntrTxE |= (1 << bEnd);
-		musb_writew(pBase, MGC_O_HDRC_INTRTXE, wIntrTxE);
+		musb_writew(mbase, MGC_O_HDRC_INTRTXE, wIntrTxE);
 
 		/* REVISIT if can_bulk_split(), use by updating "tmp";
 		 * likewise high bandwidth periodic tx
@@ -924,7 +924,7 @@ static int musb_gadget_enable(struct usb
 		musb_writew(regs, MGC_O_HDRC_TXCSR, csr);
 
 	} else {
-		u16 wIntrRxE = musb_readw(pBase, MGC_O_HDRC_INTRRXE);
+		u16 wIntrRxE = musb_readw(mbase, MGC_O_HDRC_INTRRXE);
 
 		if (hw_ep->bIsSharedFifo)
 			musb_ep->is_in = 0;
@@ -934,7 +934,7 @@ static int musb_gadget_enable(struct usb
 			goto fail;
 
 		wIntrRxE |= (1 << bEnd);
-		musb_writew(pBase, MGC_O_HDRC_INTRRXE, wIntrRxE);
+		musb_writew(mbase, MGC_O_HDRC_INTRRXE, wIntrRxE);
 
 		/* REVISIT if can_bulk_combine() use by updating "tmp"
 		 * likewise high bandwidth periodic rx
@@ -1285,7 +1285,7 @@ int musb_gadget_set_halt(struct usb_ep *
 	u8			bEnd = musb_ep->bEndNumber;
 	struct musb		*musb = musb_ep->musb;
 	void __iomem		*epio = musb->aLocalEnd[bEnd].regs;
-	void __iomem		*pBase;
+	void __iomem		*mbase;
 	unsigned long		flags;
 	u16			wCsr;
 	struct musb_request	*pRequest = NULL;
@@ -1293,7 +1293,7 @@ int musb_gadget_set_halt(struct usb_ep *
 
 	if (!ep)
 		return -EINVAL;
-	pBase = musb->mregs;
+	mbase = musb->mregs;
 
 	spin_lock_irqsave(&musb->Lock, flags);
 
@@ -1302,7 +1302,7 @@ int musb_gadget_set_halt(struct usb_ep *
 		goto done;
 	}
 
-	MGC_SelectEnd(pBase, bEnd);
+	MGC_SelectEnd(mbase, bEnd);
 
 	/* cannot portably stall with non-empty FIFO */
 	pRequest = to_musb_request(next_request(musb_ep));
@@ -2034,14 +2034,14 @@ void musb_g_reset(struct musb *musb)
 __releases(musb->Lock)
 __acquires(musb->Lock)
 {
-	void __iomem	*pBase = musb->mregs;
-	u8		devctl = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
+	void __iomem	*mbase = musb->mregs;
+	u8		devctl = musb_readb(mbase, MGC_O_HDRC_DEVCTL);
 	u8		power;
 
 	DBG(3, "<== %s addr=%x driver '%s'\n",
 			(devctl & MGC_M_DEVCTL_BDEVICE)
 				? "B-Device" : "A-Device",
-			musb_readb(pBase, MGC_O_HDRC_FADDR),
+			musb_readb(mbase, MGC_O_HDRC_FADDR),
 			musb->pGadgetDriver
 				? musb->pGadgetDriver->driver.name
 				: NULL
@@ -2053,11 +2053,11 @@ __acquires(musb->Lock)
 
 	/* clear HR */
 	else if (devctl & MGC_M_DEVCTL_HR)
-		musb_writeb(pBase, MGC_O_HDRC_DEVCTL, MGC_M_DEVCTL_SESSION);
+		musb_writeb(mbase, MGC_O_HDRC_DEVCTL, MGC_M_DEVCTL_SESSION);
 
 
 	/* what speed did we negotiate? */
-	power = musb_readb(pBase, MGC_O_HDRC_POWER);
+	power = musb_readb(mbase, MGC_O_HDRC_POWER);
 	musb->g.speed = (power & MGC_M_POWER_HSMODE)
 			? USB_SPEED_HIGH : USB_SPEED_FULL;
 
Index: linux-2.6.18/drivers/usb/musb/musb_host.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_host.c
+++ linux-2.6.18/drivers/usb/musb/musb_host.c
@@ -172,7 +172,7 @@ musb_start_urb(struct musb *musb, int is
 	u16			wFrame;
 	u32			dwLength;
 	void			*pBuffer;
-	void __iomem		*pBase =  musb->mregs;
+	void __iomem		*mbase =  musb->mregs;
 	struct urb		*urb = next_urb(qh);
 	struct musb_hw_ep	*hw_ep = qh->hw_ep;
 	unsigned		nPipe = urb->pipe;
@@ -232,7 +232,7 @@ musb_start_urb(struct musb *musb, int is
 	case USB_ENDPOINT_XFER_INT:
 		DBG(3, "check whether there's still time for periodic Tx\n");
 		qh->iso_idx = 0;
-		wFrame = musb_readw(pBase, MGC_O_HDRC_FRAME);
+		wFrame = musb_readw(mbase, MGC_O_HDRC_FRAME);
 		/* FIXME this doesn't implement that scheduling policy ...
 		 * or handle framecounter wrapping
 		 */
@@ -248,7 +248,7 @@ musb_start_urb(struct musb *musb, int is
 			/* enable SOF interrupt so we can count down */
 DBG(1,"SOF for %d\n", bEnd);
 #if 1 // ifndef	CONFIG_ARCH_DAVINCI
-			musb_writeb(pBase, MGC_O_HDRC_INTRUSBE, 0xff);
+			musb_writeb(mbase, MGC_O_HDRC_INTRUSBE, 0xff);
 #endif
 		}
 		break;
@@ -481,7 +481,7 @@ static u8 musb_host_packet_rx(struct mus
 	int			nPipe = pUrb->pipe;
 	void			*buffer = pUrb->transfer_buffer;
 
-	// MGC_SelectEnd(pBase, bEnd);
+	// MGC_SelectEnd(mbase, bEnd);
 	wRxCount = musb_readw(epio, MGC_O_HDRC_RXCOUNT);
 	DBG(3, "RX%d count %d, buffer %p len %d/%d\n", bEnd, wRxCount,
 			pUrb->transfer_buffer, qh->offset,
@@ -630,7 +630,7 @@ static void musb_ep_program(struct musb 
 	struct dma_controller	*pDmaController;
 	struct dma_channel	*pDmaChannel;
 	u8			bDmaOk;
-	void __iomem		*pBase = musb->mregs;
+	void __iomem		*mbase = musb->mregs;
 	struct musb_hw_ep	*hw_ep = musb->aLocalEnd + bEnd;
 	void __iomem		*epio = hw_ep->regs;
 	struct musb_qh		*qh;
@@ -651,7 +651,7 @@ static void musb_ep_program(struct musb 
 			qh->h_addr_reg, qh->h_port_reg,
 			dwLength);
 
-	MGC_SelectEnd(pBase, bEnd);
+	MGC_SelectEnd(mbase, bEnd);
 
 	/* candidate for DMA? */
 	pDmaController = musb->pDmaController;
@@ -679,8 +679,8 @@ static void musb_ep_program(struct musb 
 		wCsr = musb_readw(epio, MGC_O_HDRC_TXCSR);
 
 		/* disable interrupt in case we flush */
-		wIntrTxE = musb_readw(pBase, MGC_O_HDRC_INTRTXE);
-		musb_writew(pBase, MGC_O_HDRC_INTRTXE, wIntrTxE & ~(1 << bEnd));
+		wIntrTxE = musb_readw(mbase, MGC_O_HDRC_INTRTXE);
+		musb_writew(mbase, MGC_O_HDRC_INTRTXE, wIntrTxE & ~(1 << bEnd));
 
 		/* general endpoint setup */
 		if (bEnd) {
@@ -721,18 +721,18 @@ static void musb_ep_program(struct musb 
 
 		/* target addr and (for multipoint) hub addr/port */
 		if (musb->bIsMultipoint) {
-			musb_writeb(pBase,
+			musb_writeb(mbase,
 				MGC_BUSCTL_OFFSET(bEnd, MGC_O_HDRC_TXFUNCADDR),
 				qh->addr_reg);
-			musb_writeb(pBase,
+			musb_writeb(mbase,
 				MGC_BUSCTL_OFFSET(bEnd, MGC_O_HDRC_TXHUBADDR),
 				qh->h_addr_reg);
-			musb_writeb(pBase,
+			musb_writeb(mbase,
 				MGC_BUSCTL_OFFSET(bEnd, MGC_O_HDRC_TXHUBPORT),
 				qh->h_port_reg);
 /* FIXME if !bEnd, do the same for RX ... */
 		} else
-			musb_writeb(pBase, MGC_O_HDRC_FADDR, qh->addr_reg);
+			musb_writeb(mbase, MGC_O_HDRC_FADDR, qh->addr_reg);
 
 		/* protocol/endpoint/interval/NAKlimit */
 		if (bEnd) {
@@ -868,7 +868,7 @@ static void musb_ep_program(struct musb 
 		}
 
 		/* re-enable interrupt */
-		musb_writew(pBase, MGC_O_HDRC_INTRTXE, wIntrTxE);
+		musb_writew(mbase, MGC_O_HDRC_INTRTXE, wIntrTxE);
 
 	/* IN/receive */
 	} else {
@@ -1023,7 +1023,7 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 	struct urb		*pUrb;
 	u16			wCsrVal, wCount;
 	int			status = 0;
-	void __iomem		*pBase = musb->mregs;
+	void __iomem		*mbase = musb->mregs;
 	struct musb_hw_ep	*hw_ep = musb->control_ep;
 	void __iomem		*epio = hw_ep->regs;
 	struct musb_qh		*qh = hw_ep->in_qh;
@@ -1033,7 +1033,7 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 	/* ep0 only has one queue, "in" */
 	pUrb = next_urb(qh);
 
-	MGC_SelectEnd(pBase, 0);
+	MGC_SelectEnd(mbase, 0);
 	wCsrVal = musb_readw(epio, MGC_O_HDRC_CSR0);
 	wCount = (wCsrVal & MGC_M_CSR0_RXPKTRDY)
 			? musb_readb(epio, MGC_O_HDRC_COUNT0)
@@ -1174,12 +1174,12 @@ void musb_host_tx(struct musb *musb, u8 
 	void __iomem		*epio = hw_ep->regs;
 	struct musb_qh		*qh = hw_ep->out_qh;
 	u32			status = 0;
-	void __iomem		*pBase = musb->mregs;
+	void __iomem		*mbase = musb->mregs;
 	struct dma_channel	*dma;
 
 	pUrb = next_urb(qh);
 
-	MGC_SelectEnd(pBase, bEnd);
+	MGC_SelectEnd(mbase, bEnd);
 	wTxCsrVal = musb_readw(epio, MGC_O_HDRC_TXCSR);
 
 	/* with CPPI, DMA sometimes triggers "extra" irqs */
@@ -1217,7 +1217,7 @@ void musb_host_tx(struct musb *musb, u8 
 		 * if (bulk && qh->ring.next != &musb->out_bulk), then
 		 * we have a candidate... NAKing is *NOT* an error
 		 */
-		MGC_SelectEnd(pBase, bEnd);
+		MGC_SelectEnd(mbase, bEnd);
 		musb_writew(epio, MGC_O_HDRC_CSR0,
 				MGC_M_TXCSR_H_WZC_BITS
 				| MGC_M_TXCSR_TXPKTRDY);
@@ -1241,7 +1241,7 @@ void musb_host_tx(struct musb *musb, u8 
 				| MGC_M_TXCSR_H_NAKTIMEOUT
 				);
 
-		MGC_SelectEnd(pBase, bEnd);
+		MGC_SelectEnd(mbase, bEnd);
 		musb_writew(epio, MGC_O_HDRC_TXCSR, wTxCsrVal);
 		/* REVISIT may need to clear FLUSHFIFO ... */
 		musb_writew(epio, MGC_O_HDRC_TXCSR, wTxCsrVal);
@@ -1323,7 +1323,7 @@ void musb_host_tx(struct musb *musb, u8 
 		musb_write_fifo(hw_ep, wLength, pBuffer);
 		qh->segsize = wLength;
 
-		MGC_SelectEnd(pBase, bEnd);
+		MGC_SelectEnd(mbase, bEnd);
 		musb_writew(epio, MGC_O_HDRC_TXCSR,
 				MGC_M_TXCSR_H_WZC_BITS | MGC_M_TXCSR_TXPKTRDY);
 	} else
@@ -1384,7 +1384,7 @@ void musb_host_rx(struct musb *musb, u8 
 	void __iomem		*epio = hw_ep->regs;
 	struct musb_qh		*qh = hw_ep->in_qh;
 	size_t			xfer_len;
-	void __iomem		*pBase = musb->mregs;
+	void __iomem		*mbase = musb->mregs;
 	int			nPipe;
 	u16			wRxCsrVal, wVal;
 	u8			bIsochError = FALSE;
@@ -1392,7 +1392,7 @@ void musb_host_rx(struct musb *musb, u8 
 	u32			status;
 	struct dma_channel	*dma;
 
-	MGC_SelectEnd(pBase, bEnd);
+	MGC_SelectEnd(mbase, bEnd);
 
 	pUrb = next_urb(qh);
 	dma = is_dma_capable() ? hw_ep->rx_channel : NULL;
@@ -1443,7 +1443,7 @@ void musb_host_rx(struct musb *musb, u8 
 			 * we have a candidate... NAKing is *NOT* an error
 			 */
 			DBG(6, "RX end %d NAK timeout\n", bEnd);
-			MGC_SelectEnd(pBase, bEnd);
+			MGC_SelectEnd(mbase, bEnd);
 			musb_writew(epio, MGC_O_HDRC_RXCSR,
 					MGC_M_RXCSR_H_WZC_BITS
 					| MGC_M_RXCSR_H_REQPKT);
@@ -1501,7 +1501,7 @@ void musb_host_rx(struct musb *musb, u8 
 				xfer_len, dma ? ", dma" : "");
 		wRxCsrVal &= ~MGC_M_RXCSR_H_REQPKT;
 
-		MGC_SelectEnd(pBase, bEnd);
+		MGC_SelectEnd(mbase, bEnd);
 		musb_writew(epio, MGC_O_HDRC_RXCSR,
 				MGC_M_RXCSR_H_WZC_BITS | wRxCsrVal);
 	}
@@ -1545,7 +1545,7 @@ void musb_host_rx(struct musb *musb, u8 
 
 // SCRUB (RX)
 			/* do the proper sequence to abort the transfer */
-			MGC_SelectEnd(pBase, bEnd);
+			MGC_SelectEnd(mbase, bEnd);
 			wVal &= ~MGC_M_RXCSR_H_REQPKT;
 			musb_writew(epio, MGC_O_HDRC_RXCSR, wVal);
 			goto finish;
Index: linux-2.6.18/drivers/usb/musb/musb_procfs.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_procfs.c
+++ linux-2.6.18/drivers/usb/musb/musb_procfs.c
@@ -485,14 +485,14 @@ dump_end_info(struct musb *musb, u8 bEnd
 static int dump_header_stats(struct musb *musb, char *buffer)
 {
 	int code, count = 0;
-	const void __iomem *pBase = musb->mregs;
+	const void __iomem *mbase = musb->mregs;
 
 	*buffer = 0;
 	count = sprintf(buffer, "Status: %sHDRC, Mode=%s "
 				"(Power=%02x, DevCtl=%02x)\n",
 			(musb->bIsMultipoint ? "M" : ""), MUSB_MODE(musb),
-			musb_readb(pBase, MGC_O_HDRC_POWER),
-			musb_readb(pBase, MGC_O_HDRC_DEVCTL));
+			musb_readb(mbase, MGC_O_HDRC_POWER),
+			musb_readb(mbase, MGC_O_HDRC_DEVCTL));
 	if (count <= 0)
 		return 0;
 	buffer += count;
@@ -653,7 +653,7 @@ static int musb_proc_write(struct file *
 	char cmd;
 	u8 bReg;
 	struct musb *musb = (struct musb *)data;
-	void __iomem *pBase = musb->mregs;
+	void __iomem *mbase = musb->mregs;
 
 	/* MOD_INC_USE_COUNT; */
 
@@ -662,65 +662,65 @@ static int musb_proc_write(struct file *
 
 	switch (cmd) {
 	case 'C':
-		if (pBase) {
-			bReg = musb_readb(pBase, MGC_O_HDRC_POWER)
+		if (mbase) {
+			bReg = musb_readb(mbase, MGC_O_HDRC_POWER)
 					| MGC_M_POWER_SOFTCONN;
-			musb_writeb(pBase, MGC_O_HDRC_POWER, bReg);
+			musb_writeb(mbase, MGC_O_HDRC_POWER, bReg);
 		}
 		break;
 
 	case 'c':
-		if (pBase) {
-			bReg = musb_readb(pBase, MGC_O_HDRC_POWER)
+		if (mbase) {
+			bReg = musb_readb(mbase, MGC_O_HDRC_POWER)
 					& ~MGC_M_POWER_SOFTCONN;
-			musb_writeb(pBase, MGC_O_HDRC_POWER, bReg);
+			musb_writeb(mbase, MGC_O_HDRC_POWER, bReg);
 		}
 		break;
 
 	case 'I':
-		if (pBase) {
-			bReg = musb_readb(pBase, MGC_O_HDRC_POWER)
+		if (mbase) {
+			bReg = musb_readb(mbase, MGC_O_HDRC_POWER)
 					| MGC_M_POWER_HSENAB;
-			musb_writeb(pBase, MGC_O_HDRC_POWER, bReg);
+			musb_writeb(mbase, MGC_O_HDRC_POWER, bReg);
 		}
 		break;
 
 	case 'i':
-		if (pBase) {
-			bReg = musb_readb(pBase, MGC_O_HDRC_POWER)
+		if (mbase) {
+			bReg = musb_readb(mbase, MGC_O_HDRC_POWER)
 					& ~MGC_M_POWER_HSENAB;
-			musb_writeb(pBase, MGC_O_HDRC_POWER, bReg);
+			musb_writeb(mbase, MGC_O_HDRC_POWER, bReg);
 		}
 		break;
 
 	case 'F':
-		bReg = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
+		bReg = musb_readb(mbase, MGC_O_HDRC_DEVCTL);
 		bReg |= MGC_M_DEVCTL_SESSION;
-		musb_writeb(pBase, MGC_O_HDRC_DEVCTL, bReg);
+		musb_writeb(mbase, MGC_O_HDRC_DEVCTL, bReg);
 		break;
 
 	case 'H':
-		if (pBase) {
-			bReg = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
+		if (mbase) {
+			bReg = musb_readb(mbase, MGC_O_HDRC_DEVCTL);
 			bReg |= MGC_M_DEVCTL_HR;
-			musb_writeb(pBase, MGC_O_HDRC_DEVCTL, bReg);
+			musb_writeb(mbase, MGC_O_HDRC_DEVCTL, bReg);
 			//MUSB_HST_MODE( ((struct musb*)data) );
 			//WARN("Host Mode\n");
 		}
 		break;
 
 	case 'h':
-		if (pBase) {
-			bReg = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
+		if (mbase) {
+			bReg = musb_readb(mbase, MGC_O_HDRC_DEVCTL);
 			bReg &= ~MGC_M_DEVCTL_HR;
-			musb_writeb(pBase, MGC_O_HDRC_DEVCTL, bReg);
+			musb_writeb(mbase, MGC_O_HDRC_DEVCTL, bReg);
 		}
 		break;
 
 	case 'T':
-		if (pBase) {
+		if (mbase) {
 			musb_load_testpacket(musb);
-			musb_writeb(pBase, MGC_O_HDRC_TESTMODE,
+			musb_writeb(mbase, MGC_O_HDRC_TESTMODE,
 					MGC_M_TEST_PACKET);
 		}
 		break;
Index: linux-2.6.18/drivers/usb/musb/musbdefs.h
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musbdefs.h
+++ linux-2.6.18/drivers/usb/musb/musbdefs.h
@@ -218,19 +218,19 @@ enum musb_g_ep0_state {
 
 /* TUSB mapping: "flat" plus ep0 special cases */
 #if	defined(CONFIG_USB_TUSB6010)
-#define MGC_SelectEnd(_pBase, _bEnd) \
-	musb_writeb((_pBase), MGC_O_HDRC_INDEX, (_bEnd))
+#define MGC_SelectEnd(_mbase, _bEnd) \
+	musb_writeb((_mbase), MGC_O_HDRC_INDEX, (_bEnd))
 #define	MGC_END_OFFSET			MGC_TUSB_OFFSET
 
 /* "flat" mapping: each endpoint has its own i/o address */
 #elif	defined(MUSB_FLAT_REG)
-#define MGC_SelectEnd(_pBase, _bEnd)	(((void)(_pBase)),((void)(_bEnd)))
+#define MGC_SelectEnd(_mbase, _bEnd)	(((void)(_mbase)),((void)(_bEnd)))
 #define	MGC_END_OFFSET			MGC_FLAT_OFFSET
 
 /* "indexed" mapping: INDEX register controls register bank select */
 #else
-#define MGC_SelectEnd(_pBase, _bEnd) \
-	musb_writeb((_pBase), MGC_O_HDRC_INDEX, (_bEnd))
+#define MGC_SelectEnd(_mbase, _bEnd) \
+	musb_writeb((_mbase), MGC_O_HDRC_INDEX, (_bEnd))
 #define	MGC_END_OFFSET			MGC_INDEXED_OFFSET
 #endif
 
Index: linux-2.6.18/drivers/usb/musb/musbhsdma.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musbhsdma.c
+++ linux-2.6.18/drivers/usb/musb/musbhsdma.c
@@ -177,7 +177,7 @@ static void configure_channel(struct dma
 	struct musb_dma_channel *pImplChannel =
 		(struct musb_dma_channel *) pChannel->pPrivateData;
 	struct musb_dma_controller *pController = pImplChannel->pController;
-	u8 *pBase = pController->pCoreBase;
+	u8 *mbase = pController->pCoreBase;
 	u8 bChannel = pImplChannel->bIndex;
 	u16 wCsr = 0;
 
@@ -207,15 +207,15 @@ static void configure_channel(struct dma
 		| (pImplChannel->bTransmit ? (1 << MGC_S_HSDMA_TRANSMIT) : 0);
 
 	/* address/count */
-	musb_writel(pBase,
+	musb_writel(mbase,
 		    MGC_HSDMA_CHANNEL_OFFSET(bChannel, MGC_O_HSDMA_ADDRESS),
 		    dma_addr);
-	musb_writel(pBase,
+	musb_writel(mbase,
 		    MGC_HSDMA_CHANNEL_OFFSET(bChannel, MGC_O_HSDMA_COUNT),
 		    dwLength);
 
 	/* control (this should start things) */
-	musb_writew(pBase,
+	musb_writew(mbase,
 		    MGC_HSDMA_CHANNEL_OFFSET(bChannel, MGC_O_HSDMA_CONTROL),
 		    wCsr);
 }
@@ -256,37 +256,37 @@ static int dma_channel_abort(struct dma_
 	struct musb_dma_channel *pImplChannel =
 		(struct musb_dma_channel *) pChannel->pPrivateData;
 	u8 bChannel = pImplChannel->bIndex;
-	u8 *pBase = pImplChannel->pController->pCoreBase;
+	u8 *mbase = pImplChannel->pController->pCoreBase;
 	u16 csr;
 
 	if (pChannel->bStatus == MGC_DMA_STATUS_BUSY) {
 		if (pImplChannel->bTransmit) {
 
-			csr = musb_readw(pBase,
+			csr = musb_readw(mbase,
 				MGC_END_OFFSET(pImplChannel->bEnd,MGC_O_HDRC_TXCSR));
 			csr &= ~(MGC_M_TXCSR_AUTOSET |
 				 MGC_M_TXCSR_DMAENAB |
 				 MGC_M_TXCSR_DMAMODE);
-			musb_writew(pBase,
+			musb_writew(mbase,
 					MGC_END_OFFSET(pImplChannel->bEnd,MGC_O_HDRC_TXCSR),
 					csr);
 		}
 		else {
-			csr = musb_readw(pBase,
+			csr = musb_readw(mbase,
 				MGC_END_OFFSET(pImplChannel->bEnd,MGC_O_HDRC_RXCSR));
 			csr &= ~(MGC_M_RXCSR_AUTOCLEAR |
 				 MGC_M_RXCSR_DMAENAB |
 				 MGC_M_RXCSR_DMAMODE);
-			musb_writew(pBase,
+			musb_writew(mbase,
 					MGC_END_OFFSET(pImplChannel->bEnd,MGC_O_HDRC_RXCSR),
 					csr);
 		}
 
-		musb_writew(pBase,
+		musb_writew(mbase,
 		   MGC_HSDMA_CHANNEL_OFFSET(bChannel, MGC_O_HSDMA_CONTROL), 0);
-		musb_writel(pBase,
+		musb_writel(mbase,
 		   MGC_HSDMA_CHANNEL_OFFSET(bChannel, MGC_O_HSDMA_ADDRESS), 0);
-		musb_writel(pBase,
+		musb_writel(mbase,
 		   MGC_HSDMA_CHANNEL_OFFSET(bChannel, MGC_O_HSDMA_COUNT), 0);
 
 		pChannel->bStatus = MGC_DMA_STATUS_FREE;
@@ -299,7 +299,7 @@ static irqreturn_t dma_controller_irq(in
 	struct musb_dma_controller *pController =
 		(struct musb_dma_controller *)pPrivateData;
 	struct musb_dma_channel *pImplChannel;
-	u8 *pBase = pController->pCoreBase;
+	u8 *mbase = pController->pCoreBase;
 	struct dma_channel *pChannel;
 	u8 bChannel;
 	u16 wCsr;
@@ -307,7 +307,7 @@ static irqreturn_t dma_controller_irq(in
 	u8 bIntr;
 	irqreturn_t retval = IRQ_NONE;
 
-	bIntr = musb_readb(pBase, MGC_O_HSDMA_INTR);
+	bIntr = musb_readb(mbase, MGC_O_HSDMA_INTR);
 	if (!bIntr)
 		goto done;
 
@@ -317,7 +317,7 @@ static irqreturn_t dma_controller_irq(in
 					&(pController->aChannel[bChannel]);
 			pChannel = &pImplChannel->Channel;
 
-			wCsr = musb_readw(pBase,
+			wCsr = musb_readw(mbase,
 				       MGC_HSDMA_CHANNEL_OFFSET(bChannel,
 							MGC_O_HSDMA_CONTROL));
 
@@ -325,7 +325,7 @@ static irqreturn_t dma_controller_irq(in
 				pImplChannel->Channel.bStatus =
 				    MGC_DMA_STATUS_BUS_ABORT;
 			} else {
-				dwAddress = musb_readl(pBase,
+				dwAddress = musb_readl(mbase,
 						MGC_HSDMA_CHANNEL_OFFSET(
 							bChannel,
 							MGC_O_HSDMA_ADDRESS));
@@ -340,7 +340,7 @@ static irqreturn_t dma_controller_irq(in
 					pImplChannel->dwCount) ?
 					"=> reconfig 0": "=> complete");
 
-				u8 devctl = musb_readb(pBase,
+				u8 devctl = musb_readb(mbase,
 						MGC_O_HDRC_DEVCTL);
 
 				pChannel->bStatus = MGC_DMA_STATUS_FREE;
@@ -353,9 +353,9 @@ static irqreturn_t dma_controller_irq(in
 					    (pImplChannel->wMaxPacketSize - 1)))
 				   ) {
 					/* Send out the packet */
-					MGC_SelectEnd(pBase,
+					MGC_SelectEnd(mbase,
 						pImplChannel->bEnd);
-					musb_writew(pBase,
+					musb_writew(mbase,
 						MGC_END_OFFSET(pImplChannel->bEnd,MGC_O_HDRC_TXCSR),
 						MGC_M_TXCSR_TXPKTRDY);
 				} else
Index: linux-2.6.18/drivers/usb/musb/plat_uds.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/plat_uds.c
+++ linux-2.6.18/drivers/usb/musb/plat_uds.c
@@ -315,7 +315,7 @@ static DEFINE_TIMER(musb_otg_timer, musb
 void musb_hnp_stop(struct musb *musb)
 {
 	struct usb_hcd	*hcd = musb_to_hcd(musb);
-	void __iomem	*pBase = musb->mregs;
+	void __iomem	*mbase = musb->mregs;
 	u8	reg;
 
 	switch (musb->xceiv.state) {
@@ -331,9 +331,9 @@ void musb_hnp_stop(struct musb *musb)
 		DBG(1, "HNP: Disabling HR\n");
 		hcd->self.is_b_host = 0;
 		musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
-		reg = musb_readb(pBase, MGC_O_HDRC_POWER);
+		reg = musb_readb(mbase, MGC_O_HDRC_POWER);
 		reg |= MGC_M_POWER_SUSPENDM;
-		musb_writeb(pBase, MGC_O_HDRC_POWER, reg);
+		musb_writeb(mbase, MGC_O_HDRC_POWER, reg);
 		/* REVISIT: Start SESSION_REQUEST here? */
 		break;
 	default:
@@ -365,7 +365,7 @@ static irqreturn_t musb_stage0_irq(struc
 {
 	irqreturn_t handled = IRQ_NONE;
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
-	void __iomem *pBase = musb->mregs;
+	void __iomem *mbase = musb->mregs;
 #endif
 
 	DBG(3, "<== Power=%02x, DevCtl=%02x, bIntrUSB=0x%x\n", power, devctl,
@@ -395,7 +395,7 @@ static irqreturn_t musb_stage0_irq(struc
 				}
 
 				power &= ~MGC_M_POWER_SUSPENDM;
-				musb_writeb(pBase, MGC_O_HDRC_POWER,
+				musb_writeb(mbase, MGC_O_HDRC_POWER,
 						power | MGC_M_POWER_RESUME);
 
 				musb->port1_status |=
@@ -466,7 +466,7 @@ static irqreturn_t musb_stage0_irq(struc
 		 *  - ... to A_WAIT_BCON.
 		 * a_wait_vrise_tmout triggers VBUS_ERROR transitions
 		 */
-		musb_writeb(pBase, MGC_O_HDRC_DEVCTL, MGC_M_DEVCTL_SESSION);
+		musb_writeb(mbase, MGC_O_HDRC_DEVCTL, MGC_M_DEVCTL_SESSION);
 		musb->bEnd0Stage = MGC_END0_START;
 		musb->xceiv.state = OTG_STATE_A_IDLE;
 		MUSB_HST_MODE(musb);
@@ -508,7 +508,7 @@ static irqreturn_t musb_stage0_irq(struc
 				musb->vbuserr_retry--;
 				ignore = 1;
 				devctl |= MGC_M_DEVCTL_SESSION;
-				musb_writeb(pBase, MGC_O_HDRC_DEVCTL, devctl);
+				musb_writeb(mbase, MGC_O_HDRC_DEVCTL, devctl);
 			} else {
 				musb->port1_status |=
 					  (1 << USB_PORT_FEAT_OVER_CURRENT)
@@ -558,9 +558,9 @@ static irqreturn_t musb_stage0_irq(struc
 			// REVISIT HNP; just force disconnect
 		}
 		musb->bDelayPortPowerOff = FALSE;
-		musb_writew(pBase, MGC_O_HDRC_INTRTXE, musb->wEndMask);
-		musb_writew(pBase, MGC_O_HDRC_INTRRXE, musb->wEndMask & 0xfffe);
-		musb_writeb(pBase, MGC_O_HDRC_INTRUSBE, 0xf7);
+		musb_writew(mbase, MGC_O_HDRC_INTRTXE, musb->wEndMask);
+		musb_writew(mbase, MGC_O_HDRC_INTRRXE, musb->wEndMask & 0xfffe);
+		musb_writeb(mbase, MGC_O_HDRC_INTRUSBE, 0xf7);
 #endif
 		musb->port1_status &= ~(USB_PORT_STAT_LOW_SPEED
 					|USB_PORT_STAT_HIGH_SPEED
@@ -616,7 +616,7 @@ static irqreturn_t musb_stage0_irq(struc
 				DBG(1, "BABBLE devctl: %02x\n", devctl);
 			else {
 				ERR("Stopping host session because of babble\n");
-				musb_writeb(pBase, MGC_O_HDRC_DEVCTL, 0);
+				musb_writeb(mbase, MGC_O_HDRC_DEVCTL, 0);
 			}
 		} else {
 			DBG(1, "BUS RESET\n");
@@ -660,7 +660,7 @@ static irqreturn_t musb_stage2_irq(struc
  * to support ISO transfers yet.
  */
 	if (bIntrUSB & MGC_M_INTR_SOF) {
-		void __iomem *pBase = musb->mregs;
+		void __iomem *mbase = musb->mregs;
 		struct musb_hw_ep	*ep;
 		u8 bEnd;
 		u16 wFrame;
@@ -669,7 +669,7 @@ static irqreturn_t musb_stage2_irq(struc
 		handled = IRQ_HANDLED;
 
 		/* start any periodic Tx transfers waiting for current frame */
-		wFrame = musb_readw(pBase, MGC_O_HDRC_FRAME);
+		wFrame = musb_readw(mbase, MGC_O_HDRC_FRAME);
 		ep = musb->aLocalEnd;
 		for (bEnd = 1; (bEnd < musb->bEndCount)
 					&& (musb->wEndMask >= (1 << bEnd));
@@ -835,21 +835,21 @@ void musb_start(struct musb *musb)
 
 static void musb_generic_disable(struct musb *musb)
 {
-	void __iomem	*pBase = musb->mregs;
+	void __iomem	*mbase = musb->mregs;
 	u16	temp;
 
 	/* disable interrupts */
-	musb_writeb(pBase, MGC_O_HDRC_INTRUSBE, 0);
-	musb_writew(pBase, MGC_O_HDRC_INTRTXE, 0);
-	musb_writew(pBase, MGC_O_HDRC_INTRRXE, 0);
+	musb_writeb(mbase, MGC_O_HDRC_INTRUSBE, 0);
+	musb_writew(mbase, MGC_O_HDRC_INTRTXE, 0);
+	musb_writew(mbase, MGC_O_HDRC_INTRRXE, 0);
 
 	/* off */
-	musb_writeb(pBase, MGC_O_HDRC_DEVCTL, 0);
+	musb_writeb(mbase, MGC_O_HDRC_DEVCTL, 0);
 
 	/*  flush pending interrupts */
-	temp = musb_readb(pBase, MGC_O_HDRC_INTRUSB);
-	temp = musb_readw(pBase, MGC_O_HDRC_INTRTX);
-	temp = musb_readw(pBase, MGC_O_HDRC_INTRRX);
+	temp = musb_readb(mbase, MGC_O_HDRC_INTRUSB);
+	temp = musb_readw(mbase, MGC_O_HDRC_INTRTX);
+	temp = musb_readw(mbase, MGC_O_HDRC_INTRRX);
 
 }
 
@@ -1180,14 +1180,14 @@ static int __init ep_config_from_hw(stru
 {
 	u8 bEnd = 0, reg;
 	struct musb_hw_ep *hw_ep;
-	void *pBase = musb->mregs;
+	void *mbase = musb->mregs;
 
 	DBG(2, "<== static silicon ep config\n");
 
 	/* FIXME pick up ep0 maxpacket size */
 
 	for (bEnd = 1; bEnd < MUSB_C_NUM_EPS; bEnd++) {
-		MGC_SelectEnd(pBase, bEnd);
+		MGC_SelectEnd(mbase, bEnd);
 		hw_ep = musb->aLocalEnd + bEnd;
 
 		/* read from core using indexed model */
@@ -1252,13 +1252,13 @@ static int __init musb_core_init(u16 wTy
 	char *type;
 	u16 wRelease, wRelMajor, wRelMinor;
 	char aInfo[78], aRevision[32], aDate[12];
-	void __iomem	*pBase = musb->mregs;
+	void __iomem	*mbase = musb->mregs;
 	int		status = 0;
 	int		i;
 
 	/* log core options (read using indexed model) */
-	MGC_SelectEnd(pBase, 0);
-	reg = musb_readb(pBase, 0x10 + MGC_O_HDRC_CONFIGDATA);
+	MGC_SelectEnd(mbase, 0);
+	reg = musb_readb(mbase, 0x10 + MGC_O_HDRC_CONFIGDATA);
 
 	strcpy(aInfo, (reg & MGC_M_CONFIGDATA_UTMIDW) ? "UTMI-16" : "UTMI-8");
 	if (reg & MGC_M_CONFIGDATA_DYNFIFO) {
@@ -1296,15 +1296,15 @@ static int __init musb_core_init(u16 wTy
 			musb_driver_name, reg, aInfo);
 
 #ifdef MUSB_AHB_ID
-	dwData = musb_readl(pBase, 0x404);
+	dwData = musb_readl(mbase, 0x404);
 	sprintf(aDate, "%04d-%02x-%02x", (dwData & 0xffff),
 		(dwData >> 16) & 0xff, (dwData >> 24) & 0xff);
 	/* FIXME ID2 and ID3 are unused */
-	dwData = musb_readl(pBase, 0x408);
+	dwData = musb_readl(mbase, 0x408);
 	printk("ID2=%lx\n", (long unsigned)dwData);
-	dwData = musb_readl(pBase, 0x40c);
+	dwData = musb_readl(mbase, 0x40c);
 	printk("ID3=%lx\n", (long unsigned)dwData);
-	reg = musb_readb(pBase, 0x400);
+	reg = musb_readb(mbase, 0x400);
 	wType = ('M' == reg) ? MUSB_CONTROLLER_MHDRC : MUSB_CONTROLLER_HDRC;
 #else
 	aDate[0] = 0;
@@ -1325,7 +1325,7 @@ static int __init musb_core_init(u16 wTy
 	}
 
 	/* log release info */
-	wRelease = musb_readw(pBase, MGC_O_HDRC_HWVERS);
+	wRelease = musb_readw(mbase, MGC_O_HDRC_HWVERS);
 	wRelMajor = (wRelease >> 10) & 0x1f;
 	wRelMinor = wRelease & 0x3ff;
 	snprintf(aRevision, 32, "%d.%d%s", wRelMajor,
@@ -1364,7 +1364,7 @@ static int __init musb_core_init(u16 wTy
 	for (i = 0; i < musb->bEndCount; i++) {
 		struct musb_hw_ep	*hw_ep = musb->aLocalEnd + i;
 
-		hw_ep->fifo = MUSB_FIFO_OFFSET(i) + pBase;
+		hw_ep->fifo = MUSB_FIFO_OFFSET(i) + mbase;
 #ifdef CONFIG_USB_TUSB6010
 		hw_ep->fifo_async = musb->async + 0x400 + MUSB_FIFO_OFFSET(i);
 		hw_ep->fifo_sync = musb->sync + 0x400 + MUSB_FIFO_OFFSET(i);
@@ -1372,14 +1372,14 @@ static int __init musb_core_init(u16 wTy
 			musb->sync_va + 0x400 + MUSB_FIFO_OFFSET(i);
 
 		if (i == 0)
-			hw_ep->conf = pBase - 0x400 + TUSB_EP0_CONF;
+			hw_ep->conf = mbase - 0x400 + TUSB_EP0_CONF;
 		else
-			hw_ep->conf = pBase + 0x400 + (((i - 1) & 0xf) << 2);
+			hw_ep->conf = mbase + 0x400 + (((i - 1) & 0xf) << 2);
 #endif
 
-		hw_ep->regs = MGC_END_OFFSET(i, 0) + pBase;
+		hw_ep->regs = MGC_END_OFFSET(i, 0) + mbase;
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
-		hw_ep->target_regs = MGC_BUSCTL_OFFSET(i, 0) + pBase;
+		hw_ep->target_regs = MGC_BUSCTL_OFFSET(i, 0) + mbase;
 		hw_ep->rx_reinit = 1;
 		hw_ep->tx_reinit = 1;
 #endif
Index: linux-2.6.18/drivers/usb/musb/virthub.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/virthub.c
+++ linux-2.6.18/drivers/usb/musb/virthub.c
@@ -49,7 +49,7 @@
 static void musb_port_suspend(struct musb *musb, u8 bSuspend)
 {
 	u8		power;
-	void __iomem	*pBase = musb->mregs;
+	void __iomem	*mbase = musb->mregs;
 
 	if (!is_host_active(musb))
 		return;
@@ -59,18 +59,18 @@ static void musb_port_suspend(struct mus
 	 * MGC_M_POWER_ENSUSPEND.  PHY may need a clock (sigh) to detect
 	 * SE0 changing to connect (J) or wakeup (K) states.
 	 */
-	power = musb_readb(pBase, MGC_O_HDRC_POWER);
+	power = musb_readb(mbase, MGC_O_HDRC_POWER);
 	if (bSuspend) {
 		int retries = 10000;
 
 		power &= ~MGC_M_POWER_RESUME;
 		power |= MGC_M_POWER_SUSPENDM;
-		musb_writeb(pBase, MGC_O_HDRC_POWER, power);
+		musb_writeb(mbase, MGC_O_HDRC_POWER, power);
 
 		/* Needed for OPT A tests */
-		power = musb_readb(pBase, MGC_O_HDRC_POWER);
+		power = musb_readb(mbase, MGC_O_HDRC_POWER);
 		while (power & MGC_M_POWER_SUSPENDM) {
-			power = musb_readb(pBase, MGC_O_HDRC_POWER);
+			power = musb_readb(mbase, MGC_O_HDRC_POWER);
 			if (retries-- < 1)
 				break;
 		}
@@ -97,7 +97,7 @@ static void musb_port_suspend(struct mus
 	} else if (power & MGC_M_POWER_SUSPENDM) {
 		power &= ~MGC_M_POWER_SUSPENDM;
 		power |= MGC_M_POWER_RESUME;
-		musb_writeb(pBase, MGC_O_HDRC_POWER, power);
+		musb_writeb(mbase, MGC_O_HDRC_POWER, power);
 
 		DBG(3, "Root port resuming, power %02x\n", power);
 
@@ -110,11 +110,11 @@ static void musb_port_suspend(struct mus
 static void musb_port_reset(struct musb *musb, u8 bReset)
 {
 	u8		power;
-	void __iomem	*pBase = musb->mregs;
+	void __iomem	*mbase = musb->mregs;
 
 #ifdef CONFIG_USB_MUSB_OTG
 	/* REVISIT this looks wrong for HNP */
-	u8 devctl = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
+	u8 devctl = musb_readb(mbase, MGC_O_HDRC_DEVCTL);
 
 	if (musb->bDelayPortPowerOff || !(devctl & MGC_M_DEVCTL_HM)) {
 		return;
@@ -127,7 +127,7 @@ static void musb_port_reset(struct musb 
 	/* NOTE:  caller guarantees it will turn off the reset when
 	 * the appropriate amount of time has passed
 	 */
-	power = musb_readb(pBase, MGC_O_HDRC_POWER);
+	power = musb_readb(mbase, MGC_O_HDRC_POWER);
 	if (bReset) {
 
 		/*
@@ -140,14 +140,14 @@ static void musb_port_reset(struct musb 
 		if (power &  MGC_M_POWER_RESUME) {
 			while (time_before(jiffies, musb->rh_timer))
 				msleep(1);
-			musb_writeb(pBase, MGC_O_HDRC_POWER,
+			musb_writeb(mbase, MGC_O_HDRC_POWER,
 				power & ~MGC_M_POWER_RESUME);
 			msleep(1);
 		}
 
 		musb->bIgnoreDisconnect = TRUE;
 		power &= 0xf0;
-		musb_writeb(pBase, MGC_O_HDRC_POWER,
+		musb_writeb(mbase, MGC_O_HDRC_POWER,
 				power | MGC_M_POWER_RESET);
 
 		musb->port1_status |= USB_PORT_STAT_RESET;
@@ -155,12 +155,12 @@ static void musb_port_reset(struct musb 
 		musb->rh_timer = jiffies + msecs_to_jiffies(50);
 	} else {
 		DBG(4, "root port reset stopped\n");
-		musb_writeb(pBase, MGC_O_HDRC_POWER,
+		musb_writeb(mbase, MGC_O_HDRC_POWER,
 				power & ~MGC_M_POWER_RESET);
 
 		musb->bIgnoreDisconnect = FALSE;
 
-		power = musb_readb(pBase, MGC_O_HDRC_POWER);
+		power = musb_readb(mbase, MGC_O_HDRC_POWER);
 		if (power & MGC_M_POWER_HSMODE) {
 			DBG(4, "high-speed device connected\n");
 			musb->port1_status |= USB_PORT_STAT_HIGH_SPEED;
Index: linux-2.6.18/mvl_patches/pro50-1663.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-1663.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1663);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

