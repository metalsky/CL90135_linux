#! /usr/bin/env bash
# Patch: -pro_musb_hdrc_Some_more_cleanup
# Date: Fri Sep 19 14:17:45 2008
# From 9e69b0f98d500792e4dde07dc254ecf24b22722c Mon Sep 17 00:00:00 2001
# From: David Brownell <dbrownell@users.sourceforge.net>
# Date: Thu, 23 Aug 2007 05:37:31 -0700
# Subject: [PATCH] musb_hdrc: Some more cleanup
# 
# Some more cleanup:
# 
#  - Primarily move from TRUE and FALSE to use "bool", "true", "false"
#  - Some whitespace and longline cleanup
# 
# Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
# (cherry picked from commit 312887fa39ecb1042fa042c96f83d8aba1a53391)

PATCHNUM=1780
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
From 9e69b0f98d500792e4dde07dc254ecf24b22722c Mon Sep 17 00:00:00 2001
From: David Brownell <dbrownell@users.sourceforge.net>
Date: Thu, 23 Aug 2007 05:37:31 -0700
Subject: [PATCH] musb_hdrc: Some more cleanup

Some more cleanup:

 - Primarily move from TRUE and FALSE to use "bool", "true", "false"
 - Some whitespace and longline cleanup

Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
(cherry picked from commit 312887fa39ecb1042fa042c96f83d8aba1a53391)
Index: linux-2.6.18/drivers/usb/musb/cppi_dma.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/cppi_dma.c
+++ linux-2.6.18/drivers/usb/musb/cppi_dma.c
@@ -52,8 +52,7 @@ static inline void cpu_drain_writebuffer
 #endif
 }
 
-static inline struct cppi_descriptor *
-cppi_bd_alloc(struct cppi_channel *c)
+static inline struct cppi_descriptor *cppi_bd_alloc(struct cppi_channel *c)
 {
 	struct cppi_descriptor	*bd = c->bdPoolHead;
 
@@ -147,11 +146,11 @@ static int __init cppi_controller_start(
 
 	/* do whatever is necessary to start controller */
 	for (i = 0; i < ARRAY_SIZE(controller->txCppi); i++) {
-		controller->txCppi[i].transmit = TRUE;
+		controller->txCppi[i].transmit = true;
 		controller->txCppi[i].chNo = i;
 	}
 	for (i = 0; i < ARRAY_SIZE(controller->rxCppi); i++) {
-		controller->rxCppi[i].transmit = FALSE;
+		controller->rxCppi[i].transmit = false;
 		controller->rxCppi[i].chNo = i;
 	}
 
@@ -996,7 +995,7 @@ static int cppi_channel_program(struct d
 	else
 		cppi_next_rx_segment(musb, otgChannel, mode);
 
-	return TRUE;
+	return true;
 }
 
 static int cppi_rx_scan(struct cppi *cppi, unsigned ch)
Index: linux-2.6.18/drivers/usb/musb/cppi_dma.h
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/cppi_dma.h
+++ linux-2.6.18/drivers/usb/musb/cppi_dma.h
@@ -33,10 +33,10 @@
 
 struct cppi_descriptor {
 	/* Hardware Overlay */
-	u32 hNext;     /**< Next(hardware) Buffer Descriptor Pointer */
-	u32 buffPtr;	   /**<Buffer Pointer (dma_addr_t) */
-	u32 bOffBLen;	    /**<Buffer_offset16,buffer_length16 */
-	u32 hOptions;	    /**<Option fields for SOP,EOP etc*/
+	u32 hNext;	/* Next(hardware) Buffer Descriptor Pointer */
+	u32 buffPtr;	/* Buffer Pointer (dma_addr_t) */
+	u32 bOffBLen;	/* Buffer_offset16,buffer_length16 */
+	u32 hOptions;	/* Option fields for SOP,EOP etc*/
 
 	struct cppi_descriptor *next;
 	dma_addr_t dma;		/* address of this descriptor */
@@ -46,7 +46,6 @@ struct cppi_descriptor {
 } __attribute__ ((aligned(CPPI_DESCRIPTOR_ALIGN)));
 
 
-/* forward declaration for CppiDmaController structure */
 struct cppi;
 
 /**
@@ -66,7 +65,7 @@ struct cppi_channel {
 
 	/* which direction of which endpoint? */
 	struct musb_hw_ep	*hw_ep;
-	u8			transmit;
+	bool			transmit;
 	u8			chNo;
 
 	/* DMA modes:  RNDIS or "transparent" */
Index: linux-2.6.18/drivers/usb/musb/musb_core.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_core.c
+++ linux-2.6.18/drivers/usb/musb/musb_core.c
@@ -299,7 +299,7 @@ void musb_otg_timer_func(unsigned long d
 
 	spin_lock_irqsave(&musb->lock, flags);
 	if (musb->xceiv.state == OTG_STATE_B_WAIT_ACON) {
-		DBG(1, "HNP: B_WAIT_ACON timeout, going back to B_PERIPHERAL\n");
+		DBG(1, "HNP: B_WAIT_ACON timeout; back to B_PERIPHERAL\n");
 		musb_g_disconnect(musb);
 		musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
 		musb->is_active = 0;
@@ -434,7 +434,8 @@ static irqreturn_t musb_stage0_irq(struc
 				 * not get a disconnect irq...
 				 */
 				if ((devctl & MUSB_DEVCTL_VBUS)
-						!= (3 << MUSB_DEVCTL_VBUS_SHIFT)) {
+						!= (3 << MUSB_DEVCTL_VBUS_SHIFT)
+						) {
 					musb->int_usb |= MUSB_INTR_DISCONNECT;
 					musb->int_usb &= ~MUSB_INTR_SUSPEND;
 					break;
@@ -582,7 +583,7 @@ static irqreturn_t musb_stage0_irq(struc
 		switch (musb->xceiv.state) {
 		case OTG_STATE_B_PERIPHERAL:
 			if (int_usb & MUSB_INTR_SUSPEND) {
-				DBG(1, "HNP: SUSPEND and CONNECT, now b_host\n");
+				DBG(1, "HNP: SUSPEND+CONNECT, now b_host\n");
 				musb->xceiv.state = OTG_STATE_B_HOST;
 				hcd->self.is_b_host = 1;
 				int_usb &= ~MUSB_INTR_SUSPEND;
@@ -615,14 +616,14 @@ static irqreturn_t musb_stage0_irq(struc
 			/*
 			 * Looks like non-HS BABBLE can be ignored, but
 			 * HS BABBLE is an error condition. For HS the solution
-			 * is to avoid babble in the first place and fix whatever
-			 * causes BABBLE. When HS BABBLE happens we can only stop
-			 * the session.
+			 * is to avoid babble in the first place and fix what
+			 * caused BABBLE. When HS BABBLE happens we can only
+			 * stop the session.
 			 */
 			if (devctl & (MUSB_DEVCTL_FSDEV | MUSB_DEVCTL_LSDEV))
 				DBG(1, "BABBLE devctl: %02x\n", devctl);
 			else {
-				ERR("Stopping host session because of babble\n");
+				ERR("Stopping host session -- babble\n");
 				musb_writeb(mbase, MUSB_DEVCTL, 0);
 			}
 		} else if (is_peripheral_capable()) {
@@ -1088,7 +1089,7 @@ fifo_setup(struct musb *musb, struct mus
 		hw_ep->tx_double_buffered = hw_ep->rx_double_buffered;
 		hw_ep->max_packet_sz_tx = maxpacket;
 
-		hw_ep->is_shared_fifo = TRUE;
+		hw_ep->is_shared_fifo = true;
 		break;
 	}
 
@@ -1214,11 +1215,11 @@ static int __init ep_config_from_hw(stru
 		/* shared TX/RX FIFO? */
 		if ((reg & 0xf0) == 0xf0) {
 			hw_ep->max_packet_sz_rx = hw_ep->max_packet_sz_tx;
-			hw_ep->is_shared_fifo = TRUE;
+			hw_ep->is_shared_fifo = true;
 			continue;
 		} else {
 			hw_ep->max_packet_sz_rx = 1 << ((reg & 0xf0) >> 4);
-			hw_ep->is_shared_fifo = FALSE;
+			hw_ep->is_shared_fifo = false;
 		}
 
 		/* FIXME set up hw_ep->{rx,tx}_double_buffered */
@@ -1277,7 +1278,7 @@ static int __init musb_core_init(u16 mus
 	if (reg & MUSB_CONFIGDATA_MPRXE) {
 		strcat(aInfo, ", bulk combine");
 #ifdef C_MP_RX
-		musb->bulk_combine = TRUE;
+		musb->bulk_combine = true;
 #else
 		strcat(aInfo, " (X)");		/* no driver support */
 #endif
@@ -1285,7 +1286,7 @@ static int __init musb_core_init(u16 mus
 	if (reg & MUSB_CONFIGDATA_MPTXE) {
 		strcat(aInfo, ", bulk split");
 #ifdef C_MP_TX
-		musb->bulk_split = TRUE;
+		musb->bulk_split = true;
 #else
 		strcat(aInfo, " (X)");		/* no driver support */
 #endif
Index: linux-2.6.18/drivers/usb/musb/musb_core.h
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_core.h
+++ linux-2.6.18/drivers/usb/musb/musb_core.h
@@ -164,13 +164,6 @@ static inline void musb_host_rx(struct m
 
 /****************************** CONSTANTS ********************************/
 
-#ifndef TRUE
-#define TRUE 1
-#endif
-#ifndef FALSE
-#define FALSE 0
-#endif
-
 #ifndef MUSB_C_NUM_EPS
 #define MUSB_C_NUM_EPS ((u8)16)
 #endif
@@ -209,8 +202,8 @@ enum musb_g_ep0_state {
  * directly with the "flat" model, or after setting up an index register.
  */
 
-#if defined(CONFIG_ARCH_DAVINCI) || defined(CONFIG_ARCH_OMAP2430) || \
-				     defined(CONFIG_ARCH_OMAP3430)
+#if defined(CONFIG_ARCH_DAVINCI) || defined(CONFIG_ARCH_OMAP2430) \
+		|| defined(CONFIG_ARCH_OMAP3430)
 /* REVISIT indexed access seemed to
  * misbehave (on DaVinci) for at least peripheral IN ...
  */
@@ -238,9 +231,9 @@ enum musb_g_ep0_state {
 /****************************** FUNCTIONS ********************************/
 
 #define MUSB_HST_MODE(_musb)\
-	{ (_musb)->is_host=TRUE; }
+	{ (_musb)->is_host = true; }
 #define MUSB_DEV_MODE(_musb) \
-	{ (_musb)->is_host=FALSE; }
+	{ (_musb)->is_host = false; }
 
 #define test_devctl_hst_mode(_x) \
 	(musb_readb((_x)->mregs, MUSB_DEVCTL)&MUSB_DEVCTL_HM)
@@ -267,9 +260,9 @@ struct musb_hw_ep {
 	u8			epnum;
 
 	/* hardware configuration, possibly dynamic */
-	u8			is_shared_fifo;
-	u8			tx_double_buffered;
-	u8			rx_double_buffered;
+	bool			is_shared_fifo;
+	bool			tx_double_buffered;
+	bool			rx_double_buffered;
 	u16			max_packet_sz_tx;
 	u16			max_packet_sz_rx;
 
@@ -393,11 +386,12 @@ struct musb {
 
 	u8			min_power;	/* vbus for periph, in mA/2 */
 
+	bool			is_host;
+
 	/* active means connected and not suspended */
 	unsigned		is_active:1;
 
 	unsigned is_multipoint:1;
-	unsigned is_host:1;
 	unsigned ignore_disconnect:1;	/* during bus resets */
 
 	int			a_wait_bcon;	/* VBUS timeout in msecs */
@@ -413,16 +407,11 @@ struct musb {
 
 #ifdef C_MP_RX
 	unsigned bulk_combine:1;
-	/* REVISIT allegedly doesn't work reliably */
-#if 0
 #define	can_bulk_combine(musb,type) \
 		(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bulk_combine)
 #else
 #define	can_bulk_combine(musb,type)	0
 #endif
-#else
-#define	can_bulk_combine(musb,type)	0
-#endif
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	/* is_suspended means USB B_PERIPHERAL suspend */
@@ -438,9 +427,9 @@ struct musb {
 	unsigned		is_self_powered:1;
 	unsigned		is_bus_powered:1;
 
-	unsigned set_address:1;
-	unsigned test_mode:1;
-	unsigned softconnect:1;
+	unsigned		set_address:1;
+	unsigned		test_mode:1;
+	unsigned		softconnect:1;
 
 	enum musb_g_ep0_state	ep0_state;
 	u8			address;
@@ -475,10 +464,8 @@ extern const char musb_driver_name[];
 extern void musb_start(struct musb *musb);
 extern void musb_stop(struct musb *musb);
 
-extern void musb_write_fifo(struct musb_hw_ep *ep,
-			     u16 len, const u8 * src);
-extern void musb_read_fifo(struct musb_hw_ep *ep,
-			       u16 len, u8 * dst);
+extern void musb_write_fifo(struct musb_hw_ep *ep, u16 len, const u8 * src);
+extern void musb_read_fifo(struct musb_hw_ep *ep, u16 len, u8 * dst);
 
 extern void musb_load_testpacket(struct musb *);
 
@@ -507,13 +494,12 @@ extern int musb_platform_exit(struct mus
 struct proc_dir_entry;
 
 #if (MUSB_DEBUG > 0) && defined(MUSB_CONFIG_PROC_FS)
-extern struct proc_dir_entry *musb_debug_create(char *name,
-						    struct musb *data);
+extern struct proc_dir_entry *musb_debug_create(char *name, struct musb *data);
 extern void musb_debug_delete(char *name, struct musb *data);
 
 #else
-static inline struct proc_dir_entry *musb_debug_create(char *name,
-							   struct musb *data)
+static inline struct proc_dir_entry *
+musb_debug_create(char *name, struct musb *data)
 {
 	return NULL;
 }
Index: linux-2.6.18/drivers/usb/musb/musb_dma.h
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_dma.h
+++ linux-2.6.18/drivers/usb/musb/musb_dma.h
@@ -106,7 +106,7 @@ struct dma_controller;
  *	transaction (typically representing many USB maximum-sized packets)
  * @actual_len: how many bytes have been transferred
  * @status: current channel status (updated e.g. on interrupt)
- * @desired_mode: TRUE if mode 1 is desired; FALSE if mode 0 is desired
+ * @desired_mode: true if mode 1 is desired; false if mode 0 is desired
  *
  * channels are associated with an endpoint for the duration of at least
  * one usb transfer.
@@ -117,7 +117,7 @@ struct dma_channel {
 	size_t			max_len;
 	size_t			actual_len;
 	enum dma_channel_status	status;
-	u8			desired_mode;
+	bool			desired_mode;
 };
 
 /*
Index: linux-2.6.18/drivers/usb/musb/musb_gadget.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_gadget.c
+++ linux-2.6.18/drivers/usb/musb/musb_gadget.c
@@ -102,7 +102,7 @@ Handling completion
 void musb_g_giveback(
 	struct musb_ep		*ep,
 	struct usb_request	*request,
-	int status)
+	int			status)
 __releases(ep->musb->lock)
 __acquires(ep->musb->lock)
 {
@@ -524,7 +524,7 @@ void musb_g_tx(struct musb *musb, u8 epn
 						: NULL;
 				if (!request) {
 					DBG(4, "%s idle now\n",
-							musb_ep->end_point.name);
+						musb_ep->end_point.name);
 					break;
 				}
 			}
@@ -635,7 +635,7 @@ static void rxstate(struct musb *musb, s
 	 * that last pckate should trigger an overflow fault.)  But in mode 1,
 	 * we don't get DMA completion interrrupt for short packets.
 	 *
-	 * Theoretically, we could enable DMAReq interrupt (MUSB_RXCSR_DMAMODE = 1),
+	 * Theoretically, we could enable DMAReq irq (MUSB_RXCSR_DMAMODE = 1),
 	 * to get endpoint interrupt on every DMA req, but that didn't seem
 	 * to work reliably.
 	 *
@@ -649,14 +649,13 @@ static void rxstate(struct musb *musb, s
 //				csr |= MUSB_RXCSR_DMAMODE;
 
 				/* this special sequence (enabling and then
-				   disabling MUSB_RXCSR_DMAMODE) is required
-				   to get DMAReq to activate
+				 * disabling MUSB_RXCSR_DMAMODE) is required
+				 * to get DMAReq to activate
 				 */
 				musb_writew(epio, MUSB_RXCSR,
 					csr | MUSB_RXCSR_DMAMODE);
 #endif
-				musb_writew(epio, MUSB_RXCSR,
-						csr);
+				musb_writew(epio, MUSB_RXCSR, csr);
 
 				if (request->actual < request->length) {
 					int transfer_size = 0;
@@ -683,7 +682,7 @@ static void rxstate(struct musb *musb, s
 				if (use_dma)
 					return;
 			}
-#endif	/* Mentor's USB */
+#endif	/* Mentor's DMA */
 
 			fifo_count = request->length - request->actual;
 			DBG(3, "%s OUT/RX pio fifo %d/%d, maxpacket %d\n",
@@ -705,7 +704,7 @@ static void rxstate(struct musb *musb, s
 						channel->desired_mode,
 						dma_addr,
 						fifo_count);
-				if (ret == TRUE)
+				if (ret)
 					return;
 			}
 #endif
@@ -1547,14 +1546,6 @@ static int musb_gadget_vbus_session(stru
 
 	return -EINVAL;
 }
-
-static int musb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned mA)
-{
-	/* FIXME -- delegate to otg_transciever logic */
-
-	DBG(2, "<= vbus_draw %u =>\n", mA);
-	return 0;
-}
 #endif
 
 static int musb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned mA)
@@ -1830,8 +1821,7 @@ int usb_gadget_register_driver(struct us
 }
 EXPORT_SYMBOL(usb_gadget_register_driver);
 
-static void
-stop_activity(struct musb *musb, struct usb_gadget_driver *driver)
+static void stop_activity(struct musb *musb, struct usb_gadget_driver *driver)
 {
 	int			i;
 	struct musb_hw_ep	*hw_ep;
Index: linux-2.6.18/drivers/usb/musb/musb_gadget_ep0.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_gadget_ep0.c
+++ linux-2.6.18/drivers/usb/musb/musb_gadget_ep0.c
@@ -170,8 +170,7 @@ static int service_tx_status_request(
  * Context:  caller holds controller lock
  */
 static int
-service_in_request(struct musb *musb,
-		const struct usb_ctrlrequest *ctrlrequest)
+service_in_request(struct musb *musb, const struct usb_ctrlrequest *ctrlrequest)
 {
 	int handled = 0;	/* not handled */
 
@@ -240,7 +239,7 @@ __acquires(musb->lock)
 		switch (ctrlrequest->bRequest) {
 		case USB_REQ_SET_ADDRESS:
 			/* change it after the status stage */
-			musb->set_address = TRUE;
+			musb->set_address = true;
 			musb->address = (u8) (ctrlrequest->wValue & 0x7f);
 			handled = 1;
 			break;
@@ -334,7 +333,7 @@ __acquires(musb->lock)
 
 					/* enter test mode after irq */
 					if (handled > 0)
-						musb->test_mode = TRUE;
+						musb->test_mode = true;
 					break;
 #ifdef CONFIG_USB_MUSB_OTG
 				case USB_DEVICE_B_HNP_ENABLE:
@@ -560,7 +559,7 @@ musb_read_setup(struct musb *musb, struc
 	 * the TX FIFO right away, and give the controller a moment
 	 * to switch modes...
 	 */
-	musb->set_address = FALSE;
+	musb->set_address = false;
 	musb->ackpend = MUSB_CSR0_P_SVDRXPKTRDY;
 	if (req->wLength == 0) {
 		if (req->bRequestType & USB_DIR_IN)
@@ -578,8 +577,7 @@ musb_read_setup(struct musb *musb, struc
 }
 
 static int
-forward_to_driver(struct musb *musb,
-		const struct usb_ctrlrequest *ctrlrequest)
+forward_to_driver(struct musb *musb, const struct usb_ctrlrequest *ctrlrequest)
 __releases(musb->lock)
 __acquires(musb->lock)
 {
@@ -663,7 +661,7 @@ irqreturn_t musb_g_ep0_irq(struct musb *
 		 * is done we won't see the next packet.
 		 */
 		if (musb->set_address) {
-			musb->set_address = FALSE;
+			musb->set_address = false;
 			musb_writeb(mbase, MUSB_FADDR, musb->address);
 		}
 
@@ -910,8 +908,7 @@ cleanup:
 	return status;
 }
 
-static int
-musb_g_ep0_dequeue(struct usb_ep *ep, struct usb_request *req)
+static int musb_g_ep0_dequeue(struct usb_ep *ep, struct usb_request *req)
 {
 	/* we just won't support this */
 	return -EINVAL;
Index: linux-2.6.18/drivers/usb/musb/musb_host.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_host.c
+++ linux-2.6.18/drivers/usb/musb/musb_host.c
@@ -311,7 +311,8 @@ __acquires(musb->lock)
 }
 
 /* for bulk/interrupt endpoints only */
-static inline void musb_save_toggle(struct musb_hw_ep *ep, int is_in, struct urb *urb)
+static inline void
+musb_save_toggle(struct musb_hw_ep *ep, int is_in, struct urb *urb)
 {
 	struct usb_device	*udev = urb->dev;
 	u16			csr;
@@ -466,13 +467,13 @@ static inline u16 musb_h_flush_rxfifo(st
 /*
  * PIO RX for a packet (or part of it).
  */
-static u8 musb_host_packet_rx(struct musb *musb, struct urb *urb,
-		u8 epnum, u8 iso_err)
+static bool
+musb_host_packet_rx(struct musb *musb, struct urb *urb, u8 epnum, u8 iso_err)
 {
-	u16 rx_count;
-	u8 *buf;
-	u16 csr;
-	u8 done = FALSE;
+	u16			rx_count;
+	u8			*buf;
+	u16			csr;
+	bool			done = false;
 	u32			length;
 	int			do_flush = 0;
 	struct musb_hw_ep	*hw_ep = musb->endpoints + epnum;
@@ -940,14 +941,13 @@ static void musb_ep_program(struct musb 
 
 /*
  * Service the default endpoint (ep0) as host.
- * Return TRUE until it's time to start the status stage.
+ * Return true until it's time to start the status stage.
  */
-static int musb_h_ep0_continue(struct musb *musb,
-				u16 len, struct urb *urb)
+static bool musb_h_ep0_continue(struct musb *musb, u16 len, struct urb *urb)
 {
-	int			 more = FALSE;
-	u8 *fifo_dest = NULL;
-	u16 fifo_count = 0;
+	bool			 more = false;
+	u8			*fifo_dest = NULL;
+	u16			fifo_count = 0;
 	struct musb_hw_ep	*hw_ep = musb->control_ep;
 	struct musb_qh		*qh = hw_ep->in_qh;
 	struct usb_ctrlrequest	*request;
@@ -969,7 +969,7 @@ static int musb_h_ep0_continue(struct mu
 			 */
 		} else if (urb->actual_length <
 				urb->transfer_buffer_length)
-			more = TRUE;
+			more = true;
 		break;
 	case MUSB_EP0_START:
 		request = (struct usb_ctrlrequest *) urb->setup_packet;
@@ -980,12 +980,12 @@ static int musb_h_ep0_continue(struct mu
 		} else if (request->bRequestType & USB_DIR_IN) {
 			DBG(4, "start IN-DATA\n");
 			musb->ep0_stage = MUSB_EP0_IN;
-			more = TRUE;
+			more = true;
 			break;
 		} else {
 			DBG(4, "start OUT-DATA\n");
 			musb->ep0_stage = MUSB_EP0_OUT;
-			more = TRUE;
+			more = true;
 		}
 		/* FALLTHROUGH */
 	case MUSB_EP0_OUT:
@@ -1001,7 +1001,7 @@ static int musb_h_ep0_continue(struct mu
 			musb_write_fifo(hw_ep, fifo_count, fifo_dest);
 
 			urb->actual_length += fifo_count;
-			more = TRUE;
+			more = true;
 		}
 		break;
 	default:
@@ -1027,7 +1027,7 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 	struct musb_hw_ep	*hw_ep = musb->control_ep;
 	void __iomem		*epio = hw_ep->regs;
 	struct musb_qh		*qh = hw_ep->in_qh;
-	u8			complete = FALSE;
+	bool			complete = false;
 	irqreturn_t		retval = IRQ_NONE;
 
 	/* ep0 only has one queue, "in" */
@@ -1045,7 +1045,7 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 	/* if we just did status stage, we are done */
 	if (MUSB_EP0_STATUS == musb->ep0_stage) {
 		retval = IRQ_HANDLED;
-		complete = TRUE;
+		complete = true;
 	}
 
 	/* prepare status */
@@ -1076,7 +1076,7 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 		retval = IRQ_HANDLED;
 		if (urb)
 			urb->status = status;
-		complete = TRUE;
+		complete = true;
 
 		/* use the proper sequence to abort the transfer */
 		if (csr & MUSB_CSR0_H_REQPKT) {
@@ -1165,7 +1165,7 @@ done:
 void musb_host_tx(struct musb *musb, u8 epnum)
 {
 	int			pipe;
-	u8			done = FALSE;
+	bool			done = false;
 	u16			tx_csr;
 	size_t			wLength = 0;
 	u8			*buf = NULL;
@@ -1247,7 +1247,7 @@ void musb_host_tx(struct musb *musb, u8 
 		musb_writew(epio, MUSB_TXCSR, tx_csr);
 		musb_writeb(epio, MUSB_TXINTERVAL, 0);
 
-		done = TRUE;
+		done = true;
 	}
 
 	/* second cppi case */
@@ -1271,22 +1271,22 @@ void musb_host_tx(struct musb *musb, u8 
 			d = urb->iso_frame_desc + qh->iso_idx;
 			d->actual_length = qh->segsize;
 			if (++qh->iso_idx >= urb->number_of_packets) {
-				done = TRUE;
+				done = true;
 			} else if (!dma) {
 				d++;
 				buf = urb->transfer_buffer + d->offset;
 				wLength = d->length;
 			}
 		} else if (dma) {
-			done = TRUE;
+			done = true;
 		} else {
 			/* see if we need to send more data, or ZLP */
 			if (qh->segsize < qh->maxpacket)
-				done = TRUE;
+				done = true;
 			else if (qh->offset == urb->transfer_buffer_length
 					&& !(urb-> transfer_flags
 							& URB_ZERO_PACKET))
-				done = TRUE;
+				done = true;
 			if (!done) {
 				buf = urb->transfer_buffer
 						+ qh->offset;
@@ -1300,7 +1300,7 @@ void musb_host_tx(struct musb *musb, u8 
 	 * so we must abort this transfer after cleanup
 	 */
 	if (urb->status != -EINPROGRESS) {
-		done = TRUE;
+		done = true;
 		if (status == 0)
 			status = urb->status;
 	}
@@ -1387,8 +1387,8 @@ void musb_host_rx(struct musb *musb, u8 
 	void __iomem		*mbase = musb->mregs;
 	int			pipe;
 	u16			rx_csr, val;
-	u8			iso_err = FALSE;
-	u8			done = FALSE;
+	bool			iso_err = false;
+	bool			done = false;
 	u32			status;
 	struct dma_channel	*dma;
 
@@ -1452,7 +1452,7 @@ void musb_host_rx(struct musb *musb, u8 
 		} else {
 			DBG(4, "RX end %d ISO data error\n", epnum);
 			/* packet error reported later */
-			iso_err = TRUE;
+			iso_err = true;
 		}
 	}
 
@@ -1466,7 +1466,7 @@ void musb_host_rx(struct musb *musb, u8 
 		}
 		musb_h_flush_rxfifo(hw_ep, 0);
 		musb_writeb(epio, MUSB_RXINTERVAL, 0);
-		done = TRUE;
+		done = true;
 		goto finish;
 	}
 
@@ -1494,7 +1494,7 @@ void musb_host_rx(struct musb *musb, u8 
 			dma->status = MUSB_DMA_STATUS_CORE_ABORT;
 			(void) musb->dma_controller->channel_abort(dma);
 			xfer_len = dma->actual_len;
-			done = TRUE;
+			done = true;
 		}
 
 		DBG(2, "RXCSR%d %04x, reqpkt, len %zd%s\n", epnum, rx_csr,
@@ -1533,7 +1533,7 @@ void musb_host_rx(struct musb *musb, u8 
 			musb_readw(epio, MUSB_RXCSR),
 			musb_readw(epio, MUSB_RXCOUNT));
 #else
-		done = TRUE;
+		done = true;
 #endif
 	} else if (urb->status == -EINPROGRESS) {
 		/* if no errors, be sure a packet is ready for unloading */
Index: linux-2.6.18/drivers/usb/musb/musb_virthub.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_virthub.c
+++ linux-2.6.18/drivers/usb/musb/musb_virthub.c
@@ -46,7 +46,7 @@
 #include "musb_core.h"
 
 
-static void musb_port_suspend(struct musb *musb, u8 bSuspend)
+static void musb_port_suspend(struct musb *musb, bool do_suspend)
 {
 	u8		power;
 	void __iomem	*mbase = musb->mregs;
@@ -60,7 +60,7 @@ static void musb_port_suspend(struct mus
 	 * SE0 changing to connect (J) or wakeup (K) states.
 	 */
 	power = musb_readb(mbase, MUSB_POWER);
-	if (bSuspend) {
+	if (do_suspend) {
 		int retries = 10000;
 
 		power &= ~MUSB_POWER_RESUME;
@@ -110,14 +110,14 @@ static void musb_port_suspend(struct mus
 	}
 }
 
-static void musb_port_reset(struct musb *musb, u8 bReset)
+static void musb_port_reset(struct musb *musb, bool do_reset)
 {
 	u8		power;
 	void __iomem	*mbase = musb->mregs;
 
 #ifdef CONFIG_USB_MUSB_OTG
 	if (musb->xceiv.state == OTG_STATE_B_IDLE) {
-		DBG(2, "HNP: Returning from HNP, not resetting hub as b_idle\n");
+		DBG(2, "HNP: Returning from HNP; no hub reset from b_idle\n");
 		musb->port1_status &= ~USB_PORT_STAT_RESET;
 		return;
 	}
@@ -130,7 +130,7 @@ static void musb_port_reset(struct musb 
 	 * the appropriate amount of time has passed
 	 */
 	power = musb_readb(mbase, MUSB_POWER);
-	if (bReset) {
+	if (do_reset) {
 
 		/*
 		 * If RESUME is set, we must make sure it stays minimum 20 ms.
@@ -147,7 +147,7 @@ static void musb_port_reset(struct musb 
 			msleep(1);
 		}
 
-		musb->ignore_disconnect = TRUE;
+		musb->ignore_disconnect = true;
 		power &= 0xf0;
 		musb_writeb(mbase, MUSB_POWER,
 				power | MUSB_POWER_RESET);
@@ -160,7 +160,7 @@ static void musb_port_reset(struct musb 
 		musb_writeb(mbase, MUSB_POWER,
 				power & ~MUSB_POWER_RESET);
 
-		musb->ignore_disconnect = FALSE;
+		musb->ignore_disconnect = false;
 
 		power = musb_readb(mbase, MUSB_POWER);
 		if (power & MUSB_POWER_HSMODE) {
@@ -255,7 +255,7 @@ int musb_hub_control(
 		case USB_PORT_FEAT_ENABLE:
 			break;
 		case USB_PORT_FEAT_SUSPEND:
-			musb_port_suspend(musb, FALSE);
+			musb_port_suspend(musb, false);
 			break;
 		case USB_PORT_FEAT_POWER:
 			if (!(is_otg_enabled(musb) && hcd->self.is_b_host))
@@ -303,7 +303,7 @@ int musb_hub_control(
 		/* finish RESET signaling? */
 		if ((musb->port1_status & USB_PORT_STAT_RESET)
 				&& time_after(jiffies, musb->rh_timer))
-			musb_port_reset(musb, FALSE);
+			musb_port_reset(musb, false);
 
 		/* finish RESUME signaling? */
 		if ((musb->port1_status & MUSB_PORT_STAT_RESUME)
@@ -330,7 +330,8 @@ int musb_hub_control(
 			musb->xceiv.state = OTG_STATE_A_HOST;
 		}
 
-		put_unaligned(cpu_to_le32(musb->port1_status & ~MUSB_PORT_STAT_RESUME),
+		put_unaligned(cpu_to_le32(musb->port1_status
+					& ~MUSB_PORT_STAT_RESUME),
 				(__le32 *) buf);
 
 		/* port change status is more interesting */
@@ -357,10 +358,10 @@ int musb_hub_control(
 				musb_start(musb);
 			break;
 		case USB_PORT_FEAT_RESET:
-			musb_port_reset(musb, TRUE);
+			musb_port_reset(musb, true);
 			break;
 		case USB_PORT_FEAT_SUSPEND:
-			musb_port_suspend(musb, TRUE);
+			musb_port_suspend(musb, true);
 			break;
 		case USB_PORT_FEAT_TEST:
 			if (unlikely(is_host_active(musb)))
@@ -390,7 +391,8 @@ int musb_hub_control(
 				temp = MUSB_TEST_FORCE_HOST
 					| MUSB_TEST_FORCE_HS;
 
-				musb_writeb(musb->mregs, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);
+				musb_writeb(musb->mregs, MUSB_DEVCTL,
+						MUSB_DEVCTL_SESSION);
 				break;
 			case 6:
 				pr_debug("TEST_FIFO_ACCESS\n");
Index: linux-2.6.18/drivers/usb/musb/musbhsdma.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musbhsdma.c
+++ linux-2.6.18/drivers/usb/musb/musbhsdma.c
@@ -85,10 +85,10 @@ struct musb_dma_channel {
 struct musb_dma_controller {
 	struct dma_controller		Controller;
 	struct musb_dma_channel		aChannel[MUSB_HSDMA_CHANNELS];
-	void 				*pDmaPrivate;
-	void __iomem 			*pCoreBase;
-	u8 				bChannelCount;
-	u8 				bmUsedChannels;
+	void				*pDmaPrivate;
+	void __iomem			*pCoreBase;
+	u8				bChannelCount;
+	u8				bmUsedChannels;
 	u8				irq;
 };
 
@@ -114,7 +114,7 @@ static int dma_controller_stop(struct dm
 
 		for (bBit = 0; bBit < MUSB_HSDMA_CHANNELS; bBit++) {
 			if (controller->bmUsedChannels & (1 << bBit)) {
-				pChannel = &(controller->aChannel[bBit].Channel);
+				pChannel = &controller->aChannel[bBit].Channel;
 				dma_channel_release(pChannel);
 
 				if (!controller->bmUsedChannels)
@@ -125,7 +125,7 @@ static int dma_controller_stop(struct dm
 	return 0;
 }
 
-static struct dma_channel* dma_channel_allocate(struct dma_controller *c,
+static struct dma_channel *dma_channel_allocate(struct dma_controller *c,
 				struct musb_hw_ep *hw_ep, u8 transmit)
 {
 	u8 bBit;
@@ -182,42 +182,43 @@ static void configure_channel(struct dma
 	u16 csr = 0;
 
 	DBG(4, "%p, pkt_sz %d, addr 0x%x, len %d, mode %d\n",
-	    pChannel, packet_sz, dma_addr, len, mode);
+			pChannel, packet_sz, dma_addr, len, mode);
 
 	if (mode) {
 		csr |= 1 << MUSB_HSDMA_MODE1_SHIFT;
-		if (len < packet_sz) {
-			return FALSE;
-		}
+		BUG_ON(len < packet_sz);
+
 		if (packet_sz >= 64) {
-			csr |=
-			    MUSB_HSDMA_BURSTMODE_INCR16 << MUSB_HSDMA_BURSTMODE_SHIFT;
+			csr |= MUSB_HSDMA_BURSTMODE_INCR16
+					<< MUSB_HSDMA_BURSTMODE_SHIFT;
 		} else if (packet_sz >= 32) {
-			csr |=
-			    MUSB_HSDMA_BURSTMODE_INCR8 << MUSB_HSDMA_BURSTMODE_SHIFT;
+			csr |= MUSB_HSDMA_BURSTMODE_INCR8
+					<< MUSB_HSDMA_BURSTMODE_SHIFT;
 		} else if (packet_sz >= 16) {
-			csr |=
-			    MUSB_HSDMA_BURSTMODE_INCR4 << MUSB_HSDMA_BURSTMODE_SHIFT;
+			csr |= MUSB_HSDMA_BURSTMODE_INCR4
+					<< MUSB_HSDMA_BURSTMODE_SHIFT;
 		}
 	}
 
 	csr |= (pImplChannel->epnum << MUSB_HSDMA_ENDPOINT_SHIFT)
 		| (1 << MUSB_HSDMA_ENABLE_SHIFT)
 		| (1 << MUSB_HSDMA_IRQENABLE_SHIFT)
-		| (pImplChannel->transmit ? (1 << MUSB_HSDMA_TRANSMIT_SHIFT) : 0);
+		| (pImplChannel->transmit
+				? (1 << MUSB_HSDMA_TRANSMIT_SHIFT)
+				: 0);
 
 	/* address/count */
 	musb_writel(mbase,
-		    MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_ADDRESS),
-		    dma_addr);
+		MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_ADDRESS),
+		dma_addr);
 	musb_writel(mbase,
-		    MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_COUNT),
-		    len);
+		MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_COUNT),
+		len);
 
 	/* control (this should start things) */
 	musb_writew(mbase,
-		    MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_CONTROL),
-		    csr);
+		MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_CONTROL),
+		csr);
 }
 
 static int dma_channel_program(struct dma_channel * pChannel,
@@ -241,14 +242,12 @@ static int dma_channel_program(struct dm
 	pImplChannel->wMaxPacketSize = packet_sz;
 	pChannel->status = MUSB_DMA_STATUS_BUSY;
 
-	if ((mode == 1) && (len >= packet_sz)) {
-		configure_channel(pChannel, packet_sz, 1, dma_addr,
-				  len);
-	} else
-		configure_channel(pChannel, packet_sz, 0, dma_addr,
-				  len);
+	if ((mode == 1) && (len >= packet_sz))
+		configure_channel(pChannel, packet_sz, 1, dma_addr, len);
+	else
+		configure_channel(pChannel, packet_sz, 0, dma_addr, len);
 
-	return TRUE;
+	return true;
 }
 
 static int dma_channel_abort(struct dma_channel *pChannel)
@@ -268,8 +267,8 @@ static int dma_channel_abort(struct dma_
 				 MUSB_TXCSR_DMAENAB |
 				 MUSB_TXCSR_DMAMODE);
 			musb_writew(mbase,
-					MUSB_EP_OFFSET(pImplChannel->epnum,MUSB_TXCSR),
-					csr);
+				MUSB_EP_OFFSET(pImplChannel->epnum,MUSB_TXCSR),
+				csr);
 		}
 		else {
 			csr = musb_readw(mbase,
@@ -278,16 +277,19 @@ static int dma_channel_abort(struct dma_
 				 MUSB_RXCSR_DMAENAB |
 				 MUSB_RXCSR_DMAMODE);
 			musb_writew(mbase,
-					MUSB_EP_OFFSET(pImplChannel->epnum,MUSB_RXCSR),
-					csr);
+				MUSB_EP_OFFSET(pImplChannel->epnum,MUSB_RXCSR),
+				csr);
 		}
 
 		musb_writew(mbase,
-		   MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_CONTROL), 0);
+			MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_CONTROL),
+			0);
 		musb_writel(mbase,
-		   MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_ADDRESS), 0);
+			MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_ADDRESS),
+			0);
 		musb_writel(mbase,
-		   MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_COUNT), 0);
+			MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_COUNT),
+			0);
 
 		pChannel->status = MUSB_DMA_STATUS_FREE;
 	}
@@ -318,26 +320,26 @@ static irqreturn_t dma_controller_irq(in
 			pChannel = &pImplChannel->Channel;
 
 			csr = musb_readw(mbase,
-				       MUSB_HSDMA_CHANNEL_OFFSET(bChannel,
+					MUSB_HSDMA_CHANNEL_OFFSET(bChannel,
 							MUSB_HSDMA_CONTROL));
 
-			if (csr & (1 << MUSB_HSDMA_BUSERROR_SHIFT)) {
+			if (csr & (1 << MUSB_HSDMA_BUSERROR_SHIFT))
 				pImplChannel->Channel.status =
-				    MUSB_DMA_STATUS_BUS_ABORT;
-			} else {
+					MUSB_DMA_STATUS_BUS_ABORT;
+			else {
 				dwAddress = musb_readl(mbase,
 						MUSB_HSDMA_CHANNEL_OFFSET(
 							bChannel,
 							MUSB_HSDMA_ADDRESS));
-				pChannel->actual_len =
-				    dwAddress - pImplChannel->dwStartAddress;
+				pChannel->actual_len = dwAddress
+					- pImplChannel->dwStartAddress;
 
 				DBG(2, "ch %p, 0x%x -> 0x%x (%d / %d) %s\n",
-				    pChannel, pImplChannel->dwStartAddress,
-				    dwAddress, pChannel->actual_len,
-				    pImplChannel->len,
-				    (pChannel->actual_len <
-					pImplChannel->len) ?
+					pChannel, pImplChannel->dwStartAddress,
+					dwAddress, pChannel->actual_len,
+					pImplChannel->len,
+					(pChannel->actual_len
+						< pImplChannel->len) ?
 					"=> reconfig 0": "=> complete");
 
 				u8 devctl = musb_readb(mbase,
@@ -347,16 +349,17 @@ static irqreturn_t dma_controller_irq(in
 
 				/* completed */
 				if ((devctl & MUSB_DEVCTL_HM)
-				    && (pImplChannel->transmit)
-				    && ((pChannel->desired_mode == 0)
-					|| (pChannel->actual_len &
+					&& (pImplChannel->transmit)
+					&& ((pChannel->desired_mode == 0)
+					    || (pChannel->actual_len &
 					    (pImplChannel->wMaxPacketSize - 1)))
-				   ) {
+					 ) {
 					/* Send out the packet */
 					musb_ep_select(mbase,
 						pImplChannel->epnum);
-					musb_writew(mbase,
-						MUSB_EP_OFFSET(pImplChannel->epnum,MUSB_TXCSR),
+					musb_writew(mbase, MUSB_EP_OFFSET(
+							pImplChannel->epnum,
+							MUSB_TXCSR),
 						MUSB_TXCSR_TXPKTRDY);
 				} else
 					musb_dma_completion(
Index: linux-2.6.18/drivers/usb/musb/omap2430.h
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/omap2430.h
+++ linux-2.6.18/drivers/usb/musb/omap2430.h
@@ -45,7 +45,7 @@
 #	define	UTMI_8BIT		(0 << PHYSEL)
 #	define	ULPI_12PIN		(1 << PHYSEL)
 #	define	ULPI_8PIN		(2 << PHYSEL)
-#define OTG_SIMENABLE_REG     	OMAP_HSOTG(0x10)
+#define OTG_SIMENABLE_REG	OMAP_HSOTG(0x10)
 #	define	TM1			(1 << 0)
 #define OTG_FORCESTDBY_REG	OMAP_HSOTG(0x14)
 #	define	ENABLEFORCE		(1 << 0)
Index: linux-2.6.18/drivers/usb/musb/tusb6010_omap.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/tusb6010_omap.c
+++ linux-2.6.18/drivers/usb/musb/tusb6010_omap.c
@@ -251,7 +251,7 @@ static int tusb_omap_dma_program(struct 
 	s8				sync_dev;
 
 	if (unlikely(dma_addr & 0x1) || (len < 32) || (len > packet_sz))
-		return FALSE;
+		return false;
 
 	/*
 	 * HW issue #10: Async dma will eventually corrupt the XFR_SIZE
@@ -260,7 +260,7 @@ static int tusb_omap_dma_program(struct 
 	 * register is corrupt, and we won't know if the DMA worked.
 	 */
 	if (dma_addr & 0x2)
-		return FALSE;
+		return false;
 
 	chdat->transfer_len = len & ~0x1f;
 
@@ -276,14 +276,14 @@ static int tusb_omap_dma_program(struct 
 	} else {
 		if (tusb_omap_use_shared_dmareq(chdat) != 0) {
 			DBG(3, "could not get dma for ep%i\n", chdat->epnum);
-			return FALSE;
+			return false;
 		}
 		if (tusb_dma->ch < 0) {
 			/* REVISIT: This should get blocked earlier, happens
 			 * with MSC ErrorRecoveryTest
 			 */
 			WARN_ON(1);
-			return FALSE;
+			return false;
 		}
 
 		ch = tusb_dma->ch;
@@ -411,7 +411,7 @@ static int tusb_omap_dma_program(struct 
 			TUSB_EP_CONFIG_XFR_SIZE(chdat->transfer_len));
 	}
 
-	return TRUE;
+	return true;
 }
 
 static int tusb_omap_dma_abort(struct dma_channel *channel)
Index: linux-2.6.18/mvl_patches/pro50-1780.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-1780.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1780);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

