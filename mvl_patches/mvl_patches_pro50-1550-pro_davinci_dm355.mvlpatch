#! /usr/bin/env bash
# Patch: -pro_davinci_dm355
# Date: Fri Sep 19 13:58:58 2008
# Source: MontaVista Software, Inc. 
# MR: 27505
# Type: Integration 
# Disposition: merged from linux-davinci-2.6.git 
# Signed-off-by: Vladimir Barinov <vbarinov@ru.mvista.com> 
# Signed-off-by: Steve Chen <schen@mvista.com> 
# Description: 
#     Support for the DM335 board
# 

PATCHNUM=1550
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc. 
MR: 27505
Type: Integration 
Disposition: merged from linux-davinci-2.6.git 
Signed-off-by: Vladimir Barinov <vbarinov@ru.mvista.com> 
Signed-off-by: Steve Chen <schen@mvista.com> 
Description: 
    Support for the DM335 board

Index: linux-2.6.18/arch/arm/mach-davinci/Kconfig
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-davinci/Kconfig
+++ linux-2.6.18/arch/arm/mach-davinci/Kconfig
@@ -4,10 +4,18 @@ menu "TI DaVinci Implementations"
 
 comment "DaVinci Core Type"
 
+choice
+	prompt "DaVinci ARCH type"
+	default ARCH_DAVINCI_DM644x
+
 config ARCH_DAVINCI644x
-	default y
 	bool "DaVinci 644x based system"
 
+config ARCH_DAVINCI_DM355
+	bool "DaVinci DM355 based system"
+
+endchoice
+
 comment "DaVinci Board Type"
 
 config MACH_DAVINCI_EVM
@@ -25,6 +33,15 @@ config DAVINCI_EVM_CF_SUPPORT
 	help
 	  Configure this option to enable CompactFlash card support.
 
+config MACH_DAVINCI_DM355_EVM
+	bool "TI DM355 EVM"
+	default n
+	depends on ARCH_DAVINCI_DM355
+	help
+	  Configure this option to specify the whether the board used
+	  for development is a DM355 EVM
+
+
 config DAVINCI_MUX
 	bool "DAVINCI multiplexing support"
 	depends on ARCH_DAVINCI
Index: linux-2.6.18/arch/arm/mach-davinci/Makefile
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-davinci/Makefile
+++ linux-2.6.18/arch/arm/mach-davinci/Makefile
@@ -9,4 +9,5 @@ obj-y 			:= time.o irq.o clock.o serial.
 
 # Board specific
 obj-$(CONFIG_MACH_DAVINCI_EVM)  += board-evm.o i2c-emac.o
+obj-$(CONFIG_MACH_DAVINCI_DM355_EVM)  += board-dm355-evm.o
 obj-$(CONFIG_DAVINCI_I2C_EXPANDER)      += i2c-client.o
Index: linux-2.6.18/arch/arm/mach-davinci/board-dm355-evm.c
===================================================================
--- /dev/null
+++ linux-2.6.18/arch/arm/mach-davinci/board-dm355-evm.c
@@ -0,0 +1,563 @@
+/*
+ * TI DaVinci DM355 EVM board
+ *
+ * Derived from: arch/arm/mach-davinci/board-evm.c
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+/**************************************************************************
+ * Included Files
+ **************************************************************************/
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/irq.h>
+#include <linux/major.h>
+#include <linux/root_dev.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mtd/nand.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+
+#include <asm/setup.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/flash.h>
+#include <asm/arch/irqs.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/edma.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/gpio.h>
+#include <linux/kgdb.h>
+#include "clock.h"
+#include <asm/arch/cpu.h>
+#include <asm/arch/common.h>
+#include <asm/arch/clock.h>
+
+/**************************************************************************
+ * Definitions
+ **************************************************************************/
+static struct plat_serial8250_port serial_platform_data[] = {
+	{
+		.membase = (char *) IO_ADDRESS(DAVINCI_UART0_BASE),
+		.mapbase = (unsigned long) DAVINCI_UART0_BASE,
+		.irq = IRQ_UARTINT0,
+		.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype = UPIO_MEM,
+		.regshift = 2,
+		.uartclk = 24000000,
+	},
+	{
+		.membase = (char *) IO_ADDRESS(DAVINCI_UART1_BASE),
+		.mapbase = (unsigned long) DAVINCI_UART1_BASE,
+		.irq = IRQ_UARTINT1,
+		.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype = UPIO_MEM,
+		.regshift = 2,
+		.uartclk = 24000000,
+	},
+	{
+		.membase = (char *) IO_ADDRESS(DM355_UART2_BASE),
+		.mapbase = (unsigned long) DM355_UART2_BASE,
+		.irq = IRQ_DM355_UARTINT2,
+		.flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+		.iotype = UPIO_MEM,
+		.regshift = 2,
+		.uartclk = 24000000,
+	},
+	{
+		.flags = 0
+	},
+};
+
+static struct platform_device serial_device = {
+	.name = "serial8250",
+	.id = 0,
+	.dev = {
+			.platform_data = serial_platform_data,
+		},
+};
+
+/**************************************************************************
+ * Public Functions
+ **************************************************************************/
+int cpu_type(void)
+{
+	return MACH_TYPE_DAVINCI_DM355_EVM;
+}
+EXPORT_SYMBOL(cpu_type);
+
+void davinci_serial_init(struct platform_device *pdev);
+
+#if defined(CONFIG_MTD_NAND_DAVINCI) ||  defined(CONFIG_MTD_NAND_DAVINCI_MODULE)
+
+
+/*
+ * The NAND partition map used by UBL/U-Boot is a function of the NAND block
+ * size.  We support NAND components with either a 128KB or 256KB block size.
+*/
+#ifdef CONFIG_DM355_NAND_256KB_BLOCKS
+	#define NAND_BLOCK_SIZE(SZ_256K)
+#else
+	#define NAND_BLOCK_SIZE(SZ_128K)
+#endif
+
+static struct mtd_partition nand_partitions[] = {
+	/* bootloader (UBL, U-Boot, BBT) in sectors: 0 - 14 */
+	{
+		.name		= "bootloader",
+		.offset		= 0,
+		.size		= 15*NAND_BLOCK_SIZE,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	},
+	/* bootloader params in the next sector 15 */
+	{
+		.name		= "params",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 1*NAND_BLOCK_SIZE,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	},
+	/* kernel in sectors: 16 */
+	{
+		.name		= "kernel",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_4M,
+		.mask_flags	= 0
+	},
+	{
+		.name		= "filesystem1",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= SZ_512M,
+		.mask_flags	= 0
+	},
+
+	{
+		.name		= "filesystem2",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= MTDPART_SIZ_FULL,
+		.mask_flags	= 0
+	}
+};
+
+/* flash bbt decriptors */
+static uint8_t nand_davinci_bbt_pattern[] = { 'B', 'b', 't', '0' };
+static uint8_t nand_davinci_mirror_pattern[] = { '1', 't', 'b', 'B' };
+
+static struct nand_bbt_descr nand_davinci_bbt_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 2,
+	.len = 4,
+	.veroffs = 16,
+	.maxblocks = 4,
+	.pattern = nand_davinci_bbt_pattern
+};
+
+static struct nand_bbt_descr nand_davinci_bbt_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+	| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs = 2,
+	.len = 4,
+	.veroffs = 16,
+	.maxblocks = 4,
+	.pattern = nand_davinci_mirror_pattern
+};
+
+
+
+static struct nand_davinci_platform_data nand_data = {
+	.options	= 0,
+	.eccmode	= NAND_ECC_HW10_512,
+	.cle_mask	= 0x10,
+	.ale_mask	= 0x08,
+	.bbt_td         = &nand_davinci_bbt_main_descr,
+	.bbt_md         = &nand_davinci_bbt_mirror_descr,
+	.parts		= nand_partitions,
+	.nr_parts	= ARRAY_SIZE(nand_partitions),
+  };
+
+static struct resource nand_resources[] = {
+	[0] = {		/* First memory resource is AEMIF control registers */
+		.start  = DM355_ASYNC_EMIF_CNTRL_BASE,
+		.end    = DM355_ASYNC_EMIF_CNTRL_BASE + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {         /* Second memory resource is NAND I/O window */
+		.start  = DAVINCI_ASYNC_EMIF_DATA_CE0_BASE,
+		.end    = DAVINCI_ASYNC_EMIF_DATA_CE0_BASE + SZ_16K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[2] = {		/*
+			* Third (optional) memory resource is NAND I/O window
+			* for second NAND chip select
+			*/
+		.start  = DAVINCI_ASYNC_EMIF_DATA_CE0_BASE + SZ_16K,
+		.end    = DAVINCI_ASYNC_EMIF_DATA_CE0_BASE + SZ_16K +
+				SZ_16K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+  };
+
+
+static struct platform_device nand_device = {
+	.name		= "nand_davinci",
+	.id		= 0,
+	.dev		= {
+		.platform_data	= &nand_data
+	},
+
+	.num_resources	= ARRAY_SIZE(nand_resources),
+	.resource	= nand_resources,
+};
+
+static void setup_nand(void)
+{
+	void __iomem *pinmux2 =
+		(void __iomem *) IO_ADDRESS(DAVINCI_SYSTEM_MODULE_BASE + 0x8);
+
+	/* Configure the pin multiplexing to enable all of the EMIF signals */
+	__raw_writel(0x00000004, pinmux2);
+}
+
+#else
+#define setup_nand()
+#endif
+
+#if defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)
+#define ETH_PHYS	(DAVINCI_ASYNC_EMIF_DATA_CE1_BASE + 0x00014000)
+static struct resource dm9000_resources[] = {
+	[0] = {
+		.start	= ETH_PHYS,
+		.end	= ETH_PHYS + 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= ETH_PHYS + 2,
+		.end	= ETH_PHYS + 3,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start	= IRQ_DM355_GPIO1,
+		.end	= IRQ_DM355_GPIO1,
+		.flags	= (IORESOURCE_IRQ | IRQT_RISING),
+	},
+};
+
+static struct platform_device dm9000_device = {
+	.name		= "dm9000",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(dm9000_resources),
+	.resource	= dm9000_resources,
+};
+
+static void setup_ethernet(void)
+{
+	/* GPIO1 is Ethernet interrupt GPIO */
+	u32 gpio = 1;
+
+	/* Configure GPIO1 as an input */
+	gpio_direction_input(gpio);
+
+	/* Configure GPIO1 to generate an interrupt on rising edge only */
+	set_irq_type(gpio_to_irq(gpio), IRQT_RISING);
+}
+#else
+#define setup_ethernet()
+#endif
+
+#if defined(CONFIG_MMC_DAVINCI) || defined(CONFIG_MMC_DAVINCI_MODULE)
+static struct resource mmc0_resources[] = {
+	[0] = {			/* registers */
+		.start	= DM355_MMC0_BASE,
+		.end	= DM355_MMC0_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {			/* interrupt */
+		.start	= IRQ_DM355_MMCINT0,
+		.end	= IRQ_DM355_MMCINT0,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {			/* dma rx */
+		.start	= DM355_DMA_MMC0RXEVT,
+		.end	= DM355_DMA_MMC0RXEVT,
+		.flags	= IORESOURCE_DMA,
+	},
+	[3] = {			/* dma tx */
+		.start	= DM355_DMA_MMC0TXEVT,
+		.end	= DM355_DMA_MMC0TXEVT,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+static struct davinci_mmc_platform_data mmc0_platform_data = {
+	.mmc_clk = "MMCSDCLK0",
+	.rw_threshold = 32,
+	.use_4bit_mode = 1,
+};
+
+static struct platform_device mmc0_device = {
+	.name = "mmc",
+	.id = 0,
+	.dev = {
+		.platform_data = &mmc0_platform_data,
+		},
+	.num_resources = ARRAY_SIZE(mmc0_resources),
+	.resource = mmc0_resources,
+};
+
+static struct resource mmc1_resources[] = {
+	[0] = {			/* registers */
+		.start	= DM355_MMC1_BASE,
+		.end	= DM355_MMC1_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {			/* interrupt */
+		.start	= IRQ_DM355_MMCINT1,
+		.end	= IRQ_DM355_MMCINT1,
+		.flags	= IORESOURCE_IRQ,
+	},
+	[2] = {			/* dma rx */
+		.start	= DM355_DMA_MMC1RXEVT,
+		.end	= DM355_DMA_MMC1RXEVT,
+		.flags	= IORESOURCE_DMA,
+	},
+	[3] = {			/* dma tx */
+		.start	= DM355_DMA_MMC1TXEVT,
+		.end	= DM355_DMA_MMC1TXEVT,
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+static struct davinci_mmc_platform_data mmc1_platform_data = {
+	.mmc_clk = "MMCSDCLK1",
+	.rw_threshold = 32,
+	.use_4bit_mode = 1,
+};
+
+static struct platform_device mmc1_device = {
+	.name = "mmc",
+	.id = 1,
+	.dev = {
+		.platform_data = &mmc1_platform_data,
+		},
+	.num_resources = ARRAY_SIZE(mmc1_resources),
+	.resource = mmc1_resources,
+};
+
+static void setup_mmc(void)
+{
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_MMC_SD0, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_MMC_SD1, 1);
+}
+#else
+#define setup_mmc()
+#endif
+
+static struct platform_device *dm355_evm_devices[] __initdata =
+{
+	&serial_device,
+#if defined(CONFIG_MTD_NAND_DAVINCI) || defined(CONFIG_MTD_NAND_DAVINCI_MODULE)
+	&nand_device,
+#endif
+#if defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)
+	&dm9000_device,
+#endif
+#if defined(CONFIG_MMC_DAVINCI) || defined(CONFIG_MMC_DAVINCI_MODULE)
+	&mmc0_device,
+	&mmc1_device,
+#endif
+};
+
+/* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
+static const u8 dm355_default_priorities[DAVINCI_N_AINTC_IRQ] = {
+	[IRQ_DM355_CCDC_VDINT0]		= 2,
+	[IRQ_DM355_CCDC_VDINT1]		= 6,
+	[IRQ_DM355_CCDC_VDINT2]		= 6,
+	[IRQ_DM355_IPIPE_HST]		= 6,
+	[IRQ_DM355_H3AINT]		= 6,
+	[IRQ_DM355_IPIPE_SDR]		= 6,
+	[IRQ_DM355_IPIPEIFINT]		= 6,
+	[IRQ_DM355_OSDINT]		= 7,
+	[IRQ_DM355_VENCINT]		= 6,
+	[IRQ_ASQINT]			= 6,
+	[IRQ_IMXINT]			= 6,
+	[IRQ_DM644X_VLCDINT]		= 6,
+	[IRQ_USBINT]			= 4,
+	[IRQ_DM355_RTOINT]		= 4,
+	[IRQ_DM355_UARTINT2]		= 7,
+	[IRQ_DM355_TINT6]		= 7,
+	[IRQ_CCINT0]			= 5,	/* dma */
+	[IRQ_CCERRINT]			= 5,	/* dma */
+	[IRQ_TCERRINT0]			= 5,	/* dma */
+	[IRQ_TCERRINT]			= 5,	/* dma */
+	[IRQ_PSCIN]			= 7,
+	[IRQ_DM355_SPINT2_1]		= 7,
+	[IRQ_DM355_TINT7]		= 4,
+	[IRQ_DM355_SDIOINT0]		= 7,
+	[IRQ_MBXINT]			= 7,
+	[IRQ_MBRINT]			= 7,
+	[IRQ_MMCINT]			= 7,
+	[IRQ_DM355_MMCINT1]		= 7,
+	[IRQ_DM355_PWMINT3]		= 7,
+	[IRQ_DDRINT]			= 7,
+	[IRQ_AEMIFINT]			= 7,
+	[IRQ_DM355_SDIOINT1]		= 4,
+	[IRQ_TINT0_TINT12]		= 2,	/* clockevent */
+	[IRQ_TINT0_TINT34]		= 2,	/* clocksource */
+	[IRQ_TINT1_TINT12]		= 7,	/* DSP timer */
+	[IRQ_TINT1_TINT34]		= 7,	/* system tick */
+	[IRQ_PWMINT0]			= 7,
+	[IRQ_PWMINT1]			= 7,
+	[IRQ_PWMINT2]			= 7,
+	[IRQ_I2C]			= 3,
+	[IRQ_UARTINT0]			= 3,
+	[IRQ_UARTINT1]			= 3,
+	[IRQ_DM355_SPINT0_0]		= 3,
+	[IRQ_DM355_SPINT0_1]		= 3,
+	[IRQ_DM355_GPIO0]		= 3,
+	[IRQ_DM355_GPIO1]		= 7,
+	[IRQ_DM355_GPIO2]		= 4,
+	[IRQ_DM355_GPIO3]		= 4,
+	[IRQ_DM355_GPIO4]		= 7,
+	[IRQ_DM355_GPIO5]		= 7,
+	[IRQ_DM355_GPIO6]		= 7,
+	[IRQ_DM355_GPIO7]		= 7,
+	[IRQ_DM355_GPIO8]		= 7,
+	[IRQ_DM355_GPIO9]		= 7,
+	[IRQ_DM355_GPIOBNK0]		= 7,
+	[IRQ_DM355_GPIOBNK1]		= 7,
+	[IRQ_DM355_GPIOBNK2]		= 7,
+	[IRQ_DM355_GPIOBNK3]		= 7,
+	[IRQ_DM355_GPIOBNK4]		= 7,
+	[IRQ_DM355_GPIOBNK5]		= 7,
+	[IRQ_DM355_GPIOBNK6]		= 7,
+	[IRQ_COMMTX]			= 7,
+	[IRQ_COMMRX]			= 7,
+	[IRQ_EMUINT]			= 7,
+};
+static void board_init(void)
+{
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_VPSSMSTR, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_VPSSSLV, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPCC, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPTC0, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPTC1, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_GPIO, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_McBSP1, 1);
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_SPI, 1);
+
+	/* Turn on WatchDog timer LPSC.  Needed for RESET to work */
+	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TIMER2, 1);
+	davinci_serial_init(&serial_device);
+	davinci_writel(0x56837210, DAVINCI_VPSS_REGS_BASE + 0x810);
+	davinci_writel(0x7b3c0004, DAVINCI_VPSS_REGS_BASE + 0x814);
+}
+
+static void dm355_setup_pinmux(unsigned int id)
+{
+	switch (id) {
+	case DAVINCI_LPSC_ATA:
+		/* DAVINCI_LPSC_PWM3 */
+		davinci_cfg_reg(DM355_PWM3_G69);
+		davinci_cfg_reg(DM355_PWM3_G70);
+		davinci_cfg_reg(DM355_PWM3_G74);
+		davinci_cfg_reg(DM355_PWM3_G75);
+
+		break;
+	case DAVINCI_LPSC_MMC_SD0:
+		davinci_cfg_reg(DM355_MMCSD0);
+		break;
+	case DAVINCI_LPSC_MMC_SD1:
+		davinci_cfg_reg(DM355_SD1_CLK);
+		davinci_cfg_reg(DM355_SD1_CMD);
+		davinci_cfg_reg(DM355_SD1_DATA3);
+		davinci_cfg_reg(DM355_SD1_DATA2);
+		davinci_cfg_reg(DM355_SD1_DATA1);
+		davinci_cfg_reg(DM355_SD1_DATA0);
+		break;
+	case DAVINCI_LPSC_I2C:
+		davinci_cfg_reg(DM355_I2C_SDA);
+		davinci_cfg_reg(DM355_I2C_SCL);
+		break;
+	case DAVINCI_LPSC_McBSP0:
+		davinci_cfg_reg(DM355_MCBSP0_BDX);
+		davinci_cfg_reg(DM355_MCBSP0_X);
+		davinci_cfg_reg(DM355_MCBSP0_BFSX);
+		davinci_cfg_reg(DM355_MCBSP0_BDR);
+		davinci_cfg_reg(DM355_MCBSP0_R);
+		davinci_cfg_reg(DM355_MCBSP0_BFSR);
+		break;
+	case DAVINCI_LPSC_PWM0:
+		davinci_cfg_reg(DM355_PWM0);
+		break;
+	case DAVINCI_LPSC_PWM1:
+		davinci_cfg_reg(DM355_PWM1);
+		break;
+	case DAVINCI_LPSC_PWM2:
+		davinci_cfg_reg(DM355_PWM2_G76);
+		davinci_cfg_reg(DM355_PWM2_G77);
+		davinci_cfg_reg(DM355_PWM2_G78);
+		davinci_cfg_reg(DM355_PWM2_G79);
+		break;
+	default:
+		break;
+	}
+}
+
+static void __init davinci_map_io(void)
+{
+	davinci_pinmux_setup = dm355_setup_pinmux;
+	davinci_irq_priorities = dm355_default_priorities;
+	davinci_map_common_io();
+	davinci_init_common_hw();
+
+#ifdef CONFIG_KGDB_8250
+	early_serial_setup((struct uart_port *)
+			&serial_platform_data[kgdb8250_ttyS]);
+	kgdb8250_add_platform_port(kgdb8250_ttyS,
+				 &serial_platform_data[kgdb8250_ttyS]);
+#endif
+
+	/* Board-specific initialization */
+	board_init();
+}
+
+static __init void davinci_init(void)
+{
+	setup_ethernet();
+	setup_mmc();
+	setup_nand();
+
+	platform_add_devices(dm355_evm_devices,
+		ARRAY_SIZE(dm355_evm_devices));
+
+}
+
+static __init void davinci_dm355_evm_irq_init(void)
+{
+	davinci_irq_init();
+}
+
+MACHINE_START(DAVINCI_DM355_EVM, "DaVinci DM355 EVM")
+	/* Maintainer: MontaVista Software <source@mvista.com> */
+	.phys_io      = IO_PHYS,
+	.io_pg_offst  = (io_p2v(IO_PHYS) >> 18) & 0xfffc,
+	.boot_params  = (DAVINCI_DDR_BASE + 0x100),
+	.map_io	      = davinci_map_io,
+	.init_irq     = davinci_dm355_evm_irq_init,
+	.timer	      = &davinci_timer,
+	.init_machine = davinci_init,
+MACHINE_END
Index: linux-2.6.18/arch/arm/mach-davinci/clock.c
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-davinci/clock.c
+++ linux-2.6.18/arch/arm/mach-davinci/clock.c
@@ -21,6 +21,7 @@
 #include <asm/io.h>
 
 #include <asm/arch/psc.h>
+#include <asm/arch/cpu.h>
 #include "clock.h"
 
 /* PLL/Reset register offsets */
@@ -31,6 +32,9 @@ static DEFINE_MUTEX(clocks_mutex);
 static DEFINE_SPINLOCK(clockfw_lock);
 
 static unsigned int commonrate;
+static unsigned int div_by_four;
+static unsigned int div_by_six;
+static unsigned int div_by_eight;
 static unsigned int armrate;
 static unsigned int fixedrate = 27000000;	/* 27 MHZ */
 
@@ -98,6 +102,8 @@ static void __clk_disable(struct clk *cl
 	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, clk->lpsc, 0);
 }
 
+void (*davinci_pinmux_setup)(unsigned int id);
+
 int clk_enable(struct clk *clk)
 {
 	unsigned long flags;
@@ -110,6 +116,9 @@ int clk_enable(struct clk *clk)
 		spin_lock_irqsave(&clockfw_lock, flags);
 		ret = __clk_enable(clk);
 		spin_unlock_irqrestore(&clockfw_lock, flags);
+		if (davinci_pinmux_setup)
+			davinci_pinmux_setup(clk->lpsc);
+
 	}
 
 	return ret;
@@ -183,7 +192,7 @@ void clk_unregister(struct clk *clk)
 }
 EXPORT_SYMBOL(clk_unregister);
 
-static struct clk davinci_clks[] = {
+static struct clk davinci_dm644x_clks[] = {
 	{
 		.name = "ARMCLK",
 		.rate = &armrate,
@@ -191,7 +200,7 @@ static struct clk davinci_clks[] = {
 		.flags = ALWAYS_ENABLED,
 	},
 	{
-		.name = "UART",
+		.name = "UART0",
 		.rate = &fixedrate,
 		.lpsc = DAVINCI_LPSC_UART0,
 	},
@@ -213,12 +222,12 @@ static struct clk davinci_clks[] = {
 	{
 		.name = "McBSPCLK",
 		.rate = &commonrate,
-		.lpsc = DAVINCI_LPSC_McBSP,
+		.lpsc = DAVINCI_LPSC_McBSP0,
 	},
 	{
-		.name = "MMCSDCLK",
+		.name = "MMCSDCLK0",
 		.rate = &commonrate,
-		.lpsc = DAVINCI_LPSC_MMC_SD,
+		.lpsc = DAVINCI_LPSC_MMC_SD0,
 	},
 	{
 		.name = "SPICLK",
@@ -235,21 +244,277 @@ static struct clk davinci_clks[] = {
 		.rate = &commonrate,
 		.lpsc = DAVINCI_LPSC_AEMIF,
 		.usecount = 1,
-	}
+	},
+	{
+		.name = "PWM0_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM0,
+	},
+	{
+		.name = "PWM1_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM1,
+	},
+	{
+		.name = "PWM2_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM2,
+	},
+	{
+		.name = "USBCLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_USB,
+	},
+	{
+		.name = "VLYNQ_CLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_VLYNQ,
+	},
+};
+static struct clk davinci_dm6467_clks[] = {
+	{
+		.name = "ARMCLK",
+		.rate = &armrate,
+		.lpsc = -1,
+		.flags = ALWAYS_ENABLED,
+	},
+	{
+		.name = "UART0",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_DM646X_LPSC_UART0,
+	},
+	{
+		.name = "UART1",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_DM646X_LPSC_UART1,
+	},
+	{
+		.name = "UART2",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_DM646X_LPSC_UART2,
+	},
+	{
+		.name = "EMACCLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_EMAC,
+	},
+	{
+		.name = "I2CCLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_I2C,
+	},
+	{
+		.name = "IDECLK",
+		.rate = &div_by_six,
+		.lpsc = DAVINCI_LPSC_ATA,
+	},
+	{
+		.name = "McASPCLK0",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_McASP0,
+	},
+	{
+		.name = "McASPCLK1",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_McASP1,
+	},
+	{
+		.name = "SPICLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_SPI,
+	},
+	{
+		.name = "gpio",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_DM646X_LPSC_GPIO,
+	},
+	{
+		.name = "AEMIFCLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_AEMIF,
+		.usecount = 1,
+	},
+	{
+		.name = "PWM0_CLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_PWM0,
+	},
+	{
+		.name = "PWM1_CLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_DM646X_LPSC_PWM1,
+	},
+	{
+		.name = "USBCLK",
+		.rate = &div_by_four,
+		.lpsc = DAVINCI_LPSC_USB,
+	},
+	{
+		.name = "VLYNQ_CLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_VLYNQ,
+	},
+	{
+		.name = "TSIF0_CLK",
+		.lpsc = DAVINCI_DM646X_LPSC_TSIF0,
+	},
+	{
+		.name = "TSIF1_CLK",
+		.lpsc = DAVINCI_DM646X_LPSC_TSIF1,
+	},
+};
+static struct clk davinci_dm355_clks[] = {
+	{
+		.name = "ARMCLK",
+		.rate = &armrate,
+		.lpsc = -1,
+		.flags = ALWAYS_ENABLED,
+	},
+	{
+		.name = "UART0",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_UART0,
+	},
+	{
+		.name = "UART1",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_UART1,
+	},
+	{
+		.name = "UART2",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_UART2,
+	},
+	{
+		.name = "EMACCLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_EMAC_WRAPPER,
+	},
+	{
+		.name = "I2CCLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_I2C,
+	},
+	{
+		.name = "IDECLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_ATA,
+	},
+	{
+		.name = "McBSPCLK0",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_McBSP0,
+	},
+	{
+		.name = "McBSPCLK1",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_McBSP1,
+	},
+	{
+		.name = "MMCSDCLK0",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_MMC_SD0,
+	},
+	{
+		.name = "MMCSDCLK1",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_MMC_SD1,
+	},
+	{
+		.name = "SPICLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_SPI,
+	},
+	{
+		.name = "gpio",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_GPIO,
+	},
+	{
+		.name = "AEMIFCLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_AEMIF,
+		.usecount = 1,
+	},
+	{
+		.name = "PWM0_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM0,
+	},
+	{
+		.name = "PWM1_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM1,
+	},
+	{
+		.name = "PWM2_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM2,
+	},
+	{
+		.name = "PWM3_CLK",
+		.rate = &fixedrate,
+		.lpsc = DAVINCI_LPSC_PWM3,
+	},
+	{
+		.name = "USBCLK",
+		.rate = &commonrate,
+		.lpsc = DAVINCI_LPSC_USB,
+	},
 };
 
 int __init davinci_clk_init(void)
 {
 	struct clk *clkp;
-	int count = 0;
+	static struct clk *board_clks;
+	int count = 0, num_clks;
 	u32 pll_mult;
 
 	pll_mult = davinci_readl(DAVINCI_PLL_CNTRL0_BASE + PLLM);
 	commonrate = ((pll_mult + 1) * 27000000) / 6;
 	armrate = ((pll_mult + 1) * 27000000) / 2;
 
-	for (clkp = davinci_clks; count < ARRAY_SIZE(davinci_clks);
-	     count++, clkp++) {
+	if (cpu_is_davinci_dm355()) {
+		/*
+		 * FIXME
+		 * We're assuming a 24MHz reference, but the DM355 also
+		 * supports a 36MHz reference.
+		 */
+		unsigned long postdiv;
+
+		/*
+		 * Read the PLL1 POSTDIV register to determine if the post
+		 * divider is /1 or /2
+		 */
+		postdiv = (davinci_readl(DAVINCI_PLL_CNTRL0_BASE + 0x128)
+			& 0x1f) + 1;
+
+		fixedrate = 24000000;
+		armrate = (pll_mult + 1) * (fixedrate / (16 * postdiv));
+		commonrate = armrate / 2;
+
+		board_clks = davinci_dm355_clks;
+		num_clks = ARRAY_SIZE(davinci_dm355_clks);
+	} else if (cpu_is_davinci_dm6467()) {
+		fixedrate = 24000000;
+		div_by_four = ((pll_mult + 1) * 27000000) / 4;
+		div_by_six = ((pll_mult + 1) * 27000000) / 6;
+		div_by_eight = ((pll_mult + 1) * 27000000) / 8;
+		armrate = ((pll_mult + 1) * 27000000) / 2;
+
+		board_clks = davinci_dm6467_clks;
+		num_clks = ARRAY_SIZE(davinci_dm6467_clks);
+	} else {
+
+		fixedrate = 27000000;
+		armrate = (pll_mult + 1) * (fixedrate / 2);
+		commonrate = armrate / 3;
+
+		board_clks = davinci_dm644x_clks;
+		num_clks = ARRAY_SIZE(davinci_dm644x_clks);
+	}
+
+	for (clkp = board_clks; count < num_clks; count++, clkp++) {
 		clk_register(clkp);
 
 		/* Turn on clocks that have been enabled in the
Index: linux-2.6.18/arch/arm/mach-davinci/irq.c
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-davinci/irq.c
+++ linux-2.6.18/arch/arm/mach-davinci/irq.c
@@ -177,11 +177,17 @@ static const u8 default_priorities[DAVIN
 	[IRQ_EMUINT]		= 7,
 };
 
+const u8 *davinci_irq_priorities;
+
 /* ARM Interrupt Controller Initialization */
 void __init davinci_irq_init(void)
 {
 	unsigned i;
-	const u8 *priority = default_priorities;
+	const u8 *priority;
+	if (!davinci_irq_priorities)
+		priority = default_priorities;
+	else
+		priority = davinci_irq_priorities;
 
 	/* Clear all interrupt requests */
 	davinci_irq_writel(~0x0, FIQ_REG0_OFFSET);
Index: linux-2.6.18/arch/arm/mach-davinci/mux_cfg.c
===================================================================
--- linux-2.6.18.orig/arch/arm/mach-davinci/mux_cfg.c
+++ linux-2.6.18/arch/arm/mach-davinci/mux_cfg.c
@@ -18,6 +18,7 @@
 
 #include <asm/hardware.h>
 
+#include <asm/arch/cpu.h>
 #include <asm/arch/mux.h>
 
 #ifdef CONFIG_DAVINCI_MUX
@@ -60,10 +61,86 @@ MUX_CFG("LOEEN",		 0,   24,    1,	  1,	 
 MUX_CFG("LFLDEN",		 0,   25,    1,	  1,	 0)
 };
 
+struct pin_config __initdata_or_module davinci_dm355_pins[] = {
+/*
+ *	 description		mux  mode   mode  mux	 dbg
+ *				reg  offset mask  mode
+ */
+MUX_CFG("MMCSD0",		 4,   2,     1,	  0,	 0)
+
+MUX_CFG("SD1_CLK",		 3,   6,     1,	  1,	 0)
+MUX_CFG("SD1_CMD",		 3,   7,     1,	  1,	 0)
+MUX_CFG("SD1_DATA3",		 3,   8,     3,	  1,	 0)
+MUX_CFG("SD1_DATA2",		 3,   10,    3,	  1,	 0)
+MUX_CFG("SD1_DATA1",		 3,   12,    3,	  1,	 0)
+MUX_CFG("SD1_DATA0",		 3,   14,    3,	  1,	 0)
+
+MUX_CFG("I2C_SDA",		 3,   19,    1,	  1,	 0)
+MUX_CFG("I2C_SCL",		 3,   20,    1,	  1,	 0)
+
+MUX_CFG("MCBSP0_BDX",		 3,   0,     1,	  1,	 0)
+MUX_CFG("MCBSP0_X",		 3,   1,     1,	  1,	 0)
+MUX_CFG("MCBSP0_BFSX",		 3,   2,     1,	  1,	 0)
+MUX_CFG("MCBSP0_BDR",		 3,   3,     1,	  1,	 0)
+MUX_CFG("MCBSP0_R",		 3,   4,     1,	  1,	 0)
+MUX_CFG("MCBSP0_BFSR",		 3,   5,     1,	  1,	 0)
+
+MUX_CFG("PWM0",			 1,   0,     3,	  2,	 1)
+
+MUX_CFG("PWM1",			 1,   2,     3,	  2,	 1)
+
+MUX_CFG("PWM2_G76",		 1,   10,    3,	  2,	 1)
+MUX_CFG("PWM2_G77",		 1,   8,     3,	  2,	 1)
+MUX_CFG("PWM2_G78",		 1,   6,     3,	  2,	 1)
+MUX_CFG("PWM2_G79",		 1,   4,     3,	  2,	 1)
+
+MUX_CFG("PWM3_G69",		 1,   20,    3,	  3,	 0)
+MUX_CFG("PWM3_G70",		 1,   18,    3,	  3,	 0)
+MUX_CFG("PWM3_G74",		 1,   14,    3,	  2,	 1)
+MUX_CFG("PWM3_G75",		 1,   12,    3,	  2,	 1)
+
+MUX_CFG("SPI0_SDI",		 4,   1,     1,	  0,	 0)
+MUX_CFG("SPI0_SDENA0",		 4,   0,     1,	  0,	 0)
+MUX_CFG("SPI0_SDENA1",		 3,   28,    1,	  1,	 0)
+
+MUX_CFG("SPI1_SCLK",		 3,   24,    1,	  1,	 0)
+MUX_CFG("SPI1_SDO",		 3,   27,    1,	  1,	 0)
+MUX_CFG("SPI1_SDENA0",		 3,   23,    1,	  1,	 0)
+MUX_CFG("SPI1_SDENA1",		 3,   25,    3,	  2,	 0)
+
+MUX_CFG("SPI2_SCLK",		 0,   0,     3,	  2,	 0)
+MUX_CFG("SPI2_SDO",		 0,   2,     3,	  2,	 0)
+MUX_CFG("SPI2_SDENA0",		 0,   4,     3,	  2,	 0)
+MUX_CFG("SPI2_SDENA1",		 0,   6,     3,	  3,	 0)
+
+MUX_CFG("GPIO14",		 3,   20,    1,	  0,	 0)
+MUX_CFG("GPIO15",		 3,   19,    1,	  0,	 0)
+MUX_CFG("GPIO71",		 1,   17,    1,	  1,	 0)
+
+MUX_CFG("VOUT_FIELD",		 1,   18,    3,	  1,	 1)
+MUX_CFG("VOUT_FIELD_G70",	 1,   18,    3,	  0,	 1)
+MUX_CFG("VOUT_HVSYNC",		 1,   16,    1,	  0,	 0)
+MUX_CFG("VOUT_COUTL_EN",	 1,   0,     0xff, 0x55,  1)
+MUX_CFG("VOUT_COUTH_EN",	 1,   8,     0xff, 0x55,  1)
+
+MUX_CFG("VIN_PCLK",		 0,   14,    1,	  1,	 0)
+MUX_CFG("VIN_CAM_WEN",		 0,   13,    1,	  1,	 0)
+MUX_CFG("VIN_CAM_VD",		 0,   12,    1,	  1,	 0)
+MUX_CFG("VIN_CAM_HD",		 0,   11,    1,	  1,	 0)
+MUX_CFG("VIN_YIN_EN",		 0,   10,    1,	  1,	 0)
+MUX_CFG("VIN_CINL_EN",		 0,   0,     0xff, 0x55,  0)
+MUX_CFG("VIN_CINH_EN",		 0,   8,     3,	  3,	 0)
+};
+
+
 void __init davinci_mux_init(void)
 {
-	davinci_mux_register(davinci_dm644x_pins,
-			     ARRAY_SIZE(davinci_dm644x_pins));
+	if (cpu_is_davinci_dm355())
+		davinci_mux_register(davinci_dm355_pins,
+					ARRAY_SIZE(davinci_dm355_pins));
+	else
+		davinci_mux_register(davinci_dm644x_pins,
+					ARRAY_SIZE(davinci_dm644x_pins));
 }
 
 #endif
Index: linux-2.6.18/arch/arm/tools/mach-types
===================================================================
--- linux-2.6.18.orig/arch/arm/tools/mach-types
+++ linux-2.6.18/arch/arm/tools/mach-types
@@ -1158,3 +1158,4 @@ oti4110			MACH_OTI4110		OTI4110			1144
 hme_pxa			MACH_HME_PXA		HME_PXA			1145
 deisterdca		MACH_DEISTERDCA		DEISTERDCA		1146
 realview_pb1176		MACH_REALVIEW_PB1176	REALVIEW_PB1176		1504
+davinci_dm355_evm	MACH_DAVINCI_DM355_EVM	DAVINCI_DM355_EVM	1381
Index: linux-2.6.18/include/asm-arm/arch-davinci/hardware.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-davinci/hardware.h
+++ linux-2.6.18/include/asm-arm/arch-davinci/hardware.h
@@ -11,6 +11,9 @@
 #ifndef __ASM_ARCH_HARDWARE_H
 #define __ASM_ARCH_HARDWARE_H
 
+#include <asm/arch/psc.h>
+#include <asm/arch/serial.h>
+
 /*
  * Base register addresses
  */
@@ -49,10 +52,19 @@
 #define DAVINCI_ASYNC_EMIF_DATA_CE3_BASE	(0x08000000)
 #define DAVINCI_VLYNQ_REMOTE_BASE		(0x0C000000)
 
+#define DM355_MMC1_BASE				(0x01E00000)
+#define DM355_UART2_BASE			(0x01E06000)
+#define DM355_ASYNC_EMIF_CNTRL_BASE		(0x01E10000)
+#define DM355_MMC0_BASE				(0x01E11000)
+
 /*
  * System module registers
  */
 #define PINMUX0		(DAVINCI_SYSTEM_MODULE_BASE + 0x00)
 #define PINMUX1		(DAVINCI_SYSTEM_MODULE_BASE + 0x04)
+#define PINMUX2		(DAVINCI_SYSTEM_MODULE_BASE + 0x08)
+#define PINMUX3		(DAVINCI_SYSTEM_MODULE_BASE + 0x0c)
+#define PINMUX4		(DAVINCI_SYSTEM_MODULE_BASE + 0x10)
+
 
 #endif /* __ASM_ARCH_HARDWARE_H */
Index: linux-2.6.18/include/asm-arm/arch-davinci/irqs.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-davinci/irqs.h
+++ linux-2.6.18/include/asm-arm/arch-davinci/irqs.h
@@ -96,9 +96,90 @@
 #define IRQ_EMUINT       63
 
 #define DAVINCI_N_AINTC_IRQ	64
-#define DAVINCI_N_GPIO		71
 
-#define NR_IRQS			(DAVINCI_N_AINTC_IRQ + DAVINCI_N_GPIO)
+/* DaVinci DM644x-specific Interrupts */
+#define IRQ_DM644X_VDINT0	0
+#define IRQ_DM644X_VDINT1	1
+#define IRQ_DM644X_VDINT2	2
+#define IRQ_DM644X_HISTINT	3
+#define IRQ_DM644X_H3AINT	4
+#define IRQ_DM644X_PRVUINT	5
+#define IRQ_DM644X_RSZINT	6
+#define IRQ_DM644X_VENCINT	8
+#define IRQ_DM644X_VLCDINT	11
+#define IRQ_DM644X_EMACINT	13
+#define IRQ_DM644X_IDE		22
+#define IRQ_DM644X_SDIOINT	27
+#define IRQ_DM644X_VLQINT	31
+#define IRQ_DM644X_UARTINT2	42
+#define IRQ_DM644X_SPINT0	43
+#define IRQ_DM644X_SPINT1	44
+#define IRQ_DM644X_DSP2ARM0	46
+#define IRQ_DM644X_DSP2ARM1	47
+#define IRQ_DM644X_GPIO0	48
+#define IRQ_DM644X_GPIO1	49
+#define IRQ_DM644X_GPIO2	50
+#define IRQ_DM644X_GPIO3	51
+#define IRQ_DM644X_GPIO4	52
+#define IRQ_DM644X_GPIO5	53
+#define IRQ_DM644X_GPIO6	54
+#define IRQ_DM644X_GPIO7	55
+#define IRQ_DM644X_GPIOBNK0	56
+#define IRQ_DM644X_GPIOBNK1	57
+#define IRQ_DM644X_GPIOBNK2	58
+#define IRQ_DM644X_GPIOBNK3	59
+#define IRQ_DM644X_GPIOBNK4	60
+
+/* DaVinci DM355-specific Interrupts */
+#define IRQ_DM355_CCDC_VDINT0	0
+#define IRQ_DM355_CCDC_VDINT1	1
+#define IRQ_DM355_CCDC_VDINT2	2
+#define IRQ_DM355_IPIPE_HST	3
+#define IRQ_DM355_H3AINT	4
+#define IRQ_DM355_IPIPE_SDR	5
+#define IRQ_DM355_IPIPEIFINT	6
+#define IRQ_DM355_OSDINT        7
+#define IRQ_DM355_VENCINT       8
+#define IRQ_DM355_IMCOPINT	11
+#define IRQ_DM355_RTOINT	13
+#define IRQ_DM355_TINT4		13
+#define IRQ_DM355_TINT2_TINT12	13
+#define IRQ_DM355_UARTINT2	14
+#define IRQ_DM355_TINT5		14
+#define IRQ_DM355_TINT2_TINT34	14
+#define IRQ_DM355_TINT6		15
+#define IRQ_DM355_TINT3_TINT12	15
+#define IRQ_DM355_SPINT1_0	17
+#define IRQ_DM355_SPINT1_1	18
+#define IRQ_DM355_SPINT2_0	19
+#define IRQ_DM355_SPINT2_1	21
+#define IRQ_DM355_TINT7		22
+#define IRQ_DM355_TINT3_TINT34	22
+#define IRQ_DM355_SDIOINT0	23
+#define IRQ_DM355_MMCINT0	26
+#define IRQ_DM355_MSINT		26
+#define IRQ_DM355_MMCINT1	27
+#define IRQ_DM355_PWMINT3	28
+#define IRQ_DM355_SDIOINT1	31
+#define IRQ_DM355_SPINT0_0	42
+#define IRQ_DM355_SPINT0_1	43
+#define IRQ_DM355_GPIO0		44
+#define IRQ_DM355_GPIO1		45
+#define IRQ_DM355_GPIO2		46
+#define IRQ_DM355_GPIO3		47
+#define IRQ_DM355_GPIO4		48
+#define IRQ_DM355_GPIO5		49
+#define IRQ_DM355_GPIO6		50
+#define IRQ_DM355_GPIO7		51
+#define IRQ_DM355_GPIO8		52
+#define IRQ_DM355_GPIO9		53
+#define IRQ_DM355_GPIOBNK0	54
+#define IRQ_DM355_GPIOBNK1	55
+#define IRQ_DM355_GPIOBNK2	56
+#define IRQ_DM355_GPIOBNK3	57
+#define IRQ_DM355_GPIOBNK4	58
+#define IRQ_DM355_GPIOBNK5	59
+#define IRQ_DM355_GPIOBNK6	60
 
 #define ARCH_TIMER_IRQ IRQ_TINT1_TINT34
 
Index: linux-2.6.18/include/asm-arm/arch-davinci/mux.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-davinci/mux.h
+++ linux-2.6.18/include/asm-arm/arch-davinci/mux.h
@@ -97,6 +97,87 @@ enum davinci_dm644x_index {
 	DM644X_LFLDEN,
 };
 
+enum davinci_dm355_index {
+	/* MMC/SD 0 */
+	DM355_MMCSD0,
+
+	/* MMC/SD 1 */
+	DM355_SD1_CLK,
+	DM355_SD1_CMD,
+	DM355_SD1_DATA3,
+	DM355_SD1_DATA2,
+	DM355_SD1_DATA1,
+	DM355_SD1_DATA0,
+
+	/* I2C */
+	DM355_I2C_SDA,
+	DM355_I2C_SCL,
+
+	/* ASP function */
+	DM355_MCBSP0_BDX,
+	DM355_MCBSP0_X,
+	DM355_MCBSP0_BFSX,
+	DM355_MCBSP0_BDR,
+	DM355_MCBSP0_R,
+	DM355_MCBSP0_BFSR,
+
+	/* PWM0 */
+	DM355_PWM0,
+
+	/* PWM1 */
+	DM355_PWM1,
+
+	/* PWM2 */
+	DM355_PWM2_G76,
+	DM355_PWM2_G77,
+	DM355_PWM2_G78,
+	DM355_PWM2_G79,
+
+	/* PWM3 */
+	DM355_PWM3_G69,
+	DM355_PWM3_G70,
+	DM355_PWM3_G74,
+	DM355_PWM3_G75,
+
+	/* SPI0 */
+	DM355_SPI0_SDI,
+	DM355_SPI0_SDENA0,
+	DM355_SPI0_SDENA1,
+
+	/* SPI1 */
+	DM355_SPI1_SCLK,
+	DM355_SPI1_SDO,
+	DM355_SPI1_SDENA0,
+	DM355_SPI1_SDENA1,
+
+	/* SPI2 */
+	DM355_SPI2_SCLK,
+	DM355_SPI2_SDO,
+	DM355_SPI2_SDENA0,
+	DM355_SPI2_SDENA1,
+
+	/* GPIO */
+	DM355_GPIO14,
+	DM355_GPIO15,
+	DM355_GPIO71,
+
+	/* Video Out */
+	DM355_VOUT_FIELD,
+	DM355_VOUT_FIELD_G70,
+	DM355_VOUT_HVSYNC,
+	DM355_VOUT_COUTL_EN,
+	DM355_VOUT_COUTH_EN,
+
+	/* Video In */
+	DM355_VIN_PCLK,
+	DM355_VIN_CAM_WEN,
+	DM355_VIN_CAM_VD,
+	DM355_VIN_CAM_HD,
+	DM355_VIN_YIN_EN,
+	DM355_VIN_CINL_EN,
+	DM355_VIN_CINH_EN,
+};
+
 #ifdef	CONFIG_DAVINCI_MUX
 /* setup pin muxing in Linux */
 extern void davinci_mux_init(void);
Index: linux-2.6.18/include/asm-arm/arch-davinci/psc.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-davinci/psc.h
+++ linux-2.6.18/include/asm-arm/arch-davinci/psc.h
@@ -39,16 +39,21 @@
 #define DAVINCI_LPSC_EMAC           5
 #define DAVINCI_LPSC_EMAC_WRAPPER   6
 #define DAVINCI_LPSC_MDIO           7
+#define DAVINCI_LPSC_MMC_SD1        7
 #define DAVINCI_LPSC_IEEE1394       8
+#define DAVINCI_LPSC_McBSP1         8
 #define DAVINCI_LPSC_USB            9
 #define DAVINCI_LPSC_ATA            10
+#define DAVINCI_LPSC_PWM3           10
 #define DAVINCI_LPSC_VLYNQ          11
 #define DAVINCI_LPSC_UHPI           12
 #define DAVINCI_LPSC_DDR_EMIF       13
 #define DAVINCI_LPSC_AEMIF          14
 #define DAVINCI_LPSC_MMC_SD         15
+#define DAVINCI_LPSC_MMC_SD0        15
 #define DAVINCI_LPSC_MEMSTICK       16
 #define DAVINCI_LPSC_McBSP          17
+#define DAVINCI_LPSC_McBSP0         17
 #define DAVINCI_LPSC_I2C            18
 #define DAVINCI_LPSC_UART0          19
 #define DAVINCI_LPSC_UART1          20
Index: linux-2.6.18/include/asm-arm/arch-davinci/common.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-davinci/common.h
+++ linux-2.6.18/include/asm-arm/arch-davinci/common.h
@@ -16,4 +16,11 @@ struct sys_timer;
 
 extern struct sys_timer davinci_timer;
 
+extern const u8 *davinci_irq_priorities;
+
+void __init davinci_map_common_io(void);
+void __init davinci_init_common_hw(void);
+
+void __init davinci_irq_init(void);
+
 #endif /* __ARCH_ARM_MACH_DAVINCI_COMMON_H */
Index: linux-2.6.18/mvl_patches/pro50-1550.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-1550.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1550);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

