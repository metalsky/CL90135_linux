#! /usr/bin/env bash
# Patch: -pro_musb_hdrc_Search_and_replace_pThis_with_musb
# Date: Fri Sep 19 14:06:34 2008
# From 8599b7afc08b29e839b89402866e6ea28f062a76 Mon Sep 17 00:00:00 2001
# From: Dmitry Krivoschekov <dkrivoschekov@ru.mvista.com>
# Date: Wed, 21 May 2008 18:13:47 +0400
# Subject: [PATCH] musb_hdrc: Search and replace pThis with musb
# 
# Search and replace pThis with musb
# 
# Signed-off-by: Tony Lindgren <tony@atomide.com>
# (cherry picked from commit 04d2e6bda99b17e5170c5eb167bc767e70780b24)
# 
# Conflicts:
# 
# 	drivers/usb/musb/musbhsdma.c

PATCHNUM=1658
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
From 8599b7afc08b29e839b89402866e6ea28f062a76 Mon Sep 17 00:00:00 2001
From: Dmitry Krivoschekov <dkrivoschekov@ru.mvista.com>
Date: Wed, 21 May 2008 18:13:47 +0400
Subject: [PATCH] musb_hdrc: Search and replace pThis with musb

Search and replace pThis with musb

Signed-off-by: Tony Lindgren <tony@atomide.com>
(cherry picked from commit 04d2e6bda99b17e5170c5eb167bc767e70780b24)

Conflicts:

	drivers/usb/musb/musbhsdma.c
Index: linux-2.6.18/drivers/usb/musb/cppi_dma.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/cppi_dma.c
+++ linux-2.6.18/drivers/usb/musb/cppi_dma.c
@@ -1134,7 +1134,7 @@ static int cppi_rx_scan(struct cppi *cpp
 	return completed;
 }
 
-void cppi_completion(struct musb *pThis, u32 rx, u32 tx)
+void cppi_completion(struct musb *musb, u32 rx, u32 tx)
 {
 	void			*__iomem regBase;
 	int			i, chanNum, numCompleted;
@@ -1143,9 +1143,9 @@ void cppi_completion(struct musb *pThis,
 	struct cppi_descriptor	*bdPtr;
 	struct musb_hw_ep	*pEnd = NULL;
 
-	cppi = container_of(pThis->pDmaController, struct cppi, Controller);
+	cppi = container_of(musb->pDmaController, struct cppi, Controller);
 
-	regBase = pThis->ctrl_base;
+	regBase = musb->ctrl_base;
 
 	chanNum = 0;
 	/* process TX channels */
@@ -1253,13 +1253,13 @@ void cppi_completion(struct musb *pThis,
 					}
 					if (bReqComplete)
 						musb_dma_completion(
-							pThis, chanNum + 1, 1);
+							musb, chanNum + 1, 1);
 
 				} else {
 					/* Bigger transfer than we could fit in
 					 * that first batch of descriptors...
 					 */
-					cppi_next_tx_segment(pThis, txChannel);
+					cppi_next_tx_segment(musb, txChannel);
 				}
 			} else
 				txChannel->activeQueueHead = bdPtr;
@@ -1283,7 +1283,7 @@ void cppi_completion(struct musb *pThis,
 			if (rxChannel->actualLen != rxChannel->transferSize
 					&& rxChannel->actualLen
 						== rxChannel->currOffset) {
-				cppi_next_rx_segment(pThis, rxChannel, 1);
+				cppi_next_rx_segment(musb, rxChannel, 1);
 				continue;
 			}
 
@@ -1295,7 +1295,7 @@ void cppi_completion(struct musb *pThis,
 			rxChannel->Channel.dwActualLength =
 					rxChannel->actualLen;
 			core_rxirq_disable(regBase, chanNum + 1);
-			musb_dma_completion(pThis, chanNum + 1, 0);
+			musb_dma_completion(musb, chanNum + 1, 0);
 		}
 	}
 
Index: linux-2.6.18/drivers/usb/musb/g_ep0.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/g_ep0.c
+++ linux-2.6.18/drivers/usb/musb/g_ep0.c
@@ -841,7 +841,7 @@ musb_g_ep0_queue(struct usb_ep *e, struc
 		return -EINVAL;
 
 	ep = to_musb_ep(e);
-	musb = ep->pThis;
+	musb = ep->musb;
 	regs = musb->control_ep->regs;
 
 	req = to_musb_request(r);
@@ -892,7 +892,7 @@ musb_g_ep0_queue(struct usb_ep *e, struc
 			musb_writew(regs, MGC_O_HDRC_CSR0,
 					musb->ackpend | MGC_M_CSR0_P_DATAEND);
 			musb->ackpend = 0;
-			musb_g_ep0_giveback(ep->pThis, r);
+			musb_g_ep0_giveback(ep->musb, r);
 		}
 
 	/* else for sequence #2 (OUT), caller provides a buffer
@@ -929,7 +929,7 @@ static int musb_g_ep0_halt(struct usb_ep
 		return -EINVAL;
 
 	ep = to_musb_ep(e);
-	musb = ep->pThis;
+	musb = ep->musb;
 	base = musb->pRegs;
 	regs = musb->control_ep->regs;
 
Index: linux-2.6.18/drivers/usb/musb/musb_gadget.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_gadget.c
+++ linux-2.6.18/drivers/usb/musb/musb_gadget.c
@@ -159,12 +159,12 @@ __acquires(ep->musb->Lock)
 static void nuke(struct musb_ep *ep, const int status)
 {
 	struct musb_request	*req = NULL;
-	void __iomem *epio = ep->pThis->aLocalEnd[ep->bEndNumber].regs;
+	void __iomem *epio = ep->musb->aLocalEnd[ep->bEndNumber].regs;
 
 	ep->busy = 1;
 
 	if (is_dma_capable() && ep->dma) {
-		struct dma_controller	*c = ep->pThis->pDmaController;
+		struct dma_controller	*c = ep->musb->pDmaController;
 		int value;
 		if (ep->is_in) {
 			musb_writew(epio, MGC_O_HDRC_TXCSR,
@@ -867,7 +867,7 @@ static int musb_gadget_enable(struct usb
 	pEnd = to_musb_ep(ep);
 	hw_ep = pEnd->hw_ep;
 	regs = hw_ep->regs;
-	musb = pEnd->pThis;
+	musb = pEnd->musb;
 	pBase = musb->pRegs;
 	bEnd = pEnd->bEndNumber;
 
@@ -1005,7 +1005,7 @@ static int musb_gadget_disable(struct us
 	int		status = 0;
 
 	pEnd = to_musb_ep(ep);
-	musb = pEnd->pThis;
+	musb = pEnd->musb;
 	bEnd = pEnd->bEndNumber;
 	epio = musb->aLocalEnd[bEnd].regs;
 
@@ -1161,7 +1161,7 @@ static int musb_gadget_queue(struct usb_
 		return -ENODATA;
 
 	pEnd = to_musb_ep(ep);
-	musb = pEnd->pThis;
+	musb = pEnd->musb;
 
 	pRequest = to_musb_request(req);
 	pRequest->musb = musb;
@@ -1229,7 +1229,7 @@ static int musb_gadget_dequeue(struct us
 	struct usb_request	*r;
 	unsigned long		flags;
 	int			status = 0;
-	struct musb		*musb = pEnd->pThis;
+	struct musb		*musb = pEnd->musb;
 
 	if (!ep || !pRequest || to_musb_request(pRequest)->ep != pEnd)
 		return -EINVAL;
@@ -1283,7 +1283,7 @@ int musb_gadget_set_halt(struct usb_ep *
 {
 	struct musb_ep		*pEnd = to_musb_ep(ep);
 	u8			bEnd = pEnd->bEndNumber;
-	struct musb		*musb = pEnd->pThis;
+	struct musb		*musb = pEnd->musb;
 	void __iomem		*epio = musb->aLocalEnd[bEnd].regs;
 	void __iomem		*pBase;
 	unsigned long		flags;
@@ -1363,7 +1363,7 @@ static int musb_gadget_fifo_status(struc
 	int			retval = -EINVAL;
 
 	if (musb_ep->desc && !musb_ep->is_in) {
-		struct musb		*musb = musb_ep->pThis;
+		struct musb		*musb = musb_ep->musb;
 		int			bEnd = musb_ep->bEndNumber;
 		void __iomem		*mbase = musb->pRegs;
 		unsigned long		flags;
@@ -1382,7 +1382,7 @@ static int musb_gadget_fifo_status(struc
 static void musb_gadget_fifo_flush(struct usb_ep *ep)
 {
 	struct musb_ep	*musb_ep = to_musb_ep(ep);
-	struct musb	*musb = musb_ep->pThis;
+	struct musb	*musb = musb_ep->musb;
 	u8		nEnd = musb_ep->bEndNumber;
 	void __iomem	*epio = musb->aLocalEnd[nEnd].regs;
 	void __iomem	*mbase;
@@ -1617,7 +1617,7 @@ init_peripheral_ep(struct musb *musb, st
 	memset(ep, 0, sizeof *ep);
 
 	ep->bEndNumber = bEnd;
-	ep->pThis = musb;
+	ep->musb = musb;
 	ep->hw_ep = hw_ep;
 	ep->is_in = is_in;
 
Index: linux-2.6.18/drivers/usb/musb/musb_gadget.h
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_gadget.h
+++ linux-2.6.18/drivers/usb/musb/musb_gadget.h
@@ -61,7 +61,7 @@ struct musb_ep {
 	struct usb_ep			end_point;
 	char				name[12];
 	struct musb_hw_ep		*hw_ep;
-	struct musb			*pThis;
+	struct musb			*musb;
 	u8				bEndNumber;
 
 	/* ... when enabled/disabled ... */
@@ -92,8 +92,8 @@ static inline struct usb_request *next_r
 	return container_of(queue->next, struct usb_request, list);
 }
 
-extern void musb_g_tx(struct musb *pThis, u8 bEnd);
-extern void musb_g_rx(struct musb *pThis, u8 bEnd);
+extern void musb_g_tx(struct musb *musb, u8 bEnd);
+extern void musb_g_rx(struct musb *musb, u8 bEnd);
 
 extern const struct usb_ep_ops musb_g_ep0_ops;
 
Index: linux-2.6.18/drivers/usb/musb/musb_host.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_host.c
+++ linux-2.6.18/drivers/usb/musb/musb_host.c
@@ -103,7 +103,7 @@
 
 /*************************** Forwards ***************************/
 
-static void musb_ep_program(struct musb *pThis, u8 bEnd,
+static void musb_ep_program(struct musb *musb, u8 bEnd,
 			struct urb *pUrb, unsigned int nOut,
 			u8 * pBuffer, u32 dwLength);
 
@@ -132,7 +132,7 @@ static inline void musb_h_tx_flush_fifo(
 
 /*
  * Start transmit. Caller is responsible for locking shared resources.
- * pThis must be locked.
+ * musb must be locked.
  */
 static inline void musb_h_tx_start(struct musb_hw_ep *ep)
 {
@@ -424,7 +424,7 @@ musb_giveback(struct musb_qh *qh, struct
  * Context: caller owns controller lock, irqs are blocked
  */
 static void
-musb_advance_schedule(struct musb *pThis, struct urb *urb,
+musb_advance_schedule(struct musb *musb, struct urb *urb,
 		struct musb_hw_ep *pEnd, int is_in)
 {
 	struct musb_qh	*qh;
@@ -439,7 +439,7 @@ musb_advance_schedule(struct musb *pThis
 		DBG(4, "... next ep%d %cX urb %p\n",
 				pEnd->bLocalEnd, is_in ? 'R' : 'T',
 				next_urb(qh));
-		musb_start_urb(pThis, is_in, qh);
+		musb_start_urb(musb, is_in, qh);
 	}
 }
 
@@ -466,7 +466,7 @@ static inline u16 musb_h_flush_rxfifo(st
 /*
  * PIO RX for a packet (or part of it).
  */
-static u8 musb_host_packet_rx(struct musb *pThis, struct urb *pUrb,
+static u8 musb_host_packet_rx(struct musb *musb, struct urb *pUrb,
 		u8 bEnd, u8 bIsochError)
 {
 	u16 wRxCount;
@@ -475,7 +475,7 @@ static u8 musb_host_packet_rx(struct mus
 	u8 bDone = FALSE;
 	u32			length;
 	int			do_flush = 0;
-	struct musb_hw_ep	*pEnd = pThis->aLocalEnd + bEnd;
+	struct musb_hw_ep	*pEnd = musb->aLocalEnd + bEnd;
 	void __iomem		*epio = pEnd->regs;
 	struct musb_qh		*qh = pEnd->in_qh;
 	int			nPipe = pUrb->pipe;
@@ -623,15 +623,15 @@ musb_rx_reinit(struct musb *musb, struct
  * Program an HDRC endpoint as per the given URB
  * Context: irqs blocked, controller lock held
  */
-static void musb_ep_program(struct musb *pThis, u8 bEnd,
+static void musb_ep_program(struct musb *musb, u8 bEnd,
 			struct urb *pUrb, unsigned int is_out,
 			u8 * pBuffer, u32 dwLength)
 {
 	struct dma_controller	*pDmaController;
 	struct dma_channel	*pDmaChannel;
 	u8			bDmaOk;
-	void __iomem		*pBase = pThis->pRegs;
-	struct musb_hw_ep	*pEnd = pThis->aLocalEnd + bEnd;
+	void __iomem		*pBase = musb->pRegs;
+	struct musb_hw_ep	*pEnd = musb->aLocalEnd + bEnd;
 	void __iomem		*epio = pEnd->regs;
 	struct musb_qh		*qh;
 	u16			wPacketSize;
@@ -654,7 +654,7 @@ static void musb_ep_program(struct musb 
 	MGC_SelectEnd(pBase, bEnd);
 
 	/* candidate for DMA? */
-	pDmaController = pThis->pDmaController;
+	pDmaController = musb->pDmaController;
 	if (is_dma_capable() && bEnd && pDmaController) {
 		pDmaChannel = is_out ? pEnd->tx_channel : pEnd->rx_channel;
 		if (!pDmaChannel) {
@@ -720,7 +720,7 @@ static void musb_ep_program(struct musb 
 		}
 
 		/* target addr and (for multipoint) hub addr/port */
-		if (pThis->bIsMultipoint) {
+		if (musb->bIsMultipoint) {
 			musb_writeb(pBase,
 				MGC_BUSCTL_OFFSET(bEnd, MGC_O_HDRC_TXFUNCADDR),
 				qh->addr_reg);
@@ -737,7 +737,7 @@ static void musb_ep_program(struct musb 
 		/* protocol/endpoint/interval/NAKlimit */
 		if (bEnd) {
 			musb_writeb(epio, MGC_O_HDRC_TXTYPE, qh->type_reg);
-			if (can_bulk_split(pThis, qh->type))
+			if (can_bulk_split(musb, qh->type))
 				musb_writew(epio, MGC_O_HDRC_TXMAXP,
 					wPacketSize
 					| ((pEnd->wMaxPacketSizeTx /
@@ -748,12 +748,12 @@ static void musb_ep_program(struct musb 
 			musb_writeb(epio, MGC_O_HDRC_TXINTERVAL, qh->intv_reg);
 		} else {
 			musb_writeb(epio, MGC_O_HDRC_NAKLIMIT0, qh->intv_reg);
-			if (pThis->bIsMultipoint)
+			if (musb->bIsMultipoint)
 				musb_writeb(epio, MGC_O_HDRC_TYPE0,
 						qh->type_reg);
 		}
 
-		if (can_bulk_split(pThis, qh->type))
+		if (can_bulk_split(musb, qh->type))
 			wLoadCount = min((u32) pEnd->wMaxPacketSizeTx,
 						dwLength);
 		else
@@ -875,7 +875,7 @@ static void musb_ep_program(struct musb 
 		u16	csr;
 
 		if (pEnd->rx_reinit) {
-			musb_rx_reinit(pThis, qh, pEnd);
+			musb_rx_reinit(musb, qh, pEnd);
 
 			/* init new state: toggle and NYET, maybe DMA later */
 			if (usb_gettoggle(pUrb->dev, qh->epnum, 0))
@@ -942,17 +942,17 @@ static void musb_ep_program(struct musb 
  * Service the default endpoint (ep0) as host.
  * Return TRUE until it's time to start the status stage.
  */
-static int musb_h_ep0_continue(struct musb *pThis,
+static int musb_h_ep0_continue(struct musb *musb,
 				u16 wCount, struct urb *pUrb)
 {
 	int			 bMore = FALSE;
 	u8 *pFifoDest = NULL;
 	u16 wFifoCount = 0;
-	struct musb_hw_ep	*pEnd = pThis->control_ep;
+	struct musb_hw_ep	*pEnd = musb->control_ep;
 	struct musb_qh		*qh = pEnd->in_qh;
 	struct usb_ctrlrequest	*pRequest;
 
-	switch (pThis->bEnd0Stage) {
+	switch (musb->bEnd0Stage) {
 	case MGC_END0_IN:
 		pFifoDest = pUrb->transfer_buffer + pUrb->actual_length;
 		wFifoCount = min(wCount, ((u16) (pUrb->transfer_buffer_length
@@ -979,12 +979,12 @@ static int musb_h_ep0_continue(struct mu
 			break;
 		} else if (pRequest->bRequestType & USB_DIR_IN) {
 			DBG(4, "start IN-DATA\n");
-			pThis->bEnd0Stage = MGC_END0_IN;
+			musb->bEnd0Stage = MGC_END0_IN;
 			bMore = TRUE;
 			break;
 		} else {
 			DBG(4, "start OUT-DATA\n");
-			pThis->bEnd0Stage = MGC_END0_OUT;
+			musb->bEnd0Stage = MGC_END0_OUT;
 			bMore = TRUE;
 		}
 		/* FALLTHROUGH */
@@ -1005,7 +1005,7 @@ static int musb_h_ep0_continue(struct mu
 		}
 		break;
 	default:
-		ERR("bogus ep0 stage %d\n", pThis->bEnd0Stage);
+		ERR("bogus ep0 stage %d\n", musb->bEnd0Stage);
 		break;
 	}
 
@@ -1018,13 +1018,13 @@ static int musb_h_ep0_continue(struct mu
  *
  * called with controller irqlocked
  */
-irqreturn_t musb_h_ep0_irq(struct musb *pThis)
+irqreturn_t musb_h_ep0_irq(struct musb *musb)
 {
 	struct urb		*pUrb;
 	u16			wCsrVal, wCount;
 	int			status = 0;
-	void __iomem		*pBase = pThis->pRegs;
-	struct musb_hw_ep	*pEnd = pThis->control_ep;
+	void __iomem		*pBase = musb->pRegs;
+	struct musb_hw_ep	*pEnd = musb->control_ep;
 	void __iomem		*epio = pEnd->regs;
 	struct musb_qh		*qh = pEnd->in_qh;
 	u8			bComplete = FALSE;
@@ -1040,10 +1040,10 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 			: 0;
 
 	DBG(4, "<== csr0 %04x, qh %p, count %d, urb %p, stage %d\n",
-		wCsrVal, qh, wCount, pUrb, pThis->bEnd0Stage);
+		wCsrVal, qh, wCount, pUrb, musb->bEnd0Stage);
 
 	/* if we just did status stage, we are done */
-	if (MGC_END0_STATUS == pThis->bEnd0Stage) {
+	if (MGC_END0_STATUS == musb->bEnd0Stage) {
 		retval = IRQ_HANDLED;
 		bComplete = TRUE;
 	}
@@ -1112,9 +1112,9 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 
 	if (!bComplete) {
 		/* call common logic and prepare response */
-		if (musb_h_ep0_continue(pThis, wCount, pUrb)) {
+		if (musb_h_ep0_continue(musb, wCount, pUrb)) {
 			/* more packets required */
-			wCsrVal = (MGC_END0_IN == pThis->bEnd0Stage)
+			wCsrVal = (MGC_END0_IN == musb->bEnd0Stage)
 				?  MGC_M_CSR0_H_REQPKT : MGC_M_CSR0_TXPKTRDY;
 		} else {
 			/* data transfer complete; perform status phase */
@@ -1127,7 +1127,7 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 					| MGC_M_CSR0_TXPKTRDY;
 
 			/* flag status stage */
-			pThis->bEnd0Stage = MGC_END0_STATUS;
+			musb->bEnd0Stage = MGC_END0_STATUS;
 
 			DBG(5, "ep0 STATUS, csr %04x\n", wCsrVal);
 
@@ -1135,11 +1135,11 @@ irqreturn_t musb_h_ep0_irq(struct musb *
 		musb_writew(epio, MGC_O_HDRC_CSR0, wCsrVal);
 		retval = IRQ_HANDLED;
 	} else
-		pThis->bEnd0Stage = MGC_END0_IDLE;
+		musb->bEnd0Stage = MGC_END0_IDLE;
 
 	/* call completion handler if done */
 	if (bComplete)
-		musb_advance_schedule(pThis, pUrb, pEnd, 1);
+		musb_advance_schedule(musb, pUrb, pEnd, 1);
 done:
 	return retval;
 }
@@ -1162,7 +1162,7 @@ done:
 #endif
 
 /* Service a Tx-Available or dma completion irq for the endpoint */
-void musb_host_tx(struct musb *pThis, u8 bEnd)
+void musb_host_tx(struct musb *musb, u8 bEnd)
 {
 	int			nPipe;
 	u8			bDone = FALSE;
@@ -1170,11 +1170,11 @@ void musb_host_tx(struct musb *pThis, u8
 	size_t			wLength = 0;
 	u8			*pBuffer = NULL;
 	struct urb		*pUrb;
-	struct musb_hw_ep	*pEnd = pThis->aLocalEnd + bEnd;
+	struct musb_hw_ep	*pEnd = musb->aLocalEnd + bEnd;
 	void __iomem		*epio = pEnd->regs;
 	struct musb_qh		*qh = pEnd->out_qh;
 	u32			status = 0;
-	void __iomem		*pBase = pThis->pRegs;
+	void __iomem		*pBase = musb->pRegs;
 	struct dma_channel	*dma;
 
 	pUrb = next_urb(qh);
@@ -1227,7 +1227,7 @@ void musb_host_tx(struct musb *pThis, u8
 	if (status) {
 		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
 			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
-			(void) pThis->pDmaController->channel_abort(dma);
+			(void) musb->pDmaController->channel_abort(dma);
 		}
 
 		/* do the proper sequence to abort the transfer in the
@@ -1309,7 +1309,7 @@ void musb_host_tx(struct musb *pThis, u8
 		/* set status */
 		pUrb->status = status;
 		pUrb->actual_length = qh->offset;
-		musb_advance_schedule(pThis, pUrb, pEnd, USB_DIR_OUT);
+		musb_advance_schedule(musb, pUrb, pEnd, USB_DIR_OUT);
 
 	} else if (!(wTxCsrVal & MGC_M_TXCSR_DMAENAB)) {
 		// WARN_ON(!pBuffer);
@@ -1377,14 +1377,14 @@ finish:
  * Service an RX interrupt for the given IN endpoint; docs cover bulk, iso,
  * and high-bandwidth IN transfer cases.
  */
-void musb_host_rx(struct musb *pThis, u8 bEnd)
+void musb_host_rx(struct musb *musb, u8 bEnd)
 {
 	struct urb		*pUrb;
-	struct musb_hw_ep	*pEnd = pThis->aLocalEnd + bEnd;
+	struct musb_hw_ep	*pEnd = musb->aLocalEnd + bEnd;
 	void __iomem		*epio = pEnd->regs;
 	struct musb_qh		*qh = pEnd->in_qh;
 	size_t			xfer_len;
-	void __iomem		*pBase = pThis->pRegs;
+	void __iomem		*pBase = musb->pRegs;
 	int			nPipe;
 	u16			wRxCsrVal, wVal;
 	u8			bIsochError = FALSE;
@@ -1461,7 +1461,7 @@ void musb_host_rx(struct musb *pThis, u8
 		/* clean up dma and collect transfer count */
 		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
 			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
-			(void) pThis->pDmaController->channel_abort(dma);
+			(void) musb->pDmaController->channel_abort(dma);
 			xfer_len = dma->dwActualLength;
 		}
 		musb_h_flush_rxfifo(pEnd, 0);
@@ -1492,7 +1492,7 @@ void musb_host_rx(struct musb *pThis, u8
 		 */
 		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
 			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
-			(void) pThis->pDmaController->channel_abort(dma);
+			(void) musb->pDmaController->channel_abort(dma);
 			xfer_len = dma->dwActualLength;
 			bDone = TRUE;
 		}
@@ -1567,7 +1567,7 @@ void musb_host_rx(struct musb *pThis, u8
 					qh->offset,
 					pUrb->transfer_buffer_length);
 
-			c = pThis->pDmaController;
+			c = musb->pDmaController;
 
 			dma->bDesiredMode = 0;
 #ifdef USE_MODE1
@@ -1633,7 +1633,7 @@ void musb_host_rx(struct musb *pThis, u8
 #endif	/* Mentor DMA */
 
 		if (!dma) {
-			bDone = musb_host_packet_rx(pThis, pUrb,
+			bDone = musb_host_packet_rx(musb, pUrb,
 					bEnd, bIsochError);
 			DBG(6, "read %spacket\n", bDone ? "last " : "");
 		}
@@ -1645,7 +1645,7 @@ finish:
 	if (bDone) {
 		if (pUrb->status == -EINPROGRESS)
 			pUrb->status = status;
-		musb_advance_schedule(pThis, pUrb, pEnd, USB_DIR_IN);
+		musb_advance_schedule(musb, pUrb, pEnd, USB_DIR_IN);
 	}
 }
 
Index: linux-2.6.18/drivers/usb/musb/musb_procfs.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musb_procfs.c
+++ linux-2.6.18/drivers/usb/musb/musb_procfs.c
@@ -171,7 +171,7 @@ static int dump_ep(struct musb_ep *ep, c
 
 		if (is_cppi_enabled() && ep->bEndNumber) {
 			unsigned	cppi = ep->bEndNumber - 1;
-			void __iomem	*base = ep->pThis->ctrl_base;
+			void __iomem	*base = ep->musb->ctrl_base;
 			unsigned	off1 = cppi << 2;
 			void __iomem	*ram = base;
 			char		tmp[16];
@@ -233,16 +233,16 @@ static int dump_ep(struct musb_ep *ep, c
 #endif
 
 static int
-dump_end_info(struct musb *pThis, u8 bEnd, char *aBuffer, unsigned max)
+dump_end_info(struct musb *musb, u8 bEnd, char *aBuffer, unsigned max)
 {
 	int			code = 0;
 	char			*buf = aBuffer;
-	struct musb_hw_ep	*pEnd = &pThis->aLocalEnd[bEnd];
+	struct musb_hw_ep	*pEnd = &musb->aLocalEnd[bEnd];
 
 	do {
-		MGC_SelectEnd(pThis->pRegs, bEnd);
+		MGC_SelectEnd(musb->pRegs, bEnd);
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
-		if (is_host_active(pThis)) {
+		if (is_host_active(musb)) {
 			int		dump_rx, dump_tx;
 			void __iomem	*regs = pEnd->regs;
 
@@ -253,15 +253,15 @@ dump_end_info(struct musb *pThis, u8 bEn
 				/* control is shared, uses RX queue
 				 * but (mostly) shadowed tx registers
 				 */
-				dump_tx = !list_empty(&pThis->control);
+				dump_tx = !list_empty(&musb->control);
 				dump_rx = 0;
-			} else if (pEnd == pThis->bulk_ep) {
-				dump_tx = !list_empty(&pThis->out_bulk);
-				dump_rx = !list_empty(&pThis->in_bulk);
-			} else if (pThis->periodic[bEnd]) {
+			} else if (pEnd == musb->bulk_ep) {
+				dump_tx = !list_empty(&musb->out_bulk);
+				dump_rx = !list_empty(&musb->in_bulk);
+			} else if (musb->periodic[bEnd]) {
 				struct usb_host_endpoint	*hep;
 
-				hep = pThis->periodic[bEnd]->hep;
+				hep = musb->periodic[bEnd]->hep;
 				dump_rx = hep->desc.bEndpointAddress
 						& USB_ENDPOINT_DIR_MASK;
 				dump_tx = !dump_rx;
@@ -284,13 +284,13 @@ dump_end_info(struct musb *pThis, u8 bEn
 					musb_readw(regs, MGC_O_HDRC_RXMAXP),
 					musb_readb(regs, MGC_O_HDRC_RXTYPE),
 					/* FIXME:  assumes multipoint */
-					musb_readb(pThis->pRegs,
+					musb_readb(musb->pRegs,
 						MGC_BUSCTL_OFFSET(bEnd,
 						MGC_O_HDRC_RXFUNCADDR)),
-					musb_readb(pThis->pRegs,
+					musb_readb(musb->pRegs,
 						MGC_BUSCTL_OFFSET(bEnd,
 						MGC_O_HDRC_RXHUBADDR)),
-					musb_readb(pThis->pRegs,
+					musb_readb(musb->pRegs,
 						MGC_BUSCTL_OFFSET(bEnd,
 						MGC_O_HDRC_RXHUBPORT))
 					);
@@ -309,7 +309,7 @@ dump_end_info(struct musb *pThis, u8 bEn
 					void __iomem	*ram;
 					char		tmp[16];
 
-					base = pThis->ctrl_base;
+					base = musb->ctrl_base;
 					ram = DAVINCI_RXCPPI_STATERAM_OFFSET(
 							cppi) + base;
 					snprintf(tmp, sizeof tmp, "%d left, ",
@@ -337,18 +337,18 @@ dump_end_info(struct musb *pThis, u8 bEn
 					max -= code;
 				}
 
-				if (pEnd == pThis->bulk_ep
+				if (pEnd == musb->bulk_ep
 						&& !list_empty(
-							&pThis->in_bulk)) {
-					code = dump_queue(&pThis->in_bulk,
+							&musb->in_bulk)) {
+					code = dump_queue(&musb->in_bulk,
 							buf, max);
 					if (code <= 0)
 						break;
 					code = min(code, (int) max);
 					buf += code;
 					max -= code;
-				} else if (pThis->periodic[bEnd]) {
-					code = dump_qh(pThis->periodic[bEnd],
+				} else if (musb->periodic[bEnd]) {
+					code = dump_qh(musb->periodic[bEnd],
 							buf, max);
 					if (code <= 0)
 						break;
@@ -372,13 +372,13 @@ dump_end_info(struct musb *pThis, u8 bEn
 					musb_readw(regs, MGC_O_HDRC_TXMAXP),
 					musb_readb(regs, MGC_O_HDRC_TXTYPE),
 					/* FIXME:  assumes multipoint */
-					musb_readb(pThis->pRegs,
+					musb_readb(musb->pRegs,
 						MGC_BUSCTL_OFFSET(bEnd,
 						MGC_O_HDRC_TXFUNCADDR)),
-					musb_readb(pThis->pRegs,
+					musb_readb(musb->pRegs,
 						MGC_BUSCTL_OFFSET(bEnd,
 						MGC_O_HDRC_TXHUBADDR)),
-					musb_readb(pThis->pRegs,
+					musb_readb(musb->pRegs,
 						MGC_BUSCTL_OFFSET(bEnd,
 						MGC_O_HDRC_TXHUBPORT))
 					);
@@ -395,7 +395,7 @@ dump_end_info(struct musb *pThis, u8 bEn
 					void __iomem	*base;
 					void __iomem	*ram;
 
-					base = pThis->ctrl_base;
+					base = musb->ctrl_base;
 					ram = DAVINCI_RXCPPI_STATERAM_OFFSET(
 							cppi) + base;
 					code = snprintf(buf, max,
@@ -418,28 +418,28 @@ dump_end_info(struct musb *pThis, u8 bEn
 					max -= code;
 				}
 
-				if (pEnd == pThis->control_ep
+				if (pEnd == musb->control_ep
 						&& !list_empty(
-							&pThis->control)) {
-					code = dump_queue(&pThis->control,
+							&musb->control)) {
+					code = dump_queue(&musb->control,
 							buf, max);
 					if (code <= 0)
 						break;
 					code = min(code, (int) max);
 					buf += code;
 					max -= code;
-				} else if (pEnd == pThis->bulk_ep
+				} else if (pEnd == musb->bulk_ep
 						&& !list_empty(
-							&pThis->out_bulk)) {
-					code = dump_queue(&pThis->out_bulk,
+							&musb->out_bulk)) {
+					code = dump_queue(&musb->out_bulk,
 							buf, max);
 					if (code <= 0)
 						break;
 					code = min(code, (int) max);
 					buf += code;
 					max -= code;
-				} else if (pThis->periodic[bEnd]) {
-					code = dump_qh(pThis->periodic[bEnd],
+				} else if (musb->periodic[bEnd]) {
+					code = dump_qh(musb->periodic[bEnd],
 							buf, max);
 					if (code <= 0)
 						break;
@@ -451,7 +451,7 @@ dump_end_info(struct musb *pThis, u8 bEn
 		}
 #endif
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
-		if (is_peripheral_active(pThis)) {
+		if (is_peripheral_active(musb)) {
 			code = 0;
 
 			if (pEnd->ep_in.desc || !bEnd) {
@@ -478,19 +478,19 @@ dump_end_info(struct musb *pThis, u8 bEn
 }
 
 /** Dump the current status and compile options.
- * @param pThis the device driver instance
+ * @param musb the device driver instance
  * @param buffer where to dump the status; it must be big enough hold the
  * result otherwise "BAD THINGS HAPPENS(TM)".
  */
-static int dump_header_stats(struct musb *pThis, char *buffer)
+static int dump_header_stats(struct musb *musb, char *buffer)
 {
 	int code, count = 0;
-	const void __iomem *pBase = pThis->pRegs;
+	const void __iomem *pBase = musb->pRegs;
 
 	*buffer = 0;
 	count = sprintf(buffer, "Status: %sHDRC, Mode=%s "
 				"(Power=%02x, DevCtl=%02x)\n",
-			(pThis->bIsMultipoint ? "M" : ""), MUSB_MODE(pThis),
+			(musb->bIsMultipoint ? "M" : ""), MUSB_MODE(musb),
 			musb_readb(pBase, MGC_O_HDRC_POWER),
 			musb_readb(pBase, MGC_O_HDRC_DEVCTL));
 	if (count <= 0)
@@ -498,8 +498,8 @@ static int dump_header_stats(struct musb
 	buffer += count;
 
 	code = sprintf(buffer, "OTG state: %s; %sactive\n",
-			otg_state_string(pThis),
-			pThis->is_active ? "" : "in");
+			otg_state_string(musb),
+			musb->is_active ? "" : "in");
 	if (code <= 0)
 		goto done;
 	buffer += code;
@@ -528,7 +528,7 @@ static int dump_header_stats(struct musb
 #endif
 			", debug=%d [eps=%d]\n",
 		debug,
-		pThis->bEndCount);
+		musb->bEndCount);
 	if (code <= 0)
 		goto done;
 	count += code;
@@ -536,7 +536,7 @@ static int dump_header_stats(struct musb
 
 #ifdef	CONFIG_USB_GADGET_MUSB_HDRC
 	code = sprintf(buffer, "Peripheral address: %02x\n",
-			musb_readb(pThis, MGC_O_HDRC_FADDR));
+			musb_readb(musb, MGC_O_HDRC_FADDR));
 	if (code <= 0)
 		goto done;
 	buffer += code;
@@ -545,7 +545,7 @@ static int dump_header_stats(struct musb
 
 #ifdef	CONFIG_USB_MUSB_HDRC_HCD
 	code = sprintf(buffer, "Root port status: %08x\n",
-			pThis->port1_status);
+			musb->port1_status);
 	if (code <= 0)
 		goto done;
 	buffer += code;
@@ -557,14 +557,14 @@ static int dump_header_stats(struct musb
 			"DaVinci: ctrl=%02x stat=%1x phy=%03x\n"
 			"\trndis=%05x auto=%04x intsrc=%08x intmsk=%08x"
 			"\n",
-			musb_readl(pThis->ctrl_base, DAVINCI_USB_CTRL_REG),
-			musb_readl(pThis->ctrl_base, DAVINCI_USB_STAT_REG),
+			musb_readl(musb->ctrl_base, DAVINCI_USB_CTRL_REG),
+			musb_readl(musb->ctrl_base, DAVINCI_USB_STAT_REG),
 			__raw_readl(IO_ADDRESS(USBPHY_CTL_PADDR)),
-			musb_readl(pThis->ctrl_base, DAVINCI_RNDIS_REG),
-			musb_readl(pThis->ctrl_base, DAVINCI_AUTOREQ_REG),
-			musb_readl(pThis->ctrl_base,
+			musb_readl(musb->ctrl_base, DAVINCI_RNDIS_REG),
+			musb_readl(musb->ctrl_base, DAVINCI_AUTOREQ_REG),
+			musb_readl(musb->ctrl_base,
 					DAVINCI_USB_INT_SOURCE_REG),
-			musb_readl(pThis->ctrl_base,
+			musb_readl(musb->ctrl_base,
 					DAVINCI_USB_INT_MASK_REG));
 	if (code <= 0)
 		goto done;
@@ -578,37 +578,37 @@ static int dump_header_stats(struct musb
 			"\n\totg %03x timer %08x"
 			"\n\tprcm conf %08x mgmt %08x; int src %08x mask %08x"
 			"\n",
-			musb_readl(pThis->ctrl_base, TUSB_DEV_CONF),
-			musb_readl(pThis->ctrl_base, TUSB_PHY_OTG_CTRL_ENABLE),
-			musb_readl(pThis->ctrl_base, TUSB_PHY_OTG_CTRL),
-			musb_readl(pThis->ctrl_base, TUSB_DEV_OTG_STAT),
-			musb_readl(pThis->ctrl_base, TUSB_DEV_OTG_TIMER),
-			musb_readl(pThis->ctrl_base, TUSB_PRCM_CONF),
-			musb_readl(pThis->ctrl_base, TUSB_PRCM_MNGMT),
-			musb_readl(pThis->ctrl_base, TUSB_INT_SRC),
-			musb_readl(pThis->ctrl_base, TUSB_INT_MASK));
+			musb_readl(musb->ctrl_base, TUSB_DEV_CONF),
+			musb_readl(musb->ctrl_base, TUSB_PHY_OTG_CTRL_ENABLE),
+			musb_readl(musb->ctrl_base, TUSB_PHY_OTG_CTRL),
+			musb_readl(musb->ctrl_base, TUSB_DEV_OTG_STAT),
+			musb_readl(musb->ctrl_base, TUSB_DEV_OTG_TIMER),
+			musb_readl(musb->ctrl_base, TUSB_PRCM_CONF),
+			musb_readl(musb->ctrl_base, TUSB_PRCM_MNGMT),
+			musb_readl(musb->ctrl_base, TUSB_INT_SRC),
+			musb_readl(musb->ctrl_base, TUSB_INT_MASK));
 	if (code <= 0)
 		goto done;
 	count += code;
 	buffer += code;
 #endif	/* DAVINCI */
 
-	if (is_cppi_enabled() && pThis->pDmaController) {
+	if (is_cppi_enabled() && musb->pDmaController) {
 		code = sprintf(buffer,
 				"CPPI: txcr=%d txsrc=%01x txena=%01x; "
 				"rxcr=%d rxsrc=%01x rxena=%01x "
 				"\n",
-				musb_readl(pThis->ctrl_base,
+				musb_readl(musb->ctrl_base,
 						DAVINCI_TXCPPI_CTRL_REG),
-				musb_readl(pThis->ctrl_base,
+				musb_readl(musb->ctrl_base,
 						DAVINCI_TXCPPI_RAW_REG),
-				musb_readl(pThis->ctrl_base,
+				musb_readl(musb->ctrl_base,
 						DAVINCI_TXCPPI_INTENAB_REG),
-				musb_readl(pThis->ctrl_base,
+				musb_readl(musb->ctrl_base,
 						DAVINCI_RXCPPI_CTRL_REG),
-				musb_readl(pThis->ctrl_base,
+				musb_readl(musb->ctrl_base,
 						DAVINCI_RXCPPI_RAW_REG),
-				musb_readl(pThis->ctrl_base,
+				musb_readl(musb->ctrl_base,
 						DAVINCI_RXCPPI_INTENAB_REG));
 		if (code <= 0)
 			goto done;
@@ -617,10 +617,10 @@ static int dump_header_stats(struct musb
 	}
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
-	if (is_peripheral_enabled(pThis)) {
+	if (is_peripheral_enabled(musb)) {
 		code = sprintf(buffer, "Gadget driver: %s\n",
-				pThis->pGadgetDriver
-					? pThis->pGadgetDriver->driver.name
+				musb->pGadgetDriver
+					? musb->pGadgetDriver->driver.name
 					: "(none)");
 		if (code <= 0)
 			goto done;
@@ -784,7 +784,7 @@ static int musb_proc_read(char *page, ch
 	char *buffer = page;
 	int code = 0;
 	unsigned long	flags;
-	struct musb	*pThis = data;
+	struct musb	*musb = data;
 	unsigned	bEnd;
 
 	count -= off;
@@ -792,9 +792,9 @@ static int musb_proc_read(char *page, ch
 	if (count <= 0)
 		return -EINVAL;
 
-	spin_lock_irqsave(&pThis->Lock, flags);
+	spin_lock_irqsave(&musb->Lock, flags);
 
-	code = dump_header_stats(pThis, buffer);
+	code = dump_header_stats(musb, buffer);
 	if (code > 0) {
 		buffer += code;
 		count -= code;
@@ -802,18 +802,18 @@ static int musb_proc_read(char *page, ch
 
 	/* generate the report for the end points */
 	// REVISIT ... not unless something's connected!
-	for (bEnd = 0; count >= 0 && bEnd < pThis->bEndCount;
+	for (bEnd = 0; count >= 0 && bEnd < musb->bEndCount;
 			bEnd++) {
-		code = dump_end_info(pThis, bEnd, buffer, count);
+		code = dump_end_info(musb, bEnd, buffer, count);
 		if (code > 0) {
 			buffer += code;
 			count -= code;
 		}
 	}
 
-	musb_platform_try_idle(pThis, 0);
+	musb_platform_try_idle(musb, 0);
 
-	spin_unlock_irqrestore(&pThis->Lock, flags);
+	spin_unlock_irqrestore(&musb->Lock, flags);
 	*eof = 1;
 
 	return buffer - page;
Index: linux-2.6.18/drivers/usb/musb/musbdefs.h
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musbdefs.h
+++ linux-2.6.18/drivers/usb/musb/musbdefs.h
@@ -496,8 +496,8 @@ static inline struct musb *gadget_to_mus
 
 extern const char musb_driver_name[];
 
-extern void musb_start(struct musb *pThis);
-extern void musb_stop(struct musb *pThis);
+extern void musb_start(struct musb *musb);
+extern void musb_stop(struct musb *musb);
 
 extern void musb_write_fifo(struct musb_hw_ep *ep,
 			     u16 wCount, const u8 * pSource);
Index: linux-2.6.18/drivers/usb/musb/musbhsdma.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/musbhsdma.c
+++ linux-2.6.18/drivers/usb/musb/musbhsdma.c
@@ -104,12 +104,12 @@ static int dma_controller_stop(struct dm
 {
 	struct musb_dma_controller *pController =
 		container_of(c, struct musb_dma_controller, Controller);
-	struct musb *pThis = (struct musb *) pController->pDmaPrivate;
+	struct musb *musb = (struct musb *) pController->pDmaPrivate;
 	struct dma_channel *pChannel;
 	u8 bBit;
 
 	if (pController->bmUsedChannels != 0) {
-		dev_err(pThis->controller,
+		dev_err(musb->controller,
 			"Stopping DMA controller while channel active\n");
 
 		for (bBit = 0; bBit < MGC_HSDMA_CHANNELS; bBit++) {
@@ -387,10 +387,10 @@ void dma_controller_destroy(struct dma_c
 }
 
 struct dma_controller *__init
-dma_controller_create(struct musb *pThis, void __iomem *pCoreBase)
+dma_controller_create(struct musb *musb, void __iomem *pCoreBase)
 {
 	struct musb_dma_controller *pController;
-	struct device *dev = pThis->controller;
+	struct device *dev = musb->controller;
 	struct platform_device *pdev = to_platform_device(dev);
 	int irq = platform_get_irq(pdev, 1);
 
@@ -404,7 +404,7 @@ dma_controller_create(struct musb *pThis
 		return NULL;
 
 	pController->bChannelCount = MGC_HSDMA_CHANNELS;
-	pController->pDmaPrivate = pThis;
+	pController->pDmaPrivate = musb;
 	pController->pCoreBase = pCoreBase;
 
 	pController->Controller.pPrivateData = pController;
@@ -416,7 +416,7 @@ dma_controller_create(struct musb *pThis
 	pController->Controller.channel_abort = dma_channel_abort;
 
 	if (request_irq(irq, dma_controller_irq, SA_INTERRUPT,
-			pThis->controller->bus_id, &pController->Controller)) {
+			musb->controller->bus_id, &pController->Controller)) {
 		dev_err(dev, "request_irq %d failed!\n", irq);
 		dma_controller_destroy(&pController->Controller);
 		return NULL;
Index: linux-2.6.18/drivers/usb/musb/plat_uds.c
===================================================================
--- linux-2.6.18.orig/drivers/usb/musb/plat_uds.c
+++ linux-2.6.18/drivers/usb/musb/plat_uds.c
@@ -350,7 +350,7 @@ void musb_hnp_stop(struct musb *musb)
  * paramount importance, it seems OK to check them individually;
  * the order of the tests is specified in the manual
  *
- * @param pThis instance pointer
+ * @param musb instance pointer
  * @param bIntrUSB register contents
  * @param devctl
  * @param power
@@ -360,12 +360,12 @@ void musb_hnp_stop(struct musb *musb)
 		| MGC_M_INTR_VBUSERROR | MGC_M_INTR_CONNECT \
 		| MGC_M_INTR_RESET )
 
-static irqreturn_t musb_stage0_irq(struct musb * pThis, u8 bIntrUSB,
+static irqreturn_t musb_stage0_irq(struct musb * musb, u8 bIntrUSB,
 				u8 devctl, u8 power)
 {
 	irqreturn_t handled = IRQ_NONE;
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
-	void __iomem *pBase = pThis->pRegs;
+	void __iomem *pBase = musb->pRegs;
 #endif
 
 	DBG(3, "<== Power=%02x, DevCtl=%02x, bIntrUSB=0x%x\n", power, devctl,
@@ -377,11 +377,11 @@ static irqreturn_t musb_stage0_irq(struc
 	 */
 	if (bIntrUSB & MGC_M_INTR_RESUME) {
 		handled = IRQ_HANDLED;
-		DBG(3, "RESUME (%s)\n", otg_state_string(pThis));
+		DBG(3, "RESUME (%s)\n", otg_state_string(musb));
 
 		if (devctl & MGC_M_DEVCTL_HM) {
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
-			switch (pThis->xceiv.state) {
+			switch (musb->xceiv.state) {
 			case OTG_STATE_A_SUSPEND:
 				/* remote wakeup?  later, GetPortStatus
 				 * will stop RESUME signaling
@@ -389,7 +389,7 @@ static irqreturn_t musb_stage0_irq(struc
 
 				if (power & MGC_M_POWER_SUSPENDM) {
 					/* spurious */
-					pThis->int_usb &= ~MGC_M_INTR_SUSPEND;
+					musb->int_usb &= ~MGC_M_INTR_SUSPEND;
 					DBG(2, "Spurious SUSPENDM\n");
 					break;
 				}
@@ -398,34 +398,34 @@ static irqreturn_t musb_stage0_irq(struc
 				musb_writeb(pBase, MGC_O_HDRC_POWER,
 						power | MGC_M_POWER_RESUME);
 
-				pThis->port1_status |=
+				musb->port1_status |=
 						(USB_PORT_STAT_C_SUSPEND << 16)
 						| MUSB_PORT_STAT_RESUME;
-				pThis->rh_timer = jiffies
+				musb->rh_timer = jiffies
 						+ msecs_to_jiffies(20);
 
-				pThis->xceiv.state = OTG_STATE_A_HOST;
-				pThis->is_active = 1;
-				usb_hcd_resume_root_hub(musb_to_hcd(pThis));
+				musb->xceiv.state = OTG_STATE_A_HOST;
+				musb->is_active = 1;
+				usb_hcd_resume_root_hub(musb_to_hcd(musb));
 				break;
 			case OTG_STATE_B_WAIT_ACON:
-				pThis->xceiv.state = OTG_STATE_B_PERIPHERAL;
-				pThis->is_active = 1;
-				MUSB_DEV_MODE(pThis);
+				musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
+				musb->is_active = 1;
+				MUSB_DEV_MODE(musb);
 				break;
 			default:
 				WARN("bogus %s RESUME (%s)\n",
 					"host",
-					otg_state_string(pThis));
+					otg_state_string(musb));
 			}
 #endif
 		} else {
-			switch (pThis->xceiv.state) {
+			switch (musb->xceiv.state) {
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 			case OTG_STATE_A_SUSPEND:
 				/* possibly DISCONNECT is upcoming */
-				pThis->xceiv.state = OTG_STATE_A_HOST;
-				usb_hcd_resume_root_hub(musb_to_hcd(pThis));
+				musb->xceiv.state = OTG_STATE_A_HOST;
+				usb_hcd_resume_root_hub(musb_to_hcd(musb));
 				break;
 #endif
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
@@ -436,20 +436,20 @@ static irqreturn_t musb_stage0_irq(struc
 				 */
 				if ((devctl & MGC_M_DEVCTL_VBUS)
 						!= (3 << MGC_S_DEVCTL_VBUS)) {
-					pThis->int_usb |= MGC_M_INTR_DISCONNECT;
-					pThis->int_usb &= ~MGC_M_INTR_SUSPEND;
+					musb->int_usb |= MGC_M_INTR_DISCONNECT;
+					musb->int_usb &= ~MGC_M_INTR_SUSPEND;
 					break;
 				}
-				musb_g_resume(pThis);
+				musb_g_resume(musb);
 				break;
 			case OTG_STATE_B_IDLE:
-				pThis->int_usb &= ~MGC_M_INTR_SUSPEND;
+				musb->int_usb &= ~MGC_M_INTR_SUSPEND;
 				break;
 #endif
 			default:
 				WARN("bogus %s RESUME (%s)\n",
 					"peripheral",
-					otg_state_string(pThis));
+					otg_state_string(musb));
 			}
 		}
 	}
@@ -457,7 +457,7 @@ static irqreturn_t musb_stage0_irq(struc
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 	/* see manual for the order of the tests */
 	if (bIntrUSB & MGC_M_INTR_SESSREQ) {
-		DBG(1, "SESSION_REQUEST (%s)\n", otg_state_string(pThis));
+		DBG(1, "SESSION_REQUEST (%s)\n", otg_state_string(musb));
 
 		/* IRQ arrives from ID pin sense or (later, if VBUS power
 		 * is removed) SRP.  responses are time critical:
@@ -467,10 +467,10 @@ static irqreturn_t musb_stage0_irq(struc
 		 * a_wait_vrise_tmout triggers VBUS_ERROR transitions
 		 */
 		musb_writeb(pBase, MGC_O_HDRC_DEVCTL, MGC_M_DEVCTL_SESSION);
-		pThis->bEnd0Stage = MGC_END0_START;
-		pThis->xceiv.state = OTG_STATE_A_IDLE;
-		MUSB_HST_MODE(pThis);
-		musb_set_vbus(pThis, 1);
+		musb->bEnd0Stage = MGC_END0_START;
+		musb->xceiv.state = OTG_STATE_A_IDLE;
+		MUSB_HST_MODE(musb);
+		musb_set_vbus(musb, 1);
 
 		handled = IRQ_HANDLED;
 	}
@@ -494,7 +494,7 @@ static irqreturn_t musb_stage0_irq(struc
 		 * REVISIT:  do delays from lots of DEBUG_KERNEL checks
 		 * make trouble here, keeping VBUS < 4.4V ?
 		 */
-		switch (pThis->xceiv.state) {
+		switch (musb->xceiv.state) {
 		case OTG_STATE_A_HOST:
 			/* recovery is dicey once we've gotten past the
 			 * initial stages of enumeration, but if VBUS
@@ -504,13 +504,13 @@ static irqreturn_t musb_stage0_irq(struc
 			 */
 		case OTG_STATE_A_WAIT_BCON:
 		case OTG_STATE_A_WAIT_VRISE:
-			if (pThis->vbuserr_retry) {
-				pThis->vbuserr_retry--;
+			if (musb->vbuserr_retry) {
+				musb->vbuserr_retry--;
 				ignore = 1;
 				devctl |= MGC_M_DEVCTL_SESSION;
 				musb_writeb(pBase, MGC_O_HDRC_DEVCTL, devctl);
 			} else {
-				pThis->port1_status |=
+				musb->port1_status |=
 					  (1 << USB_PORT_FEAT_OVER_CURRENT)
 					| (1 << USB_PORT_FEAT_C_OVER_CURRENT);
 			}
@@ -520,7 +520,7 @@ static irqreturn_t musb_stage0_irq(struc
 		}
 
 		DBG(1, "VBUS_ERROR in %s (%02x, %s), retry #%d, port1 %08x\n",
-				otg_state_string(pThis),
+				otg_state_string(musb),
 				devctl,
 				({ char *s;
 				switch (devctl & MGC_M_DEVCTL_VBUS) {
@@ -534,69 +534,69 @@ static irqreturn_t musb_stage0_irq(struc
 				default:
 					s = "VALID"; break;
 				}; s; }),
-				VBUSERR_RETRY_COUNT - pThis->vbuserr_retry,
-				pThis->port1_status);
+				VBUSERR_RETRY_COUNT - musb->vbuserr_retry,
+				musb->port1_status);
 
 		/* go through A_WAIT_VFALL then start a new session */
 		if (!ignore)
-			musb_set_vbus(pThis, 0);
+			musb_set_vbus(musb, 0);
 		handled = IRQ_HANDLED;
 	}
 
 	if (bIntrUSB & MGC_M_INTR_CONNECT) {
-		struct usb_hcd *hcd = musb_to_hcd(pThis);
+		struct usb_hcd *hcd = musb_to_hcd(musb);
 
 		handled = IRQ_HANDLED;
-		pThis->is_active = 1;
+		musb->is_active = 1;
 		set_bit(HCD_FLAG_SAW_IRQ, &hcd->flags);
 
-		pThis->bEnd0Stage = MGC_END0_START;
+		musb->bEnd0Stage = MGC_END0_START;
 
 #ifdef CONFIG_USB_MUSB_OTG
 		/* flush endpoints when transitioning from Device Mode */
-		if (is_peripheral_active(pThis)) {
+		if (is_peripheral_active(musb)) {
 			// REVISIT HNP; just force disconnect
 		}
-		pThis->bDelayPortPowerOff = FALSE;
-		musb_writew(pBase, MGC_O_HDRC_INTRTXE, pThis->wEndMask);
-		musb_writew(pBase, MGC_O_HDRC_INTRRXE, pThis->wEndMask & 0xfffe);
+		musb->bDelayPortPowerOff = FALSE;
+		musb_writew(pBase, MGC_O_HDRC_INTRTXE, musb->wEndMask);
+		musb_writew(pBase, MGC_O_HDRC_INTRRXE, musb->wEndMask & 0xfffe);
 		musb_writeb(pBase, MGC_O_HDRC_INTRUSBE, 0xf7);
 #endif
-		pThis->port1_status &= ~(USB_PORT_STAT_LOW_SPEED
+		musb->port1_status &= ~(USB_PORT_STAT_LOW_SPEED
 					|USB_PORT_STAT_HIGH_SPEED
 					|USB_PORT_STAT_ENABLE
 					);
-		pThis->port1_status |= USB_PORT_STAT_CONNECTION
+		musb->port1_status |= USB_PORT_STAT_CONNECTION
 					|(USB_PORT_STAT_C_CONNECTION << 16);
 
 		/* high vs full speed is just a guess until after reset */
 		if (devctl & MGC_M_DEVCTL_LSDEV)
-			pThis->port1_status |= USB_PORT_STAT_LOW_SPEED;
+			musb->port1_status |= USB_PORT_STAT_LOW_SPEED;
 
 		if (hcd->status_urb)
 			usb_hcd_poll_rh_status(hcd);
 		else
 			usb_hcd_resume_root_hub(hcd);
 
-		MUSB_HST_MODE(pThis);
+		MUSB_HST_MODE(musb);
 
 		/* indicate new connection to OTG machine */
-		switch (pThis->xceiv.state) {
+		switch (musb->xceiv.state) {
 		case OTG_STATE_B_WAIT_ACON:
 			DBG(1, "HNP: Waiting to switch to b_host state\n");
-			pThis->xceiv.state = OTG_STATE_B_HOST;
+			musb->xceiv.state = OTG_STATE_B_HOST;
 			hcd->self.is_b_host = 1;
 			break;
 		default:
 			if ((devctl & MGC_M_DEVCTL_VBUS)
 					== (3 << MGC_S_DEVCTL_VBUS)) {
-				pThis->xceiv.state = OTG_STATE_A_HOST;
+				musb->xceiv.state = OTG_STATE_A_HOST;
 				hcd->self.is_b_host = 0;
 			}
 			break;
 		}
 		DBG(1, "CONNECT (%s) devctl %02x\n",
-				otg_state_string(pThis), devctl);
+				otg_state_string(musb), devctl);
 	}
 #endif	/* CONFIG_USB_MUSB_HDRC_HCD */
 
@@ -621,8 +621,8 @@ static irqreturn_t musb_stage0_irq(struc
 		} else {
 			DBG(1, "BUS RESET\n");
 
-			musb_g_reset(pThis);
-			schedule_work(&pThis->irq_work);
+			musb_g_reset(musb);
+			schedule_work(&musb->irq_work);
 		}
 
 		handled = IRQ_HANDLED;
@@ -637,12 +637,12 @@ static irqreturn_t musb_stage0_irq(struc
  * paramount importance, it seems OK to check them individually;
  * the order of the tests is specified in the manual
  *
- * @param pThis instance pointer
+ * @param musb instance pointer
  * @param bIntrUSB register contents
  * @param devctl
  * @param power
  */
-static irqreturn_t musb_stage2_irq(struct musb * pThis, u8 bIntrUSB,
+static irqreturn_t musb_stage2_irq(struct musb * musb, u8 bIntrUSB,
 				u8 devctl, u8 power)
 {
 	irqreturn_t handled = IRQ_NONE;
@@ -660,7 +660,7 @@ static irqreturn_t musb_stage2_irq(struc
  * to support ISO transfers yet.
  */
 	if (bIntrUSB & MGC_M_INTR_SOF) {
-		void __iomem *pBase = pThis->pRegs;
+		void __iomem *pBase = musb->pRegs;
 		struct musb_hw_ep	*ep;
 		u8 bEnd;
 		u16 wFrame;
@@ -670,9 +670,9 @@ static irqreturn_t musb_stage2_irq(struc
 
 		/* start any periodic Tx transfers waiting for current frame */
 		wFrame = musb_readw(pBase, MGC_O_HDRC_FRAME);
-		ep = pThis->aLocalEnd;
-		for (bEnd = 1; (bEnd < pThis->bEndCount)
-					&& (pThis->wEndMask >= (1 << bEnd));
+		ep = musb->aLocalEnd;
+		for (bEnd = 1; (bEnd < musb->bEndCount)
+					&& (musb->wEndMask >= (1 << bEnd));
 				bEnd++, ep++) {
 			// FIXME handle framecounter wraps (12 bits)
 			// eliminate duplicated StartUrb logic
@@ -682,86 +682,86 @@ static irqreturn_t musb_stage2_irq(struc
 					ep->tx_channel ? " DMA" : "",
 					bEnd);
 				if (!ep->tx_channel)
-					musb_h_tx_start(pThis, bEnd);
+					musb_h_tx_start(musb, bEnd);
 				else
-					cppi_hostdma_start(pThis, bEnd);
+					cppi_hostdma_start(musb, bEnd);
 			}
 		}		/* end of for loop */
 	}
 #endif
 
-	if ((bIntrUSB & MGC_M_INTR_DISCONNECT) && !pThis->bIgnoreDisconnect) {
+	if ((bIntrUSB & MGC_M_INTR_DISCONNECT) && !musb->bIgnoreDisconnect) {
 		DBG(1, "DISCONNECT (%s) as %s, devctl %02x\n",
-				otg_state_string(pThis),
-				MUSB_MODE(pThis), devctl);
+				otg_state_string(musb),
+				MUSB_MODE(musb), devctl);
 		handled = IRQ_HANDLED;
 
-		switch (pThis->xceiv.state) {
+		switch (musb->xceiv.state) {
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 		case OTG_STATE_A_HOST:
 		case OTG_STATE_A_SUSPEND:
-			musb_root_disconnect(pThis);
-			if (pThis->a_wait_bcon != 0)
-				musb_platform_try_idle(pThis, jiffies
-					+ msecs_to_jiffies(pThis->a_wait_bcon));
+			musb_root_disconnect(musb);
+			if (musb->a_wait_bcon != 0)
+				musb_platform_try_idle(musb, jiffies
+					+ msecs_to_jiffies(musb->a_wait_bcon));
 			break;
 #endif	/* HOST */
 #ifdef CONFIG_USB_MUSB_OTG
 		case OTG_STATE_B_HOST:
-			musb_hnp_stop(pThis);
+			musb_hnp_stop(musb);
 			break;
 			/* FALLTHROUGH */
 		case OTG_STATE_A_PERIPHERAL:
-			musb_root_disconnect(pThis);
+			musb_root_disconnect(musb);
 			/* FALLTHROUGH */
 		case OTG_STATE_B_WAIT_ACON:
 #endif	/* OTG */
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 		case OTG_STATE_B_PERIPHERAL:
-			musb_g_disconnect(pThis);
+			musb_g_disconnect(musb);
 			break;
 #endif	/* GADGET */
 		default:
 			WARN("unhandled DISCONNECT transition (%s)\n",
-				otg_state_string(pThis));
+				otg_state_string(musb));
 			break;
 		}
 
-		schedule_work(&pThis->irq_work);
+		schedule_work(&musb->irq_work);
 	}
 
 	if (bIntrUSB & MGC_M_INTR_SUSPEND) {
 		DBG(1, "SUSPEND (%s) devctl %02x power %02x\n",
-				otg_state_string(pThis), devctl, power);
+				otg_state_string(musb), devctl, power);
 		handled = IRQ_HANDLED;
 
-		switch (pThis->xceiv.state) {
+		switch (musb->xceiv.state) {
 		case OTG_STATE_A_PERIPHERAL:
-			musb_hnp_stop(pThis);
+			musb_hnp_stop(musb);
 			break;
 		case OTG_STATE_B_PERIPHERAL:
-			musb_g_suspend(pThis);
-			pThis->is_active = is_otg_enabled(pThis)
-					&& pThis->xceiv.gadget->b_hnp_enable;
-			if (pThis->is_active) {
-				pThis->xceiv.state = OTG_STATE_B_WAIT_ACON;
+			musb_g_suspend(musb);
+			musb->is_active = is_otg_enabled(musb)
+					&& musb->xceiv.gadget->b_hnp_enable;
+			if (musb->is_active) {
+				musb->xceiv.state = OTG_STATE_B_WAIT_ACON;
 #ifdef	CONFIG_USB_MUSB_OTG
 				DBG(1, "HNP: Setting timer for b_ase0_brst\n");
-				musb_otg_timer.data = (unsigned long)pThis;
+				musb_otg_timer.data = (unsigned long)musb;
 				mod_timer(&musb_otg_timer, jiffies
 					+ msecs_to_jiffies(TB_ASE0_BRST));
 #endif
 			}
 			break;
 		case OTG_STATE_A_WAIT_BCON:
-			if (pThis->a_wait_bcon != 0)
-				musb_platform_try_idle(pThis, jiffies
-					+ msecs_to_jiffies(pThis->a_wait_bcon));
+			if (musb->a_wait_bcon != 0)
+				musb_platform_try_idle(musb, jiffies
+					+ msecs_to_jiffies(musb->a_wait_bcon));
 			break;
 		case OTG_STATE_A_HOST:
-			pThis->xceiv.state = OTG_STATE_A_SUSPEND;
-			pThis->is_active = is_otg_enabled(pThis)
-					&& pThis->xceiv.host->b_hnp_enable;
+			musb->xceiv.state = OTG_STATE_A_SUSPEND;
+			musb->is_active = is_otg_enabled(musb)
+					&& musb->xceiv.host->b_hnp_enable;
 			break;
 		case OTG_STATE_B_HOST:
 			/* Transition to B_PERIPHERAL, see 6.8.2.6 p 44 */
@@ -769,7 +769,7 @@ static irqreturn_t musb_stage2_irq(struc
 			break;
 		default:
 			/* "should not happen" */
-			pThis->is_active = 0;
+			musb->is_active = 0;
 			break;
 		}
 	}
@@ -833,9 +833,9 @@ void musb_start(struct musb *musb)
 }
 
 
-static void musb_generic_disable(struct musb *pThis)
+static void musb_generic_disable(struct musb *musb)
 {
-	void __iomem	*pBase = pThis->pRegs;
+	void __iomem	*pBase = musb->pRegs;
 	u16	temp;
 
 	/* disable interrupts */
@@ -1174,7 +1174,7 @@ static int __init ep_config_from_table(s
 
 /*
  * ep_config_from_hw - when MUSB_C_DYNFIFO_DEF is false
- * @param pThis the controller
+ * @param musb the controller
  */
 static int __init ep_config_from_hw(struct musb *musb)
 {
@@ -1243,7 +1243,7 @@ enum { MUSB_CONTROLLER_MHDRC, MUSB_CONTR
 /* Initialize MUSB (M)HDRC part of the USB hardware subsystem;
  * configure endpoints, or take their config from silicon
  */
-static int __init musb_core_init(u16 wType, struct musb *pThis)
+static int __init musb_core_init(u16 wType, struct musb *musb)
 {
 #ifdef MUSB_AHB_ID
 	u32 dwData;
@@ -1252,7 +1252,7 @@ static int __init musb_core_init(u16 wTy
 	char *type;
 	u16 wRelease, wRelMajor, wRelMinor;
 	char aInfo[78], aRevision[32], aDate[12];
-	void __iomem	*pBase = pThis->pRegs;
+	void __iomem	*pBase = musb->pRegs;
 	int		status = 0;
 	int		i;
 
@@ -1267,7 +1267,7 @@ static int __init musb_core_init(u16 wTy
 	if (reg & MGC_M_CONFIGDATA_MPRXE) {
 		strcat(aInfo, ", bulk combine");
 #ifdef C_MP_RX
-		pThis->bBulkCombine = TRUE;
+		musb->bBulkCombine = TRUE;
 #else
 		strcat(aInfo, " (X)");		/* no driver support */
 #endif
@@ -1275,7 +1275,7 @@ static int __init musb_core_init(u16 wTy
 	if (reg & MGC_M_CONFIGDATA_MPTXE) {
 		strcat(aInfo, ", bulk split");
 #ifdef C_MP_TX
-		pThis->bBulkSplit = TRUE;
+		musb->bBulkSplit = TRUE;
 #else
 		strcat(aInfo, " (X)");		/* no driver support */
 #endif
@@ -1310,10 +1310,10 @@ static int __init musb_core_init(u16 wTy
 	aDate[0] = 0;
 #endif
 	if (MUSB_CONTROLLER_MHDRC == wType) {
-		pThis->bIsMultipoint = 1;
+		musb->bIsMultipoint = 1;
 		type = "M";
 	} else {
-		pThis->bIsMultipoint = 0;
+		musb->bIsMultipoint = 0;
 		type = "";
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 #ifndef	CONFIG_USB_OTG_BLACKLIST_HUB
@@ -1334,23 +1334,23 @@ static int __init musb_core_init(u16 wTy
 			musb_driver_name, type, aRevision, aDate);
 
 	/* configure ep0 */
-	pThis->aLocalEnd[0].wMaxPacketSizeTx = MGC_END0_FIFOSIZE;
-	pThis->aLocalEnd[0].wMaxPacketSizeRx = MGC_END0_FIFOSIZE;
+	musb->aLocalEnd[0].wMaxPacketSizeTx = MGC_END0_FIFOSIZE;
+	musb->aLocalEnd[0].wMaxPacketSizeRx = MGC_END0_FIFOSIZE;
 
 	/* discover endpoint configuration */
-	pThis->bEndCount = 1;
-	pThis->wEndMask = 1;
+	musb->bEndCount = 1;
+	musb->wEndMask = 1;
 
 	if (reg & MGC_M_CONFIGDATA_DYNFIFO) {
 		if (can_dynfifo())
-			status = ep_config_from_table(pThis);
+			status = ep_config_from_table(musb);
 		else {
 			ERR("reconfigure software for Dynamic FIFOs\n");
 			status = -ENODEV;
 		}
 	} else {
 		if (!can_dynfifo())
-			status = ep_config_from_hw(pThis);
+			status = ep_config_from_hw(musb);
 		else {
 			ERR("reconfigure software for static FIFOs\n");
 			return -ENODEV;
@@ -1361,15 +1361,15 @@ static int __init musb_core_init(u16 wTy
 		return status;
 
 	/* finish init, and print endpoint config */
-	for (i = 0; i < pThis->bEndCount; i++) {
-		struct musb_hw_ep	*hw_ep = pThis->aLocalEnd + i;
+	for (i = 0; i < musb->bEndCount; i++) {
+		struct musb_hw_ep	*hw_ep = musb->aLocalEnd + i;
 
 		hw_ep->fifo = MUSB_FIFO_OFFSET(i) + pBase;
 #ifdef CONFIG_USB_TUSB6010
-		hw_ep->fifo_async = pThis->async + 0x400 + MUSB_FIFO_OFFSET(i);
-		hw_ep->fifo_sync = pThis->sync + 0x400 + MUSB_FIFO_OFFSET(i);
+		hw_ep->fifo_async = musb->async + 0x400 + MUSB_FIFO_OFFSET(i);
+		hw_ep->fifo_sync = musb->sync + 0x400 + MUSB_FIFO_OFFSET(i);
 		hw_ep->fifo_sync_va =
-			pThis->sync_va + 0x400 + MUSB_FIFO_OFFSET(i);
+			musb->sync_va + 0x400 + MUSB_FIFO_OFFSET(i);
 
 		if (i == 0)
 			hw_ep->conf = pBase - 0x400 + TUSB_EP0_CONF;
@@ -1842,7 +1842,7 @@ static int __init
 musb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)
 {
 	int			status;
-	struct musb		*pThis;
+	struct musb		*musb;
 	struct musb_hdrc_platform_data *plat = dev->platform_data;
 
 	/* The driver might handle more features than the board; OK.
@@ -1877,15 +1877,15 @@ musb_init_controller(struct device *dev,
 	}
 
 	/* allocate */
-	pThis = allocate_instance(dev, ctrl);
-	if (!pThis)
+	musb = allocate_instance(dev, ctrl);
+	if (!musb)
 		return -ENOMEM;
 
-	spin_lock_init(&pThis->Lock);
-	pThis->board_mode = plat->mode;
-	pThis->board_set_power = plat->set_power;
-	pThis->set_clock = plat->set_clock;
-	pThis->min_power = plat->min_power;
+	spin_lock_init(&musb->Lock);
+	musb->board_mode = plat->mode;
+	musb->board_set_power = plat->set_power;
+	musb->set_clock = plat->set_clock;
+	musb->min_power = plat->min_power;
 
 	/* Clock usage is chip-specific ... functional clock (DaVinci,
 	 * OMAP2430), or PHY ref (some TUSB6010 boards).  All this core
@@ -1893,25 +1893,25 @@ musb_init_controller(struct device *dev,
 	 * code manages it during start/stop and suspend/resume.
 	 */
 	if (plat->clock) {
-		pThis->clock = clk_get(dev, plat->clock);
-		if (IS_ERR(pThis->clock)) {
-			status = PTR_ERR(pThis->clock);
-			pThis->clock = NULL;
+		musb->clock = clk_get(dev, plat->clock);
+		if (IS_ERR(musb->clock)) {
+			status = PTR_ERR(musb->clock);
+			musb->clock = NULL;
 			goto fail;
 		}
 	}
 
 	/* assume vbus is off */
 
-	/* platform adjusts pThis->pRegs and pThis->isr if needed,
+	/* platform adjusts musb->pRegs and musb->isr if needed,
 	 * and activates clocks
 	 */
-	pThis->isr = generic_interrupt;
-	status = musb_platform_init(pThis);
+	musb->isr = generic_interrupt;
+	status = musb_platform_init(musb);
 
 	if (status < 0)
 		goto fail;
-	if (!pThis->isr) {
+	if (!musb->isr) {
 		status = -ENODEV;
 		goto fail2;
 	}
@@ -1920,34 +1920,34 @@ musb_init_controller(struct device *dev,
 	if (use_dma && dev->dma_mask) {
 		struct dma_controller	*c;
 
-		c = dma_controller_create(pThis, pThis->pRegs);
-		pThis->pDmaController = c;
+		c = dma_controller_create(musb, musb->pRegs);
+		musb->pDmaController = c;
 		if (c)
 			(void) c->start(c->pPrivateData);
 	}
 #endif
 	/* ideally this would be abstracted in platform setup */
-	if (!is_dma_capable() || !pThis->pDmaController)
+	if (!is_dma_capable() || !musb->pDmaController)
 		dev->dma_mask = NULL;
 
 	/* be sure interrupts are disabled before connecting ISR */
-	musb_platform_disable(pThis);
-	musb_generic_disable(pThis);
+	musb_platform_disable(musb);
+	musb_generic_disable(musb);
 
 	/* setup musb parts of the core (especially endpoints) */
 	status = musb_core_init(plat->multipoint
 			? MUSB_CONTROLLER_MHDRC
-			: MUSB_CONTROLLER_HDRC, pThis);
+			: MUSB_CONTROLLER_HDRC, musb);
 	if (status < 0)
 		goto fail2;
 
 	/* attach to the IRQ */
-	if (request_irq (nIrq, pThis->isr, 0, dev->bus_id, pThis)) {
+	if (request_irq (nIrq, musb->isr, 0, dev->bus_id, musb)) {
 		dev_err(dev, "request_irq %d failed!\n", nIrq);
 		status = -ENODEV;
 		goto fail2;
 	}
-	pThis->nIrq = nIrq;
+	musb->nIrq = nIrq;
 // FIXME this handles wakeup irqs wrong
 	if (enable_irq_wake(nIrq) == 0)
 		device_init_wakeup(dev, 1);
@@ -1955,24 +1955,24 @@ musb_init_controller(struct device *dev,
 	pr_info("%s: USB %s mode controller at %p using %s, IRQ %d\n",
 			musb_driver_name,
 			({char *s;
-			switch (pThis->board_mode) {
+			switch (musb->board_mode) {
 			case MUSB_HOST:		s = "Host"; break;
 			case MUSB_PERIPHERAL:	s = "Peripheral"; break;
 			default:		s = "OTG"; break;
 			}; s; }),
 			ctrl,
-			(is_dma_capable() && pThis->pDmaController)
+			(is_dma_capable() && musb->pDmaController)
 				? "DMA" : "PIO",
-			pThis->nIrq);
+			musb->nIrq);
 
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 	/* host side needs more setup, except for no-host modes */
-	if (pThis->board_mode != MUSB_PERIPHERAL) {
-		struct usb_hcd	*hcd = musb_to_hcd(pThis);
+	if (musb->board_mode != MUSB_PERIPHERAL) {
+		struct usb_hcd	*hcd = musb_to_hcd(musb);
 
-		if (pThis->board_mode == MUSB_OTG)
+		if (musb->board_mode == MUSB_OTG)
 			hcd->self.otg_port = 1;
-		pThis->xceiv.host = &hcd->self;
+		musb->xceiv.host = &hcd->self;
 		hcd->power_budget = 2 * (plat->power ? : 250);
 	}
 #endif				/* CONFIG_USB_MUSB_HDRC_HCD */
@@ -1981,46 +1981,46 @@ musb_init_controller(struct device *dev,
 	 * (We expect the ID pin to be forcibly grounded!!)
 	 * Otherwise, wait till the gadget driver hooks up.
 	 */
-	if (!is_otg_enabled(pThis) && is_host_enabled(pThis)) {
-		MUSB_HST_MODE(pThis);
-		pThis->xceiv.default_a = 1;
-		pThis->xceiv.state = OTG_STATE_A_IDLE;
+	if (!is_otg_enabled(musb) && is_host_enabled(musb)) {
+		MUSB_HST_MODE(musb);
+		musb->xceiv.default_a = 1;
+		musb->xceiv.state = OTG_STATE_A_IDLE;
 
-		status = usb_add_hcd(musb_to_hcd(pThis), -1, 0);
+		status = usb_add_hcd(musb_to_hcd(musb), -1, 0);
 
 		DBG(1, "%s mode, status %d, devctl %02x %c\n",
 			"HOST", status,
-			musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL),
-			(musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL)
+			musb_readb(musb->pRegs, MGC_O_HDRC_DEVCTL),
+			(musb_readb(musb->pRegs, MGC_O_HDRC_DEVCTL)
 					& MGC_M_DEVCTL_BDEVICE
 				? 'B' : 'A'));
 
 	} else /* peripheral is enabled */ {
-		MUSB_DEV_MODE(pThis);
-		pThis->xceiv.default_a = 0;
-		pThis->xceiv.state = OTG_STATE_B_IDLE;
+		MUSB_DEV_MODE(musb);
+		musb->xceiv.default_a = 0;
+		musb->xceiv.state = OTG_STATE_B_IDLE;
 
-		status = musb_gadget_setup(pThis);
+		status = musb_gadget_setup(musb);
 
 		DBG(1, "%s mode, status %d, dev%02x\n",
-			is_otg_enabled(pThis) ? "OTG" : "PERIPHERAL",
+			is_otg_enabled(musb) ? "OTG" : "PERIPHERAL",
 			status,
-			musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL));
+			musb_readb(musb->pRegs, MGC_O_HDRC_DEVCTL));
 
 	}
 
 	if (status == 0)
-		musb_debug_create("driver/musb_hdrc", pThis);
+		musb_debug_create("driver/musb_hdrc", musb);
 	else {
 fail:
-		if (pThis->clock)
-			clk_put(pThis->clock);
+		if (musb->clock)
+			clk_put(musb->clock);
 		device_init_wakeup(dev, 0);
-		musb_free(pThis);
+		musb_free(musb);
 		return status;
 	}
 
-	INIT_WORK(&pThis->irq_work, musb_irq_work);
+	INIT_WORK(&musb->irq_work, musb_irq_work);
 
 #ifdef CONFIG_SYSFS
 	status = device_create_file(dev, &dev_attr_mode);
@@ -2035,7 +2035,7 @@ fail:
 	return status;
 
 fail2:
-	musb_platform_exit(pThis);
+	musb_platform_exit(musb);
 	goto fail;
 }
 
Index: linux-2.6.18/mvl_patches/pro50-1658.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-1658.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1658);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

