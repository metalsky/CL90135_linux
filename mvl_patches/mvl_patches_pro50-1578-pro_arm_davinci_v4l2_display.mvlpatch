#! /usr/bin/env bash
# Patch: -pro_arm_davinci_v4l2_display
# Date: Fri Sep 19 14:00:52 2008
# Source: MontaVista Software, Inc.
# MR: 28149
# Type:  Integration
# Disposition: merged from pro_40
# Signed-off-by: Pavel Kiryukhin <pkiryukhin@ru.mvista.com>
# Description: DaVinci EVM V4L2 drivers.
# 
#  drivers/media/video/Kconfig                    |   36 
#  drivers/media/video/Makefile                   |    2 
#  drivers/media/video/davinci/Makefile           |    4 
#  drivers/media/video/davinci/davinci_display.c  | 1877 ++++++++++++++++++++++
#  drivers/media/video/davinci/davinci_enc_mngr.c | 1162 +++++++++++++
#  drivers/media/video/davinci/davinci_osd.c      | 2084 +++++++++++++++++++++++++
#  drivers/media/video/davinci/davinci_platform.c | 1010 ++++++++++++
#  include/asm-arm/arch-davinci/hardware.h        |    1 
#  include/media/davinci/davinci_display.h        |  166 +
#  include/media/davinci/davinci_enc.h            |  249 ++
#  include/media/davinci/davinci_enc_mngr.h       |   57 
#  include/media/davinci/davinci_platform.h       |   43 
#  include/media/davinci/vid_encoder_if.h         |  287 +++
#  include/media/davinci/vid_encoder_types.h      |  231 ++
#  include/video/davinci_osd.h                    |  887 ++++++++++
#  include/video/davinci_vpbe.h                   |  497 +++++
#  16 files changed, 8593 insertions(+)
# 

PATCHNUM=1578
LSPINFO=include/linux/lsppatchlevel.h
TMPFILE=/tmp/mvl_patch_$$

function dopatch() {
    patch $* >${TMPFILE} 2>&1 <<"EOF"
Source: MontaVista Software, Inc.
MR: 28149
Type:  Integration
Disposition: merged from pro_40
Signed-off-by: Pavel Kiryukhin <pkiryukhin@ru.mvista.com>
Description: DaVinci EVM V4L2 drivers.

 drivers/media/video/Kconfig                    |   36 
 drivers/media/video/Makefile                   |    2 
 drivers/media/video/davinci/Makefile           |    4 
 drivers/media/video/davinci/davinci_display.c  | 1877 ++++++++++++++++++++++
 drivers/media/video/davinci/davinci_enc_mngr.c | 1162 +++++++++++++
 drivers/media/video/davinci/davinci_osd.c      | 2084 +++++++++++++++++++++++++
 drivers/media/video/davinci/davinci_platform.c | 1010 ++++++++++++
 include/asm-arm/arch-davinci/hardware.h        |    1 
 include/media/davinci/davinci_display.h        |  166 +
 include/media/davinci/davinci_enc.h            |  249 ++
 include/media/davinci/davinci_enc_mngr.h       |   57 
 include/media/davinci/davinci_platform.h       |   43 
 include/media/davinci/vid_encoder_if.h         |  287 +++
 include/media/davinci/vid_encoder_types.h      |  231 ++
 include/video/davinci_osd.h                    |  887 ++++++++++
 include/video/davinci_vpbe.h                   |  497 +++++
 mvl_patches/pro50-1578.c                       |   16 
 17 files changed, 8609 insertions(+)

Index: linux-2.6.18/drivers/media/video/Kconfig
===================================================================
--- linux-2.6.18.orig/drivers/media/video/Kconfig
+++ linux-2.6.18/drivers/media/video/Kconfig
@@ -464,6 +464,42 @@ config VIDEO_UPD64083
 	  To compile this driver as a module, choose M here: the
 	  module will be called upd64083.
 
+config VIDEO_DAVINCI_DISPLAY
+	tristate "Davinci V4L2 Video Display"
+	depends on VIDEO_DEV && (ARCH_DAVINCI_DM644x || ARCH_DAVINCI_DM355) && DAVINCI_ENC_MNGR
+	select VIDEO_BUF
+	select DAVINCI_OSD
+	help
+	  V4L2 Display driver support for davinci.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called davinci_display.
+
+config DAVINCI_ENC_MNGR
+	tristate "Davinci Encoder Manager support"
+	depends on ARCH_DAVINCI_DM646x || ARCH_DAVINCI_DM644x || ARCH_DAVINCI_DM355
+	default y
+	help
+	  Enable support for the DaVinci Encoder Manager. This is responsible
+	  for managing output and video/graphics modes for davinci video drivers.
+
+config ENC_MNGR_MAX_CHANNELS
+	int "Max number of channels for Encoder Manager"
+	depends on DAVINCI_ENC_MNGR
+	default "2"
+	help
+	  Used to give max number of channels supported by encoder manager
+	  driver.
+
+config DAVINCI_OSD
+	tristate "Davinci Display Manager"
+	depends on VIDEO_DAVINCI_DISPLAY || FB_DAVINCI
+	help
+	  Support for Davinci On-Screen Display Manager.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called vpif.
+
 endmenu # encoder / decoder chips
 
 #
Index: linux-2.6.18/drivers/media/video/davinci/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/Makefile
@@ -0,0 +1,4 @@
+obj-$(CONFIG_DAVINCI_OSD) += davinci_osd.o davinci_platform.o
+# Encoder Manager and Encoders
+obj-$(CONFIG_DAVINCI_ENC_MNGR)  += davinci_enc_mngr.o
+obj-$(CONFIG_VIDEO_DAVINCI_DISPLAY) += davinci_display.o
Index: linux-2.6.18/drivers/media/video/davinci/davinci_display.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/davinci_display.c
@@ -0,0 +1,1877 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+/* davinci_display.c */
+
+/*#define DEBUG */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <media/v4l2-dev.h>
+#include <linux/wait.h>
+#include <linux/time.h>
+#include <linux/platform_device.h>
+#include <asm/irq.h>
+#include <asm/page.h>
+#include <asm/arch/cpu.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/davinci_display.h>
+
+#define DAVINCI_DISPLAY_DRIVER "DavinciDisplay"
+#define DM355_EVM_CARD  "DM355 EVM"
+#define DM644X_EVM_CARD "DM644X EVM"
+
+static u32 video2_numbuffers = 3;
+static u32 video3_numbuffers = 3;
+
+#define DAVINCI_DISPLAY_HD_BUF_SIZE (1920*1088*2)
+#define DAVINCI_DISPLAY_SD_BUF_SIZE (720*576*2)
+
+#ifdef FB_DAVINCI_THS8200_ENCODER
+static u32 video2_bufsize = DAVINCI_DISPLAY_HD_BUF_SIZE;
+#else
+static u32 video2_bufsize = DAVINCI_DISPLAY_SD_BUF_SIZE;
+#endif
+static u32 video3_bufsize = DAVINCI_DISPLAY_SD_BUF_SIZE;
+
+module_param(video2_numbuffers, uint, S_IRUGO);
+module_param(video3_numbuffers, uint, S_IRUGO);
+
+module_param(video2_bufsize, uint, S_IRUGO);
+module_param(video3_bufsize, uint, S_IRUGO);
+
+#define DAVINCI_DEFAULT_NUM_BUFS 3
+static struct buf_config_params display_buf_config_params = {
+	.min_numbuffers = DAVINCI_DEFAULT_NUM_BUFS,
+	.numbuffers[0] = DAVINCI_DEFAULT_NUM_BUFS,
+	.numbuffers[1] = DAVINCI_DEFAULT_NUM_BUFS,
+	.min_bufsize[0] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+	.min_bufsize[1] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+#ifdef CONFIG_DAVINCI_THS8200_ENCODER
+	.layer_bufsize[0] = DAVINCI_DISPLAY_HD_BUF_SIZE,
+	.layer_bufsize[1] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+#else
+	.layer_bufsize[0] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+	.layer_bufsize[1] = DAVINCI_DISPLAY_SD_BUF_SIZE,
+#endif
+};
+
+static int davinci_display_nr[] = { 2, 3 };
+
+/* global variables */
+static struct davinci_display davinci_dm;
+
+struct device *davinci_display_dev = NULL;
+
+static struct v4l2_capability davinci_display_videocap = {
+	.driver = DAVINCI_DISPLAY_DRIVER,
+	.bus_info = "Platform",
+	.version = DAVINCI_DISPLAY_VERSION_CODE,
+	.capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING
+};
+
+static struct v4l2_fract ntsc_aspect = DAVINCI_DISPLAY_PIXELASPECT_NTSC;
+static struct v4l2_fract pal_aspect = DAVINCI_DISPLAY_PIXELASPECT_PAL;
+static struct v4l2_fract sp_aspect = DAVINCI_DISPLAY_PIXELASPECT_SP;
+
+static struct v4l2_rect ntsc_bounds = DAVINCI_DISPLAY_WIN_NTSC;
+static struct v4l2_rect pal_bounds = DAVINCI_DISPLAY_WIN_PAL;
+static struct v4l2_rect vga_bounds = DAVINCI_DISPLAY_WIN_640_480;
+static struct v4l2_rect hd_720p_bounds = DAVINCI_DISPLAY_WIN_720P;
+static struct v4l2_rect hd_1080i_bounds = DAVINCI_DISPLAY_WIN_1080I;
+
+/*
+ *=====davinci_alloc_buffer=====*/
+/* Allocate memory for buffers */
+static inline unsigned long davinci_alloc_buffer(unsigned int buf_size)
+{
+	void *mem = 0;
+	u32 size = PAGE_SIZE << (get_order(buf_size));
+
+	mem = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+				       get_order(buf_size));
+	if (mem) {
+		unsigned long adr = (unsigned long)mem;
+		while (size > 0) {
+			SetPageReserved(virt_to_page(adr));
+			adr += PAGE_SIZE;
+			size -= PAGE_SIZE;
+		}
+	}
+	return (unsigned long)mem;
+}
+
+/*
+ *=====davinci_free_buffer=====*/
+/* Free memory for buffers */
+static inline void davinci_free_buffer(unsigned long addr,
+				       unsigned int buf_size)
+{
+	unsigned int size, adr;
+
+	if (!addr)
+		return;
+	adr = addr;
+	size = PAGE_SIZE << (get_order(buf_size));
+	while (size > 0) {
+		ClearPageReserved(virt_to_page(adr));
+		adr += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+	free_pages(addr, get_order(buf_size));
+}
+
+/*
+ * ===== davinci_uservirt_to_phys =====
+ *
+ * This inline function is used to convert user space virtual address
+ * to physical address.
+ */
+static inline u32 davinci_uservirt_to_phys(u32 virt)
+{
+	pgd_t *pgd;
+	pmd_t *pmd;
+	pte_t *pte;
+
+	struct mm_struct *mm = current->mm;
+	pgd = pgd_offset(mm, virt);
+	if (!(pgd_none(*pgd) || pgd_bad(*pgd))) {
+		pmd = pmd_offset(pgd, virt);
+
+		if (!(pmd_none(*pmd) || pmd_bad(*pmd))) {
+			pte = pte_offset_kernel(pmd, virt);
+
+			if (pte_present(*pte)) {
+				return __pa(page_address(pte_page(*pte))
+					    + (virt & ~PAGE_MASK));
+			}
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * =====buffer_prepare=====*/
+/* This is the callback function called from videobuf_qbuf() function
+ * the buffer is prepared and user space virtual address is converted into
+ * physical address */
+static int davinci_buffer_prepare(struct videobuf_queue *q,
+				  struct videobuf_buffer *vb,
+				  enum v4l2_field field)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+	dev_dbg(davinci_display_dev, "<davinci_buffer_prepare>\n");
+
+	/* If buffer is not initialized, initialize it */
+	if (STATE_NEEDS_INIT == vb->state) {
+		vb->width = davinci_dm.mode_info.xres;
+		vb->height = davinci_dm.mode_info.yres;
+		vb->size = vb->width * vb->height;
+		vb->field = field;
+	}
+	vb->state = STATE_PREPARED;
+	/* if user pointer memory mechanism is used, get the physical
+	 * address of the buffer
+	 */
+	if (V4L2_MEMORY_USERPTR == layer->memory) {
+		vb->boff = davinci_uservirt_to_phys(vb->baddr);
+		if (!ISALIGNED(vb->boff)) {
+			dev_err(davinci_display_dev, "buffer_prepare:offset is \
+				not aligned to 8 bytes\n");
+			return -EINVAL;
+		}
+	}
+	dev_dbg(davinci_display_dev, "</davinci_buffer_prepare>\n");
+	return 0;
+}
+
+/*
+ * =====davinci_buffer_config=====*/
+/* This function is responsible to responsible for buffer's
+ * physical address */
+static void davinci_buffer_config(struct videobuf_queue *q, unsigned int count)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+	int i;
+	dev_dbg(davinci_display_dev, "<davinci_buffer_config>\n");
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != layer->memory) {
+		dev_err(davinci_display_dev, "Not MMAP\n");
+		return;
+	}
+	/* Convert kernel space virtual address to physical address */
+	for (i = 0; i < count; i++) {
+		q->bufs[i]->boff = virt_to_phys((void *)layer->fbuffers[i]);
+		dev_dbg(davinci_display_dev, "buffer address: %x\n",
+			q->bufs[i]->boff);
+	}
+	dev_dbg(davinci_display_dev, "</davinci_buffer_config>\n");
+}
+
+/*
+ * =====davinci_buffer_setup=====*/
+/* This function allocates memory for the buffers */
+static int davinci_buffer_setup(struct videobuf_queue *q, unsigned int *count,
+				unsigned int *size)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+	int i;
+	dev_dbg(davinci_display_dev, "<davinci_buffer_setup>\n");
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != layer->memory) {
+		dev_err(davinci_display_dev, "Not MMAP\n");
+		return 0;
+	}
+
+	/* Calculate the size of the buffer */
+	*size = display_buf_config_params.layer_bufsize[layer->device_id];
+
+	for (i = display_buf_config_params.numbuffers[layer->device_id];
+	     i < *count; i++) {
+		/* Allocate memory for the buffers */
+		layer->fbuffers[i] = davinci_alloc_buffer(*size);
+		if (!layer->fbuffers[i])
+			break;
+	}
+	/* Store number of buffers allocated in numbuffer member */
+	*count = layer->numbuffers = i;
+	dev_dbg(davinci_display_dev, "</davinci_buffer_setup>\n");
+	return 0;
+}
+
+/*
+ * =====davinci_buffer_queue=====*/
+/* This function adds the buffer to DMA queue  */
+static void davinci_buffer_queue(struct videobuf_queue *q,
+				 struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+	dev_dbg(davinci_display_dev, "<davinci_buffer_queue>\n");
+
+	/* add the buffer to the DMA queue */
+	list_add_tail(&vb->queue, &layer->dma_queue);
+	/* Change state of the buffer */
+	vb->state = STATE_QUEUED;
+	dev_dbg(davinci_display_dev, "</davinci_buffer_queue>\n");
+}
+
+/*
+ * =====davinci_buffer_release=====*/
+/* This function is called from the videobuf layer to free memory allocated to
+ * the buffers */
+static void davinci_buffer_release(struct videobuf_queue *q,
+				   struct videobuf_buffer *vb)
+{
+	/* Get the file handle object and layer object */
+	struct davinci_fh *fh = q->priv_data;
+	struct display_obj *layer = fh->layer;
+	unsigned int buf_size = 0;
+	dev_dbg(davinci_display_dev, "<davinci_buffer_release>\n");
+
+	/* If memory type is not mmap, return */
+	if (V4L2_MEMORY_MMAP != layer->memory) {
+		dev_err(davinci_display_dev, "Not MMAP\n");
+		return;
+	}
+	/* Calculate the size of the buffer */
+	buf_size = display_buf_config_params.layer_bufsize[layer->device_id];
+
+	if (((vb->i < layer->numbuffers)
+	     && (vb->i >=
+		 display_buf_config_params.numbuffers[layer->device_id]))
+	    && layer->fbuffers[vb->i]) {
+		davinci_free_buffer(layer->fbuffers[vb->i], buf_size);
+		layer->fbuffers[vb->i] = 0;
+	}
+	vb->state = STATE_NEEDS_INIT;
+	dev_dbg(davinci_display_dev, "</davinci_buffer_release>\n");
+}
+
+static struct videobuf_queue_ops video_qops = {
+	.buf_setup = davinci_buffer_setup,
+	.buf_prepare = davinci_buffer_prepare,
+	.buf_queue = davinci_buffer_queue,
+	.buf_release = davinci_buffer_release,
+	.buf_config = davinci_buffer_config,
+};
+
+static u8 layer_first_int = 1;
+
+/* It changes status of the displayed buffer, takes next buffer from the queue
+ * and sets its address in VPBE registers */
+static void davinci_display_isr(unsigned int event, void *dispObj)
+{
+	unsigned long jiffies_time = get_jiffies_64();
+	struct timeval timevalue;
+	int i, fid;
+	unsigned long addr = 0;
+	struct display_obj *layer = NULL;
+	struct davinci_display *dispDevice = (struct davinci_display *)dispObj;
+
+	/* Convert time represention from jiffies to timeval */
+	jiffies_to_timeval(jiffies_time, &timevalue);
+
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		layer = dispDevice->dev[i];
+		/* If streaming is started in this layer */
+		if (!layer->started)
+			continue;
+		/* Check the field format */
+		if ((V4L2_FIELD_NONE == layer->pix_fmt.field) &&
+		    (!list_empty(&layer->dma_queue)) &&
+		    (event & DAVINCI_DISP_END_OF_FRAME)) {
+			/* Progressive mode */
+			/* Progressive mode */
+			if (layer_first_int) {
+				layer_first_int = 0;
+				continue;
+			} else {
+				/* Mark status of the curFrm to
+				 * done and unlock semaphore on it */
+				layer->curFrm->ts = timevalue;
+				layer->curFrm->state = STATE_DONE;
+				wake_up_interruptible(&layer->curFrm->done);
+				/* Make curFrm pointing to nextFrm */
+				layer->curFrm = layer->nextFrm;
+			}
+			/* Get the next buffer from buffer queue */
+			layer->nextFrm =
+			    list_entry(layer->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove that buffer from the buffer queue */
+			list_del(&layer->nextFrm->queue);
+			/* Mark status of the buffer as active */
+			layer->nextFrm->state = STATE_ACTIVE;
+			/* Set top and bottom field addresses in
+			   VPIF registers */
+			addr = layer->curFrm->boff;
+			davinci_disp_start_layer(layer->layer_info.id, addr);
+		} else {
+			/* Interlaced mode */
+			/* If it is first interrupt, ignore it */
+			if (layer_first_int) {
+				layer_first_int = 0;
+				dev_dbg(davinci_display_dev,
+					"irq_first time\n");
+				return;
+			}
+
+			layer->field_id ^= 1;
+			if (event & DAVINCI_DISP_FIRST_FIELD)
+				fid = 0;
+			else if (event & DAVINCI_DISP_SECOND_FIELD)
+				fid = 1;
+			else
+				return;
+
+			/* If field id does not match with stored
+			   field id */
+			if (fid != layer->field_id) {
+				/* Make them in sync */
+				if (0 == fid) {
+					layer->field_id = fid;
+					dev_dbg(davinci_display_dev,
+						"field synced\n");
+				}
+				return;
+			}
+			/* device field id and local field id are
+			   in sync */
+			/* If this is even field */
+			if (0 == fid) {
+				if (layer->curFrm == layer->nextFrm)
+					continue;
+				/* one frame is displayed If next frame is
+				 *  available, release curFrm and move on*/
+
+				/* Copy frame display time */
+				layer->curFrm->ts = timevalue;
+				/* Change status of the curFrm */
+				dev_dbg(davinci_display_dev,
+					"Done with this video buffer\n");
+				layer->curFrm->state = STATE_DONE;
+				/* unlock semaphore on curFrm */
+				wake_up_interruptible(&layer->curFrm->done);
+				/* Make curFrm pointing to
+				   nextFrm */
+				layer->curFrm = layer->nextFrm;
+			} else if (1 == fid) {	/* odd field */
+				if (list_empty(&layer->dma_queue)
+				    || (layer->curFrm != layer->nextFrm))
+					continue;
+
+				/* one field is displayed configure
+				   the next frame if it is available
+				   otherwise hold on current frame
+				 */
+				/* Get next from the buffer
+				   queue */
+				layer->nextFrm = list_entry(layer->
+							    dma_queue.
+							    next, struct
+							    videobuf_buffer,
+							    queue);
+
+				/* Remove that from the
+				   buffer queue */
+				list_del(&layer->nextFrm->queue);
+
+				/* Mark state of the frame
+				   to active */
+				layer->nextFrm->state = STATE_ACTIVE;
+				addr = layer->nextFrm->boff;
+				davinci_disp_start_layer(layer->layer_info.id,
+							 addr);
+			}
+		}
+	}
+}
+
+static int davinci_check_format(struct display_obj *layer,
+				struct v4l2_pix_format *pixfmt)
+{
+	enum v4l2_field field = pixfmt->field;
+	struct vid_enc_mode_info *mode_info;
+	int temp_width = pixfmt->width, temp_height = pixfmt->height;
+	dev_dbg(davinci_display_dev, "<davinci_check_format, >\n");
+
+	if (layer->memory == V4L2_MEMORY_USERPTR) {
+		/* We use bytesperline to calculate the width of the image */
+		temp_width = pixfmt->bytesperline / 2;
+		temp_height = pixfmt->sizeimage / pixfmt->bytesperline;
+	}
+
+	dev_dbg(davinci_display_dev,
+		"<pixelformat = %x, height = %d, width = %d, field = %d >\n",
+		(unsigned int)pixfmt->pixelformat, (unsigned int)temp_height,
+		(unsigned int)temp_width, (unsigned int)pixfmt->field);
+
+	if (!(DAVINCI_DISPLAY_VALID_FIELD(field))) {
+		dev_err(davinci_display_dev,
+			"invalid frame format , field = %d\n", (int)field);
+		return -EINVAL;
+	}
+
+	if (pixfmt->pixelformat != V4L2_PIX_FMT_UYVY) {
+		dev_err(davinci_display_dev, "invalid frame format\n");
+		return -EINVAL;
+	}
+	if (temp_width && ((temp_width % 16) != 0)) {
+		/* must be a mutliple of 32 */
+		dev_err(davinci_display_dev,
+			"width should be a multiple of 16\n");
+		return -EINVAL;
+	}
+
+	if ((temp_height & 0x1) && (field == V4L2_FIELD_INTERLACED)) {
+		dev_err(davinci_display_dev,
+			"height should be even for interlaced mode\n");
+		return -EINVAL;
+	}
+
+	/* get the current video display mode from encoder manager */
+	mode_info = &davinci_dm.mode_info;
+	if (davinci_enc_get_mode(0, mode_info)) {
+		dev_err(davinci_display_dev,
+			"Error in getting current display mode from enc mngr\n");
+		return -1;
+	}
+
+	if ((0 == temp_width) || (temp_width > mode_info->xres) ||
+	    (0 == temp_height) || (temp_height > mode_info->yres)) {
+		dev_err(davinci_display_dev, "Invalid width or height\n");
+		return -EINVAL;
+	}
+
+	if (field == V4L2_FIELD_ANY) {
+		field = (mode_info->interlaced) ? V4L2_FIELD_INTERLACED :
+		    V4L2_FIELD_NONE;
+	}
+	if ((!mode_info->interlaced && (field == V4L2_FIELD_INTERLACED)) ||
+	    (mode_info->interlaced && (field == V4L2_FIELD_NONE))) {
+		dev_err(davinci_display_dev, "Invalid field\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(davinci_display_dev, "</davinci_check_format>\n");
+	return 0;
+}
+
+static int davinci_set_video_display_params(struct display_obj *layer)
+{
+	unsigned long addr;
+
+	addr = layer->curFrm->boff;
+	/* Set address in the display registers */
+	davinci_disp_start_layer(layer->layer_info.id, addr);
+	davinci_disp_enable_layer(layer->layer_info.id);
+	/* Enable the window */
+	layer->layer_info.enable = 1;
+	return 0;
+}
+static void davinci_disp_calculate_scale_factor(struct display_obj *layer,
+						int expected_xsize,
+						int expected_ysize)
+{
+	struct display_layer_info *layer_info = &layer->layer_info;
+	struct v4l2_pix_format *pixfmt = &layer->pix_fmt;
+	int h_scale = 0, v_scale = 0, h_exp = 0, v_exp = 0, temp;
+	/* Application initially set the image format. Current display
+	   size is obtained from the encoder manager. expected_xsize
+	   and expected_ysize are set through S_CROP ioctl. Based on this,
+	   driver will calculate the scale factors for vertical and
+	   horizontal direction so that the image is displayed scaled
+	   and expanded. Application uses expansion to display the image
+	   in a square pixel. Otherwise it is displayed using displays
+	   pixel aspect ratio.It is expected that application chooses
+	   the crop coordinates for cropped or scaled display. if crop
+	   size is less than the image size, it is displayed cropped or
+	   it is displayed scaled and/or expanded.
+	 */
+
+	/* to begin with, set the crop window same as expected. Later we
+	   will override with scaled window size
+	 */
+	layer->layer_info.config.xsize = pixfmt->width;
+	layer->layer_info.config.ysize = pixfmt->height;
+	layer_info->h_zoom = ZOOM_X1;	/* no horizontal zoom */
+	layer_info->v_zoom = ZOOM_X1;	/* no horizontal zoom */
+	layer_info->h_exp = H_EXP_OFF;	/* no horizontal zoom */
+	layer_info->v_exp = V_EXP_OFF;	/* no horizontal zoom */
+
+	if (pixfmt->width < expected_xsize) {
+		h_scale = davinci_dm.mode_info.xres / pixfmt->width;
+		if (h_scale < 2)
+			h_scale = 1;
+		else if (h_scale >= 4)
+			h_scale = 4;
+		else
+			h_scale = 2;
+		layer->layer_info.config.xsize *= h_scale;
+		if (layer->layer_info.config.xsize < expected_xsize) {
+			if (!strcmp(davinci_dm.mode_info.name, VID_ENC_STD_NTSC)
+			    || !strcmp(davinci_dm.mode_info.name,
+				       VID_ENC_STD_PAL)) {
+				temp =
+				    (layer->layer_info.config.xsize *
+				     DAVINCI_DISPLAY_H_EXP_RATIO_N)
+				    / DAVINCI_DISPLAY_H_EXP_RATIO_D;
+				if (temp <= expected_xsize) {
+					h_exp = 1;
+					layer->layer_info.config.xsize = temp;
+				}
+			}
+		}
+		if (h_scale == 2)
+			layer_info->h_zoom = ZOOM_X2;
+		else if (h_scale == 4)
+			layer_info->h_zoom = ZOOM_X4;
+		if (h_exp)
+			layer_info->h_exp = H_EXP_9_OVER_8;
+	} else {
+		/* no scaling, only cropping. Set display area to crop area */
+		layer->layer_info.config.xsize = expected_xsize;
+	}
+
+	if (pixfmt->height < expected_ysize) {
+		v_scale = expected_ysize / pixfmt->height;
+		if (v_scale < 2)
+			v_scale = 1;
+		else if (v_scale >= 4)
+			v_scale = 4;
+		else
+			v_scale = 2;
+		layer->layer_info.config.ysize *= v_scale;
+		if (layer->layer_info.config.ysize < expected_ysize) {
+			if (!strcmp(davinci_dm.mode_info.name, "PAL")) {
+				temp =
+				    (layer->layer_info.config.ysize *
+				     DAVINCI_DISPLAY_V_EXP_RATIO_N)
+				    / DAVINCI_DISPLAY_V_EXP_RATIO_D;
+				if (temp <= expected_ysize) {
+					v_exp = 1;
+					layer->layer_info.config.ysize = temp;
+				}
+			}
+		}
+		if (v_scale == 2)
+			layer_info->v_zoom = ZOOM_X2;
+		else if (v_scale == 4)
+			layer_info->v_zoom = ZOOM_X4;
+		if (v_exp)
+			layer_info->h_exp = V_EXP_6_OVER_5;
+	} else {
+		/* no scaling, only cropping. Set display area to crop area */
+		layer->layer_info.config.ysize = expected_ysize;
+	}
+	dev_dbg(davinci_display_dev,
+		"crop display xsize = %d, ysize = %d\n",
+		layer->layer_info.config.xsize, layer->layer_info.config.ysize);
+}
+
+static void davinci_disp_adj_position(struct display_obj *layer, int top,
+				      int left)
+{
+	layer->layer_info.config.xpos = 0;
+	layer->layer_info.config.ypos = 0;
+	if (left + layer->layer_info.config.xsize <= davinci_dm.mode_info.xres)
+		layer->layer_info.config.xpos = left;
+	if (top + layer->layer_info.config.ysize <= davinci_dm.mode_info.yres)
+		layer->layer_info.config.ypos = top;
+	dev_dbg(davinci_display_dev,
+		"new xpos = %d, ypos = %d\n",
+		layer->layer_info.config.xpos, layer->layer_info.config.ypos);
+}
+
+static int davinci_disp_check_window_params(struct v4l2_rect *c)
+{
+	if ((c->width == 0)
+	    || ((c->width + c->left) > davinci_dm.mode_info.xres)
+	    || (c->height == 0)
+	    || ((c->height + c->top) > davinci_dm.mode_info.yres)) {
+		dev_err(davinci_display_dev, "Invalid crop values\n");
+		return -1;
+	}
+	if ((c->height & 0x1) && (davinci_dm.mode_info.interlaced)) {
+		dev_err(davinci_display_dev,
+			"window height must be even for interlaced display\n");
+		return -1;
+	}
+	return 0;
+}
+
+/*
+ * ======== davinci_doioctl ========*
+ * This function will provide different V4L2 commands.This function can be
+ * used to configure driver or get status of driver as per command passed
+ * by application */
+static int davinci_doioctl(struct inode *inode, struct file *file,
+			   unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	struct davinci_fh *fh = file->private_data;
+	struct display_obj *layer = fh->layer;
+	unsigned int index = 0;
+	unsigned long addr, flags;
+	dev_dbg(davinci_display_dev, "<davinci_doioctl>\n");
+
+	/* Check for the priority */
+	switch (cmd) {
+	case VIDIOC_S_FMT:
+		ret = v4l2_prio_check(&layer->prio, &fh->prio);
+		if (0 != ret)
+			return ret;
+		break;
+	}
+
+	/* Check for null value of parameter */
+	if (ISNULL((void *)arg)) {
+		dev_err(davinci_display_dev, "Null pointer\n");
+		return -EINVAL;
+	}
+	/* Switch on the command value */
+	switch (cmd) {
+		/* If the case is for querying capabilities */
+	case VIDIOC_QUERYCAP:
+		{
+			struct v4l2_capability *cap =
+			    (struct v4l2_capability *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_QUERYCAP, layer id = %d\n",
+				layer->device_id);
+			memset(cap, 0, sizeof(*cap));
+			*cap = davinci_display_videocap;
+			break;
+		}
+
+	case VIDIOC_CROPCAP:
+		{
+			struct v4l2_cropcap *cropcap =
+			    (struct v4l2_cropcap *)arg;
+			dev_dbg(davinci_display_dev,
+				"\nStart of VIDIOC_CROPCAP ioctl");
+			if (davinci_enc_get_mode(0, &davinci_dm.mode_info)) {
+				dev_err(davinci_display_dev,
+					"Error in getting current display mode from enc mngr\n");
+				up(&davinci_dm.lock);
+				return -EINVAL;
+			}
+			down_interruptible(&davinci_dm.lock);
+			cropcap->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+			if (!strcmp
+			    (davinci_dm.mode_info.name, VID_ENC_STD_NTSC)) {
+				cropcap->bounds = cropcap->defrect =
+				    ntsc_bounds;
+				cropcap->pixelaspect = ntsc_aspect;
+			} else
+			    if (!strcmp
+				(davinci_dm.mode_info.name, VID_ENC_STD_PAL)) {
+				cropcap->bounds = cropcap->defrect = pal_bounds;
+				cropcap->pixelaspect = pal_aspect;
+			} else
+			    if (!strcmp
+				(davinci_dm.mode_info.name,
+				 VID_ENC_STD_640x480)) {
+				cropcap->bounds = cropcap->defrect = vga_bounds;
+				cropcap->pixelaspect = sp_aspect;
+			} else
+			    if (!strcmp
+				(davinci_dm.mode_info.name,
+				 VID_ENC_STD_640x400)) {
+				cropcap->bounds = cropcap->defrect = vga_bounds;
+				cropcap->bounds.height =
+				    cropcap->defrect.height = 400;
+				cropcap->pixelaspect = sp_aspect;
+			} else
+			    if (!strcmp
+				(davinci_dm.mode_info.name,
+				 VID_ENC_STD_640x350)) {
+				cropcap->bounds = cropcap->defrect = vga_bounds;
+				cropcap->bounds.height =
+				    cropcap->defrect.height = 350;
+				cropcap->pixelaspect = sp_aspect;
+			} else
+			    if (!strcmp
+				(davinci_dm.mode_info.name,
+				 VID_ENC_STD_720P_60)) {
+				cropcap->bounds = cropcap->defrect =
+				    hd_720p_bounds;
+				cropcap->pixelaspect = sp_aspect;
+			} else
+			    if (!strcmp
+				(davinci_dm.mode_info.name,
+				 VID_ENC_STD_1080I_30)) {
+				cropcap->bounds = cropcap->defrect =
+				    hd_1080i_bounds;
+				cropcap->pixelaspect = sp_aspect;
+			} else {
+				dev_err(davinci_display_dev,
+					"Unknown encoder display mode\n");
+				up(&davinci_dm.lock);
+				return -EINVAL;
+			}
+			up(&davinci_dm.lock);
+			dev_dbg(davinci_display_dev,
+				"\nEnd of VIDIOC_CROPCAP ioctl");
+			break;
+		}
+
+	case VIDIOC_G_CROP:
+		{
+			/* TBD to get the x,y and height/width params */
+			struct v4l2_crop *crop = (struct v4l2_crop *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_G_CROP, layer id = %d\n",
+				layer->device_id);
+
+			if (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				struct v4l2_rect *rect = &crop->c;
+				down_interruptible(&davinci_dm.lock);
+				davinci_disp_get_layer_config(layer->layer_info.
+							      id,
+							      &layer->
+							      layer_info.
+							      config);
+				rect->top = layer->layer_info.config.ypos;
+				rect->left = layer->layer_info.config.xpos;
+				rect->width = layer->layer_info.config.xsize;
+				rect->height = layer->layer_info.config.ysize;
+				up(&davinci_dm.lock);
+			} else {
+				dev_err(davinci_display_dev,
+					"Invalid buf type \n");
+				return -EINVAL;
+			}
+			break;
+		}
+	case VIDIOC_S_CROP:
+		{
+			/* TBD to get the x,y and height/width params */
+			struct v4l2_crop *crop = (struct v4l2_crop *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_S_CROP, layer id = %d\n",
+				layer->device_id);
+
+			if (crop->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {
+				struct v4l2_rect *rect = &crop->c;
+
+				if (davinci_disp_check_window_params(rect)) {
+					dev_err(davinci_display_dev,
+						"Error in S_CROP params\n");
+					return -EINVAL;
+				}
+				down_interruptible(&davinci_dm.lock);
+				davinci_disp_get_layer_config(layer->layer_info.
+							      id,
+							      &layer->
+							      layer_info.
+							      config);
+
+				davinci_disp_calculate_scale_factor(layer,
+								    rect->width,
+								    rect->
+								    height);
+
+				davinci_disp_adj_position(layer, rect->top,
+							  rect->left);
+
+				if (davinci_disp_set_layer_config
+				    (layer->layer_info.id,
+				     &layer->layer_info.config)) {
+					dev_err(davinci_display_dev,
+						"Error in S_CROP params\n");
+					up(&davinci_dm.lock);
+					return -EINVAL;
+				}
+				/* apply zooming and h or v expansion */
+				davinci_disp_set_zoom
+				    (layer->layer_info.id,
+				     layer->layer_info.h_zoom,
+				     layer->layer_info.v_zoom);
+
+				davinci_disp_set_vid_expansion
+				    (layer->layer_info.h_exp,
+				     layer->layer_info.v_exp);
+
+				if ((layer->layer_info.h_zoom != ZOOM_X1) ||
+				    (layer->layer_info.v_zoom != ZOOM_X1) ||
+				    (layer->layer_info.h_exp != H_EXP_OFF) ||
+				    (layer->layer_info.v_exp != V_EXP_OFF))
+					/* Enable expansion filter */
+					davinci_disp_set_interpolation_filter
+					    (1);
+				else
+					davinci_disp_set_interpolation_filter
+					    (0);
+				up(&davinci_dm.lock);
+			} else {
+				dev_err(davinci_display_dev,
+					"Invalid buf type \n");
+				return -EINVAL;
+			}
+			break;
+		}
+		/* If the case is for enumerating formats */
+	case VIDIOC_ENUM_FMT:
+		{
+			struct v4l2_fmtdesc *fmt = (struct v4l2_fmtdesc *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_ENUM_FMT, layer id = %d\n",
+				layer->device_id);
+			if (fmt->index > 0) {
+				dev_err(davinci_display_dev,
+					"Invalid format index\n");
+				return -EINVAL;
+			}
+			/* Fill in the information about format */
+
+			index = fmt->index;
+			memset(fmt, 0, sizeof(*fmt));
+			fmt->index = index;
+			fmt->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+			if (index == 0) {
+				strcpy(fmt->description, "YUV 4:2:2 - UYVY");
+				fmt->pixelformat = V4L2_PIX_FMT_UYVY;
+			}
+			break;
+		}
+
+		/* If the case is for getting formats */
+	case VIDIOC_G_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_G_FMT, layer id = %d\n",
+				layer->device_id);
+
+			/* If buffer type is video output */
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Fill in the information about
+				 * format */
+				down_interruptible(&davinci_dm.lock);
+				*pixfmt = layer->pix_fmt;
+				up(&davinci_dm.lock);
+			} else {
+				dev_err(davinci_display_dev, "invalid type\n");
+				ret = -EINVAL;
+			}
+			break;
+		}
+
+		/* If the case is for setting formats */
+	case VIDIOC_S_FMT:
+		{
+			struct v4l2_format *fmt = (struct v4l2_format *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_S_FMT, layer id = %d\n",
+				layer->device_id);
+
+			/* If streaming is started, return error */
+			if (layer->started) {
+				dev_err(davinci_display_dev,
+					"Streaming is started\n");
+				return -EBUSY;
+			}
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Check for valid field format */
+				ret = davinci_check_format(layer, pixfmt);
+
+				if (ret)
+					return ret;
+
+				down_interruptible(&davinci_dm.lock);
+				/* store the pixel format in the layer
+				 * object */
+				davinci_disp_get_layer_config(layer->layer_info.
+							      id,
+							      &layer->
+							      layer_info.
+							      config);
+
+				if (davinci_enc_get_mode
+				    (0, &davinci_dm.mode_info)) {
+					dev_err(davinci_display_dev,
+						"couldn't get current display mode from enc mngr\n");
+					up(&davinci_dm.lock);
+					return -EINVAL;
+				}
+
+				/* For user ptr io, we calculate image size from bytes
+				   perline and sizeimage as per DaVinciHD
+				 */
+				if (layer->memory == V4L2_MEMORY_USERPTR) {
+					layer->layer_info.config.xsize =
+					    pixfmt->bytesperline / 2;
+					layer->layer_info.config.line_length =
+					    pixfmt->bytesperline;
+					layer->layer_info.config.ysize =
+					    pixfmt->sizeimage /
+					    pixfmt->bytesperline;
+				} else {
+					layer->layer_info.config.xsize =
+					    pixfmt->width;
+					layer->layer_info.config.ysize =
+					    pixfmt->height;
+					layer->layer_info.config.line_length =
+					    pixfmt->width * 2;
+				}
+				layer->layer_info.config.ypos = 0;
+				layer->layer_info.config.xpos = 0;
+				layer->layer_info.config.interlaced =
+				    davinci_dm.mode_info.interlaced;
+
+				if (davinci_disp_set_layer_config
+				    (layer->layer_info.id,
+				     &layer->layer_info.config)) {
+					dev_err(davinci_display_dev,
+						"Error in S_FMT params:- field\n");
+					up(&davinci_dm.lock);
+					return -EINVAL;
+				}
+
+				/* readback and fill the local copy of current pix format */
+				davinci_disp_get_layer_config(layer->layer_info.
+							      id,
+							      &layer->
+							      layer_info.
+							      config);
+
+				layer->pix_fmt.width =
+				    layer->layer_info.config.xsize;
+				layer->pix_fmt.height =
+				    layer->layer_info.config.ysize;
+				layer->pix_fmt.bytesperline =
+				    layer->layer_info.config.line_length;
+				layer->pix_fmt.sizeimage =
+				    layer->pix_fmt.bytesperline *
+				    layer->pix_fmt.height;
+				if (layer->layer_info.config.interlaced)
+					layer->pix_fmt.field =
+					    V4L2_FIELD_INTERLACED;
+				else
+					layer->pix_fmt.field = V4L2_FIELD_NONE;
+				layer->pix_fmt.pixelformat = V4L2_PIX_FMT_UYVY;
+				/* Set the scale factors */
+				up(&davinci_dm.lock);
+			} else {
+				dev_err(davinci_display_dev, "invalid type\n");
+				ret = -EINVAL;
+			}
+			break;
+		}
+		/* If the case is for trying formats */
+	case VIDIOC_TRY_FMT:
+		{
+			struct v4l2_format *fmt;
+			dev_dbg(davinci_display_dev, "VIDIOC_TRY_FMT\n");
+			fmt = (struct v4l2_format *)arg;
+
+			if (V4L2_BUF_TYPE_VIDEO_OUTPUT == fmt->type) {
+				struct v4l2_pix_format *pixfmt = &fmt->fmt.pix;
+				/* Check for valid field format */
+				ret = davinci_check_format(layer, pixfmt);
+				if (ret) {
+					*pixfmt = layer->pix_fmt;
+				}
+			} else {
+				dev_err(davinci_display_dev, "invalid type\n");
+				ret = -EINVAL;
+			}
+			break;
+		}
+
+		/* If the case is for requesting buffer allocation */
+	case VIDIOC_REQBUFS:
+		{
+			struct v4l2_requestbuffers *reqbuf;
+			reqbuf = (struct v4l2_requestbuffers *)arg;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_REQBUFS, count= %d, type = %d, memory = %d\n",
+				reqbuf->count, reqbuf->type, reqbuf->memory);
+
+			down_interruptible(&davinci_dm.lock);
+			/* If io users of the layer is not zero,
+			   return error */
+			if (0 != layer->io_usrs) {
+				dev_err(davinci_display_dev, "not IO user\n");
+				ret = -EBUSY;
+				break;
+			}
+			/* Initialize videobuf queue as per the
+			   buffer type */
+			videobuf_queue_init(&layer->buffer_queue,
+					    &video_qops, NULL,
+					    &layer->irqlock,
+					    V4L2_BUF_TYPE_VIDEO_OUTPUT,
+					    layer->pix_fmt.field,
+					    sizeof(struct videobuf_buffer), fh);
+			/* Set buffer to Linear buffer */
+			videobuf_set_buftype(&layer->buffer_queue,
+					     VIDEOBUF_BUF_LINEAR);
+			/* Set io allowed member of file handle to
+			 * TRUE */
+			fh->io_allowed = 1;
+			/* Increment io usrs member of layer object
+			   to 1 */
+			layer->io_usrs = 1;
+			/* Store type of memory requested in layer
+			   object */
+			layer->memory = reqbuf->memory;
+			/* Initialize buffer queue */
+			INIT_LIST_HEAD(&layer->dma_queue);
+			/* Allocate buffers */
+			ret = videobuf_reqbufs(&layer->buffer_queue, reqbuf);
+			up(&davinci_dm.lock);
+			break;
+		}
+		/* If the case is for en-queing buffer in the buffer
+		 * queue */
+	case VIDIOC_QBUF:
+		{
+			struct v4l2_buffer tbuf;
+			struct videobuf_buffer *buf1;
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_QBUF, layer id = %d\n",
+				layer->device_id);
+
+			/* If this file handle is not allowed to do IO,
+			   return error */
+			if (!fh->io_allowed) {
+				dev_err(davinci_display_dev, "No io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			if (!(list_empty(&layer->dma_queue)) ||
+			    (layer->curFrm != layer->nextFrm) ||
+			    !(layer->started) ||
+			    (layer->started && (0 == layer->field_id))) {
+
+				ret = videobuf_qbuf(&layer->buffer_queue,
+						    (struct v4l2_buffer *)arg);
+				break;
+			}
+			/* bufferqueue is empty store buffer address
+			 *  in VPBE registers */
+			mutex_lock(&layer->buffer_queue.lock);
+			tbuf = *(struct v4l2_buffer *)arg;
+			buf1 = layer->buffer_queue.bufs[tbuf.index];
+			if (buf1->memory != tbuf.memory) {
+				dev_err(davinci_display_dev,
+					"invalid buffer type\n");
+				mutex_unlock(&layer->buffer_queue.lock);
+				return -EINVAL;
+			}
+			if ((buf1->state == STATE_QUEUED) ||
+			    (buf1->state == STATE_ACTIVE)) {
+				mutex_unlock(&layer->buffer_queue.lock);
+				dev_err(davinci_display_dev, "invalid state\n");
+				return -EINVAL;
+			}
+
+			switch (buf1->memory) {
+			case V4L2_MEMORY_MMAP:
+				if (buf1->baddr == 0) {
+					mutex_unlock(&layer->buffer_queue.lock);
+					dev_err(davinci_display_dev,
+						"No Buffer address\n");
+					return -EINVAL;
+				}
+				break;
+			case V4L2_MEMORY_USERPTR:
+				if (tbuf.length < buf1->bsize) {
+					mutex_unlock(&layer->buffer_queue.lock);
+					dev_err(davinci_display_dev,
+						"No Buffer address\n");
+					return -EINVAL;
+				}
+				if ((STATE_NEEDS_INIT != buf1->state)
+				    && (buf1->baddr != tbuf.m.userptr))
+					davinci_buffer_release(&layer->
+							       buffer_queue,
+							       buf1);
+				buf1->baddr = tbuf.m.userptr;
+				break;
+			default:
+				mutex_unlock(&layer->buffer_queue.lock);
+				dev_err(davinci_display_dev,
+					"Unknow Buffer type \n");
+				return -EINVAL;
+			}
+			local_irq_save(flags);
+			ret =
+			    davinci_buffer_prepare(&layer->buffer_queue,
+						   buf1,
+						   layer->buffer_queue.field);
+			buf1->state = STATE_ACTIVE;
+			addr = buf1->boff;
+			layer->nextFrm = buf1;
+
+			davinci_disp_start_layer(layer->layer_info.id, addr);
+			local_irq_restore(flags);
+			list_add_tail(&buf1->stream,
+				      &(layer->buffer_queue.stream));
+			mutex_unlock(&layer->buffer_queue.lock);
+			break;
+		}
+
+		/* If the case is for de-queing buffer from the
+		 * buffer queue */
+	case VIDIOC_DQBUF:
+		{
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_DQBUF, layer id = %d\n",
+				layer->device_id);
+
+			/* If this file handle is not allowed to do IO,
+			   return error */
+			if (!fh->io_allowed) {
+				dev_err(davinci_display_dev, "No io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			if (file->f_flags & O_NONBLOCK)
+				/* Call videobuf_dqbuf for non
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(&layer->buffer_queue,
+						   (struct v4l2_buffer *)
+						   arg, 1);
+			else
+				/* Call videobuf_dqbuf for
+				   blocking mode */
+				ret =
+				    videobuf_dqbuf(&layer->buffer_queue,
+						   (struct v4l2_buffer *)
+						   arg, 0);
+			break;
+		}
+
+		/* If the case is for querying information about
+		 *  buffer for memory mapping io */
+	case VIDIOC_QUERYBUF:
+		{
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_QUERYBUF, layer id = %d\n",
+				layer->device_id);
+			/* Call videobuf_querybuf to get information */
+			ret = videobuf_querybuf(&layer->buffer_queue,
+						(struct v4l2_buffer *)
+						arg);
+			break;
+		}
+
+		/* If the case is starting streaming */
+	case VIDIOC_STREAMON:
+		{
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_STREAMON, layer id = %d\n",
+				layer->device_id);
+			/* If file handle is not allowed IO,
+			 * return error */
+			if (!fh->io_allowed) {
+				dev_err(davinci_display_dev, "No io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			/* If Streaming is already started,
+			 * return error */
+			if (layer->started) {
+				dev_err(davinci_display_dev,
+					"layer is already streaming\n");
+				ret = -EBUSY;
+				break;
+			}
+
+			/* Call videobuf_streamon to start streaming
+			   in videobuf */
+			ret = videobuf_streamon(&layer->buffer_queue);
+			if (ret) {
+				dev_err(davinci_display_dev,
+					"error in videobuf_streamon\n");
+				break;
+			}
+			down_interruptible(&davinci_dm.lock);
+			/* If buffer queue is empty, return error */
+			if (list_empty(&layer->dma_queue)) {
+				dev_err(davinci_display_dev,
+					"buffer queue is empty\n");
+				ret = -EIO;
+				up(&davinci_dm.lock);
+				break;
+			}
+			/* Get the next frame from the buffer queue */
+			layer->nextFrm = layer->curFrm =
+			    list_entry(layer->dma_queue.next,
+				       struct videobuf_buffer, queue);
+			/* Remove buffer from the buffer queue */
+			list_del(&layer->curFrm->queue);
+			/* Mark state of the current frame to active */
+			layer->curFrm->state = STATE_ACTIVE;
+			/* Initialize field_id and started member */
+
+			layer->field_id = 0;
+
+			/* Set parameters in OSD and VENC */
+			ret = davinci_set_video_display_params(layer);
+			if (ret < 0) {
+				up(&davinci_dm.lock);
+				return ret;
+			}
+			layer->started = 1;
+			dev_dbg(davinci_display_dev,
+				"Started streaming on layer id = %d, ret = %d\n",
+				layer->device_id, ret);
+			layer_first_int = 1;
+			up(&davinci_dm.lock);
+			break;
+		}
+
+		/* If the case is for stopping streaming */
+	case VIDIOC_STREAMOFF:
+		{
+			dev_dbg(davinci_display_dev,
+				"VIDIOC_STREAMOFF,layer id = %d\n",
+				layer->device_id);
+			/* If io is allowed for this file handle,
+			   return error */
+			if (!fh->io_allowed) {
+				dev_err(davinci_display_dev, "No io_allowed\n");
+				ret = -EACCES;
+				break;
+			}
+			/* If streaming is not started, return error */
+			if (!layer->started) {
+				dev_err(davinci_display_dev,
+					"streaming not started in layer id = %d\n",
+					layer->device_id);
+				ret = -EINVAL;
+				break;
+			}
+			down_interruptible(&davinci_dm.lock);
+			davinci_disp_disable_layer(layer->layer_info.id);
+			layer->started = 0;
+			up(&davinci_dm.lock);
+			ret = videobuf_streamoff(&layer->buffer_queue);
+			break;
+		}
+
+	default:
+		return -EINVAL;
+	}
+
+	dev_dbg(davinci_display_dev, "<davinci_doioctl>\n");
+	return ret;
+}
+
+/*
+ * ======== davinci_ioctl ========*/
+/* Calls davinci_doioctl function */
+static int davinci_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	dev_dbg(davinci_display_dev, "Start of davinci ioctl\n");
+	ret = video_usercopy(inode, file, cmd, arg, (void *)davinci_doioctl);
+	if ((ret >= 0) && (VIDIOC_S_FMT == cmd || VIDIOC_TRY_FMT == cmd)) {
+		ret = video_usercopy(inode, file, VIDIOC_G_FMT,
+				     arg, (void *)davinci_doioctl);
+	}
+	dev_dbg(davinci_display_dev, "</davinci_ioctl>\n");
+	return ret;
+}
+
+/*
+ * ======== davinci_mmap ========*/
+/* It is used to map kernel space buffers into user spaces */
+static int davinci_mmap(struct file *filep, struct vm_area_struct *vma)
+{
+	/* Get the layer object and file handle object */
+	struct davinci_fh *fh = filep->private_data;
+	struct display_obj *layer = fh->layer;
+	int err = 0;
+	dev_dbg(davinci_display_dev, "<davinci_mmap>\n");
+
+	err = videobuf_mmap_mapper(&layer->buffer_queue, vma);
+	dev_dbg(davinci_display_dev, "</davinci_mmap>\n");
+	return err;
+}
+
+static int davinci_config_layer(enum davinci_display_device_id id)
+{
+	int err = 0;
+	struct davinci_layer_config *layer_config;
+	struct vid_enc_mode_info *mode_info;
+	struct display_obj *layer = davinci_dm.dev[id];
+
+	/* First claim the layer for this device */
+	if (davinci_disp_request_layer(layer->layer_info.id)) {
+		/* Couldn't get layer */
+		dev_err(davinci_display_dev,
+			"Display Manager failed to allocate layer\n");
+		return -EBUSY;
+	}
+
+	/* get the current video display mode from encoder manager */
+	mode_info = &davinci_dm.mode_info;
+	if (davinci_enc_get_mode(0, mode_info)) {
+		dev_err(davinci_display_dev,
+			"Error in getting current display mode from enc mngr\n");
+		return -1;
+	}
+
+	layer_config = &layer->layer_info.config;
+	/* Set the default image and crop values */
+	layer_config->pixfmt = PIXFMT_YCbCrI;
+	layer->pix_fmt.pixelformat = V4L2_PIX_FMT_UYVY;
+	layer->pix_fmt.bytesperline = layer_config->line_length =
+	    mode_info->xres * 2;
+
+	layer->pix_fmt.width = layer_config->xsize = mode_info->xres;
+	layer->pix_fmt.height = layer_config->ysize = mode_info->yres;
+	layer->pix_fmt.sizeimage =
+	    layer->pix_fmt.bytesperline * layer->pix_fmt.height;
+	layer_config->xpos = 0;
+	layer_config->ypos = 0;
+	layer_config->interlaced = mode_info->interlaced;
+
+	/* turn off ping-pong buffer and field inversion to fix
+	   the image shaking problem in 1080I mode */
+	if (id == DAVINCI_DISPLAY_DEVICE_0 &&
+	    strcmp(mode_info->name, VID_ENC_STD_1080I_30) == 0 &&
+	    cpu_is_davinci_dm644x())
+		davinci_disp_set_field_inversion(0);
+
+	if (layer->layer_info.config.interlaced)
+		layer->pix_fmt.field = V4L2_FIELD_INTERLACED;
+	else
+		layer->pix_fmt.field = V4L2_FIELD_NONE;
+	davinci_disp_set_layer_config(layer->layer_info.id, layer_config);
+	return err;
+}
+
+/*
+ *=====davinci_open===== */
+/* It creates object of file handle structure and stores it in private_data
+ * member of filepointer */
+static int davinci_open(struct inode *inode, struct file *filep)
+{
+	int minor = iminor(inode);
+	int found = -1;
+	int i = 0;
+	struct display_obj *layer;
+	struct davinci_fh *fh = NULL;
+	/* Check for valid minor number */
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the layer object */
+		layer = davinci_dm.dev[i];
+		if (minor == layer->video_dev->minor) {
+			found = i;
+			break;
+		}
+	}
+
+	/* If not found, return error no device */
+	if (0 > found) {
+		dev_err(davinci_display_dev, "device not found\n");
+		return -ENODEV;
+	}
+
+	/* Allocate memory for the file handle object */
+	fh = kmalloc(sizeof(struct davinci_fh), GFP_KERNEL);
+	if (ISNULL(fh)) {
+		dev_err(davinci_display_dev,
+			"unable to allocate memory for file handle object\n");
+		return -ENOMEM;
+	}
+	dev_dbg(davinci_display_dev, "<davinci open> plane = %d\n",
+		layer->device_id);
+	/* store pointer to fh in private_data member of filep */
+	filep->private_data = fh;
+	fh->layer = layer;
+
+	if (!layer->usrs) {
+		/* Configure the default values for the layer */
+		if (davinci_config_layer(layer->device_id)) {
+			dev_err(davinci_display_dev,
+				"Unable to configure video layer for id = %d\n",
+				layer->device_id);
+			return -EINVAL;
+		}
+	}
+
+	/* Increment layer usrs counter */
+	layer->usrs++;
+	/* Set io_allowed member to false */
+	fh->io_allowed = 0;
+	/* Initialize priority of this instance to default priority */
+	fh->prio = V4L2_PRIORITY_UNSET;
+	v4l2_prio_open(&layer->prio, &fh->prio);
+	dev_dbg(davinci_display_dev, "</davinci_open>\n");
+	return 0;
+}
+
+/*
+ *=====davinci_release=====*/
+/* This function deletes buffer queue, frees the buffers and the davinci
+   display file * handle */
+static int davinci_release(struct inode *inode, struct file *filep)
+{
+	/* Get the layer object and file handle object */
+	struct davinci_fh *fh = filep->private_data;
+	struct display_obj *layer = fh->layer;
+
+	dev_dbg(davinci_display_dev, "<davinci_release>\n");
+	/* If this is doing IO and other layer are not closed */
+	if ((layer->usrs != 1) && fh->io_allowed) {
+		dev_err(davinci_display_dev, "Close other instances\n");
+		return -EAGAIN;
+	}
+	/* Get the lock on layer object */
+	down_interruptible(&davinci_dm.lock);
+	/* if this instance is doing IO */
+	if (fh->io_allowed) {
+		/* Reset io_usrs member of layer object */
+		layer->io_usrs = 0;
+		davinci_disp_disable_layer(layer->layer_info.id);
+		layer->started = 0;
+		/* Free buffers allocated */
+		videobuf_queue_cancel(&layer->buffer_queue);
+		videobuf_mmap_free(&layer->buffer_queue);
+	}
+
+	/* Decrement layer usrs counter */
+	layer->usrs--;
+	/* If this file handle has initialize encoder device, reset it */
+	if (!layer->usrs) {
+		davinci_disp_disable_layer(layer->layer_info.id);
+		davinci_disp_release_layer(layer->layer_info.id);
+	}
+
+	/* Close the priority */
+	v4l2_prio_close(&layer->prio, &fh->prio);
+	filep->private_data = NULL;
+
+	/* Free memory allocated to file handle object */
+	if (!ISNULL(fh))
+		kfree(fh);
+	/* unlock semaphore on layer object */
+	up(&davinci_dm.lock);
+	dev_dbg(davinci_display_dev, "</davinci_release>\n");
+	return 0;
+}
+
+static void davinci_platform_release(struct device
+				     *device)
+{
+	/* This is called when the reference count goes to zero */
+}
+
+static struct file_operations davinci_fops = {
+	.owner = THIS_MODULE,
+	.open = davinci_open,
+	.release = davinci_release,
+	.ioctl = davinci_ioctl,
+	.mmap = davinci_mmap
+};
+static struct video_device davinci_video_template = {
+	.name = "davinci",
+	.type = VID_TYPE_CAPTURE,
+	.hardware = 0,
+	.fops = &davinci_fops,
+	.minor = -1
+};
+
+/*
+ *=====davinci_probe=====*/
+/* This function creates device entries by register itself to the V4L2 driver
+ * and initializes fields of each layer objects */
+static __init int davinci_probe(struct device *device)
+{
+	int i, j = 0, k, err = 0;
+	struct video_device *vbd = NULL;
+	struct display_obj *layer = NULL;
+	struct platform_device *pdev;
+
+	davinci_display_dev = device;
+
+	dev_dbg(davinci_display_dev, "<davinci_probe>\n");
+
+	/* First request memory region for io */
+	pdev = to_platform_device(device);
+	if (pdev->num_resources != 0) {
+		dev_err(davinci_display_dev, "probed for an unknown device\n");
+		return -ENODEV;
+	}
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the layer object */
+		layer = davinci_dm.dev[i];
+		/* Allocate memory for video device */
+		vbd = video_device_alloc();
+		if (ISNULL(vbd)) {
+			for (j = 0; j < i; j++) {
+				video_device_release
+				    (davinci_dm.dev[j]->video_dev);
+			}
+			dev_err(davinci_display_dev, "ran out of memory\n");
+			return -ENOMEM;
+		}
+
+		/* Initialize field of video device */
+		*vbd = davinci_video_template;
+		vbd->dev = device;
+		vbd->release = video_device_release;
+		snprintf(vbd->name, sizeof(vbd->name),
+			 "DaVinci_VPBEDisplay_DRIVER_V%d.%d.%d",
+			 (DAVINCI_DISPLAY_VERSION_CODE >> 16)
+			 & 0xff,
+			 (DAVINCI_DISPLAY_VERSION_CODE >> 8) &
+			 0xff, (DAVINCI_DISPLAY_VERSION_CODE) & 0xff);
+		/* Set video_dev to the video device */
+		layer->video_dev = vbd;
+		layer->device_id = i;
+		layer->layer_info.id =
+		    ((i == DAVINCI_DISPLAY_DEVICE_0) ? WIN_VID0 : WIN_VID1);
+		if (display_buf_config_params.numbuffers[i] == 0)
+			layer->memory = V4L2_MEMORY_USERPTR;
+		else
+			layer->memory = V4L2_MEMORY_MMAP;
+		/* Initialize field of the layer objects */
+		layer->usrs = layer->io_usrs = 0;
+		layer->started = 0;
+#if 0
+		if (j < 2)
+			layer->numbuffers
+			    =
+			    display_buf_config_params.numbuffers[layer->
+								 layer_id];
+		else
+			layer->numbuffers = 0;
+#endif
+
+		/* Initialize prio member of layer object */
+		v4l2_prio_init(&layer->prio);
+
+		/* register video device */
+		printk(KERN_NOTICE
+		       "Trying to register davinci display video device.\n");
+		printk(KERN_NOTICE "layer=%x,layer->video_dev=%x\n", (int)layer,
+		       (int)&layer->video_dev);
+
+		err = video_register_device(layer->
+					    video_dev,
+					    VFL_TYPE_GRABBER,
+					    davinci_display_nr[i]);
+		if (err)
+			goto probe_out;
+	}
+	/* Initialize mutex */
+	init_MUTEX(&davinci_dm.lock);
+	return 0;
+
+      probe_out:
+	for (k = 0; k < j; k++) {
+		/* Get the pointer to the layer object */
+		layer = davinci_dm.dev[k];
+		/* Unregister video device */
+		video_unregister_device(layer->video_dev);
+		/* Release video device */
+		video_device_release(layer->video_dev);
+		layer->video_dev = NULL;
+	}
+	return err;
+}
+
+/*
+ * ===== davinci_remove =====*/
+/* It un-register hardware planes from V4L2 driver */
+static int davinci_remove(struct device *device)
+{
+	int i;
+	struct display_obj *plane;
+	dev_dbg(davinci_display_dev, "<davinci_remove>\n");
+	/* un-register device */
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		/* Get the pointer to the layer object */
+		plane = davinci_dm.dev[i];
+		/* Unregister video device */
+		video_unregister_device(plane->video_dev);
+
+		plane->video_dev = NULL;
+	}
+
+	dev_dbg(davinci_display_dev, "</davinci_remove>\n");
+	return 0;
+}
+
+static struct device_driver davinci_driver = {
+	.name = DAVINCI_DISPLAY_DRIVER,
+	.bus = &platform_bus_type,
+	.probe = davinci_probe,
+	.remove = davinci_remove,
+};
+static struct platform_device _davinci_display_device = {
+	.name = DAVINCI_DISPLAY_DRIVER,
+	.id = 1,
+	.dev = {
+		.release = davinci_platform_release,
+		}
+};
+
+/*
+ *=====davinci_display_init=====*/
+/* This function registers device and driver to the kernel, requests irq
+ * handler and allocates memory for layer objects */
+static __init int davinci_display_init(void)
+{
+	int err = 0, i, j;
+	int free_layer_objects_index;
+	int free_buffer_layer_index;
+	int free_buffer_index;
+	u32 addr;
+	int size;
+
+	printk(KERN_DEBUG "<davinci_display_init>\n");
+
+	/* Default number of buffers should be 3 */
+	if ((video2_numbuffers > 0) &&
+	    (video2_numbuffers < display_buf_config_params.min_numbuffers))
+		video2_numbuffers = display_buf_config_params.min_numbuffers;
+	if ((video3_numbuffers > 0) &&
+	    (video3_numbuffers < display_buf_config_params.min_numbuffers))
+		video3_numbuffers = display_buf_config_params.min_numbuffers;
+
+	/* Set buffer size to min buffers size if invalid buffer size is
+	 * given */
+	if (video2_bufsize <
+	    display_buf_config_params.min_bufsize[DAVINCI_DISPLAY_DEVICE_0])
+		video2_bufsize =
+		    display_buf_config_params.
+		    min_bufsize[DAVINCI_DISPLAY_DEVICE_0];
+
+	if (video3_bufsize <
+	    display_buf_config_params.min_bufsize[DAVINCI_DISPLAY_DEVICE_1])
+		video3_bufsize =
+		    display_buf_config_params.
+		    min_bufsize[DAVINCI_DISPLAY_DEVICE_1];
+
+	if (video2_numbuffers) {
+		display_buf_config_params.numbuffers[DAVINCI_DISPLAY_DEVICE_0] =
+		    video2_numbuffers;
+	}
+	if (video3_numbuffers) {
+		display_buf_config_params.numbuffers[DAVINCI_DISPLAY_DEVICE_1] =
+		    video3_numbuffers;
+	}
+	if (cpu_is_davinci_dm355()) {
+		strcpy(davinci_display_videocap.card, DM355_EVM_CARD);
+	} else {
+		strcpy(davinci_display_videocap.card, DM644X_EVM_CARD);
+	}
+	/* Allocate memory for four plane display objects */
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		davinci_dm.dev[i] =
+		    kmalloc(sizeof(struct display_obj), GFP_KERNEL);
+		/* If memory allocation fails, return error */
+		if (!davinci_dm.dev[i]) {
+			free_layer_objects_index = i;
+			printk(KERN_ERR "ran out of memory\n");
+			err = -ENOMEM;
+			goto davinci_init_free_layer_objects;
+		}
+		spin_lock_init(&davinci_dm.dev[i]->irqlock);
+	}
+	free_layer_objects_index = DAVINCI_DISPLAY_MAX_DEVICES;
+
+	/* Allocate memory for buffers */
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		size = display_buf_config_params.layer_bufsize[i];
+		for (j = 0; j < display_buf_config_params.numbuffers[i]; j++) {
+			addr = davinci_alloc_buffer(size);
+			if (!addr) {
+				free_buffer_layer_index = i;
+				free_buffer_index = j;
+				printk(KERN_ERR "ran out of memory\n");
+				err = -ENOMEM;
+				goto davinci_init_free_buffers;
+			}
+			davinci_dm.dev[i]->fbuffers[j] = addr;
+		}
+	}
+	free_buffer_layer_index = DAVINCI_DISPLAY_MAX_DEVICES;
+	free_buffer_index = display_buf_config_params.numbuffers[i - 1];
+	/* Register driver to the kernel */
+	err = driver_register(&davinci_driver);
+	if (0 != err) {
+		goto davinci_init_free_buffers;
+	}
+	/* register device as a platform device to the kernel */
+	err = platform_device_register(&_davinci_display_device);
+	if (0 != err) {
+		goto davinci_init_unregister_driver;
+	}
+
+	davinci_dm.event_callback.mask = (DAVINCI_DISP_END_OF_FRAME |
+					  DAVINCI_DISP_FIRST_FIELD |
+					  DAVINCI_DISP_SECOND_FIELD);
+
+	davinci_dm.event_callback.arg = &davinci_dm;
+	davinci_dm.event_callback.handler = davinci_display_isr;
+
+	err = davinci_disp_register_callback(&davinci_dm.event_callback);
+
+	if (0 != err) {
+		goto davinci_init_unregister_driver;
+	}
+	printk(KERN_NOTICE
+	       "davinci_init:DaVinci V4L2 Display Driver V1.0 loaded\n");
+	printk(KERN_DEBUG "</davinci_init>\n");
+	return 0;
+
+      davinci_init_unregister_driver:
+	driver_unregister(&davinci_driver);
+
+      davinci_init_free_buffers:
+	for (i = 0; i < free_buffer_layer_index; i++) {
+		for (j = 0; j < display_buf_config_params.numbuffers[i]; j++) {
+			addr = davinci_dm.dev[i]->fbuffers[j];
+			if (addr) {
+				davinci_free_buffer(addr,
+						    display_buf_config_params.
+						    layer_bufsize[i]
+				    );
+				davinci_dm.dev[i]->fbuffers[j] = 0;
+			}
+		}
+	}
+	for (j = 0; j < display_buf_config_params.numbuffers[free_buffer_index];
+	     j++) {
+		addr = davinci_dm.dev[free_buffer_layer_index]->fbuffers[j];
+		if (addr) {
+			davinci_free_buffer(addr,
+					    display_buf_config_params.
+					    layer_bufsize[i]);
+			davinci_dm.dev[free_buffer_layer_index]->fbuffers[j]
+			    = 0;
+		}
+
+	}
+
+      davinci_init_free_layer_objects:
+	for (j = 0; j < free_layer_objects_index; j++) {
+		if (davinci_dm.dev[i]) {
+			kfree(davinci_dm.dev[j]);
+			davinci_dm.dev[i] = NULL;
+		}
+	}
+	return err;
+}
+
+/* =====davinci_cleanup=====
+ * This function un-registers device and driver to the kernel, frees requested
+ * irq handler and de-allocates memory allocated for layer objects.
+ * */
+static void davinci_cleanup(void)
+{
+	int i = 0, j = 0;
+	u32 addr;
+	printk(KERN_INFO "<davinci_cleanup>\n");
+
+	davinci_disp_unregister_callback(&davinci_dm.event_callback);
+	platform_device_unregister(&_davinci_display_device);
+	driver_unregister(&davinci_driver);
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		for (j = 0; j < display_buf_config_params.numbuffers[i]; j++) {
+			addr = davinci_dm.dev[i]->fbuffers[j];
+			if (addr) {
+				davinci_free_buffer(addr,
+						    display_buf_config_params.
+						    layer_bufsize[i]);
+				davinci_dm.dev[i]->fbuffers[j] = 0;
+			}
+		}
+	}
+	for (i = 0; i < DAVINCI_DISPLAY_MAX_DEVICES; i++) {
+		if (davinci_dm.dev[i]) {
+			kfree(davinci_dm.dev[i]);
+			davinci_dm.dev[i] = NULL;
+		}
+	}
+	printk(KERN_INFO "</davinci_cleanup>\n");
+}
+
+EXPORT_SYMBOL(davinci_display_dev);
+MODULE_LICENSE("GPL");
+/* Function for module initialization and cleanup */
+module_init(davinci_display_init);
+module_exit(davinci_cleanup);
Index: linux-2.6.18/drivers/media/video/davinci/davinci_enc_mngr.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/davinci_enc_mngr.c
@@ -0,0 +1,1162 @@
+
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/io.h>
+#include <asm/io.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <media/davinci/vid_encoder_if.h>
+#include <media/davinci/davinci_enc_mngr.h>
+#include <media/davinci/davinci_platform.h>
+
+#define ISNULL(p)       ((NULL) == (p))
+
+static char *ch0_output = "";
+static char *ch1_output = "";
+static char *ch0_mode = "";
+static char *ch1_mode = "";
+module_param(ch0_output, charp, S_IRUGO);
+module_param(ch1_output, charp, S_IRUGO);
+module_param(ch0_mode, charp, S_IRUGO);
+module_param(ch1_mode, charp, S_IRUGO);
+
+struct vid_enc_device_mgr enc_dev[DAVINCI_ENC_MAX_CHANNELS] = {
+};
+
+EXPORT_SYMBOL(enc_dev);
+extern struct enc_config davinci_enc_default[];
+extern char *davinci_outputs[];
+extern char *davinci_modes[];
+
+#ifdef CONFIG_SYSFS
+struct display_device {
+	struct module *owner;
+	struct class_device class_dev;
+	int channel;
+};
+
+static struct display_device *davinci_display_device[DAVINCI_ENC_MAX_CHANNELS];
+
+#define to_display_dev(cdev)	container_of(cdev, \
+ struct display_device, class_dev)
+
+static void display_class_release(struct class_device *cdev)
+{
+	struct display_device *dev = to_display_dev(cdev);
+
+	if (dev != NULL)
+		kfree(dev);
+}
+
+struct class display_class = {
+	.name = "davinci_display",
+	.release = display_class_release,
+};
+
+static ssize_t output_show(struct class_device *cdev, char *buf)
+{
+	char name[VID_ENC_NAME_MAX_CHARS];
+	struct display_device *dev = to_display_dev(cdev);
+	int p, ret;
+
+	ret = davinci_enc_get_output(dev->channel, name);
+	if (ret < 0)
+		return ret;
+
+	p = sprintf(buf, name);
+	p += sprintf(buf + p, "\n");
+
+	return p;
+}
+
+static ssize_t
+output_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	char name[count];
+	int ret;
+	if (!buffer || (count == 0))
+		return 0;
+
+	strncpy(name, buffer, VID_ENC_NAME_MAX_CHARS);
+	name[count - 1] = 0;
+	ret = davinci_enc_set_output(dev->channel, name);
+	if (ret < 0) {
+		return ret;
+	}
+
+	return count;
+}
+
+static ssize_t mode_show(struct class_device *cdev, char *buf)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	struct vid_enc_mode_info mode_info;
+	int p;
+	int ret;
+
+	ret = davinci_enc_get_mode(dev->channel, &mode_info);
+	if (ret < 0)
+		return ret;
+
+	p = sprintf(buf, mode_info.name);
+	p += sprintf(buf + p, "\n");
+
+	return p;
+}
+
+static ssize_t
+mode_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	char name[count];
+	struct vid_enc_mode_info mode_info;
+	int ret;
+
+	if (!buffer || (count == 0))
+		return 0;
+
+	strncpy(name, buffer, VID_ENC_NAME_MAX_CHARS);
+	name[count - 1] = 0;
+
+	ret = davinci_enc_get_mode(dev->channel, &mode_info);
+
+	if (ret < 0)
+		return ret;
+
+	mode_info.name = name;
+	ret = davinci_enc_set_mode(dev->channel, &mode_info);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t enable_show(struct class_device *cdev, char *buf)
+{
+	return 0;
+}
+
+static ssize_t
+enable_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	int enable_output_state, ret;
+
+	if (!buffer || (count == 0))
+		return 0;
+
+	if (strncmp(buffer, "on", 2) == 0)
+		enable_output_state = 1;
+	else if (strncmp(buffer, "off", 3) == 0)
+		enable_output_state = 0;
+	else
+		return -EINVAL;
+
+	ret = davinci_enc_enable_output(dev->channel, enable_output_state);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t
+control_store(struct class_device *cdev, const char *buffer, size_t count,
+	      u8 ctrl)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	int val;
+	int ret;
+
+	if (!buffer || (count == 0))
+		return 0;
+
+	val = simple_strtoul(buffer, NULL, 0);
+
+	ret = davinci_enc_set_control(dev->channel, ctrl, (char)val);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+static ssize_t control_show(struct class_device *cdev, char *buf, u8 ctrl)
+{
+	struct display_device *dev = to_display_dev(cdev);
+	unsigned int p;
+	unsigned char val;
+	int ret;
+
+	ret = davinci_enc_get_control(dev->channel, ctrl, &val);
+	if (ret < 0)
+		return ret;
+
+	p = sprintf(buf, "%d", val);
+	p += sprintf(buf + p, "\n");
+
+	return p;
+}
+
+static ssize_t
+brightness_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	return control_store(cdev, buffer, count, VID_ENC_CTRL_BRIGHTNESS);
+}
+static ssize_t brightness_show(struct class_device *cdev, char *buf)
+{
+	return control_show(cdev, buf, VID_ENC_CTRL_BRIGHTNESS);
+}
+static ssize_t
+hue_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	return control_store(cdev, buffer, count, VID_ENC_CTRL_HUE);
+}
+static ssize_t hue_show(struct class_device *cdev, char *buf)
+{
+	return control_show(cdev, buf, VID_ENC_CTRL_HUE);
+}
+static ssize_t
+gain_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	return control_store(cdev, buffer, count, VID_ENC_CTRL_GAIN);
+}
+static ssize_t gain_show(struct class_device *cdev, char *buf)
+{
+	return control_show(cdev, buf, VID_ENC_CTRL_GAIN);
+}
+
+#define DECLARE_ATTR(_name, _mode, _show, _store)                  \
+{                                                               \
+	.attr   = { .name = __stringify(_name), .mode = _mode,	\
+		    .owner = THIS_MODULE },  			\
+	.show   = _show,                                        \
+	.store  = _store,                                       \
+}
+static struct class_device_attribute bl_class_device_attributes[] = {
+	DECLARE_ATTR(output, S_IRWXUGO, output_show, output_store),
+	DECLARE_ATTR(mode, S_IRWXUGO, mode_show, mode_store),
+	DECLARE_ATTR(enable, S_IRWXUGO, enable_show, enable_store),
+	DECLARE_ATTR(brightness, S_IRWXUGO, brightness_show, brightness_store),
+	DECLARE_ATTR(hue, S_IRWXUGO, hue_show, hue_store),
+	DECLARE_ATTR(gain, S_IRWXUGO, gain_show, gain_store)
+};
+
+static void *create_sysfs_files(int channel)
+{
+	struct display_device *dev;
+	int ret;
+	int i;
+
+	dev = kzalloc(sizeof(struct display_device), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->owner = THIS_MODULE;
+	dev->channel = channel;
+	dev->class_dev.class = &display_class;
+	snprintf(dev->class_dev.class_id, BUS_ID_SIZE, "ch%d", channel);
+
+	ret = class_device_register(&dev->class_dev);
+	if (ret < 0) {
+		kfree(dev);
+		return NULL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(bl_class_device_attributes); i++) {
+		ret = class_device_create_file(&dev->class_dev,
+					       &bl_class_device_attributes[i]);
+		if (ret < 0) {
+			while (--i >= 0)
+				class_device_remove_file(&dev->class_dev,
+							 &bl_class_device_attributes
+							 [i]);
+			class_device_unregister(&dev->class_dev);
+			return NULL;
+		}
+	}
+
+	return dev;
+}
+
+static void remove_sysfs_files(struct display_device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(bl_class_device_attributes); i++)
+		class_device_remove_file(&dev->class_dev,
+					 &bl_class_device_attributes[i]);
+
+	class_device_unregister(&dev->class_dev);
+}
+#endif
+
+static void davinci_enc_check_options(void)
+{
+	int i;
+
+	i = 0;
+	while (*(davinci_modes[i]) != 0) {
+		if (*ch0_mode != 0 && !strcmp(ch0_mode, davinci_modes[i])) {
+			if (strcmp(ch0_mode, "ntsc") == 0
+			    || strcmp(ch0_mode, "pal") == 0)
+				strcpy(davinci_enc_default[0].mode,
+				       davinci_modes[i - 1]);
+			else
+				strcpy(davinci_enc_default[0].mode,
+				       davinci_modes[i]);
+		}
+		if (*ch1_mode != 0 &&
+		    (DAVINCI_ENC_MAX_CHANNELS > 1) &&
+		    !strcmp(ch1_mode, davinci_modes[i])) {
+			if (strcmp(ch1_mode, "ntsc") == 0
+			    || strcmp(ch1_mode, "pal") == 0)
+				strcpy(davinci_enc_default[1].mode,
+				       davinci_modes[i - 1]);
+			else
+				strcpy(davinci_enc_default[1].mode,
+				       davinci_modes[i]);
+		}
+		i++;
+	}
+
+	i = 0;
+	while (*(davinci_outputs[i]) != 0) {
+		if (*ch0_output != 0 && !strcmp(ch0_output, davinci_outputs[i]))
+			strcpy(davinci_enc_default[0].output,
+			       davinci_outputs[i]);
+
+		if (*ch1_output != 0 &&
+		    (DAVINCI_ENC_MAX_CHANNELS > 1) &&
+		    !strcmp(ch1_output, davinci_outputs[i]))
+			strcpy(davinci_enc_default[1].output,
+			       davinci_outputs[i]);
+		i++;
+	}
+	printk(KERN_NOTICE "ch0 default output \"%s\", mode \"%s\"\n",
+	       davinci_enc_default[0].output, davinci_enc_default[0].mode);
+	if (DAVINCI_ENC_MAX_CHANNELS > 1)
+		printk(KERN_NOTICE "ch1 default output \"%s\", mode \"%s\"\n",
+		       davinci_enc_default[1].output,
+		       davinci_enc_default[1].mode);
+	return;
+}
+
+/*
+ * vid_enc_mgr_init
+ */
+static int davinci_enc_mngr_init(void)
+{
+	int i, err = -EINVAL;
+	struct vid_enc_device_mgr *ptr = 0;
+
+#ifdef CONFIG_SYSFS
+	class_register(&display_class);
+#endif
+
+	for (i = 0; i < DAVINCI_ENC_MAX_CHANNELS; i++) {
+		ptr = &enc_dev[i];
+
+		memset((void *)ptr, 0, sizeof(struct vid_enc_device_mgr));
+		init_MUTEX(&ptr->lock);
+#ifdef CONFIG_SYSFS
+		davinci_display_device[i] = create_sysfs_files(i);
+		if (!davinci_display_device[i]) {
+			printk(KERN_ERR
+			       "Could not create display control sysfs "
+			       "files for channel %d\n", i);
+			return -EINVAL;
+		}
+#endif
+	}
+
+	davinci_enc_check_options();
+	err = 0;
+	return err;
+}
+
+/*
+ * vid_enc_mgr_cleanup
+ */
+static void davinci_enc_mngr_cleanup(void)
+{
+#ifdef CONFIG_SYSFS
+	int i;
+
+	for (i = 0; i < DAVINCI_ENC_MAX_CHANNELS; i++)
+		remove_sysfs_files(davinci_display_device[i]);
+
+	class_unregister(&display_class);
+#endif
+
+	return;
+}
+
+/*
+ * davinci_get_cur_encoder: get current encoder on the specified channel
+ */
+static struct vid_encoder_device *davinci_get_cur_encoder(int channel)
+{
+	struct vid_enc_device_mgr *mgr;
+
+	if ((channel > DAVINCI_ENC_MAX_CHANNELS) || (channel < 0))
+		return NULL;
+
+	mgr = &enc_dev[channel];
+
+	if (mgr->current_encoder > mgr->num_encoders)
+		return NULL;
+
+	if (mgr->num_encoders == 0)
+		return NULL;
+
+	return mgr->encoder[mgr->current_encoder];
+}
+
+/**
+ * function davinci_enc_setparams
+ * @params: pointer to params structure.
+ * @channel: channel number.
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set parameters at current active encoder. params will be defined by
+ * the specific encoder and used by user space applications to set encoder
+ * parameters.
+ */
+int davinci_enc_setparams(int channel, void *params)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->params_ops || NULL == params)
+		return -EINVAL;
+
+	if (cur_enc->params_ops->setparams != NULL)
+		return cur_enc->params_ops->setparams(params, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_setparams);
+
+/**
+ * function davinci_enc_getparams
+ * @params: pointer to params structure.
+ * @channel: channel number, 0 for first channel and so forth
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Get parameters at current active encoder. params will be defined by
+ * the specific encoder and used by user space applications to get encoder
+ * parameters.
+ */
+int davinci_enc_getparams(int channel, void *params)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->params_ops || NULL == params)
+		return -EINVAL;
+
+	if (cur_enc->params_ops->getparams != NULL)
+		return cur_enc->params_ops->getparams(params, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_getparams);
+
+/**
+ * function davinci_enc_set_control
+ * @channel: channel number.
+ * @ctrl: davinci_vid_enc_control type
+ * @val:  control value to be set
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set controls at the current encoder's output.
+ *
+ */
+int davinci_enc_set_control(int channel, enum vid_enc_ctrl_id ctrl, char val)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->ctrl_ops)
+		return -EINVAL;
+
+	if (cur_enc->ctrl_ops->setcontrol != NULL)
+		return cur_enc->ctrl_ops->setcontrol(ctrl, val, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_set_control);
+
+/**
+ * function davinci_enc_get_control
+ * @channel: channel number.
+ * @ctrl: control type as per davinci_vid_enc_ctrl_type
+ * @val:  ptr to value that gets updated
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get controls at the current encoder's output.
+ *
+ */
+int davinci_enc_get_control(int channel, enum vid_enc_ctrl_id ctrl, char *val)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->ctrl_ops || NULL == val)
+		return -EINVAL;
+
+	if (cur_enc->ctrl_ops->getcontrol != NULL)
+		return cur_enc->ctrl_ops->getcontrol(ctrl, val, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_get_control);
+
+/**
+ * function davinci_enc_reset
+ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *  Do a software Reset the current encoder. Some of the encoders require this.
+ * This shouldn't affect the contents of the registers configured already for
+ * for output, standard, control etc. If there is no support, encoder doesn't
+ * implement this API.
+ */
+int davinci_enc_reset(int channel)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->misc_ops)
+		return -EINVAL;
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->reset != NULL)
+		return cur_enc->misc_ops->reset(cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_reset);
+
+/**
+ * function davinci_enc_enable_output
+ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
+ * @flag: flag to indicate enable or disable, 0 - disable, 1 - enable
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+*  Enable/Disable the current ouput. While the VPSS is configured for a
+ * video mode or graphics mode, you may observe noise on the display device
+ * due to timing changes. To avoid this, the output may be disabled during
+* configuration of the VENC or related hardware in the VPSS and re-enabled
+* using this API. This will switch the output DACs Off or On based on the
+* flag.
+ */
+int davinci_enc_enable_output(int channel, int flag)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->misc_ops)
+		return -EINVAL;
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->enable != NULL)
+		return cur_enc->misc_ops->enable(flag, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_enable_output);
+
+/**
+ * function davinci_enc_set_output
+ * @channel: channel number.
+ * @output: ptr to output name string
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set output - Set channel's output to the one identified by output string
+ * The encoder manager calls enumoutput() of each of the encoder to determine
+ * the encoder that supports this output and set this encoder as the current
+ * encoder. It calls setoutput() of the selected encoder. Encoder is expected
+ * set a default mode on this output internally. Manager calls the getmode()
+ * to get information about the mode to program the SoC hardware (VENC/DLCD
+ * for Davinci/DM355. During programing of the SoC hardware for timing, manager
+ * would call enable() to disable and re-enable the output of the encoder
+ * to avoid noise at the display. It may also call reset() to make sure the
+ * encoder is reset if required by the encoder hardware.
+ */
+int davinci_enc_set_output(int channel, char *output)
+{
+	int i, j, found = -1;
+	int err = -EINVAL;
+	struct vid_encoder_device *cur_enc, *new_enc = 0;
+	struct vid_enc_device_mgr *mgr = NULL;
+	char buf[VID_ENC_NAME_MAX_CHARS];
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == output)
+		return err;
+
+	mgr = &enc_dev[channel];
+
+	/* enumerate the output for each encoder on this channel
+	   to find a matching one */
+	for (i = 0; i < mgr->num_encoders; i++) {
+		if (ISNULL(mgr->encoder[i]))
+			return err;
+
+		for (j = 0; j < mgr->encoder[i]->output_ops->count; j++) {
+			err =
+			    mgr->encoder[i]->output_ops->
+			    enumoutput(j, buf, mgr->encoder[i]);
+			if (err != 0)
+				return err;
+			if (strcmp(buf, output) == 0) {
+				found = i;
+				new_enc = mgr->encoder[i];
+				break;
+			}
+		}
+	}
+
+	if (found < 0) {
+		printk(KERN_ERR "output not found\n");
+		return -EINVAL;
+	}
+
+	/* found the encoder */
+	err = 0;
+	mgr->current_encoder = found;
+	down_interruptible(&mgr->lock);
+	err |= cur_enc->deinitialize(cur_enc);
+	err |= new_enc->initialize(new_enc, VID_ENC_FULL_INIT_FLAG);
+	err |= new_enc->output_ops->setoutput(output, new_enc);
+
+	if (err < 0) {
+		up(&mgr->lock);
+		return err;
+	}
+
+	/* get default mode */
+	err |= new_enc->mode_ops->getmode(&mgr->current_mode, new_enc);
+
+	if (new_enc->misc_ops != NULL && new_enc->misc_ops->enable != NULL)
+		err |= new_enc->misc_ops->enable(0, new_enc);
+
+	davinci_enc_set_mode_platform(channel, mgr);
+
+	/* Some encoders need a soft reset after configuring VENC, ex.
+	   ths8200
+	 */
+	if (new_enc->misc_ops != NULL && new_enc->misc_ops->reset != NULL)
+		err |= new_enc->misc_ops->reset(new_enc);
+
+	if (new_enc->misc_ops != NULL && new_enc->misc_ops->enable != NULL)
+		err |= new_enc->misc_ops->enable(1, new_enc);
+
+	if (0 == err)
+		strcpy(enc_dev[channel].current_output, output);
+
+	up(&mgr->lock);
+
+	return err;
+}
+
+EXPORT_SYMBOL(davinci_enc_set_output);
+
+/**
+ * function davinci_enc_set_mode
+ * @channel: channel number.
+ * @mode_info: ptr to vid_enc_mode_info structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   set standard or non-standard mode at current encoder's active output.
+ * Encoder Manager first configure the VENC or associated SoC hardware
+ * before calling the setmode() API of the encoder. To do so, encoder Manager
+ * calls the getmode() to get the mode_info for this mode and configure the
+ * mode based on the timing information present in this structure.
+ */
+int davinci_enc_set_mode(int channel, struct vid_enc_mode_info *mode_info)
+{
+	struct vid_encoder_device *cur_enc;
+	struct vid_enc_device_mgr *mgr = 0;
+
+	int err = -EINVAL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->mode_ops || NULL == mode_info)
+		return err;
+
+	mgr = &enc_dev[channel];
+
+	if (cur_enc->mode_ops->setmode != NULL) {
+		down_interruptible(&mgr->lock);
+		err = cur_enc->mode_ops->setmode(mode_info, cur_enc);
+		up(&mgr->lock);
+	} else
+		return err;
+
+	if (err < 0)
+		return err;
+
+	err = cur_enc->mode_ops->getmode(&mgr->current_mode, cur_enc);
+	if (err < 0)
+		return err;
+
+	err = 0;
+
+	down_interruptible(&mgr->lock);
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->enable != NULL)
+		err |= cur_enc->misc_ops->enable(0, cur_enc);
+
+	/* non-standard */
+	if (mgr->current_mode.std == 0) {
+		davinci_enc_set_display_timing(&mgr->current_mode);
+		up(&mgr->lock);
+		return err;
+	}
+
+	davinci_enc_set_mode_platform(channel, mgr);
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->reset != NULL)
+		err |= cur_enc->misc_ops->reset(cur_enc);
+
+	if (cur_enc->misc_ops != NULL && cur_enc->misc_ops->enable != NULL)
+		err |= cur_enc->misc_ops->enable(1, cur_enc);
+
+	up(&mgr->lock);
+
+	return err;
+}
+
+EXPORT_SYMBOL(davinci_enc_set_mode);
+
+/**
+ * function davinci_enc_get_mode
+ * @channel: channel number, starting index 0.
+ * @mode_info: ptr to vid_enc_mode_info structure
+ * This is updated by encoder manager
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   get video or graphics mode at current encoder's active output.
+ *
+*/
+int davinci_enc_get_mode(int channel, struct vid_enc_mode_info *mode_info)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->mode_ops || NULL == mode_info)
+		return -EINVAL;
+
+	if (cur_enc->mode_ops->getmode != NULL)
+		return cur_enc->mode_ops->getmode(mode_info, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_get_mode);
+
+/**
+ * function davinci_enc_get_output
+ * @channel: channel number.
+ * @output: ptr to array of char to hold output name.
+ * size VID_ENC_NAME_MAX_CHARS
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get output - Get channel's output. User call this to get the current
+*   output name
+ */
+int davinci_enc_get_output(int channel, char *output)
+{
+	struct vid_encoder_device *cur_enc;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->output_ops || NULL == output)
+		return -EINVAL;
+
+	if (cur_enc->output_ops->getoutput != NULL)
+		return cur_enc->output_ops->getoutput(output, cur_enc);
+	else
+		return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_get_output);
+
+/**
+ * vid_enc_register_encoder
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int vid_enc_register_encoder(struct vid_encoder_device *encoder)
+{
+	int i, found = 0, err = 0;
+	int ch_id = 0;
+	struct vid_enc_device_mgr *mgr = 0;
+	struct vid_encoder_device *cur_enc = 0;
+	struct enc_config *enc_def = 0;
+	struct vid_enc_mode_info mode_info;
+	char buf[VID_ENC_NAME_MAX_CHARS];
+
+	if (ISNULL(encoder))
+		return -EINVAL;
+
+	memset(&mode_info, 0, sizeof(struct vid_enc_mode_info));
+	ch_id = encoder->channel_id;
+
+	if ((ch_id > DAVINCI_ENC_MAX_CHANNELS) || (ch_id < 0))
+		return -EINVAL;
+
+	mgr = &enc_dev[ch_id];
+
+	if (mgr->num_encoders > DAVINCI_ENC_MAX_ENCODERS)
+		return -EINVAL;
+
+	/* get module boot args */
+	enc_def = &davinci_enc_default[ch_id];
+
+	/* we'd assume only std mode being reqeusted from bootargs */
+	mode_info.name = enc_def->mode;
+	mode_info.std = 1;
+
+	if (mgr->num_encoders == 0) {
+		/* set default for the first encoder */
+		err = encoder->initialize(encoder, VID_ENC_FULL_INIT_FLAG);
+
+		if (err >= 0) {
+			/* see if this has output requested by default
+			   or bootarg */
+
+			for (i = 0; i < encoder->output_ops->count; i++) {
+				err =
+				    encoder->output_ops->enumoutput(i, buf,
+								    encoder);
+				if (err != 0)
+					return err;
+				if (strcmp(buf, enc_def->output) == 0) {
+					err =
+					    encoder->output_ops->
+					    setoutput(enc_def->output, encoder);
+					found = 1;
+					break;
+				}
+			}
+
+			if (found == 1) {
+				err =
+				    encoder->mode_ops->setmode(&mode_info,
+							       encoder);
+				if (err != 0) {
+					printk
+					    (KERN_ERR
+					     "Setmode failed, reset to encoder"
+					     " default...\n");
+					encoder->deinitialize(encoder);
+					encoder->initialize(encoder, 0);
+					err = 0;
+				}
+			}
+
+			mgr->encoder[mgr->num_encoders++] = encoder;
+			mgr->current_encoder = 0;
+			encoder->output_ops->getoutput(mgr->current_output,
+						       encoder);
+			encoder->mode_ops->getmode(&mgr->current_mode, encoder);
+			down_interruptible(&mgr->lock);
+			davinci_enc_set_mode_platform(ch_id, mgr);
+			if (encoder->misc_ops != NULL
+			    && encoder->misc_ops->reset != NULL)
+				err |= encoder->misc_ops->reset(encoder);
+			up(&mgr->lock);
+			if (encoder->misc_ops != NULL
+			    && encoder->misc_ops->enable != NULL)
+				encoder->misc_ops->enable(1, encoder);
+		}
+	} else {
+		/* If we have more than one encoder module, then we still
+		   want to make sure we can set to the default output and
+		   mode. If current one is not the default, try this new
+		   one. If still no luck, just use the newly registered
+		   one as default */
+		cur_enc = davinci_get_cur_encoder(ch_id);
+
+		if ((strcmp(mgr->current_output,
+			    enc_def->output) != 0) && (cur_enc != NULL)) {
+			cur_enc->deinitialize(cur_enc);
+
+			err = encoder->initialize(encoder,
+						  VID_ENC_FULL_INIT_FLAG);
+
+			if (err < 0) {
+				/* no change if new one cannot be
+				   initialized */
+				encoder->deinitialize(encoder);
+				cur_enc->initialize(cur_enc, 0);
+				return err;
+			}
+			/* look for matching output */
+			for (i = 0; i < encoder->output_ops->count; i++) {
+				err =
+				    encoder->output_ops->enumoutput(i, buf,
+								    encoder);
+				if (err != 0)
+					return err;
+				if (strcmp(buf, enc_def->output) == 0) {
+					err =
+					    encoder->output_ops->
+					    setoutput(enc_def->output, encoder);
+					found = 1;
+					break;
+				}
+			}
+
+			if (found == 1) {
+				err |=
+				    encoder->mode_ops->setmode(&mode_info,
+							       encoder);
+				/* setmode went wrong, try redo init */
+				if (err != 0) {
+					printk
+					    (KERN_ERR
+					     "Set output or mode failed, "
+					     "reset to encoder default...\n");
+					encoder->deinitialize(encoder);
+					encoder->initialize(encoder, 0);
+					err = 0;
+				}
+			}
+
+			mgr->encoder[mgr->num_encoders++] = encoder;
+			mgr->current_encoder = mgr->num_encoders - 1;
+			encoder->output_ops->getoutput(mgr->current_output,
+						       encoder);
+			encoder->mode_ops->getmode(&mgr->current_mode, encoder);
+			down_interruptible(&mgr->lock);
+			davinci_enc_set_mode_platform(ch_id, mgr);
+			if (encoder->misc_ops != NULL
+			    && encoder->misc_ops->reset != NULL)
+				err |= encoder->misc_ops->reset(encoder);
+			up(&mgr->lock);
+			if (encoder->misc_ops != NULL
+			    && encoder->misc_ops->enable != NULL)
+				encoder->misc_ops->enable(1, encoder);
+
+		} else if (strcmp(mgr->current_output, enc_def->output) == 0) {
+			/* no change in output or mode */
+			mgr->encoder[mgr->num_encoders++] = encoder;
+
+		}
+	}
+
+	return err;
+}
+
+EXPORT_SYMBOL(vid_enc_register_encoder);
+
+/**
+ * vid_enc_unregister_encoder
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int vid_enc_unregister_encoder(struct vid_encoder_device *encoder)
+{
+	int i, j = 0, err = -EINVAL, ch_id;
+	struct vid_enc_device_mgr *mgr = 0;
+
+	if (ISNULL(encoder))
+		return err;
+
+	ch_id = encoder->channel_id;
+
+	if ((ch_id > DAVINCI_ENC_MAX_CHANNELS) || (ch_id < 0))
+		return err;
+
+	mgr = &enc_dev[ch_id];
+
+	for (i = 0; i < mgr->num_encoders; i++) {
+		if (encoder == mgr->encoder[i]) {
+
+			mgr->encoder[i] = NULL;
+			for (j = i; j < mgr->num_encoders - 1; j++)
+				mgr->encoder[j] = mgr->encoder[j + 1];
+			mgr->num_encoders--;
+			err = 0;
+			break;
+		}
+	}
+	return err;
+
+}
+
+EXPORT_SYMBOL(vid_enc_unregister_encoder);
+
+/**
+ * davinci_enc_enable_vbi
+ * @flag: flag which tells whether to enable or disable raw vbi
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * This function is used to enable/disable RAW VBI sending in
+ * the encoder.
+ */
+int davinci_enc_enable_vbi(int channel, int flag)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->enable_vbi)
+		return -EINVAL;
+
+	return cur_enc->enable_vbi(flag, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_enable_vbi);
+
+/**
+ * davinci_enc_enable_hbi
+ * @flag: flag which tells whether to enable or disable raw hbi
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * This function is used to enable/disable RAW HBI sending in
+ * the encoder.
+ */
+int davinci_enc_enable_hbi(int channel, int flag)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->enable_hbi)
+		return -EINVAL;
+
+	return cur_enc->enable_hbi(flag, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_enable_hbi);
+
+/**
+ * davinci_enc_enable_sliced_vbi
+ * @channel: channel number.
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Following funcion is used to enable support for
+ * sending set of sliced vbi services. Caller calls
+ * this function with pointer to the structure vid_enc_sliced_vbi_service
+ */
+int davinci_enc_enable_sliced_vbi(int channel,
+				  struct vid_enc_sliced_vbi_service *services)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->set_vbi_services)
+		return -EINVAL;
+
+	return cur_enc->set_vbi_services(services, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_enable_sliced_vbi);
+
+/**
+ * davinci_enc_write_sliced_vbi_data
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int davinci_enc_write_sliced_vbi_data(int channel,
+				      struct vid_enc_sliced_vbi_data *data)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->write_vbi_data)
+		return -EINVAL;
+
+	return cur_enc->write_vbi_data(data, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_write_sliced_vbi_data);
+
+int davinci_enc_get_sliced_cap(int channel,
+			       struct vid_enc_sliced_vbi_service *service)
+{
+	struct vid_encoder_device *cur_enc = NULL;
+
+	cur_enc = davinci_get_cur_encoder(channel);
+
+	if (NULL == cur_enc || NULL == cur_enc->get_sliced_cap)
+		return -EINVAL;
+
+	return cur_enc->get_sliced_cap(service, cur_enc);
+}
+
+EXPORT_SYMBOL(davinci_enc_get_sliced_cap);
+
+subsys_initcall(davinci_enc_mngr_init);
+module_exit(davinci_enc_mngr_cleanup);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/media/video/davinci/davinci_osd.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/davinci_osd.c
@@ -0,0 +1,2084 @@
+/*
+ * TI DaVinci On-Screen Display Manager
+ *
+ * Andy Lowe (alowe@mvista.com), MontaVista Software
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <video/davinci_vpbe.h>
+#include <video/davinci_osd.h>
+#include <asm/arch/io.h>
+#include <asm/arch/cpu.h>
+
+/* parameters that apply on a per-window (OSD or video) basis */
+struct davinci_window_state {
+	int is_allocated;
+	int is_enabled;
+	unsigned long fb_base_phys;
+	enum davinci_zoom_factor h_zoom;
+	enum davinci_zoom_factor v_zoom;
+	struct davinci_layer_config lconfig;
+};
+
+/* parameters that apply on a per-OSD-window basis */
+struct davinci_osdwin_state {
+	enum davinci_clut clut;
+	enum davinci_blending_factor blend;
+	int colorkey_blending;
+	unsigned colorkey;
+	int rec601_attenuation;
+	unsigned char palette_map[16];	/* index is pixel value */
+};
+
+/* hardware rectangular cursor parameters */
+struct davinci_cursor_state {
+	int is_enabled;
+	struct davinci_cursor_config config;
+};
+
+struct davinci_osd_state {
+	spinlock_t lock;
+	unsigned long osdregs;	/* physical base address of OSD registers */
+	unsigned long vencregs;	/* physical base address of VENC registers */
+	int irq;
+	struct davinci_disp_callback *callback;
+	int pingpong;		/* 1-->the isr will toggle the VID0 ping-pong buffer */
+	int interpolation_filter;
+	int field_inversion;
+	enum davinci_h_exp_ratio osd_h_exp;
+	enum davinci_v_exp_ratio osd_v_exp;
+	enum davinci_h_exp_ratio vid_h_exp;
+	enum davinci_v_exp_ratio vid_v_exp;
+	enum davinci_clut backg_clut;
+	unsigned backg_clut_index;
+	enum davinci_rom_clut rom_clut;
+	int is_blinking;	/* attribute window blinking enabled */
+	enum davinci_blink_interval blink;
+	enum davinci_pix_format yc_pixfmt;	/* YCbCrI or YCrCbI */
+	unsigned char clut_ram[256][3];	/* columns are Y, Cb, Cr */
+	struct davinci_cursor_state cursor;
+	struct davinci_window_state win[4];	/* OSD0, VID0, OSD1, VID1 */
+	struct davinci_osdwin_state osdwin[2];	/* OSD0, OSD1 */
+};
+
+static struct davinci_osd_state osd_state;
+static struct davinci_osd_state *osd = &osd_state;
+
+/* register access routines */
+static __inline__ u32 osd_read(u32 offset)
+{
+	return davinci_readl(osd->osdregs + offset);
+}
+
+static __inline__ u32 osd_write(u32 val, u32 offset)
+{
+	davinci_writel(val, osd->osdregs + offset);
+	return val;
+}
+
+static __inline__ u32 osd_set(u32 mask, u32 offset)
+{
+	u32 addr = osd->osdregs + offset;
+	u32 val = davinci_readl(addr) | mask;
+
+	davinci_writel(val, addr);
+	return val;
+}
+
+static __inline__ u32 osd_clear(u32 mask, u32 offset)
+{
+	u32 addr = osd->osdregs + offset;
+	u32 val = davinci_readl(addr) & ~mask;
+
+	davinci_writel(val, addr);
+	return val;
+}
+
+static __inline__ u32 osd_merge(u32 mask, u32 val, u32 offset)
+{
+	u32 addr = osd->osdregs + offset;
+	u32 new_val = (davinci_readl(addr) & ~mask) | (val & mask);
+
+	davinci_writel(new_val, addr);
+	return new_val;
+}
+
+/* define some macros for layer and pixfmt classification */
+#define is_osd_win(layer) (((layer) == WIN_OSD0) || ((layer) == WIN_OSD1))
+#define is_vid_win(layer) (((layer) == WIN_VID0) || ((layer) == WIN_VID1))
+#define is_rgb_pixfmt(pixfmt) \
+	(((pixfmt) == PIXFMT_RGB565) || ((pixfmt) == PIXFMT_RGB888))
+#define is_yc_pixfmt(pixfmt) \
+	(((pixfmt) == PIXFMT_YCbCrI) || ((pixfmt) == PIXFMT_YCrCbI))
+
+#define MAX_WIN_SIZE OSD_VIDWIN0XP_V0X
+#define MAX_LINE_LENGTH (OSD_VIDWIN0OFST_V0LO << 5)
+
+/* interrupt service routine */
+static irqreturn_t davinci_disp_isr(int irq, void *arg, struct pt_regs *regs)
+{
+	unsigned event = 0;
+	struct davinci_disp_callback *callback = osd->callback;
+	static unsigned last_event;
+
+	if (cpu_is_davinci_dm355()) {
+		if (!
+		    (davinci_readl(DM355_VPSSBL_REG_BASE + VPSSBL_INTSTAT) &
+		     VPSSBL_INTSTAT_VENCINT)) {
+			return IRQ_NONE;
+		}
+		davinci_writel(VPSSBL_INTSTAT_VENCINT,
+			       DM355_VPSSBL_REG_BASE + VPSSBL_INTSTAT);
+	}
+
+	if ((davinci_readl(osd->vencregs + VENC_VSTAT) & VENC_VSTAT_FIDST) ==
+	    VENC_VSTAT_FIDST)
+		event |= DAVINCI_DISP_SECOND_FIELD;
+	else
+		event |= DAVINCI_DISP_FIRST_FIELD;
+
+	if (event == (last_event & ~DAVINCI_DISP_END_OF_FRAME)) {
+		/*
+		 * If the display is non-interlaced, then we need to flag the
+		 * end-of-frame event at every interrupt regardless of the
+		 * value of the FIDST bit.  We can conclude that the display is
+		 * non-interlaced if the value of the FIDST bit is unchanged
+		 * from the previous interrupt.
+		 */
+		event |= DAVINCI_DISP_END_OF_FRAME;
+	} else if (event == DAVINCI_DISP_SECOND_FIELD) {
+		/* end-of-frame for interlaced display */
+		event |= DAVINCI_DISP_END_OF_FRAME;
+	}
+	last_event = event;
+
+	if (osd->pingpong) {
+		/*
+		 * Toggle the ping-pong buffers for VID0.  This is part of the
+		 * workaround for field signal inversion Advisory 1.3.8 for
+		 * the DM6446.
+		 */
+		if (event & DAVINCI_DISP_SECOND_FIELD)
+			osd_set(OSD_MISCCTL_PPSW, OSD_MISCCTL);
+		else
+			osd_clear(OSD_MISCCTL_PPSW, OSD_MISCCTL);
+	}
+
+	while (callback) {
+		if (callback->mask & event)
+			callback->handler(event, callback->arg);
+		callback = callback->next;
+	}
+
+	return IRQ_HANDLED;
+}
+
+int davinci_disp_unregister_callback(struct davinci_disp_callback *callback)
+{
+	unsigned long flags;
+	struct davinci_disp_callback *prev;
+	int err = 0;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	prev = osd->callback;
+	if (!prev)
+		err = -1;
+	else if (prev == callback)
+		osd->callback = callback->next;
+	else {
+		while (prev->next && (prev->next != callback))
+			prev = prev->next;
+		if (!prev->next)
+			err = -1;
+		else
+			prev->next = callback->next;
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return err;
+}
+
+int davinci_disp_register_callback(struct davinci_disp_callback *callback)
+{
+	unsigned long flags;
+	struct davinci_disp_callback *next;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	next = osd->callback;
+	osd->callback = callback;
+	callback->next = next;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return 0;
+}
+
+/*
+ * This routine implements a workaround for the field signal inversion silicon
+ * erratum described in Advisory 1.3.8 for the DM6446.  The fb_base_phys and
+ * lconfig parameters apply to the vid0 window.  This routine should be called
+ * whenever the vid0 layer configuration or start address is modified, or when
+ * the OSD field inversion setting is modified.
+ * Returns: 1 if the ping-pong buffers need to be toggled in the vsync isr, or
+ *          0 otherwise
+ */
+static int _davinci_disp_dm6446_vid0_pingpong(int field_inversion,
+					      unsigned long fb_base_phys,
+					      const struct davinci_layer_config
+					      *lconfig)
+{
+	if (!cpu_is_davinci_dm644x())
+		return 0;
+
+	if (!field_inversion || !lconfig->interlaced) {
+		osd_write(fb_base_phys & ~0x1F, OSD_VIDWIN0ADR);
+		osd_write(fb_base_phys & ~0x1F, OSD_PPVWIN0ADR);
+		osd_merge(OSD_MISCCTL_PPSW | OSD_MISCCTL_PPRV, 0, OSD_MISCCTL);
+
+		return 0;
+	} else {
+		unsigned miscctl = OSD_MISCCTL_PPRV;
+
+		osd_write((fb_base_phys & ~0x1F) - lconfig->line_length,
+			  OSD_VIDWIN0ADR);
+		osd_write((fb_base_phys & ~0x1F) + lconfig->line_length,
+			  OSD_PPVWIN0ADR);
+		if ((davinci_readl(osd->vencregs + VENC_VSTAT) &
+		     VENC_VSTAT_FIDST) == VENC_VSTAT_FIDST) {
+			miscctl |= OSD_MISCCTL_PPSW;
+		}
+		osd_merge(OSD_MISCCTL_PPSW | OSD_MISCCTL_PPRV, miscctl,
+			  OSD_MISCCTL);
+
+		return 1;
+	}
+}
+
+int davinci_disp_get_field_inversion(void)
+{
+	return osd->field_inversion;
+}
+
+static void _davinci_disp_set_field_inversion(int enable)
+{
+	unsigned fsinv = 0;
+
+	if (enable)
+		fsinv = OSD_MODE_FSINV;
+
+	osd_merge(OSD_MODE_FSINV, fsinv, OSD_MODE);
+}
+
+void davinci_disp_set_field_inversion(int enable)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->field_inversion = (enable != 0);
+	_davinci_disp_set_field_inversion(enable);
+
+	osd->pingpong =
+	    _davinci_disp_dm6446_vid0_pingpong(osd->field_inversion,
+					       osd->win[WIN_VID0].fb_base_phys,
+					       &osd->win[WIN_VID0].lconfig);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+void davinci_disp_get_background(enum davinci_clut *clut,
+				 unsigned char *clut_index)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*clut = osd->backg_clut;
+	*clut_index = osd->backg_clut_index;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_background(enum davinci_clut clut,
+					 unsigned char clut_index)
+{
+	u32 mode = 0;
+
+	if (clut == RAM_CLUT)
+		mode |= OSD_MODE_BCLUT;
+	mode |= clut_index;
+	osd_merge(OSD_MODE_BCLUT | OSD_MODE_CABG, mode, OSD_MODE);
+}
+
+void davinci_disp_set_background(enum davinci_clut clut,
+				 unsigned char clut_index)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->backg_clut = clut;
+	osd->backg_clut_index = clut_index;
+	_davinci_disp_set_background(clut, clut_index);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+int davinci_disp_get_interpolation_filter(void)
+{
+	return osd->interpolation_filter;
+}
+
+static void _davinci_disp_set_interpolation_filter(int filter)
+{
+	if (cpu_is_davinci_dm355())
+		osd_clear(OSD_EXTMODE_EXPMDSEL, OSD_EXTMODE);
+	osd_merge(OSD_MODE_EF, filter ? OSD_MODE_EF : 0, OSD_MODE);
+}
+
+void davinci_disp_set_interpolation_filter(int filter)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->interpolation_filter = (filter != 0);
+	_davinci_disp_set_interpolation_filter(filter);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+void davinci_disp_get_cursor_config(struct davinci_cursor_config *cursor)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*cursor = osd->cursor.config;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_cursor_config(const struct davinci_cursor_config
+					    *cursor)
+{
+	unsigned rectcur = 0;
+
+	osd_write(cursor->xsize, OSD_CURXL);
+	osd_write(cursor->xpos, OSD_CURXP);
+
+	if (cursor->interlaced) {
+		osd_write(cursor->ypos >> 1, OSD_CURYP);
+		if (cpu_is_davinci_dm644x()) {
+			/* Must add 1 to ysize due to device erratum. */
+			osd_write((cursor->ysize >> 1) + 1, OSD_CURYL);
+		} else
+			osd_write(cursor->ysize >> 1, OSD_CURYL);
+	} else {
+		osd_write(cursor->ypos, OSD_CURYP);
+		if (cpu_is_davinci_dm644x()) {
+			/* Must add 1 to ysize due to device erratum. */
+			osd_write(cursor->ysize + 1, OSD_CURYL);
+		} else
+			osd_write(cursor->ysize, OSD_CURYL);
+	}
+
+	if (cursor->clut == RAM_CLUT)
+		rectcur |= OSD_RECTCUR_CLUTSR;
+	rectcur |= (cursor->clut_index << OSD_RECTCUR_RCAD_SHIFT);
+	rectcur |= (cursor->h_width << OSD_RECTCUR_RCHW_SHIFT);
+	rectcur |= (cursor->v_width << OSD_RECTCUR_RCVW_SHIFT);
+	osd_merge(OSD_RECTCUR_RCAD | OSD_RECTCUR_CLUTSR | OSD_RECTCUR_RCHW |
+		  OSD_RECTCUR_RCVW, rectcur, OSD_RECTCUR);
+}
+
+void davinci_disp_set_cursor_config(struct davinci_cursor_config *cursor)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	cursor->xsize = min(cursor->xsize, (unsigned)OSD_CURXL_RCSW);
+	cursor->ysize = min(cursor->ysize, (unsigned)OSD_CURYL_RCSH);
+	cursor->xpos = min(cursor->xpos, (unsigned)OSD_CURXP_RCSX);
+	cursor->ypos = min(cursor->ypos, (unsigned)OSD_CURYP_RCSY);
+	cursor->interlaced = (cursor->interlaced != 0);
+	if (cursor->interlaced) {
+		cursor->ysize &= ~1;
+		cursor->ypos &= ~1;
+	}
+	cursor->h_width &= (OSD_RECTCUR_RCHW >> OSD_RECTCUR_RCHW_SHIFT);
+	cursor->v_width &= (OSD_RECTCUR_RCVW >> OSD_RECTCUR_RCVW_SHIFT);
+	cursor->clut = (cursor->clut == RAM_CLUT) ? RAM_CLUT : ROM_CLUT;
+
+	osd->cursor.config = *cursor;
+	_davinci_disp_set_cursor_config(cursor);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+int davinci_disp_cursor_is_enabled(void)
+{
+	return osd->cursor.is_enabled;
+}
+
+static void _davinci_disp_cursor_disable(void)
+{
+	osd_clear(OSD_RECTCUR_RCACT, OSD_RECTCUR);
+}
+
+void davinci_disp_cursor_disable(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->cursor.is_enabled = 0;
+	_davinci_disp_cursor_disable();
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_cursor_enable(void)
+{
+	osd_set(OSD_RECTCUR_RCACT, OSD_RECTCUR);
+}
+
+void davinci_disp_cursor_enable(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->cursor.is_enabled = 1;
+	_davinci_disp_cursor_enable();
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+void davinci_disp_get_vid_expansion(enum davinci_h_exp_ratio *h_exp,
+				    enum davinci_v_exp_ratio *v_exp)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*h_exp = osd->vid_h_exp;
+	*v_exp = osd->vid_v_exp;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_vid_expansion(enum davinci_h_exp_ratio h_exp,
+					    enum davinci_v_exp_ratio v_exp)
+{
+	u32 mode = 0, extmode = 0;
+
+	switch (h_exp) {
+	case H_EXP_OFF:
+		break;
+	case H_EXP_9_OVER_8:
+		mode |= OSD_MODE_VHRSZ;
+		break;
+	case H_EXP_3_OVER_2:
+		extmode |= OSD_EXTMODE_VIDHRSZ15;
+		break;
+	}
+
+	switch (v_exp) {
+	case V_EXP_OFF:
+		break;
+	case V_EXP_6_OVER_5:
+		mode |= OSD_MODE_VVRSZ;
+		break;
+	}
+
+	if (cpu_is_davinci_dm355())
+		osd_merge(OSD_EXTMODE_VIDHRSZ15, extmode, OSD_EXTMODE);
+	osd_merge(OSD_MODE_VHRSZ | OSD_MODE_VVRSZ, mode, OSD_MODE);
+}
+
+int davinci_disp_set_vid_expansion(enum davinci_h_exp_ratio h_exp,
+				   enum davinci_v_exp_ratio v_exp)
+{
+	unsigned long flags;
+
+	if (h_exp == H_EXP_3_OVER_2 && cpu_is_davinci_dm644x())
+		return -1;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->vid_h_exp = h_exp;
+	osd->vid_v_exp = v_exp;
+	_davinci_disp_set_vid_expansion(h_exp, v_exp);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	return 0;
+}
+
+void davinci_disp_get_osd_expansion(enum davinci_h_exp_ratio *h_exp,
+				    enum davinci_v_exp_ratio *v_exp)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*h_exp = osd->osd_h_exp;
+	*v_exp = osd->osd_v_exp;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_osd_expansion(enum davinci_h_exp_ratio h_exp,
+					    enum davinci_v_exp_ratio v_exp)
+{
+	u32 mode = 0, extmode = 0;
+
+	switch (h_exp) {
+	case H_EXP_OFF:
+		break;
+	case H_EXP_9_OVER_8:
+		mode |= OSD_MODE_OHRSZ;
+		break;
+	case H_EXP_3_OVER_2:
+		extmode |= OSD_EXTMODE_OSDHRSZ15;
+		break;
+	}
+
+	switch (v_exp) {
+	case V_EXP_OFF:
+		break;
+	case V_EXP_6_OVER_5:
+		mode |= OSD_MODE_OVRSZ;
+		break;
+	}
+
+	if (cpu_is_davinci_dm355())
+		osd_merge(OSD_EXTMODE_OSDHRSZ15, extmode, OSD_EXTMODE);
+	osd_merge(OSD_MODE_OHRSZ | OSD_MODE_OVRSZ, mode, OSD_MODE);
+}
+
+int davinci_disp_set_osd_expansion(enum davinci_h_exp_ratio h_exp,
+				   enum davinci_v_exp_ratio v_exp)
+{
+	unsigned long flags;
+
+	if (h_exp == H_EXP_3_OVER_2 && cpu_is_davinci_dm644x())
+		return -1;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->osd_h_exp = h_exp;
+	osd->osd_v_exp = v_exp;
+	_davinci_disp_set_osd_expansion(h_exp, v_exp);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	return 0;
+}
+
+void davinci_disp_get_blink_attribute(int *enable,
+				      enum davinci_blink_interval *blink)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*enable = osd->is_blinking;
+	*blink = osd->blink;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_blink_attribute(int enable,
+					      enum davinci_blink_interval blink)
+{
+	u32 osdatrmd = 0;
+
+	if (enable) {
+		osdatrmd |= OSD_OSDATRMD_BLNK;
+		osdatrmd |= blink << OSD_OSDATRMD_BLNKINT_SHIFT;
+	}
+	/* caller must ensure that OSD1 is configured in attribute mode */
+	osd_merge(OSD_OSDATRMD_BLNKINT | OSD_OSDATRMD_BLNK, osdatrmd,
+		  OSD_OSDATRMD);
+}
+
+void davinci_disp_set_blink_attribute(int enable,
+				      enum davinci_blink_interval blink)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->is_blinking = (enable != 0);
+	osd->blink = blink;
+	if (osd->win[WIN_OSD1].lconfig.pixfmt == PIXFMT_OSD_ATTR)
+		_davinci_disp_set_blink_attribute(enable, blink);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+enum davinci_rom_clut davinci_disp_get_rom_clut(void)
+{
+	return osd->rom_clut;
+}
+
+static void _davinci_disp_set_rom_clut(enum davinci_rom_clut rom_clut)
+{
+	if (rom_clut == ROM_CLUT0)
+		osd_clear(OSD_MISCCTL_RSEL, OSD_MISCCTL);
+	else
+		osd_set(OSD_MISCCTL_RSEL, OSD_MISCCTL);
+}
+
+void davinci_disp_set_rom_clut(enum davinci_rom_clut rom_clut)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->rom_clut = rom_clut;
+	_davinci_disp_set_rom_clut(rom_clut);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_clut_ycbcr(unsigned char clut_index,
+					 unsigned char y, unsigned char cb,
+					 unsigned char cr)
+{
+	/* wait until any previous writes to the CLUT RAM have completed */
+	while (osd_read(OSD_MISCCTL) & OSD_MISCCTL_CPBSY)
+		cpu_relax();
+
+	osd_write((y << OSD_CLUTRAMYCB_Y_SHIFT) | cb, OSD_CLUTRAMYCB);
+	osd_write((cr << OSD_CLUTRAMCR_CR_SHIFT) | clut_index, OSD_CLUTRAMCR);
+}
+
+void davinci_disp_set_clut_ycbcr(unsigned char clut_index, unsigned char y,
+				 unsigned char cb, unsigned char cr)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->clut_ram[clut_index][0] = y;
+	osd->clut_ram[clut_index][1] = cb;
+	osd->clut_ram[clut_index][2] = cr;
+	_davinci_disp_set_clut_ycbcr(clut_index, y, cb, cr);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_rgb_to_ycbcr(const unsigned char rgb[3],
+				       unsigned char ycbcr[3])
+{
+	int y, cb, cr;
+	int r = rgb[0];
+	int g = rgb[1];
+	int b = rgb[2];
+	/*
+	 * This conversion matrix corresponds to the conversion matrix used
+	 * by the OSD to convert RGB values to YCbCr values.  All coefficients
+	 * have been scaled by a factor of 2^22.
+	 */
+	static const int rgb_to_ycbcr[3][3] = {
+		{1250330, 2453618, 490352},
+		{-726093, -1424868, 2150957},
+		{2099836, -1750086, -349759}
+	};
+
+	y = rgb_to_ycbcr[0][0] * r + rgb_to_ycbcr[0][1] * g +
+	    rgb_to_ycbcr[0][2] * b;
+	cb = rgb_to_ycbcr[1][0] * r + rgb_to_ycbcr[1][1] * g +
+	    rgb_to_ycbcr[1][2] * b;
+	cr = rgb_to_ycbcr[2][0] * r + rgb_to_ycbcr[2][1] * g +
+	    rgb_to_ycbcr[2][2] * b;
+
+	/* round and scale */
+	y = ((y + (1 << 21)) >> 22);
+	cb = ((cb + (1 << 21)) >> 22) + 128;
+	cr = ((cr + (1 << 21)) >> 22) + 128;
+
+	/* clip */
+	y = (y < 0) ? 0 : y;
+	y = (y > 255) ? 255 : y;
+	cb = (cb < 0) ? 0 : cb;
+	cb = (cb > 255) ? 255 : cb;
+	cr = (cr < 0) ? 0 : cr;
+	cr = (cr > 255) ? 255 : cr;
+
+	ycbcr[0] = y;
+	ycbcr[1] = cb;
+	ycbcr[2] = cr;
+}
+
+void davinci_disp_set_clut_rgb(unsigned char clut_index, unsigned char r,
+			       unsigned char g, unsigned char b)
+{
+	unsigned char rgb[3], ycbcr[3];
+	unsigned long flags;
+
+	rgb[0] = r;
+	rgb[1] = g;
+	rgb[2] = b;
+	_davinci_disp_rgb_to_ycbcr(rgb, ycbcr);
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osd->clut_ram[clut_index][0] = ycbcr[0];
+	osd->clut_ram[clut_index][1] = ycbcr[1];
+	osd->clut_ram[clut_index][2] = ycbcr[2];
+	_davinci_disp_set_clut_ycbcr(clut_index, ycbcr[0], ycbcr[1], ycbcr[2]);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+unsigned char davinci_disp_get_palette_map(enum davinci_osd_layer osdwin,
+					   unsigned char pixel_value)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned char clut_index;
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	switch (win->lconfig.pixfmt) {
+	case PIXFMT_1BPP:
+		clut_index = osdwin_state->palette_map[pixel_value & 0x1];
+		break;
+	case PIXFMT_2BPP:
+		clut_index = osdwin_state->palette_map[pixel_value & 0x3];
+		break;
+	case PIXFMT_4BPP:
+		clut_index = osdwin_state->palette_map[pixel_value & 0xf];
+		break;
+	default:
+		clut_index = 0;
+		break;
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return clut_index;
+}
+
+static void _davinci_disp_set_palette_map(enum davinci_osd_layer osdwin,
+					  unsigned char pixel_value,
+					  unsigned char clut_index,
+					  enum davinci_pix_format pixfmt)
+{
+	int bmp_reg, bmp_offset, bmp_mask, bmp_shift;
+	static const int map_1bpp[] = { 0, 15 };
+	static const int map_2bpp[] = { 0, 5, 10, 15 };
+
+	switch (pixfmt) {
+	case PIXFMT_1BPP:
+		bmp_reg = map_1bpp[pixel_value & 0x1];
+		break;
+	case PIXFMT_2BPP:
+		bmp_reg = map_2bpp[pixel_value & 0x3];
+		break;
+	case PIXFMT_4BPP:
+		bmp_reg = pixel_value & 0xf;
+		break;
+	default:
+		return;
+	}
+
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		bmp_offset = OSD_W0BMP01 + (bmp_reg >> 1) * sizeof(u32);
+		break;
+	case OSDWIN_OSD1:
+		bmp_offset = OSD_W1BMP01 + (bmp_reg >> 1) * sizeof(u32);
+		break;
+	default:
+		return;
+	}
+
+	if (bmp_reg & 1) {
+		bmp_shift = 8;
+		bmp_mask = 0xff << 8;
+	} else {
+		bmp_shift = 0;
+		bmp_mask = 0xff;
+	}
+
+	osd_merge(bmp_mask, clut_index << bmp_shift, bmp_offset);
+}
+
+void davinci_disp_set_palette_map(enum davinci_osd_layer osdwin,
+				  unsigned char pixel_value,
+				  unsigned char clut_index)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	switch (win->lconfig.pixfmt) {
+	case PIXFMT_1BPP:
+		osdwin_state->palette_map[pixel_value & 0x1] = clut_index;
+		break;
+	case PIXFMT_2BPP:
+		osdwin_state->palette_map[pixel_value & 0x3] = clut_index;
+		break;
+	case PIXFMT_4BPP:
+		osdwin_state->palette_map[pixel_value & 0xf] = clut_index;
+		break;
+	default:
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return;
+	}
+
+	_davinci_disp_set_palette_map(osdwin, pixel_value, clut_index,
+				      win->lconfig.pixfmt);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+int davinci_disp_get_rec601_attenuation(enum davinci_osd_layer osdwin)
+{
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+
+	return osdwin_state->rec601_attenuation;
+}
+
+static void _davinci_disp_set_rec601_attenuation(enum davinci_osd_layer osdwin,
+						 int enable)
+{
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		if (cpu_is_davinci_dm644x()) {
+			osd_merge(OSD_OSDWIN0MD_ATN0E,
+				  enable ? OSD_OSDWIN0MD_ATN0E : 0,
+				  OSD_OSDWIN0MD);
+		} else if (cpu_is_davinci_dm355()) {
+			osd_merge(OSD_EXTMODE_ATNOSD0EN,
+				  enable ? OSD_EXTMODE_ATNOSD0EN : 0,
+				  OSD_EXTMODE);
+		}
+		break;
+	case OSDWIN_OSD1:
+		if (cpu_is_davinci_dm644x()) {
+			osd_merge(OSD_OSDWIN1MD_ATN1E,
+				  enable ? OSD_OSDWIN1MD_ATN1E : 0,
+				  OSD_OSDWIN1MD);
+		} else if (cpu_is_davinci_dm355()) {
+			osd_merge(OSD_EXTMODE_ATNOSD1EN,
+				  enable ? OSD_EXTMODE_ATNOSD1EN : 0,
+				  OSD_EXTMODE);
+		}
+		break;
+	}
+}
+
+void davinci_disp_set_rec601_attenuation(enum davinci_osd_layer osdwin,
+					 int enable)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->rec601_attenuation = (enable != 0);
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_set_rec601_attenuation(osdwin, enable);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+enum davinci_blending_factor davinci_disp_get_blending_factor(enum
+							      davinci_osd_layer
+							      osdwin)
+{
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+
+	return osdwin_state->blend;
+}
+
+static void _davinci_disp_set_blending_factor(enum davinci_osd_layer osdwin,
+					      enum davinci_blending_factor
+					      blend)
+{
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		osd_merge(OSD_OSDWIN0MD_BLND0,
+			  blend << OSD_OSDWIN0MD_BLND0_SHIFT, OSD_OSDWIN0MD);
+		break;
+	case OSDWIN_OSD1:
+		osd_merge(OSD_OSDWIN1MD_BLND1,
+			  blend << OSD_OSDWIN1MD_BLND1_SHIFT, OSD_OSDWIN1MD);
+		break;
+	}
+}
+
+void davinci_disp_set_blending_factor(enum davinci_osd_layer osdwin,
+				      enum davinci_blending_factor blend)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->blend = blend;
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_set_blending_factor(osdwin, blend);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_disable_color_key(enum davinci_osd_layer osdwin)
+{
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		osd_clear(OSD_OSDWIN0MD_TE0, OSD_OSDWIN0MD);
+		break;
+	case OSDWIN_OSD1:
+		osd_clear(OSD_OSDWIN1MD_TE1, OSD_OSDWIN1MD);
+		break;
+	}
+}
+
+void davinci_disp_disable_color_key(enum davinci_osd_layer osdwin)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->colorkey_blending = 0;
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_disable_color_key(osdwin);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_enable_color_key(enum davinci_osd_layer osdwin,
+					   unsigned colorkey,
+					   enum davinci_pix_format pixfmt)
+{
+	switch (pixfmt) {
+	case PIXFMT_1BPP:
+	case PIXFMT_2BPP:
+	case PIXFMT_4BPP:
+	case PIXFMT_8BPP:
+		if (cpu_is_davinci_dm355()) {
+			switch (osdwin) {
+			case OSDWIN_OSD0:
+				osd_merge(OSD_TRANSPBMPIDX_BMP0,
+					  colorkey <<
+					  OSD_TRANSPBMPIDX_BMP0_SHIFT,
+					  OSD_TRANSPBMPIDX);
+				break;
+			case OSDWIN_OSD1:
+				osd_merge(OSD_TRANSPBMPIDX_BMP1,
+					  colorkey <<
+					  OSD_TRANSPBMPIDX_BMP1_SHIFT,
+					  OSD_TRANSPBMPIDX);
+				break;
+			}
+		}
+		break;
+	case PIXFMT_RGB565:
+		if (cpu_is_davinci_dm644x()) {
+			osd_write(colorkey & OSD_TRANSPVAL_RGBTRANS,
+				  OSD_TRANSPVAL);
+		} else if (cpu_is_davinci_dm355()) {
+			osd_write(colorkey & OSD_TRANSPVALL_RGBL,
+				  OSD_TRANSPVALL);
+		}
+		break;
+	case PIXFMT_YCbCrI:
+	case PIXFMT_YCrCbI:
+		if (cpu_is_davinci_dm355())
+			osd_merge(OSD_TRANSPVALU_Y, colorkey, OSD_TRANSPVALU);
+		break;
+	case PIXFMT_RGB888:
+		if (cpu_is_davinci_dm355()) {
+			osd_write(colorkey & OSD_TRANSPVALL_RGBL,
+				  OSD_TRANSPVALL);
+			osd_merge(OSD_TRANSPVALU_RGBU, colorkey >> 16,
+				  OSD_TRANSPVALU);
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		osd_set(OSD_OSDWIN0MD_TE0, OSD_OSDWIN0MD);
+		break;
+	case OSDWIN_OSD1:
+		osd_set(OSD_OSDWIN1MD_TE1, OSD_OSDWIN1MD);
+		break;
+	}
+}
+
+void davinci_disp_enable_color_key(enum davinci_osd_layer osdwin,
+				   unsigned colorkey)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->colorkey_blending = 1;
+	osdwin_state->colorkey = colorkey;
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR) {
+		_davinci_disp_enable_color_key(osdwin, colorkey,
+					       win->lconfig.pixfmt);
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+enum davinci_clut davinci_disp_get_osd_clut(enum davinci_osd_layer osdwin)
+{
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+
+	return osdwin_state->clut;
+}
+
+static void _davinci_disp_set_osd_clut(enum davinci_osd_layer osdwin,
+				       enum davinci_clut clut)
+{
+	u32 winmd = 0;
+
+	switch (osdwin) {
+	case OSDWIN_OSD0:
+		if (clut == RAM_CLUT)
+			winmd |= OSD_OSDWIN0MD_CLUTS0;
+		osd_merge(OSD_OSDWIN0MD_CLUTS0, winmd, OSD_OSDWIN0MD);
+		break;
+	case OSDWIN_OSD1:
+		if (clut == RAM_CLUT)
+			winmd |= OSD_OSDWIN1MD_CLUTS1;
+		osd_merge(OSD_OSDWIN1MD_CLUTS1, winmd, OSD_OSDWIN1MD);
+		break;
+	}
+}
+
+void davinci_disp_set_osd_clut(enum davinci_osd_layer osdwin,
+			       enum davinci_clut clut)
+{
+	enum davinci_disp_layer layer =
+	    (osdwin == OSDWIN_OSD0) ? WIN_OSD0 : WIN_OSD1;
+	struct davinci_window_state *win = &osd->win[layer];
+	struct davinci_osdwin_state *osdwin_state = &osd->osdwin[osdwin];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	osdwin_state->clut = clut;
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_set_osd_clut(osdwin, clut);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+void davinci_disp_get_zoom(enum davinci_disp_layer layer,
+			   enum davinci_zoom_factor *h_zoom,
+			   enum davinci_zoom_factor *v_zoom)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*h_zoom = win->h_zoom;
+	*v_zoom = win->v_zoom;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_set_zoom(enum davinci_disp_layer layer,
+				   enum davinci_zoom_factor h_zoom,
+				   enum davinci_zoom_factor v_zoom)
+{
+	u32 winmd = 0;
+
+	switch (layer) {
+	case WIN_OSD0:
+		winmd |= (h_zoom << OSD_OSDWIN0MD_OHZ0_SHIFT);
+		winmd |= (v_zoom << OSD_OSDWIN0MD_OVZ0_SHIFT);
+		osd_merge(OSD_OSDWIN0MD_OHZ0 | OSD_OSDWIN0MD_OVZ0, winmd,
+			  OSD_OSDWIN0MD);
+		break;
+	case WIN_VID0:
+		winmd |= (h_zoom << OSD_VIDWINMD_VHZ0_SHIFT);
+		winmd |= (v_zoom << OSD_VIDWINMD_VVZ0_SHIFT);
+		osd_merge(OSD_VIDWINMD_VHZ0 | OSD_VIDWINMD_VVZ0, winmd,
+			  OSD_VIDWINMD);
+		break;
+	case WIN_OSD1:
+		winmd |= (h_zoom << OSD_OSDWIN1MD_OHZ1_SHIFT);
+		winmd |= (v_zoom << OSD_OSDWIN1MD_OVZ1_SHIFT);
+		osd_merge(OSD_OSDWIN1MD_OHZ1 | OSD_OSDWIN1MD_OVZ1, winmd,
+			  OSD_OSDWIN1MD);
+		break;
+	case WIN_VID1:
+		winmd |= (h_zoom << OSD_VIDWINMD_VHZ1_SHIFT);
+		winmd |= (v_zoom << OSD_VIDWINMD_VVZ1_SHIFT);
+		osd_merge(OSD_VIDWINMD_VHZ1 | OSD_VIDWINMD_VVZ1, winmd,
+			  OSD_VIDWINMD);
+		break;
+	}
+}
+
+void davinci_disp_set_zoom(enum davinci_disp_layer layer,
+			   enum davinci_zoom_factor h_zoom,
+			   enum davinci_zoom_factor v_zoom)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	win->h_zoom = h_zoom;
+	win->v_zoom = v_zoom;
+	_davinci_disp_set_zoom(layer, h_zoom, v_zoom);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+int davinci_disp_layer_is_enabled(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	return win->is_enabled;
+}
+
+static void _davinci_disp_disable_layer(enum
+					davinci_disp_layer layer)
+{
+	switch (layer) {
+	case WIN_OSD0:
+		osd_clear(OSD_OSDWIN0MD_OACT0, OSD_OSDWIN0MD);
+		break;
+	case WIN_VID0:
+		osd_clear(OSD_VIDWINMD_ACT0, OSD_VIDWINMD);
+		break;
+	case WIN_OSD1:
+		/* disable attribute mode as well as disabling the window */
+		osd_clear(OSD_OSDWIN1MD_OASW | OSD_OSDWIN1MD_OACT1,
+			  OSD_OSDWIN1MD);
+		break;
+	case WIN_VID1:
+		osd_clear(OSD_VIDWINMD_ACT1, OSD_VIDWINMD);
+		break;
+	}
+}
+
+void davinci_disp_disable_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	if (!win->is_enabled) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return;
+	}
+	win->is_enabled = 0;
+
+	_davinci_disp_disable_layer(layer);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+static void _davinci_disp_enable_attribute_mode(void)
+{
+	/* enable attribute mode for OSD1 */
+	osd_set(OSD_OSDWIN1MD_OASW, OSD_OSDWIN1MD);
+}
+
+static void _davinci_disp_enable_layer(enum
+				       davinci_disp_layer layer)
+{
+	switch (layer) {
+	case WIN_OSD0:
+		osd_set(OSD_OSDWIN0MD_OACT0, OSD_OSDWIN0MD);
+		break;
+	case WIN_VID0:
+		osd_set(OSD_VIDWINMD_ACT0, OSD_VIDWINMD);
+		break;
+	case WIN_OSD1:
+		/* enable OSD1 and disable attribute mode */
+		osd_merge(OSD_OSDWIN1MD_OASW | OSD_OSDWIN1MD_OACT1,
+			  OSD_OSDWIN1MD_OACT1, OSD_OSDWIN1MD);
+		break;
+	case WIN_VID1:
+		osd_set(OSD_VIDWINMD_ACT1, OSD_VIDWINMD);
+		break;
+	}
+}
+
+int davinci_disp_enable_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	if (!win->is_allocated || !win->fb_base_phys
+	    || !win->lconfig.line_length || !win->lconfig.xsize
+	    || !win->lconfig.ysize) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return -1;
+	}
+
+	if (win->is_enabled) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return 0;
+	}
+	win->is_enabled = 1;
+
+	if (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)
+		_davinci_disp_enable_layer(layer);
+	else {
+		_davinci_disp_enable_attribute_mode();
+		_davinci_disp_set_blink_attribute(osd->is_blinking, osd->blink);
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	return 0;
+}
+
+static void _davinci_disp_start_layer(enum davinci_disp_layer layer,
+				      unsigned long fb_base_phys)
+{
+	if (cpu_is_davinci_dm644x()) {
+		switch (layer) {
+		case WIN_OSD0:
+			osd_write(fb_base_phys & ~0x1F, OSD_OSDWIN0ADR);
+			break;
+		case WIN_VID0:
+			osd_write(fb_base_phys & ~0x1F, OSD_VIDWIN0ADR);
+			break;
+		case WIN_OSD1:
+			osd_write(fb_base_phys & ~0x1F, OSD_OSDWIN1ADR);
+			break;
+		case WIN_VID1:
+			osd_write(fb_base_phys & ~0x1F, OSD_VIDWIN1ADR);
+			break;
+		}
+	} else if (cpu_is_davinci_dm355()) {
+		unsigned long fb_offset_32 =
+		    (fb_base_phys - DAVINCI_DDR_BASE) >> 5;
+
+		switch (layer) {
+		case WIN_OSD0:
+			osd_merge(OSD_OSDWINADH_O0AH,
+				  fb_offset_32 >> (16 -
+						   OSD_OSDWINADH_O0AH_SHIFT),
+				  OSD_OSDWINADH);
+			osd_write(fb_offset_32 & OSD_OSDWIN0ADL_O0AL,
+				  OSD_OSDWIN0ADL);
+			break;
+		case WIN_VID0:
+			osd_merge(OSD_VIDWINADH_V0AH,
+				  fb_offset_32 >> (16 -
+						   OSD_VIDWINADH_V0AH_SHIFT),
+				  OSD_VIDWINADH);
+			osd_write(fb_offset_32 & OSD_VIDWIN0ADL_V0AL,
+				  OSD_VIDWIN0ADL);
+			break;
+		case WIN_OSD1:
+			osd_merge(OSD_OSDWINADH_O1AH,
+				  fb_offset_32 >> (16 -
+						   OSD_OSDWINADH_O1AH_SHIFT),
+				  OSD_OSDWINADH);
+			osd_write(fb_offset_32 & OSD_OSDWIN1ADL_O1AL,
+				  OSD_OSDWIN1ADL);
+			break;
+		case WIN_VID1:
+			osd_merge(OSD_VIDWINADH_V1AH,
+				  fb_offset_32 >> (16 -
+						   OSD_VIDWINADH_V1AH_SHIFT),
+				  OSD_VIDWINADH);
+			osd_write(fb_offset_32 & OSD_VIDWIN1ADL_V1AL,
+				  OSD_VIDWIN1ADL);
+			break;
+		}
+	}
+}
+
+void davinci_disp_start_layer(enum davinci_disp_layer layer,
+			      unsigned long fb_base_phys)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	win->fb_base_phys = fb_base_phys & ~0x1F;
+	_davinci_disp_start_layer(layer, fb_base_phys);
+
+	if (layer == WIN_VID0) {
+		osd->pingpong =
+		    _davinci_disp_dm6446_vid0_pingpong(osd->field_inversion,
+						       win->fb_base_phys,
+						       &win->lconfig);
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+void davinci_disp_get_layer_config(enum davinci_disp_layer layer,
+				   struct davinci_layer_config *lconfig)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	*lconfig = win->lconfig;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+/*
+ * If the requested lconfig is completely rejected and the value of lconfig on
+ * exit is the current lconfig, then try_layer_config() returns 1.  Otherwise,
+ * try_layer_config() returns 0.  A return value of 0 does not necessarily mean
+ * that the value of lconfig on exit is identical to the value of lconfig on
+ * entry, but merely that it represents a change from the current lconfig.
+ */
+static int try_layer_config(enum davinci_disp_layer layer,
+			    struct davinci_layer_config *lconfig)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	int bad_config = 0;
+
+	/* verify that the pixel format is compatible with the layer */
+	switch (lconfig->pixfmt) {
+	case PIXFMT_1BPP:
+	case PIXFMT_2BPP:
+	case PIXFMT_4BPP:
+	case PIXFMT_8BPP:
+	case PIXFMT_RGB565:
+		bad_config = !is_osd_win(layer);
+		break;
+	case PIXFMT_YCbCrI:
+	case PIXFMT_YCrCbI:
+		if (cpu_is_davinci_dm644x())
+			bad_config = !is_vid_win(layer);
+		break;
+	case PIXFMT_RGB888:
+		if (cpu_is_davinci_dm644x())
+			bad_config = !is_vid_win(layer);
+		else if (cpu_is_davinci_dm355())
+			bad_config = !is_osd_win(layer);
+		break;
+	case PIXFMT_OSD_ATTR:
+		bad_config = (layer != WIN_OSD1);
+		break;
+	default:
+		bad_config = 1;
+		break;
+	}
+	if (bad_config) {
+		/*
+		 * The requested pixel format is incompatible with the layer, so
+		 * keep the current layer configuration.
+		 */
+		*lconfig = win->lconfig;
+		return bad_config;
+	}
+
+	/* only one OSD window at a time can use RGB or YC pixel formats */
+	if (is_osd_win(layer)
+	    && (is_rgb_pixfmt(lconfig->pixfmt)
+		|| is_yc_pixfmt(lconfig->pixfmt))) {
+		enum davinci_pix_format pixfmt;
+
+		if (layer == WIN_OSD0)
+			pixfmt = osd->win[WIN_OSD1].lconfig.pixfmt;
+		else
+			pixfmt = osd->win[WIN_OSD0].lconfig.pixfmt;
+
+		if (is_rgb_pixfmt(pixfmt) || is_yc_pixfmt(pixfmt)) {
+			/*
+			 * The other OSD window is already configured for an RGB
+			 * or YC pixel format, so keep the current layer
+			 * configuration.
+			 */
+			*lconfig = win->lconfig;
+			return 1;
+		}
+	}
+
+	/* DM6446: only one video window at a time can use RGB888 */
+	if (is_vid_win(layer) && lconfig->pixfmt == PIXFMT_RGB888) {
+		enum davinci_pix_format pixfmt;
+
+		if (layer == WIN_VID0)
+			pixfmt = osd->win[WIN_VID1].lconfig.pixfmt;
+		else
+			pixfmt = osd->win[WIN_VID0].lconfig.pixfmt;
+
+		if (pixfmt == PIXFMT_RGB888) {
+			/*
+			 * The other video window is already configured for
+			 * RGB888, so keep the current layer configuration.
+			 */
+			*lconfig = win->lconfig;
+			return 1;
+		}
+	}
+
+	/* window dimensions must be non-zero */
+	if (!lconfig->line_length || !lconfig->xsize || !lconfig->ysize) {
+		*lconfig = win->lconfig;
+		return 1;
+	}
+
+	/* round line_length up to a multiple of 32 */
+	lconfig->line_length = ((lconfig->line_length + 31) / 32) * 32;
+	lconfig->line_length =
+	    min(lconfig->line_length, (unsigned)MAX_LINE_LENGTH);
+	lconfig->xsize = min(lconfig->xsize, (unsigned)MAX_WIN_SIZE);
+	lconfig->ysize = min(lconfig->ysize, (unsigned)MAX_WIN_SIZE);
+	lconfig->xpos = min(lconfig->xpos, (unsigned)MAX_WIN_SIZE);
+	lconfig->ypos = min(lconfig->ypos, (unsigned)MAX_WIN_SIZE);
+	lconfig->interlaced = (lconfig->interlaced != 0);
+	if (lconfig->interlaced) {
+		/* ysize and ypos must be even for interlaced displays */
+		lconfig->ysize &= ~1;
+		lconfig->ypos &= ~1;
+	}
+
+	return 0;
+}
+
+int davinci_disp_try_layer_config(enum davinci_disp_layer layer,
+				  struct davinci_layer_config *lconfig)
+{
+	int reject_config;
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	reject_config = try_layer_config(layer, lconfig);
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return reject_config;
+}
+
+static void _davinci_disp_disable_vid_rgb888(void)
+{
+	/*
+	 * The DM6446 supports RGB888 pixel format in a single video window.
+	 * This routine disables RGB888 pixel format for both video windows.
+	 * The caller must ensure that neither video window is currently
+	 * configured for RGB888 pixel format.
+	 */
+	if (cpu_is_davinci_dm644x())
+		osd_clear(OSD_MISCCTL_RGBEN, OSD_MISCCTL);
+}
+
+static void _davinci_disp_enable_vid_rgb888(enum davinci_disp_layer layer)
+{
+	/*
+	 * The DM6446 supports RGB888 pixel format in a single video window.
+	 * This routine enables RGB888 pixel format for the specified video
+	 * window.  The caller must ensure that the other video window is not
+	 * currently configured for RGB888 pixel format, as this routine will
+	 * disable RGB888 pixel format for the other window.
+	 */
+	if (cpu_is_davinci_dm644x()) {
+		if (layer == WIN_VID0) {
+			osd_merge(OSD_MISCCTL_RGBEN | OSD_MISCCTL_RGBWIN,
+				  OSD_MISCCTL_RGBEN, OSD_MISCCTL);
+		} else if (layer == WIN_VID1) {
+			osd_merge(OSD_MISCCTL_RGBEN | OSD_MISCCTL_RGBWIN,
+				  OSD_MISCCTL_RGBEN | OSD_MISCCTL_RGBWIN,
+				  OSD_MISCCTL);
+		}
+	}
+}
+
+static void _davinci_disp_set_cbcr_order(enum davinci_pix_format pixfmt)
+{
+	/*
+	 * The caller must ensure that all windows using YC pixfmt use the same
+	 * Cb/Cr order.
+	 */
+	if (pixfmt == PIXFMT_YCbCrI)
+		osd_clear(OSD_MODE_CS, OSD_MODE);
+	else if (pixfmt == PIXFMT_YCrCbI)
+		osd_set(OSD_MODE_CS, OSD_MODE);
+}
+
+static void _davinci_disp_set_layer_config(enum davinci_disp_layer layer, const struct davinci_layer_config
+					   *lconfig)
+{
+	u32 winmd = 0, winmd_mask = 0, bmw = 0;
+
+	_davinci_disp_set_cbcr_order(lconfig->pixfmt);
+
+	switch (layer) {
+	case WIN_OSD0:
+		if (cpu_is_davinci_dm644x()) {
+			winmd_mask |= OSD_OSDWIN0MD_RGB0E;
+			if (lconfig->pixfmt == PIXFMT_RGB565)
+				winmd |= OSD_OSDWIN0MD_RGB0E;
+		} else if (cpu_is_davinci_dm355()) {
+			winmd_mask |= OSD_OSDWIN0MD_BMP0MD;
+			switch (lconfig->pixfmt) {
+			case PIXFMT_RGB565:
+				winmd |= (1 << OSD_OSDWIN0MD_BMP0MD_SHIFT);
+				break;
+			case PIXFMT_RGB888:
+				winmd |= (2 << OSD_OSDWIN0MD_BMP0MD_SHIFT);
+				break;
+			case PIXFMT_YCbCrI:
+			case PIXFMT_YCrCbI:
+				winmd |= (3 << OSD_OSDWIN0MD_BMP0MD_SHIFT);
+				break;
+			default:
+				break;
+			}
+		}
+
+		winmd_mask |= OSD_OSDWIN0MD_BMW0 | OSD_OSDWIN0MD_OFF0;
+
+		switch (lconfig->pixfmt) {
+		case PIXFMT_1BPP:
+			bmw = 0;
+			break;
+		case PIXFMT_2BPP:
+			bmw = 1;
+			break;
+		case PIXFMT_4BPP:
+			bmw = 2;
+			break;
+		case PIXFMT_8BPP:
+			bmw = 3;
+			break;
+		default:
+			break;
+		}
+		winmd |= (bmw << OSD_OSDWIN0MD_BMW0_SHIFT);
+
+		if (lconfig->interlaced)
+			winmd |= OSD_OSDWIN0MD_OFF0;
+
+		osd_merge(winmd_mask, winmd, OSD_OSDWIN0MD);
+		osd_write(lconfig->line_length >> 5, OSD_OSDWIN0OFST);
+		osd_write(lconfig->xpos, OSD_OSDWIN0XP);
+		osd_write(lconfig->xsize, OSD_OSDWIN0XL);
+		if (lconfig->interlaced) {
+			osd_write(lconfig->ypos >> 1, OSD_OSDWIN0YP);
+			osd_write(lconfig->ysize >> 1, OSD_OSDWIN0YL);
+		} else {
+			osd_write(lconfig->ypos, OSD_OSDWIN0YP);
+			osd_write(lconfig->ysize, OSD_OSDWIN0YL);
+		}
+		break;
+	case WIN_VID0:
+		winmd_mask |= OSD_VIDWINMD_VFF0;
+		if (lconfig->interlaced)
+			winmd |= OSD_VIDWINMD_VFF0;
+
+		osd_merge(winmd_mask, winmd, OSD_VIDWINMD);
+		osd_write(lconfig->line_length >> 5, OSD_VIDWIN0OFST);
+		osd_write(lconfig->xpos, OSD_VIDWIN0XP);
+		osd_write(lconfig->xsize, OSD_VIDWIN0XL);
+		if (lconfig->interlaced) {
+			osd_write(lconfig->ypos >> 1, OSD_VIDWIN0YP);
+			osd_write(lconfig->ysize >> 1, OSD_VIDWIN0YL);
+		} else {
+			osd_write(lconfig->ypos, OSD_VIDWIN0YP);
+			osd_write(lconfig->ysize, OSD_VIDWIN0YL);
+		}
+		break;
+	case WIN_OSD1:
+		/*
+		 * The caller must ensure that OSD1 is disabled prior to
+		 * switching from a normal mode to attribute mode or from
+		 * attribute mode to a normal mode.
+		 */
+		if (lconfig->pixfmt == PIXFMT_OSD_ATTR) {
+			if (cpu_is_davinci_dm644x()) {
+				winmd_mask |=
+				    OSD_OSDWIN1MD_ATN1E | OSD_OSDWIN1MD_RGB1E |
+				    OSD_OSDWIN1MD_CLUTS1 | OSD_OSDWIN1MD_BLND1 |
+				    OSD_OSDWIN1MD_TE1;
+			} else {
+				winmd_mask |=
+				    OSD_OSDWIN1MD_BMP1MD | OSD_OSDWIN1MD_CLUTS1
+				    | OSD_OSDWIN1MD_BLND1 | OSD_OSDWIN1MD_TE1;
+			}
+		} else {
+			if (cpu_is_davinci_dm644x()) {
+				winmd_mask |= OSD_OSDWIN1MD_RGB1E;
+				if (lconfig->pixfmt == PIXFMT_RGB565)
+					winmd |= OSD_OSDWIN1MD_RGB1E;
+			} else if (cpu_is_davinci_dm355()) {
+				winmd_mask |= OSD_OSDWIN1MD_BMP1MD;
+				switch (lconfig->pixfmt) {
+				case PIXFMT_RGB565:
+					winmd |=
+					    (1 << OSD_OSDWIN1MD_BMP1MD_SHIFT);
+					break;
+				case PIXFMT_RGB888:
+					winmd |=
+					    (2 << OSD_OSDWIN1MD_BMP1MD_SHIFT);
+					break;
+				case PIXFMT_YCbCrI:
+				case PIXFMT_YCrCbI:
+					winmd |=
+					    (3 << OSD_OSDWIN1MD_BMP1MD_SHIFT);
+					break;
+				default:
+					break;
+				}
+			}
+
+			winmd_mask |= OSD_OSDWIN1MD_BMW1;
+			switch (lconfig->pixfmt) {
+			case PIXFMT_1BPP:
+				bmw = 0;
+				break;
+			case PIXFMT_2BPP:
+				bmw = 1;
+				break;
+			case PIXFMT_4BPP:
+				bmw = 2;
+				break;
+			case PIXFMT_8BPP:
+				bmw = 3;
+				break;
+			default:
+				break;
+			}
+			winmd |= (bmw << OSD_OSDWIN1MD_BMW1_SHIFT);
+		}
+
+		winmd_mask |= OSD_OSDWIN1MD_OFF1;
+		if (lconfig->interlaced)
+			winmd |= OSD_OSDWIN1MD_OFF1;
+
+		osd_merge(winmd_mask, winmd, OSD_OSDWIN1MD);
+		osd_write(lconfig->line_length >> 5, OSD_OSDWIN1OFST);
+		osd_write(lconfig->xpos, OSD_OSDWIN1XP);
+		osd_write(lconfig->xsize, OSD_OSDWIN1XL);
+		if (lconfig->interlaced) {
+			osd_write(lconfig->ypos >> 1, OSD_OSDWIN1YP);
+			osd_write(lconfig->ysize >> 1, OSD_OSDWIN1YL);
+		} else {
+			osd_write(lconfig->ypos, OSD_OSDWIN1YP);
+			osd_write(lconfig->ysize, OSD_OSDWIN1YL);
+		}
+		break;
+	case WIN_VID1:
+		winmd_mask |= OSD_VIDWINMD_VFF1;
+		if (lconfig->interlaced)
+			winmd |= OSD_VIDWINMD_VFF1;
+
+		osd_merge(winmd_mask, winmd, OSD_VIDWINMD);
+		osd_write(lconfig->line_length >> 5, OSD_VIDWIN1OFST);
+		osd_write(lconfig->xpos, OSD_VIDWIN1XP);
+		osd_write(lconfig->xsize, OSD_VIDWIN1XL);
+		if (lconfig->interlaced) {
+			osd_write(lconfig->ypos >> 1, OSD_VIDWIN1YP);
+			osd_write(lconfig->ysize >> 1, OSD_VIDWIN1YL);
+		} else {
+			osd_write(lconfig->ypos, OSD_VIDWIN1YP);
+			osd_write(lconfig->ysize, OSD_VIDWIN1YL);
+		}
+		break;
+	}
+}
+
+int davinci_disp_set_layer_config(enum davinci_disp_layer layer,
+				  struct davinci_layer_config *lconfig)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	int reject_config;
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	reject_config = try_layer_config(layer, lconfig);
+	if (reject_config) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return reject_config;
+	}
+
+	/* update the current Cb/Cr order */
+	if (is_yc_pixfmt(lconfig->pixfmt))
+		osd->yc_pixfmt = lconfig->pixfmt;
+
+	/*
+	 * If we are switching OSD1 from normal mode to attribute mode or from
+	 * attribute mode to normal mode, then we must disable the window.
+	 */
+	if (layer == WIN_OSD1) {
+		if (((lconfig->pixfmt == PIXFMT_OSD_ATTR)
+		     && (win->lconfig.pixfmt != PIXFMT_OSD_ATTR))
+		    || ((lconfig->pixfmt != PIXFMT_OSD_ATTR)
+			&& (win->lconfig.pixfmt == PIXFMT_OSD_ATTR))) {
+			win->is_enabled = 0;
+			_davinci_disp_disable_layer(layer);
+		}
+	}
+
+	_davinci_disp_set_layer_config(layer, lconfig);
+
+	if (layer == WIN_OSD1) {
+		struct davinci_osdwin_state *osdwin_state =
+		    &osd->osdwin[OSDWIN_OSD1];
+
+		if ((lconfig->pixfmt != PIXFMT_OSD_ATTR)
+		    && (win->lconfig.pixfmt == PIXFMT_OSD_ATTR)) {
+			/*
+			 * We just switched OSD1 from attribute mode to normal
+			 * mode, so we must initialize the CLUT select, the
+			 * blend factor, transparency colorkey enable, and
+			 * attenuation enable (DM6446 only) bits in the
+			 * OSDWIN1MD register.
+			 */
+			_davinci_disp_set_osd_clut(OSDWIN_OSD1,
+						   osdwin_state->clut);
+			_davinci_disp_set_blending_factor(OSDWIN_OSD1,
+							  osdwin_state->blend);
+			if (osdwin_state->colorkey_blending) {
+				_davinci_disp_enable_color_key(OSDWIN_OSD1,
+							       osdwin_state->
+							       colorkey,
+							       lconfig->pixfmt);
+			} else
+				_davinci_disp_disable_color_key(OSDWIN_OSD1);
+			_davinci_disp_set_rec601_attenuation(OSDWIN_OSD1,
+							     osdwin_state->
+							     rec601_attenuation);
+		} else if ((lconfig->pixfmt == PIXFMT_OSD_ATTR)
+			   && (win->lconfig.pixfmt != PIXFMT_OSD_ATTR)) {
+			/*
+			 * We just switched OSD1 from normal mode to attribute
+			 * mode, so we must initialize the blink enable and
+			 * blink interval bits in the OSDATRMD register.
+			 */
+			_davinci_disp_set_blink_attribute(osd->is_blinking,
+							  osd->blink);
+		}
+	}
+
+	/*
+	 * If we just switched to a 1-, 2-, or 4-bits-per-pixel bitmap format
+	 * then configure a default palette map.
+	 */
+	if ((lconfig->pixfmt != win->lconfig.pixfmt)
+	    && ((lconfig->pixfmt == PIXFMT_1BPP)
+		|| (lconfig->pixfmt == PIXFMT_2BPP)
+		|| (lconfig->pixfmt == PIXFMT_4BPP))) {
+		enum davinci_osd_layer osdwin =
+		    ((layer == WIN_OSD0) ? OSDWIN_OSD0 : OSDWIN_OSD1);
+		struct davinci_osdwin_state *osdwin_state =
+		    &osd->osdwin[osdwin];
+		unsigned char clut_index;
+		unsigned char clut_entries = 0;
+
+		switch (lconfig->pixfmt) {
+		case PIXFMT_1BPP:
+			clut_entries = 2;
+			break;
+		case PIXFMT_2BPP:
+			clut_entries = 4;
+			break;
+		case PIXFMT_4BPP:
+			clut_entries = 16;
+			break;
+		default:
+			break;
+		}
+		/*
+		 * The default palette map maps the pixel value to the clut
+		 * index, i.e. pixel value 0 maps to clut entry 0, pixel value 1
+		 * maps to clut entry 1, etc.
+		 */
+		for (clut_index = 0; clut_index < 16; clut_index++) {
+			osdwin_state->palette_map[clut_index] = clut_index;
+			if (clut_index < clut_entries) {
+				_davinci_disp_set_palette_map(osdwin,
+							      clut_index,
+							      clut_index,
+							      lconfig->pixfmt);
+			}
+		}
+	}
+
+	win->lconfig = *lconfig;
+
+	/* DM6446: configure the RGB888 enable and window selection */
+	if (osd->win[WIN_VID0].lconfig.pixfmt == PIXFMT_RGB888)
+		_davinci_disp_enable_vid_rgb888(WIN_VID0);
+	else if (osd->win[WIN_VID1].lconfig.pixfmt == PIXFMT_RGB888)
+		_davinci_disp_enable_vid_rgb888(WIN_VID1);
+	else
+		_davinci_disp_disable_vid_rgb888();
+
+	if (layer == WIN_VID0) {
+		osd->pingpong =
+		    _davinci_disp_dm6446_vid0_pingpong(osd->field_inversion,
+						       win->fb_base_phys,
+						       &win->lconfig);
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+
+	return 0;
+}
+
+void davinci_disp_init_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	enum davinci_osd_layer osdwin;
+	struct davinci_osdwin_state *osdwin_state;
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	win->is_enabled = 0;
+	_davinci_disp_disable_layer(layer);
+
+	win->h_zoom = ZOOM_X1;
+	win->v_zoom = ZOOM_X1;
+	_davinci_disp_set_zoom(layer, win->h_zoom, win->v_zoom);
+
+	win->fb_base_phys = 0;
+	_davinci_disp_start_layer(layer, win->fb_base_phys);
+
+	win->lconfig.line_length = 0;
+	win->lconfig.xsize = 0;
+	win->lconfig.ysize = 0;
+	win->lconfig.xpos = 0;
+	win->lconfig.ypos = 0;
+	win->lconfig.interlaced = 0;
+	switch (layer) {
+	case WIN_OSD0:
+	case WIN_OSD1:
+		osdwin = (layer == WIN_OSD0) ? OSDWIN_OSD0 : OSDWIN_OSD1;
+		osdwin_state = &osd->osdwin[osdwin];
+		/*
+		 * Other code relies on the fact that OSD windows default to a
+		 * bitmap pixel format when they are deallocated, so don't
+		 * change this default pixel format.
+		 */
+		win->lconfig.pixfmt = PIXFMT_8BPP;
+		_davinci_disp_set_layer_config(layer, &win->lconfig);
+		osdwin_state->clut = RAM_CLUT;
+		_davinci_disp_set_osd_clut(osdwin, osdwin_state->clut);
+		osdwin_state->colorkey_blending = 0;
+		_davinci_disp_disable_color_key(osdwin);
+		osdwin_state->blend = OSD_8_VID_0;
+		_davinci_disp_set_blending_factor(osdwin, osdwin_state->blend);
+		osdwin_state->rec601_attenuation = 0;
+		_davinci_disp_set_rec601_attenuation(osdwin,
+						     osdwin_state->
+						     rec601_attenuation);
+		if (osdwin == OSDWIN_OSD1) {
+			osd->is_blinking = 0;
+			osd->blink = BLINK_X1;
+		}
+		break;
+	case WIN_VID0:
+	case WIN_VID1:
+		win->lconfig.pixfmt = osd->yc_pixfmt;
+		_davinci_disp_set_layer_config(layer, &win->lconfig);
+		break;
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+void davinci_disp_release_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	if (!win->is_allocated) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return;
+	}
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	davinci_disp_init_layer(layer);
+	spin_lock_irqsave(&osd->lock, flags);
+
+	win->is_allocated = 0;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+}
+
+int davinci_disp_request_layer(enum davinci_disp_layer layer)
+{
+	struct davinci_window_state *win = &osd->win[layer];
+	unsigned long flags;
+
+	spin_lock_irqsave(&osd->lock, flags);
+
+	if (win->is_allocated) {
+		spin_unlock_irqrestore(&osd->lock, flags);
+		return -1;
+	}
+	win->is_allocated = 1;
+
+	spin_unlock_irqrestore(&osd->lock, flags);
+	return 0;
+}
+
+static void _davinci_disp_init(void)
+{
+	osd_write(0, OSD_MODE);
+	osd_write(0, OSD_VIDWINMD);
+	osd_write(0, OSD_OSDWIN0MD);
+	osd_write(0, OSD_OSDWIN1MD);
+	osd_write(0, OSD_RECTCUR);
+	osd_write(0, OSD_MISCCTL);
+	if (cpu_is_davinci_dm355()) {
+		osd_write(0, OSD_VBNDRY);
+		osd_write(0, OSD_EXTMODE);
+		osd_write(OSD_MISCCTL_DMANG, OSD_MISCCTL);
+	}
+}
+
+int davinci_disp_init(void)
+{
+	spin_lock_init(&osd->lock);
+
+	if (cpu_is_davinci_dm644x()) {
+		osd->osdregs = DM644X_OSD_REG_BASE;
+		osd->vencregs = DM644X_VENC_REG_BASE;
+	} else if (cpu_is_davinci_dm355()) {
+		osd->osdregs = DM355_OSD_REG_BASE;
+		osd->vencregs = DM355_VENC_REG_BASE;
+	} else
+		return -1;
+
+	osd->irq = IRQ_VENCINT;
+
+	_davinci_disp_init();
+
+	/* set default Cb/Cr order */
+	osd->yc_pixfmt = PIXFMT_YCbCrI;
+
+	if (cpu_is_davinci_dm644x()) {
+		/*
+		 * DM6446 silicon advisory 1.3.8 says that when using interlaced
+		 * video output, the field signal is improperly inverted for
+		 * OSD0, OSD1, and VID1.  The field signal is not inverted for
+		 * VID0.  The workaround is to set the field signal inversion
+		 * bit so that OSD0, OSD1, and VID1 have the correct field
+		 * polarity.  The VID0 ping-pong buffer register will be used
+		 * in the encoder ISR to compensate for the reversed field
+		 * polarity of VID0.
+		 */
+		osd->field_inversion = 1;
+	}
+	if (cpu_is_davinci_dm355()) {
+		/*
+		 * ROM CLUT1 on the DM355 is similar (identical?) to ROM CLUT0
+		 * on the DM6446, so make ROM_CLUT1 the default on the DM355.
+		 */
+		osd->rom_clut = ROM_CLUT1;
+	}
+	_davinci_disp_set_field_inversion(osd->field_inversion);
+	_davinci_disp_set_rom_clut(osd->rom_clut);
+
+	davinci_disp_init_layer(WIN_OSD0);
+	davinci_disp_init_layer(WIN_VID0);
+	davinci_disp_init_layer(WIN_OSD1);
+	davinci_disp_init_layer(WIN_VID1);
+
+	if (request_irq
+	    (osd->irq, davinci_disp_isr, SA_SHIRQ, "davinci_osd", osd))
+		return -1;
+
+	return 0;
+}
+
+subsys_initcall(davinci_disp_init);
+
+EXPORT_SYMBOL(davinci_disp_request_layer);
+EXPORT_SYMBOL(davinci_disp_release_layer);
+EXPORT_SYMBOL(davinci_disp_init_layer);
+EXPORT_SYMBOL(davinci_disp_enable_layer);
+EXPORT_SYMBOL(davinci_disp_disable_layer);
+EXPORT_SYMBOL(davinci_disp_layer_is_enabled);
+EXPORT_SYMBOL(davinci_disp_set_layer_config);
+EXPORT_SYMBOL(davinci_disp_try_layer_config);
+EXPORT_SYMBOL(davinci_disp_get_layer_config);
+EXPORT_SYMBOL(davinci_disp_start_layer);
+EXPORT_SYMBOL(davinci_disp_set_interpolation_filter);
+EXPORT_SYMBOL(davinci_disp_get_interpolation_filter);
+EXPORT_SYMBOL(davinci_disp_set_osd_expansion);
+EXPORT_SYMBOL(davinci_disp_get_osd_expansion);
+EXPORT_SYMBOL(davinci_disp_set_vid_expansion);
+EXPORT_SYMBOL(davinci_disp_get_vid_expansion);
+EXPORT_SYMBOL(davinci_disp_set_zoom);
+EXPORT_SYMBOL(davinci_disp_get_zoom);
+EXPORT_SYMBOL(davinci_disp_set_background);
+EXPORT_SYMBOL(davinci_disp_get_background);
+EXPORT_SYMBOL(davinci_disp_set_rom_clut);
+EXPORT_SYMBOL(davinci_disp_get_rom_clut);
+EXPORT_SYMBOL(davinci_disp_set_clut_ycbcr);
+EXPORT_SYMBOL(davinci_disp_set_clut_rgb);
+EXPORT_SYMBOL(davinci_disp_set_osd_clut);
+EXPORT_SYMBOL(davinci_disp_get_osd_clut);
+EXPORT_SYMBOL(davinci_disp_enable_color_key);
+EXPORT_SYMBOL(davinci_disp_disable_color_key);
+EXPORT_SYMBOL(davinci_disp_set_blending_factor);
+EXPORT_SYMBOL(davinci_disp_get_blending_factor);
+EXPORT_SYMBOL(davinci_disp_set_rec601_attenuation);
+EXPORT_SYMBOL(davinci_disp_get_rec601_attenuation);
+EXPORT_SYMBOL(davinci_disp_set_palette_map);
+EXPORT_SYMBOL(davinci_disp_get_palette_map);
+EXPORT_SYMBOL(davinci_disp_set_blink_attribute);
+EXPORT_SYMBOL(davinci_disp_get_blink_attribute);
+EXPORT_SYMBOL(davinci_disp_cursor_enable);
+EXPORT_SYMBOL(davinci_disp_cursor_disable);
+EXPORT_SYMBOL(davinci_disp_cursor_is_enabled);
+EXPORT_SYMBOL(davinci_disp_set_cursor_config);
+EXPORT_SYMBOL(davinci_disp_get_cursor_config);
+EXPORT_SYMBOL(davinci_disp_set_field_inversion);
+EXPORT_SYMBOL(davinci_disp_get_field_inversion);
+EXPORT_SYMBOL(davinci_disp_register_callback);
+EXPORT_SYMBOL(davinci_disp_unregister_callback);
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/drivers/media/video/davinci/davinci_platform.c
===================================================================
--- /dev/null
+++ linux-2.6.18/drivers/media/video/davinci/davinci_platform.c
@@ -0,0 +1,1010 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/io.h>
+#include <asm/io.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <video/davinci_vpbe.h>
+#include <video/davinci_osd.h>
+#include <media/davinci/davinci_enc_mngr.h>
+#include <media/davinci/davinci_platform.h>
+
+extern struct vid_enc_device_mgr enc_dev[];
+
+struct enc_config davinci_enc_default[DAVINCI_ENC_MAX_CHANNELS] = {
+	{VID_ENC_OUTPUT_COMPOSITE,
+	 VID_ENC_STD_NTSC}
+};
+
+EXPORT_SYMBOL(davinci_enc_default);
+
+char *davinci_outputs[] = {
+	VID_ENC_OUTPUT_COMPOSITE,
+	VID_ENC_OUTPUT_COMPOSITE1,
+	VID_ENC_OUTPUT_SVIDEO,
+	VID_ENC_OUTPUT_SVIDEO1,
+	VID_ENC_OUTPUT_COMPONENT,
+	VID_ENC_OUTPUT_COMPONENT1,
+	VID_ENC_OUTPUT_LCD,
+	VID_ENC_OUTPUT_LCD1,
+	""
+};
+
+EXPORT_SYMBOL(davinci_outputs);
+
+char *davinci_modes[] = {
+	VID_ENC_STD_NTSC,
+	"ntsc",
+	VID_ENC_STD_NTSC_RGB,
+	VID_ENC_STD_PAL,
+	"pal",
+	VID_ENC_STD_PAL_RGB,
+	VID_ENC_STD_720P_25,
+	VID_ENC_STD_720P_30,
+	VID_ENC_STD_720P_50,
+	VID_ENC_STD_720P_60,
+	VID_ENC_STD_1080I_25,
+	VID_ENC_STD_1080I_30,
+	VID_ENC_STD_1080P_25,
+	VID_ENC_STD_1080P_30,
+	VID_ENC_STD_1080P_50,
+	VID_ENC_STD_1080P_60,
+	VID_ENC_STD_480P_60,
+	VID_ENC_STD_576P_50,
+	VID_ENC_STD_640x480,
+	VID_ENC_STD_640x400,
+	VID_ENC_STD_640x350,
+	""
+};
+EXPORT_SYMBOL(davinci_modes);
+
+static __inline__ u32 dispc_reg_in(u32 offset)
+{
+	if (cpu_is_davinci_dm355())
+		return (davinci_readl(DM355_VENC_REG_BASE + offset));
+	else
+		return (davinci_readl(DM644X_VENC_REG_BASE + offset));
+}
+
+static __inline__ u32 dispc_reg_out(u32 offset, u32 val)
+{
+	if (cpu_is_davinci_dm355())
+		davinci_writel(val, (DM355_VENC_REG_BASE + offset));
+	else
+		davinci_writel(val, (DM644X_VENC_REG_BASE + offset));
+	return (val);
+}
+
+static __inline__ u32 dispc_reg_merge(u32 offset, u32 val, u32 mask)
+{
+	u32 addr, new_val;
+
+	if (cpu_is_davinci_dm355())
+		addr = DM355_VENC_REG_BASE + offset;
+	else
+		addr = DM644X_VENC_REG_BASE + offset;
+
+	new_val = (davinci_readl(addr) & ~mask) | (val & mask);
+	davinci_writel(new_val, addr);
+	return (new_val);
+}
+
+#ifdef CONFIG_SYSFS
+
+static DEFINE_SPINLOCK(reg_access_lock);
+static void davinci_enc_set_basep(int channel, unsigned basepx, unsigned basepy)
+{
+	spin_lock(&reg_access_lock);
+	if (cpu_is_davinci_dm355()) {
+		davinci_writel((basepx & OSD_BASEPX_BPX),
+			       (DM355_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel((basepy & OSD_BASEPY_BPY),
+			       (DM355_OSD_REG_BASE + OSD_BASEPY));
+	} else if (cpu_is_davinci_dm644x()) {
+		davinci_writel((basepx & OSD_BASEPX_BPX),
+			       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel((basepy & OSD_BASEPY_BPY),
+			       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+	} else {
+		printk(KERN_WARNING "Unsupported platform\n");
+	}
+	spin_unlock(&reg_access_lock);
+}
+
+static void davinci_enc_get_basep(int channel, unsigned *basepx,
+				  unsigned *basepy)
+{
+	spin_lock(&reg_access_lock);
+	if (cpu_is_davinci_dm355()) {
+		*basepx =
+		    (OSD_BASEPX_BPX &
+		     davinci_readl(DM355_OSD_REG_BASE + OSD_BASEPX));
+		*basepy =
+		    (OSD_BASEPY_BPY &
+		     davinci_readl(DM355_OSD_REG_BASE + OSD_BASEPY));
+	} else if (cpu_is_davinci_dm644x()) {
+		*basepx =
+		    (OSD_BASEPX_BPX &
+		     davinci_readl(DM644X_OSD_REG_BASE + OSD_BASEPX));
+		*basepy =
+		    (OSD_BASEPY_BPY &
+		     davinci_readl(DM644X_OSD_REG_BASE + OSD_BASEPY));
+	} else {
+		*basepx = 0;
+		*basepy = 0;
+		printk(KERN_WARNING "Unsupported platform\n");
+	}
+	spin_unlock(&reg_access_lock);
+}
+
+struct system_device {
+	struct module *owner;
+	struct class_device class_dev;
+};
+
+static struct system_device *davinci_system_device;
+
+#define to_system_dev(cdev)	container_of(cdev, \
+ struct system_device, class_dev)
+
+static void davinci_system_class_release(struct class_device *cdev)
+{
+	struct system_device *dev = to_system_dev(cdev);
+
+	if (dev != NULL)
+		kfree(dev);
+}
+
+static void __iomem *display_cntl_base;
+
+struct class davinci_system_class = {
+	.name = "davinci_system",
+	.release = davinci_system_class_release,
+};
+
+static ssize_t
+reg_store(struct class_device *cdev, const char *buffer, size_t count)
+{
+	char *str = 0;
+	char *bufv = 0;
+	int addr = 0;
+	int val = 0;
+	int len = 0;
+
+	if (!buffer || (count == 0) || (count >= 128))
+		return 0;
+
+	str = kmalloc(128, GFP_KERNEL);
+	if (0 == str)
+		return -ENOMEM;
+
+	strcpy(str, buffer);
+	/* overwrite the '\n' */
+	strcpy(str + count - 1, "\0");
+
+	/* format: <address> [<value>]
+	   if only <address> present, it is a read
+	   if <address> <value>, then it is a write */
+	len = strcspn(str, " ");
+	addr = simple_strtoul(str, NULL, 16);
+
+	if (len != count - 1) {
+		bufv = str;
+		strsep(&bufv, " ");
+		val = simple_strtoul(bufv, NULL, 16);
+	}
+
+	kfree(str);
+
+	/* for now, restrict this to access DDR2 controller
+	   Peripheral Bust Burst Priority Register PBBPR
+	   (addr: 0x20000020) only */
+	if (addr != (DM644X_DDR2_CNTL_BASE + 0x20))
+		return -EINVAL;
+
+	spin_lock(&reg_access_lock);
+	if (bufv != 0)
+		writel(val, display_cntl_base + addr - DM644X_DDR2_CNTL_BASE);
+	printk(KERN_NOTICE "%05x  %08x\n", addr,
+	       readl(display_cntl_base + addr - DM644X_DDR2_CNTL_BASE));
+	spin_unlock(&reg_access_lock);
+
+	return count;
+}
+
+static ssize_t reg_show(struct class_device *cdev, char *buf)
+{
+	return 0;
+}
+
+static ssize_t osd_basepx_show(struct class_device *cdev, char *buf)
+{
+	unsigned int basepx, basepy;
+	int p;
+
+	davinci_enc_get_basep(0, &basepx, &basepy);
+	p = sprintf(buf, "%d\n", basepx);
+	return p;
+}
+
+static ssize_t osd_basepx_store(struct class_device *cdev, const char *buffer,
+				size_t count)
+{
+	unsigned int basepx, basepy;
+	char reg_val[10];
+
+	if (count >= 9) {
+		strncpy(reg_val, buffer, 9);
+		reg_val[9] = '\0';
+	} else {
+		/* overwrite the '\n' */
+		strcpy(reg_val, buffer);
+		strcpy(reg_val + count - 1, "\0");
+	}
+	davinci_enc_get_basep(0, &basepx, &basepy);
+	basepx = simple_strtoul(reg_val, NULL, 10);
+
+	if (basepx > OSD_BASEPX_BPX) {
+		printk(KERN_ERR "Invalid value for OSD basepx\n");
+		return count;
+	}
+	davinci_enc_set_basep(0, basepx, basepy);
+	return count;
+}
+
+static ssize_t osd_basepy_show(struct class_device *cdev, char *buf)
+{
+	unsigned int basepx, basepy;
+	int p;
+
+	davinci_enc_get_basep(0, &basepx, &basepy);
+	p = sprintf(buf, "%d\n", basepy);
+	return p;
+}
+
+static ssize_t osd_basepy_store(struct class_device *cdev, const char *buffer,
+				size_t count)
+{
+	unsigned int basepx, basepy;
+	char reg_val[10];
+
+	if (count >= 9) {
+		strncpy(reg_val, buffer, 9);
+		reg_val[9] = '\0';
+	} else {
+		/* overwrite the '\n' */
+		strcpy(reg_val, buffer);
+		strcpy(reg_val + count - 1, "\0");
+	}
+
+	davinci_enc_get_basep(0, &basepx, &basepy);
+	basepy = simple_strtoul(reg_val, NULL, 10);
+	if (basepy > OSD_BASEPY_BPY) {
+		printk(KERN_ERR "Invalid value for OSD basepy\n");
+		return count;
+	}
+	davinci_enc_set_basep(0, basepx, basepy);
+	return count;
+}
+
+#define DECLARE_ATTR(_name, _mode, _show, _store) {		\
+	.attr   = { .name = __stringify(_name), .mode = _mode,	\
+		    .owner = THIS_MODULE },  			\
+	.show   = _show,                                        \
+	.store  = _store,}
+
+static struct class_device_attribute system_class_device_attributes[] = {
+	DECLARE_ATTR(reg, S_IRWXUGO, reg_show, reg_store),
+	DECLARE_ATTR(vpbe_osd_basepx, S_IRWXUGO, osd_basepx_show,
+		     osd_basepx_store),
+	DECLARE_ATTR(vpbe_osd_basepy, S_IRWXUGO, osd_basepy_show,
+		     osd_basepy_store)
+};
+
+static void *create_sysfs_files(void)
+{
+	struct system_device *dev;
+	int ret;
+	int i;
+
+	dev = kzalloc(sizeof(struct system_device), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	dev->owner = THIS_MODULE;
+	dev->class_dev.class = &davinci_system_class;
+	snprintf(dev->class_dev.class_id, BUS_ID_SIZE, "system");
+	ret = class_device_register(&dev->class_dev);
+	if (ret < 0) {
+		printk(KERN_ERR "Error in class_device_register\n");
+		kfree(dev);
+		return NULL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(system_class_device_attributes); i++) {
+		ret = class_device_create_file(&dev->class_dev,
+					       &system_class_device_attributes
+					       [i]);
+		if (ret < 0) {
+			while (--i >= 0)
+				class_device_remove_file(&dev->class_dev,
+					&system_class_device_attributes[i]);
+			class_device_unregister(&dev->class_dev);
+			printk(KERN_ERR "Error in class_device_create_file\n");
+			return NULL;
+		}
+	}
+
+	return dev;
+}
+
+static void remove_sysfs_files(struct system_device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(system_class_device_attributes); i++)
+		class_device_remove_file(&dev->class_dev,
+					 &system_class_device_attributes[i]);
+
+	class_device_unregister(&dev->class_dev);
+}
+#endif
+
+/**
+ * function davinci_enc_select_venc_clk
+ * @clk_source: clock source defined by davinci_enc_clk_source_type
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *  Select the venc input clock based on the clk_source_type.
+ */
+int davinci_enc_select_venc_clock(int clk)
+{
+	return 0;
+}
+
+EXPORT_SYMBOL(davinci_enc_select_venc_clock);
+
+static void enableDigitalOutput(int bEnable)
+{
+	if (bEnable) {
+		dispc_reg_out(VENC_VMOD, 0);
+		dispc_reg_out(VENC_CVBS, 0);
+
+		if (!cpu_is_davinci_dm355()) {
+			davinci_writel(0, (DM644X_VPBE_REG_BASE + VPBE_PCR));
+		}
+		dispc_reg_out(VENC_LCDOUT, 0);
+		dispc_reg_out(VENC_HSPLS, 0);
+		dispc_reg_out(VENC_HSTART, 0);
+		dispc_reg_out(VENC_HVALID, 0);
+		dispc_reg_out(VENC_HINT, 0);
+		dispc_reg_out(VENC_VSPLS, 0);
+		dispc_reg_out(VENC_VSTART, 0);
+		dispc_reg_out(VENC_VVALID, 0);
+		dispc_reg_out(VENC_VINT, 0);
+		dispc_reg_out(VENC_YCCCTL, 0);
+		dispc_reg_out(VENC_DACSEL, 0);
+
+	} else {
+		/* Initialize the VPSS Clock Control register */
+		davinci_writel(0x18, SYS_VPSS_CLKCTL);
+		davinci_writel(0, (DM644X_VPBE_REG_BASE + VPBE_PCR));
+
+		/* Set PINMUX0 reg to enable LCD (all other settings are kept
+		   per boot)
+		 */
+		if (!cpu_is_davinci_dm355()) {
+			davinci_cfg_reg(DM644X_LOEEN);
+			davinci_cfg_reg(DM644X_LFLDEN);
+		}
+
+		/* disable VCLK output pin enable */
+		dispc_reg_out(VENC_VIDCTL, 0x141);
+
+		/* Disable output sync pins */
+		dispc_reg_out(VENC_SYNCCTL, 0);
+
+		/* Disable DCLOCK */
+		dispc_reg_out(VENC_DCLKCTL, 0);
+		dispc_reg_out(VENC_DRGBX1, 0x0000057C);
+
+		/* Disable LCD output control (accepting default polarity) */
+		dispc_reg_out(VENC_LCDOUT, 0);
+		if (!cpu_is_davinci_dm355()) {
+			dispc_reg_out(VENC_CMPNT, 0x100);
+		}
+
+		dispc_reg_out(VENC_HSPLS, 0);
+		dispc_reg_out(VENC_HINT, 0);
+		dispc_reg_out(VENC_HSTART, 0);
+		dispc_reg_out(VENC_HVALID, 0);
+
+		dispc_reg_out(VENC_VSPLS, 0);
+		dispc_reg_out(VENC_VINT, 0);
+		dispc_reg_out(VENC_VSTART, 0);
+		dispc_reg_out(VENC_VVALID, 0);
+
+		dispc_reg_out(VENC_HSDLY, 0);
+		dispc_reg_out(VENC_VSDLY, 0);
+
+		dispc_reg_out(VENC_YCCCTL, 0);
+		dispc_reg_out(VENC_VSTARTA, 0);
+
+		/* Set OSD clock and OSD Sync Adavance registers */
+		dispc_reg_out(VENC_OSDCLK0, 1);
+		dispc_reg_out(VENC_OSDCLK1, 2);
+	}
+}
+
+/*
+ * setting NTSC mode
+ */
+
+static void davinci_enc_set_ntsc(struct vid_enc_mode_info *mode_info)
+{
+	enableDigitalOutput(0);
+
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_CLKCTL, 0x01);
+		dispc_reg_out(VENC_VIDCTL, 0);
+		/* DM 350 Configure VDAC_CONFIG , why ?? */
+		davinci_writel(0x0E21A6B6, DM355_VDAC_CONFIG);
+	} else {
+		/* to set VENC CLK DIV to 1 - final clock is 54 MHz */
+		dispc_reg_merge(VENC_VIDCTL, 0, 1 << 1);
+		/* Set REC656 Mode */
+		dispc_reg_out(VENC_YCCCTL, 0x1);
+		dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAFRQ);
+		dispc_reg_merge(VENC_VDPRO, 0, VENC_VDPRO_DAUPS);
+	}
+	if (cpu_is_davinci_dm355()) {
+		davinci_writel(mode_info->left_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPY));
+	} else {
+		davinci_writel(mode_info->left_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+	}
+	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
+}
+
+/*
+ * setting PAL mode
+ */
+static void davinci_enc_set_pal(struct vid_enc_mode_info *mode_info)
+{
+
+	enableDigitalOutput(0);
+
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_CLKCTL, 0x1);
+		dispc_reg_out(VENC_VIDCTL, 0);
+		/* DM350 Configure VDAC_CONFIG  */
+		davinci_writel(0x0E21A6B6, DM355_VDAC_CONFIG);
+	} else {
+		/* to set VENC CLK DIV to 1 - final clock is 54 MHz */
+		dispc_reg_merge(VENC_VIDCTL, 0, 1 << 1);
+		/* Set REC656 Mode */
+		dispc_reg_out(VENC_YCCCTL, 0x1);
+	}
+
+	dispc_reg_merge(VENC_SYNCCTL, 1 << VENC_SYNCCTL_OVD_SHIFT,
+			VENC_SYNCCTL_OVD);
+
+	if (cpu_is_davinci_dm355()) {
+		davinci_writel(mode_info->left_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPY));
+	} else {
+		davinci_writel(mode_info->left_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+	}
+
+	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
+	dispc_reg_out(VENC_DACTST, 0x0);
+}
+
+/*
+ * davinci_enc_ntsc_pal_rgb
+ */
+/* This function configures the video encoder to NTSC RGB setting.*/
+static void davinci_enc_set_ntsc_pal_rgb(struct vid_enc_mode_info *mode_info)
+{
+
+	enableDigitalOutput(0);
+
+	davinci_writel(mode_info->left_margin,
+		       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+	davinci_writel(mode_info->upper_margin,
+		       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+}
+
+/*
+ * davinci_enc_set_525p
+ */
+/* This function configures the video encoder to HDTV(525p) component setting.*/
+static void davinci_enc_set_525p(struct vid_enc_mode_info *mode_info)
+{
+	enableDigitalOutput(0);
+	davinci_writel(0x19, SYS_VPSS_CLKCTL);
+
+	davinci_writel(mode_info->left_margin,
+		       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+	davinci_writel(mode_info->upper_margin,
+		       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+
+	davinci_writel(VPBE_PCR_VENC_DIV, (DM644X_VPBE_REG_BASE + VPBE_PCR));
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+
+	dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAFRQ, VENC_VDPRO_DAFRQ);
+	dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAUPS, VENC_VDPRO_DAUPS);
+
+	dispc_reg_merge(VENC_VMOD,
+			VENC_VMOD_VDMD_YCBCR8 <<
+			VENC_VMOD_VDMD_SHIFT, VENC_VMOD_VDMD);
+
+	/* Set REC656 Mode */
+	dispc_reg_out(VENC_YCCCTL, 0x1);
+	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
+}
+
+/*
+ *  davinci_enc_set_625p
+ */
+/* This function configures the video encoder to HDTV(625p) component setting.*/
+static void davinci_enc_set_625p(struct vid_enc_mode_info *mode_info)
+{
+	enableDigitalOutput(0);
+	davinci_writel(0x19, SYS_VPSS_CLKCTL);
+
+	davinci_writel(mode_info->left_margin,
+		       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+	davinci_writel(mode_info->upper_margin,
+		       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+
+	davinci_writel(VPBE_PCR_VENC_DIV, (DM644X_VPBE_REG_BASE + VPBE_PCR));
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+
+	dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAFRQ, VENC_VDPRO_DAFRQ);
+	dispc_reg_merge(VENC_VDPRO, VENC_VDPRO_DAUPS, VENC_VDPRO_DAUPS);
+
+	dispc_reg_merge(VENC_VMOD,
+			VENC_VMOD_VDMD_YCBCR8 <<
+			VENC_VMOD_VDMD_SHIFT, VENC_VMOD_VDMD);
+
+	/* Set REC656 Mode */
+	dispc_reg_out(VENC_YCCCTL, 0x1);
+	dispc_reg_merge(VENC_VMOD, VENC_VMOD_VENC, VENC_VMOD_VENC);
+}
+
+/*
+ * davinci_enc_set_display_timing
+ */
+/* This function sets the display timing from the fb_info structure*/
+void davinci_enc_set_display_timing(struct vid_enc_mode_info *mode)
+{
+	dispc_reg_out(VENC_HSPLS, mode->hsync_len);
+	dispc_reg_out(VENC_HSTART, mode->left_margin);
+	dispc_reg_out(VENC_HVALID, mode->xres);
+	dispc_reg_out(VENC_HINT,
+		      mode->xres + mode->left_margin + mode->right_margin - 1);
+
+	dispc_reg_out(VENC_VSPLS, mode->vsync_len);
+	dispc_reg_out(VENC_VSTART, mode->upper_margin);
+	dispc_reg_out(VENC_VVALID, mode->yres);
+	dispc_reg_out(VENC_VINT,
+		      mode->yres + mode->upper_margin + mode->lower_margin);
+};
+
+EXPORT_SYMBOL(davinci_enc_set_display_timing);
+
+/*
+ * setting DLCD 480P PRGB mode
+ */
+static void davinci_enc_set_prgb(struct vid_enc_mode_info *mode_info)
+{
+
+	enableDigitalOutput(1);
+
+	dispc_reg_out(VENC_VIDCTL, 0x141);
+	/* set VPSS clock */
+	davinci_writel(0x18, SYS_VPSS_CLKCTL);
+
+	dispc_reg_out(VENC_DCLKCTL, 0);
+	dispc_reg_out(VENC_DCLKPTN0, 0);
+
+	/* Set the OSD Divisor to 1. */
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+	/* Clear composite mode register */
+	dispc_reg_out(VENC_CVBS, 0);
+
+	/* Set PINMUX1 to enable all outputs needed to support RGB666 */
+	if (cpu_is_davinci_dm355()) {
+		/* Enable the venc and dlcd clocks. */
+		dispc_reg_out(VENC_CLKCTL, 0x11);
+		davinci_cfg_reg(DM355_VOUT_FIELD_G70);
+		davinci_cfg_reg(DM355_VOUT_COUTL_EN);
+		davinci_cfg_reg(DM355_VOUT_COUTH_EN);
+	} else {
+		dispc_reg_out(VENC_CMPNT, 0x100);
+		davinci_cfg_reg(DM644X_GPIO46_47);
+		davinci_cfg_reg(DM644X_GPIO0);
+		davinci_cfg_reg(DM644X_RGB666);
+		davinci_cfg_reg(DM644X_LOEEN);
+		davinci_cfg_reg(DM644X_GPIO3);
+	}
+
+	if (cpu_is_davinci_dm355()) {
+		davinci_writel(mode_info->left_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPY));
+	} else {
+		davinci_writel(mode_info->left_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+	}
+
+	/* Set VIDCTL to select VCLKE = 1,
+	   VCLKZ =0, SYDIR = 0 (set o/p), DOMD = 0 */
+	dispc_reg_merge(VENC_VIDCTL, 1 << VENC_VIDCTL_VCLKE_SHIFT,
+			VENC_VIDCTL_VCLKE);
+	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_VCLKZ_SHIFT,
+			VENC_VIDCTL_VCLKZ);
+	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_SYDIR_SHIFT,
+			VENC_VIDCTL_SYDIR);
+	dispc_reg_merge(VENC_VIDCTL, 0 << VENC_VIDCTL_YCDIR_SHIFT,
+			VENC_VIDCTL_YCDIR);
+
+	dispc_reg_merge(VENC_DCLKCTL,
+			1 << VENC_DCLKCTL_DCKEC_SHIFT, VENC_DCLKCTL_DCKEC);
+
+	dispc_reg_out(VENC_DCLKPTN0, 0x1);
+
+	davinci_enc_set_display_timing(mode_info);
+	dispc_reg_out(VENC_SYNCCTL,
+		      (VENC_SYNCCTL_SYEV |
+		       VENC_SYNCCTL_SYEH | VENC_SYNCCTL_HPL
+		       | VENC_SYNCCTL_VPL));
+
+	/* Configure VMOD. No change in VENC bit */
+	dispc_reg_out(VENC_VMOD, 0x2011);
+	dispc_reg_out(VENC_LCDOUT, 0x1);
+
+}
+
+/*
+ *
+ */
+static void davinci_enc_set_720p(struct vid_enc_mode_info *mode_info)
+{
+	/* Reset video encoder module */
+	dispc_reg_out(VENC_VMOD, 0);
+
+	enableDigitalOutput(1);
+
+	dispc_reg_out(VENC_VIDCTL, (VENC_VIDCTL_VCLKE | VENC_VIDCTL_VCLKP));
+	/* Setting DRGB Matrix registers back to default values */
+	dispc_reg_out(VENC_DRGBX0, 0x00000400);
+	dispc_reg_out(VENC_DRGBX1, 0x00000576);
+	dispc_reg_out(VENC_DRGBX2, 0x00000159);
+	dispc_reg_out(VENC_DRGBX3, 0x000002cb);
+	dispc_reg_out(VENC_DRGBX4, 0x000006ee);
+
+	/* Enable DCLOCK */
+	dispc_reg_out(VENC_DCLKCTL, VENC_DCLKCTL_DCKEC);
+	/* Set DCLOCK pattern */
+	dispc_reg_out(VENC_DCLKPTN0, 1);
+	dispc_reg_out(VENC_DCLKPTN1, 0);
+	dispc_reg_out(VENC_DCLKPTN2, 0);
+	dispc_reg_out(VENC_DCLKPTN3, 0);
+	dispc_reg_out(VENC_DCLKPTN0A, 2);
+	dispc_reg_out(VENC_DCLKPTN1A, 0);
+	dispc_reg_out(VENC_DCLKPTN2A, 0);
+	dispc_reg_out(VENC_DCLKPTN3A, 0);
+	dispc_reg_out(VENC_DCLKHS, 0);
+	dispc_reg_out(VENC_DCLKHSA, 1);
+	dispc_reg_out(VENC_DCLKHR, 0);
+	dispc_reg_out(VENC_DCLKVS, 0);
+	dispc_reg_out(VENC_DCLKVR, 0);
+	/* Set brightness start position and pulse width to zero */
+	dispc_reg_out(VENC_BRTS, 0);
+	dispc_reg_out(VENC_BRTW, 0);
+	/* Set LCD AC toggle interval and horizontal position to zero */
+	dispc_reg_out(VENC_ACCTL, 0);
+
+	/* Set PWM period and width to zero */
+	dispc_reg_out(VENC_PWMP, 0);
+	dispc_reg_out(VENC_PWMW, 0);
+
+	dispc_reg_out(VENC_CVBS, 0);
+	dispc_reg_out(VENC_CMPNT, 0);
+	/* turning on horizontal and vertical syncs */
+	dispc_reg_out(VENC_SYNCCTL, (VENC_SYNCCTL_SYEV | VENC_SYNCCTL_SYEH));
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+	dispc_reg_out(VENC_OSDHADV, 0);
+
+	dispc_reg_out(VENC_HSDLY, 0);
+	dispc_reg_out(VENC_VSDLY, 0);
+	dispc_reg_out(VENC_YCCCTL, 0);
+	dispc_reg_out(VENC_VSTARTA, 13);
+
+	davinci_writel(0xa, SYS_VPSS_CLKCTL);
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_CLKCTL, 0x11);
+		davinci_writel(mode_info->left_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPY));
+		davinci_cfg_reg(DM355_VOUT_FIELD_G70);
+		davinci_cfg_reg(DM355_VOUT_COUTL_EN);
+		davinci_cfg_reg(DM355_VOUT_COUTH_EN);
+	} else {
+		davinci_writel(mode_info->left_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+		davinci_cfg_reg(DM644X_LOEEN);
+		davinci_cfg_reg(DM644X_GPIO3);
+	}
+
+	/* Set VENC for non-standard timing */
+	davinci_enc_set_display_timing(mode_info);
+
+	dispc_reg_out(VENC_HSDLY, 0);
+	dispc_reg_out(VENC_VSDLY, 0);
+	dispc_reg_out(VENC_YCCCTL, 0);
+	dispc_reg_out(VENC_VSTARTA, 0);
+
+	/* Enable all VENC, non-standard timing mode, master timing, HD,
+	   progressive
+	 */
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_VMOD, (VENC_VMOD_VENC | VENC_VMOD_VMD));
+	} else {
+		dispc_reg_out(VENC_VMOD,
+			      (VENC_VMOD_VENC | VENC_VMOD_VMD |
+			       VENC_VMOD_HDMD));
+	}
+	dispc_reg_out(VENC_LCDOUT, 1);
+}
+
+/*
+ *
+ */
+static void davinci_enc_set_1080i(struct vid_enc_mode_info *mode_info)
+{
+	/* Reset video encoder module */
+	dispc_reg_out(VENC_VMOD, 0);
+
+	enableDigitalOutput(1);
+	dispc_reg_out(VENC_VIDCTL, (VENC_VIDCTL_VCLKE | VENC_VIDCTL_VCLKP));
+	/* Setting DRGB Matrix registers back to default values */
+	dispc_reg_out(VENC_DRGBX0, 0x00000400);
+	dispc_reg_out(VENC_DRGBX1, 0x00000576);
+	dispc_reg_out(VENC_DRGBX2, 0x00000159);
+	dispc_reg_out(VENC_DRGBX3, 0x000002cb);
+	dispc_reg_out(VENC_DRGBX4, 0x000006ee);
+	/* Enable DCLOCK */
+	dispc_reg_out(VENC_DCLKCTL, VENC_DCLKCTL_DCKEC);
+	/* Set DCLOCK pattern */
+	dispc_reg_out(VENC_DCLKPTN0, 1);
+	dispc_reg_out(VENC_DCLKPTN1, 0);
+	dispc_reg_out(VENC_DCLKPTN2, 0);
+	dispc_reg_out(VENC_DCLKPTN3, 0);
+	dispc_reg_out(VENC_DCLKPTN0A, 2);
+	dispc_reg_out(VENC_DCLKPTN1A, 0);
+	dispc_reg_out(VENC_DCLKPTN2A, 0);
+	dispc_reg_out(VENC_DCLKPTN3A, 0);
+	dispc_reg_out(VENC_DCLKHS, 0);
+	dispc_reg_out(VENC_DCLKHSA, 1);
+	dispc_reg_out(VENC_DCLKHR, 0);
+	dispc_reg_out(VENC_DCLKVS, 0);
+	dispc_reg_out(VENC_DCLKVR, 0);
+	/* Set brightness start position and pulse width to zero */
+	dispc_reg_out(VENC_BRTS, 0);
+	dispc_reg_out(VENC_BRTW, 0);
+	/* Set LCD AC toggle interval and horizontal position to zero */
+	dispc_reg_out(VENC_ACCTL, 0);
+
+	/* Set PWM period and width to zero */
+	dispc_reg_out(VENC_PWMP, 0);
+	dispc_reg_out(VENC_PWMW, 0);
+
+	dispc_reg_out(VENC_CVBS, 0);
+	dispc_reg_out(VENC_CMPNT, 0);
+	/* turning on horizontal and vertical syncs */
+	dispc_reg_out(VENC_SYNCCTL, (VENC_SYNCCTL_SYEV | VENC_SYNCCTL_SYEH));
+	dispc_reg_out(VENC_OSDCLK0, 0);
+	dispc_reg_out(VENC_OSDCLK1, 1);
+	dispc_reg_out(VENC_OSDHADV, 0);
+
+	davinci_writel(0xa, SYS_VPSS_CLKCTL);
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_CLKCTL, 0x11);
+		davinci_writel(mode_info->left_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM355_OSD_REG_BASE + OSD_BASEPY));
+		davinci_cfg_reg(DM355_VOUT_FIELD);
+		davinci_cfg_reg(DM355_VOUT_COUTL_EN);
+		davinci_cfg_reg(DM355_VOUT_COUTH_EN);
+	} else {
+		davinci_writel(mode_info->left_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPX));
+		davinci_writel(mode_info->upper_margin,
+			       (DM644X_OSD_REG_BASE + OSD_BASEPY));
+		davinci_cfg_reg(DM644X_LFLDEN);
+	}
+
+	/* Set VENC for non-standard timing */
+	davinci_enc_set_display_timing(mode_info);
+
+	/* Enable all VENC, non-standard timing mode, master timing,
+	   HD, interlaced
+	 */
+	if (cpu_is_davinci_dm355()) {
+		dispc_reg_out(VENC_VMOD,
+			      (VENC_VMOD_VENC | VENC_VMOD_VMD |
+			       VENC_VMOD_NSIT));
+	} else {
+		dispc_reg_out(VENC_VMOD,
+			      (VENC_VMOD_VENC | VENC_VMOD_VMD | VENC_VMOD_HDMD |
+			       VENC_VMOD_NSIT));
+	}
+	dispc_reg_out(VENC_LCDOUT, 1);
+}
+
+void davinci_enc_priv_setmode(struct vid_enc_device_mgr *mgr)
+{
+
+	switch (mgr->current_mode.if_type) {
+	case VID_ENC_IF_BT656:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_YCBCR8 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		dispc_reg_merge(VENC_YCCCTL, 1, 1);
+		break;
+	case VID_ENC_IF_BT1120:
+		break;
+	case VID_ENC_IF_YCC8:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_YCBCR8 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		break;
+	case VID_ENC_IF_YCC16:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_YCBCR16 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		break;
+	case VID_ENC_IF_SRGB:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_RGB8 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		break;
+	case VID_ENC_IF_PRGB:
+		dispc_reg_merge(VENC_VMOD,
+				VENC_VMOD_VDMD_RGB666 << VENC_VMOD_VDMD_SHIFT,
+				VENC_VMOD_VDMD);
+		break;
+	default:
+		break;
+	}
+
+	if (strcmp(mgr->current_mode.name, VID_ENC_STD_NTSC) == 0) {
+		davinci_enc_set_ntsc(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_NTSC_RGB) == 0) {
+		davinci_enc_set_ntsc_pal_rgb(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_PAL) == 0) {
+		davinci_enc_set_pal(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_PAL_RGB) == 0) {
+		davinci_enc_set_ntsc_pal_rgb(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_480P_60) == 0) {
+		davinci_enc_set_525p(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_576P_50) == 0) {
+		davinci_enc_set_625p(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_640x480) == 0 ||
+		   strcmp(mgr->current_mode.name, VID_ENC_STD_640x400) == 0 ||
+		   strcmp(mgr->current_mode.name, VID_ENC_STD_640x350) == 0) {
+		davinci_enc_set_prgb(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_720P_60) == 0) {
+		davinci_enc_set_720p(&mgr->current_mode);
+	} else if (strcmp(mgr->current_mode.name, VID_ENC_STD_1080I_30) == 0) {
+		davinci_enc_set_1080i(&mgr->current_mode);
+
+	}
+
+	/* turn off ping-pong buffer and field inversion to fix
+	   the image shaking problem in 1080I mode. The problem i.d. by the
+	   DM6446 Advisory 1.3.8 is not seen in 1080I mode, but the ping-pong
+	   buffer workaround created a shaking problem. */
+	if (cpu_is_davinci_dm644x() &&
+	    strcmp(mgr->current_mode.name, VID_ENC_STD_1080I_30) == 0)
+		davinci_disp_set_field_inversion(0);
+
+	return;
+}
+
+void davinci_enc_set_mode_platform(int channel, struct vid_enc_device_mgr *mgr)
+{
+
+	if (0 == mgr->current_mode.std) {
+		davinci_enc_set_display_timing(&mgr->current_mode);
+		return;
+	}
+	davinci_enc_priv_setmode(mgr);
+}
+
+EXPORT_SYMBOL(davinci_enc_set_mode_platform);
+
+static int davinci_platform_init(void)
+{
+#ifdef CONFIG_SYSFS
+	display_cntl_base = ioremap(DM644X_DDR2_CNTL_BASE, 0x24);
+	if (!display_cntl_base) {
+		printk(KERN_ERR "Could not remap control registers\n");
+		return -EINVAL;
+	}
+	class_register(&davinci_system_class);
+
+	davinci_system_device = create_sysfs_files();
+	if (!davinci_system_device) {
+		printk(KERN_ERR "Could not create davinci system sysfs\n");
+		iounmap(display_cntl_base);
+		return -EINVAL;
+	}
+#endif
+	return 0;
+}
+
+static void davinci_platform_cleanup(void)
+{
+#ifdef CONFIG_SYSFS
+	remove_sysfs_files(davinci_system_device);
+	class_unregister(&davinci_system_class);
+	iounmap(display_cntl_base);
+#endif
+	return;
+}
+
+subsys_initcall(davinci_platform_init);
+module_exit(davinci_platform_cleanup);
+
+MODULE_LICENSE("GPL");
Index: linux-2.6.18/include/asm-arm/arch-davinci/hardware.h
===================================================================
--- linux-2.6.18.orig/include/asm-arm/arch-davinci/hardware.h
+++ linux-2.6.18/include/asm-arm/arch-davinci/hardware.h
@@ -53,6 +53,7 @@
 #define DAVINCI_VLYNQ_REMOTE_BASE		(0x0C000000)
 
 #define DM644X_UART2_BASE                       (0x01C20800)
+#define DM644X_DDR2_CNTL_BASE			(0x20000000)
 
 /*
  * DM6467 base register addresses different from original DaVinci
Index: linux-2.6.18/include/media/davinci/davinci_display.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/davinci_display.h
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2005 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/* davincihd_display.h */
+
+#ifndef DAVINCI_DISPLAY_H
+#define DAVINCI_DISPLAY_H
+
+#ifdef __KERNEL__
+
+/* Header files */
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#include <media/video-buf.h>
+#include <video/davinci_osd.h>
+#include <media/davinci/vid_encoder_types.h>
+
+#define DAVINCI_DISPLAY_MAX_DEVICES 2
+
+enum davinci_display_device_id {
+	DAVINCI_DISPLAY_DEVICE_0,
+	DAVINCI_DISPLAY_DEVICE_1
+};
+
+#define DAVINCI_DISPLAY_MAJOR_RELEASE              1
+#define DAVINCI_DISPLAY_MINOR_RELEASE              0
+#define DAVINCI_DISPLAY_BUILD                      1
+#define DAVINCI_DISPLAY_VERSION_CODE       ((DAVINCI_DISPLAY_MAJOR_RELEASE<<16) | \
+	(DAVINCI_DISPLAY_MINOR_RELEASE<<8)  | \
+	DAVINCI_DISPLAY_BUILD)
+
+#define DAVINCI_DISPLAY_VALID_FIELD(field)   ((V4L2_FIELD_NONE == field) || \
+	 (V4L2_FIELD_ANY == field) || (V4L2_FIELD_INTERLACED == field))
+
+/* Macros */
+#define ISNULL(p)       ((NULL) == (p))
+#define ISALIGNED(a)    (0 == (a%8))
+
+/* Exp ratio numerator and denominator constants */
+#define DAVINCI_DISPLAY_H_EXP_RATIO_N   (9)
+#define DAVINCI_DISPLAY_H_EXP_RATIO_D   (8)
+#define DAVINCI_DISPLAY_V_EXP_RATIO_N   (6)
+#define DAVINCI_DISPLAY_V_EXP_RATIO_D   (5)
+
+/* Zoom multiplication factor */
+#define DAVINCI_DISPLAY_ZOOM_4X (4)
+#define DAVINCI_DISPLAY_ZOOM_2X (2)
+
+#define DAVINCI_DISPLAY_PIXELASPECT_NTSC 		{11, 10}
+#define DAVINCI_DISPLAY_PIXELASPECT_PAL  		{54, 59}
+#define DAVINCI_DISPLAY_PIXELASPECT_SP    	    {1, 1}
+
+/* settings for commonly used video formats */
+#define DAVINCI_DISPLAY_WIN_NTSC     {0, 0, 720, 480}
+#define DAVINCI_DISPLAY_WIN_PAL      {0, 0, 720, 576}
+#define DAVINCI_DISPLAY_WIN_640_480  {0, 0, 640, 480}
+#define DAVINCI_DISPLAY_WIN_640_400  {0, 0, 640, 400}
+#define DAVINCI_DISPLAY_WIN_640_350  {0, 0, 640, 350}
+#define DAVINCI_DISPLAY_WIN_720P  {0, 0, 1280, 720}
+#define DAVINCI_DISPLAY_WIN_1080I  {0, 0, 1920, 1080}
+
+/* Structures */
+struct display_layer_info {
+	int enable;
+	enum davinci_disp_layer id;	/* Layer ID used by Display Manager */
+	struct davinci_layer_config config;
+	enum davinci_zoom_factor h_zoom;
+	enum davinci_zoom_factor v_zoom;
+	enum davinci_h_exp_ratio h_exp;
+	enum davinci_v_exp_ratio v_exp;
+};
+
+/* display object structure */
+struct display_obj {
+	/* Buffer specific parameters */
+	u32 fbuffers[VIDEO_MAX_FRAME];	/* List of buffer pointers for
+					   storing frames */
+	u32 numbuffers;		/* number of buffers in fbuffers */
+	struct videobuf_buffer *curFrm;	/* Pointer pointing to current
+					   v4l2_buffer */
+	struct videobuf_buffer *nextFrm;	/* Pointer pointing to current
+						   v4l2_buffer */
+	/* videobuf specific parameters */
+	struct videobuf_queue buffer_queue;	/* Buffer queue used in
+						   video-buf */
+	struct list_head dma_queue;	/* Queue of filled frames */
+	spinlock_t irqlock;	/* Used in video-buf */
+
+	/* V4l2 specific parameters */
+	struct video_device *video_dev;	/* Identifies video device for
+					   this layer */
+	enum v4l2_memory memory;	/* This field keeps track of type
+					   of buffer exchange mechanism user
+					   has selected */
+	struct v4l2_prio_state prio;	/* Used to keep track of state of
+					   the priority */
+	struct v4l2_pix_format pix_fmt;	/* Used to store pixel format */
+	enum v4l2_field buf_field;
+
+	/* Video layer configuration params */
+	struct display_layer_info layer_info;
+
+	/* vpbe specific parameters */
+	unsigned char window_enable;	/*enabke window for display */
+
+	u32 usrs;		/* number of open instances of
+				   the layer */
+	u32 io_usrs;		/* number of users performing
+				   IO */
+	u32 field_id;		/* Indicates id of the field
+				   which is being displayed */
+
+	u8 started;		/* Indicates whether streaming
+				   started */
+	enum davinci_display_device_id device_id;	/* Identifies device object */
+};
+
+/* File handle structure */
+struct davinci_fh {
+	struct display_obj *layer;	/* pointer to layer object for
+					   opened device */
+	u8 io_allowed;		/* Indicates whether this file handle
+				   is doing IO */
+	enum v4l2_priority prio;	/* Used to keep track priority of
+					   this instance */
+};
+
+/* vpbe device structure */
+struct davinci_display {
+	/* layer specifc parameters */
+	struct semaphore lock;	/* lock used to access this
+				   structure */
+
+	/* Display mode information */
+	struct vid_enc_mode_info mode_info;
+
+	/* interrupt callback */
+	struct davinci_disp_callback event_callback;
+
+	struct display_obj *dev[DAVINCI_DISPLAY_MAX_DEVICES];
+};
+
+struct buf_config_params {
+	u8 min_numbuffers;
+	u8 numbuffers[DAVINCI_DISPLAY_MAX_DEVICES];
+	u32 min_bufsize[DAVINCI_DISPLAY_MAX_DEVICES];
+	u32 layer_bufsize[DAVINCI_DISPLAY_MAX_DEVICES];
+};
+
+#endif				/* End of __KERNEL__ */
+
+#endif				/* DAVINCI_DISPLAY_H */
Index: linux-2.6.18/include/media/davinci/davinci_enc.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/davinci_enc.h
@@ -0,0 +1,249 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ *
+ * davinci_enc.h.
+ * This file contains APIs exported by Davinci Encoder Manager. Davinci Encoder
+ * manager uses the services from encoder interface for implementing it's
+ * functionality.
+ * It also configure the VENC/DLCD to support a specific video/graphics mode
+ * This interface allows set/get of output, mode , parameters and controls at
+ * the encoder. encoder may support multiple channels, each with a set of
+ * encoders So encoder manager support registration of encoders and APIs
+ * on a per channel basis.
+ */
+
+#ifndef DAVINCI_ENC_H
+#define DAVINCI_ENC_H
+
+#ifdef __KERNEL__
+#include <linux/config.h>
+#include <media/davinci/vid_encoder_types.h>
+
+/**
+ *  Maximum channels supported by encoder manager. Set to 1 for DM355 & DM6446.
+ * If a platform support multiple channel, this needs to be changed. Channel
+ * number starts with 0
+ */
+#define DAVINCI_ENC_MAX_CHANNELS	CONFIG_ENC_MNGR_MAX_CHANNELS
+
+/**
+ * function davinci_enc_setparams
+ * @params: pointer to params structure.
+ * @channel: channel number.
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set parameters at current active encoder. params will be defined by
+ * the specific encoder and used by user space applications to set
+ * encoder parameters.
+ */
+int davinci_enc_setparams(int channel, void *params);
+
+/**
+ * function davinci_enc_getparams
+ * @params: pointer to params structure.
+ * @channel: channel number, 0 for first channel and so forth
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get parameters at current active encoder. params will be defined by
+ * the specific encoder and used by user space applications to get
+ * encoder parameters.
+ */
+int davinci_enc_getparams(int channel, void *params);
+
+/**
+ * function davinci_enc_set_mode
+ * @channel: channel number.
+ * @mode_info: ptr to vid_enc_mode_info structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   set standard or non-standard mode at current encoder's active output.
+ * Encoder Manager first configure the VENC or associated SoC hardware
+ * before calling the setmode() API of the encoder. To do so, encoder Manager
+ * calls the getmode() to get the mode_info for this mode and configure the
+ * mode based on the timing information present in this structure.
+ */
+int davinci_enc_set_mode(int channel, struct vid_enc_mode_info *mode_info);
+/**
+ * function davinci_enc_get_mode
+ * @channel: channel number, starting index 0.
+ * @mode_info: ptr to vid_enc_mode_info structure. This is updated by
+ * encoder manager
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   get video or graphics mode at current encoder's active output.
+ *
+ */
+int davinci_enc_get_mode(int channel, struct vid_enc_mode_info *mode_info);
+
+/**
+ * function davinci_enc_set_control
+ * @channel: channel number.
+ * @ctrl: davinci_vid_enc_control type
+ * @val:  control value to be set
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set controls at the current encoder's output.
+ *
+ */
+int davinci_enc_set_control(int channel, enum vid_enc_ctrl_id ctrl, char val);
+
+/**
+ * function davinci_enc_get_control
+ * @channel: channel number.
+ * @ctrl: control type as per davinci_vid_enc_ctrl_type
+ * @val:  ptr to value that gets updated
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get controls at the current encoder's output.
+ *
+ */
+int davinci_enc_get_control(int channel, enum vid_enc_ctrl_id ctrl, char *val);
+
+/**
+ * function davinci_enc_set_output
+ * @channel: channel number.
+ * @output: ptr to output name string
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Set output - Set channel's output to the one identified by output string
+ * The encoder manager calls enumoutput() of each of the encoder to determine
+ * the encoder that supports this output and set this encoder as the current
+ * encoder. It calls setoutput() of the selected encoder. Encoder is expected
+ * to set a default mode on this output internally. Manager calls the getmode()
+ * to get information about the mode to configure the SoC hardware (VENC/DLCD
+ * for Davinci/DM355. During configuration of the SoC hardware for timing,
+ * mgr would call enable() to disable and re-enable the output of the encoder
+ * to avoid noise at the display. It may also call reset() to make sure the
+ * encoder is reset if required by the encoder hardware.
+ */
+int davinci_enc_set_output(int channel, char *output);
+
+/**
+ * function davinci_enc_get_output
+ * @channel: channel number.
+ * @output: ptr to array of char to hold output name. size
+ * VID_ENC_NAME_MAX_CHARS
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *   Get output - Get channel's output. User call this to get the current
+ *   output name
+ */
+int davinci_enc_get_output(int channel, char *output);
+
+/**
+ * function davinci_enc_reset
+ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *  Do a software Reset the current encoder. Some of the encoders require this.
+ * This shouldn't affect the contents of the registers configured already for
+ * for output, standard, control etc. If there is no support, encoder doesn't
+ * implement this API.
+ */
+int davinci_enc_reset(int channel);
+
+/**
+ * function davinci_enc_enable_output
+ * @channel: channel number. DAVINCI_ENC_MAX_CHANNELS set to 1
+ * @flag: flag to indicate enable or disable, 0 - disable, 1 - enable
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ *  Enable/Disable the current ouput. While the VPSS is configured for a
+ * video mode or graphics mode, you may observe noise on the display device
+ * due to timing changes. To avoid this, the output may be disabled during
+ * configuration of the VENC or related hardware in the VPSS and re-enabled
+ * using this API. This will switch the output DACs Off or On based on the
+ * flag.
+ */
+int davinci_enc_enable_output(int channel, int flag);
+
+/**
+ * davinci_enc_enable_vbi
+ * @flag: flag which tells whether to enable or disable raw vbi
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * This function is used to enable/disable RAW VBI sending in
+ * the encoder.
+ */
+int davinci_enc_enable_vbi(int channel, int flag);
+
+/**
+ * davinci_enc_enable_hbi
+ * @channel: channel number (0 to MAX_CHANNELS-1)
+ * @flag: flag which tells whether to enable or disable raw hbi
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * This function is used to enable/disable RAW HBI sending in
+ * the encoder.
+ */
+int davinci_enc_enable_hbi(int channel, int flag);
+
+/**
+ * davinci_enc_enable_sliced_vbi
+ * @channel: channel number.
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Following funcion is used to enable support for
+ * sending set of sliced vbi services. Caller calls
+ * this function with pointer to the structure vid_enc_sliced_vbi_service
+ */
+int davinci_enc_enable_sliced_vbi(int channel,
+				  struct vid_enc_sliced_vbi_service *service);
+/**
+ * davinci_enc_enable_sliced_vbi
+ * @channel: channel number.
+ * @service: pointer to the structure vid_enc_sliced_vbi_service
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Following funcion is used to enable support for
+ * sending set of sliced vbi services. Caller calls
+ * this function with pointer to the structure vid_enc_sliced_vbi_service
+ */
+int davinci_enc_get_sliced_cap(int channel,
+			       struct vid_enc_sliced_vbi_service *services);
+
+/**
+ * davinci_enc_write_sliced_vbi_data
+ * @channel: channel number.
+ * @data: pointer to the structure vid_enc_sliced_vbi_data
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int davinci_enc_write_sliced_vbi_data(int channel,
+				      struct vid_enc_sliced_vbi_data *data);
+
+#endif				/* #ifdef __KERNEL__ */
+#endif				/* #ifdef DAVINCI_ENC_H */
Index: linux-2.6.18/include/media/davinci/davinci_enc_mngr.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/davinci_enc_mngr.h
@@ -0,0 +1,57 @@
+
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef DAVINCI_ENC_MNGR_H
+#define DAVINCI_ENC_MNGR_H
+
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/io.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <video/davinci_vpbe.h>
+
+#ifdef __KERNEL__
+
+#define DAVINCI_ENC_MAX_ENCODERS (4)
+
+struct vid_enc_device_mgr {
+	struct semaphore lock;
+	int num_encoders;	/* number of encoders in this channel */
+	int current_encoder;	/* index to current encoder */
+	char current_output[VID_ENC_NAME_MAX_CHARS];	/* current output */
+	struct vid_enc_mode_info current_mode;	/* current mode */
+	struct vid_encoder_device *encoder[DAVINCI_ENC_MAX_ENCODERS];
+};
+
+struct enc_config {
+	char output[VID_ENC_NAME_MAX_CHARS];
+	char mode[VID_ENC_NAME_MAX_CHARS];
+};
+
+#endif				/* __KERNEL__ */
+
+#endif
Index: linux-2.6.18/include/media/davinci/davinci_platform.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/davinci_platform.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef DAVINCI_PLATFORM_H
+#define DAVINCI_PLATFORM_H
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/io.h>
+#include <media/davinci/davinci_enc.h>
+#include <media/davinci/vid_encoder_types.h>
+#include <video/davinci_vpbe.h>
+#include <media/davinci/davinci_enc_mngr.h>
+
+#ifdef __KERNEL__
+int davinci_enc_select_venc_clock(int clk);
+void davinci_enc_set_display_timing(struct vid_enc_mode_info *mode);
+void davinci_enc_set_mode_platform(int channel, struct vid_enc_device_mgr *mgr);
+
+#endif				/* End of __KERNEL__ */
+
+#endif				/* End of ifndef DAVINCI_PLATFORM_H */
Index: linux-2.6.18/include/media/davinci/vid_encoder_if.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/vid_encoder_if.h
@@ -0,0 +1,287 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * File: vid_encoder_if.h
+ * Description:
+ * ============
+ * This file defines the interface to allow abstraction of an encoder hardware
+ * to an encoder module. Each encoder module support one or more display
+ * channels. It registers with the encoder manager at init and
+ * unregisters at exit. Encoder modules implement a set of operations defines
+ * by this interface. For each display channel, encoder manager selects
+ * one of the encoder registered with it to support the user specified output
+ * and video/graphics modes on that output. First step is to set the output
+ * as requested by the user. To do so, encoder manager iterates through
+ * all supported encoders to match a given output name as requested by the user
+ * by calling enumoutput(). Once there is a match, this encoder is set as the
+ * current active encoder. Encoder manager calls initialize() to init the
+ * encoder and then calls setouput() set the output. If another encoder was
+ * active before this, encoder manager calls deinitialize() to make it
+ * inactive. Encoder must select a default mode for this output as part of
+ * setoutput() call. To set a mode, user call setmode(). All output names and
+ * mode names are defined in vid_encoder_types.h
+ */
+
+#ifndef VID_ENCODER_IF_H
+#define VID_ENCODER_IF_H
+
+#ifdef __KERNEL__
+#include <media/davinci/vid_encoder_types.h>
+
+struct vid_encoder_device;
+/**
+ * struct vid_enc_param_ops
+ * @setparams:
+ * @getparams:
+ *
+ * Description:
+ * Operation used for setting and getting encoder specific parameters.
+ * Operations are applied to the current encoder selected by the
+ * encoder manager
+ * @setparams: pointer to setparams function. This Set Encoder parameters.
+ *    @params - params structure type ptr declared by encoder
+ *    @enc - encoder device ptr
+ *    Returns - zero on success and non-zero otherwise
+ * @getparams: pointer to getparams function. This Get encoder parameters
+ *    @params - params structure type ptr declared by encoder
+ *    @enc - encoder device ptr
+ *    Returns - zero on success and non-zero otherwise
+ */
+struct vid_enc_param_ops {
+	int (*setparams) (void *params, struct vid_encoder_device * enc);
+	int (*getparams) (void *params, struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_enc_mode_ops
+ * @setmode:
+ * @getmode:
+ *
+ * Description:
+ *  video/graphics mode ops structure. Operations are applied to the
+ *  current output selected by the encoder
+ * @setmode: Function pointer to setmode. set video/graphics mode or standard
+ *    for current output encoder first check if the std flag is present in the
+ *    mode_info. if yes, it will use name field to match a standard mode. If std
+ *    flag is reset, it may reject the command if non-standard mode
+ *    is not implemented. If non-standard mode is implemented, it would
+ *    save the timing information in the internal structure with a
+ *    key,VID_ENC_STD_NON_STANDARD as defined in vid_encoder_types.h
+ *    It is expected that only one such instance is defined in the video driver.
+ *    Please consider defining a mode in the vid_encoder_types.h
+ *    and use that instead if encoder is to be extended to support additional
+ *    modes not already supported by existing encoders.
+ *    mode_info - ptr to mode information structure.
+ *    enc - encoder device ptr.
+ *    Returns - zero on success and non-zero otherwise.
+ * @getmode: Function pointer to getmode. get current video/graphics mode
+ *    information at the outpu.t
+ *    mode_info - ptr to mode information structure.
+ *    enc - encoder device ptr.
+ *    Returns - zero on success and non-zero otherwise.
+ */
+struct vid_enc_mode_ops {
+	int (*setmode) (struct vid_enc_mode_info * mode_info,
+			struct vid_encoder_device * enc);
+	int (*getmode) (struct vid_enc_mode_info * mode_info,
+			struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_enc_control_ops
+ * @setcontrol:
+ * @getcontrol:
+ *
+ * Description:
+ * Control ops structure. Control operations are performed for the current
+ * output. Control brightness, hue, contrast, saturation etc.
+ * @setcontrol: Function pointer to setcontrol. Set control value.
+ *   ctrl - control type.
+ *   val - value to be set for the control.
+ *   enc - ptr to encoder device.
+ *   Returns - zero on success and non-zero otherwise.
+ * @getcontrol: Function pointer to getcontrol. Get control value.
+ *   ctrl - control type.
+ *   val - ptr to value that gets updated
+ *   enc - ptr to encoder device
+ *   Returns - zero on success and non-zero otherwise
+ */
+struct vid_enc_control_ops {
+	int (*setcontrol) (enum vid_enc_ctrl_id ctrl,
+			   unsigned char val, struct vid_encoder_device * enc);
+	int (*getcontrol) (enum vid_enc_ctrl_id ctrl,
+			   unsigned char *val, struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_enc_output_ops
+ * @count: Indicates number of outputs supported
+ * @enumoutput:
+ * @setoutput:
+ * @getoutput:
+ *
+ * Description:
+ * output ops structure. enumoutput() is called to iterate
+ * through all outputs supported by the encoder. Encoder manager ues
+ * this API to select an encoder based on the output to be supported.
+ * setoutput is called to set output at the encoder. getoutput is called
+ * for getting the current output at the encoder.
+ * @enumoutput:
+ *   Function pointer.
+ *   index - index of the output.
+ *   output - ptr to char array to hold output name.(size
+ *   		VID_ENC_NAME_MAX_CHARS).
+ *   enc - pointer to encoder device.
+ *   Returns - zero on success and non-zero otherwise.
+ *   enumerates the outputs supported by encoder. To iterate the output, caller
+ *   call this successively, starting with an index set to 0, and incrementing
+ *   the same until this function returns non-zero. Each time name of the output
+ *   at the given index is copied to output. Beware that this API assumes the
+*   passed in output array size is VID_ENC_NAME_MAX_CHARS.
+ * @setoutput:
+ *   Function pointer.
+ *   setoutput to the given output identifed by name. Encoder also must set a
+ *   default mode on the selected output.
+*   output - ptr to output name string.
+*   enc - pointer to encoder device.
+ *   Returns - zero on success and non-zero otherwise.
+ * @getoutput:
+ *   Function pointer.
+ *   getoutput returns name of current output selected at the encoder.
+ *   output - ptr to char array to hold the output name. (size
+ *   		VID_ENC_NAME_MAX_CHARS).
+ *   enc - pointer to encoder device.
+ *   Returns - zero on success and non-zero otherwise.
+ */
+struct vid_enc_output_ops {
+	int count;
+	int (*enumoutput) (int index,
+			   char *output, struct vid_encoder_device * enc);
+	int (*setoutput) (char *output, struct vid_encoder_device * enc);
+	int (*getoutput) (char *output, struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_enc_misc_ops
+ * @reset:
+ * @enable: *
+ * Description:
+ *  misc ops structure. Applied for the current encoder selected by the
+ *  encoder manager
+ * @reset: Function pointer to reset.
+ *    For soft reset. Encoder may implement a soft reset that doesn't affect
+ *    any configured registers. Some of the encoder hardware may require
+ *    this if the input signal timings are changed after configuring it's
+ *    mode registers.
+ *    enc - ptr to encoder device.
+ *    Returns - zero on success and non-zero otherwise
+ * @enable: Function pointer to enable.
+ *    enable/disable output. To eliminate noise on the display during SoC mode
+ *    timing configuration, user may call this function to switch Off/On
+ *    the output. Encoder must implement this API call if there is a hardware
+ *    support for the same.
+ *    flag - 0 - disable, 1 - enable.
+ *    enc - ptr to encoder device.
+ *    Returns - zero on success and non-zero otherwise
+ */
+struct vid_enc_misc_ops {
+	int (*reset) (struct vid_encoder_device * enc);
+	int (*enable) (int flag, struct vid_encoder_device * enc);
+};
+
+/**
+ * struct vid_encoder_device
+ * @name: Name of the encoder device
+ * @channel_id:  Id of the channel to which encoder is connected
+ * @capabilities: encoder capabilities. This is only for VBI capabilities
+ * @initialize: Pointer to initialize function to initialize encoder
+ * @mode_ops: Set of functions pointers for standard related functions
+ * @ctrl_ops: Set of functions pointers for control related functions
+ * @output_ops: Set of functions pointers for output related functions
+ * @fmt_ops: Set of functions pointers for format related functions
+ * @params_ops: Set of functions pointers for params related functions
+ * @misc_ops: Set of functions pointers for miscellaneous functions functions
+ * @deinitialize: functions pointer to de-initialize functio
+ * @start_display: function to start display.
+ * @stop_display: function to stop display.
+ * @write_vbi_data: function to write sliced vbi data.
+ * @enable_vbi: Function to enable support for RAW VBI.
+ * @enable_hbi: Function to enable support for RAW HBI.
+ * @set_vbi_services: function to enable sliced vbi services
+ *
+ * Description:
+ * output ops structure
+ *   Channel_id is used when encoder support multiple channels. In this case
+ *   encoder module will use the channel id to select the channel for
+ *   which the operation applies.
+ *   initialize() called by encoder manager to initialize the encoder. Usually
+ *   called before invoking any operations on the encoder.flag may be used by
+ *   the encoder module to do different level of initialization. Encoder
+ *   module must set a default output and mode in this code.
+ *   deinitialize() called to deinitialize the current encoder that is active
+ *   before initializing the new encoder.
+ */
+struct vid_encoder_device {
+	u8 name[VID_ENC_NAME_MAX_CHARS];
+	int channel_id;
+	u32 capabilities;
+	int (*initialize) (struct vid_encoder_device * enc, int flag);
+	struct vid_enc_mode_ops *mode_ops;
+	struct vid_enc_control_ops *ctrl_ops;
+	struct vid_enc_output_ops *output_ops;
+	struct vid_enc_param_ops *params_ops;
+	struct vid_enc_misc_ops *misc_ops;
+	int (*write_vbi_data) (struct vid_enc_sliced_vbi_data * data,
+			       struct vid_encoder_device * enc);
+	int (*enable_vbi) (int flag, struct vid_encoder_device * enc);
+	int (*enable_hbi) (int flag, struct vid_encoder_device * enc);
+	int (*set_vbi_services) (struct vid_enc_sliced_vbi_service * services,
+				 struct vid_encoder_device * enc);
+	int (*get_sliced_cap) (struct vid_enc_sliced_vbi_service *,
+			       struct vid_encoder_device * enc);
+	int (*deinitialize) (struct vid_encoder_device * enc);
+	int (*start_display) (struct vid_encoder_device * enc);
+	int (*stop_display) (struct vid_encoder_device * enc);
+};
+
+/**
+ * vid_enc_register_encoder
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int vid_enc_register_encoder(struct vid_encoder_device
+			     *encoder);
+
+/**
+ * vid_enc_unregister_encoder
+ * @encoder: pointer to the encoder device structure
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Unregister the encoder module with the encoder manager
+ * This is implemented by the encoder Manager
+ */
+int vid_enc_unregister_encoder(struct vid_encoder_device
+			       *encoder);
+
+#endif				/* #ifdef __KERNEL__ */
+
+#endif				/* #ifdef VID_ENCODER_IF_H */
Index: linux-2.6.18/include/media/davinci/vid_encoder_types.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/media/davinci/vid_encoder_types.h
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2007 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * vid_encoder_types.h
+ * This file contains data types which will be used across encoder manager
+ * , encoders and users of both interfaces */
+
+#ifndef VID_ENCODER_TYPES_H
+#define VID_ENCODER_TYPES_H
+
+#ifdef __KERNEL__
+
+/**
+ * enum vid_enc_init_flag
+ * @VID_ENC_I2C_BIND_FLAG: Only I2C bind
+ * @VID_ENC_FULL_INIT_FLAG: Full initialization
+ *
+ * Description:
+ * An enumeration of the encoder initialization flag.
+ */
+enum vid_enc_init_flag {
+	VID_ENC_I2C_BIND_FLAG,
+	VID_ENC_FULL_INIT_FLAG,
+};
+
+/**
+ * enum vid_enc_frame_type
+ * @VID_ENC_FRAME_INTERLACED: Interlaced frame
+ * @VID_ENC_FRAME_PROGRESSIVE: Progressive frame
+ *
+ * Description:
+ * An enumeration of the Frame Formats.
+ */
+enum vid_enc_frame_type {
+	VID_ENC_FRAME_INTERLACED,
+	VID_ENC_FRAME_PROGRESSIVE,
+};
+
+/** VID_ENC_NAME_MAX_CHARS
+ *
+ * Description:
+ * MAX characters in the name.
+ */
+#define VID_ENC_NAME_MAX_CHARS	30
+
+/**
+ * enum vid_enc_if_type
+ * @VID_ENC_IF_INT: for internal DAC
+ * @VID_ENC_IF_BT656: for BT656 input format
+ * @VID_ENC_IF_BT1120: for BT1120 input format
+ * @VID_ENC_IF_YCC8: for YCC8 input format
+ * @VID_ENC_IF_YCC16: for YCC16 input format
+ * @VID_ENC_IF_SRGB: for SRGB input format
+ * @VID_ENC_IF_PRGB: for PRGB input format
+ *
+ * Description:
+ * An enumeration of the encoder interface types.
+ *
+ */
+enum vid_enc_if_type {
+	VID_ENC_IF_INT,
+	VID_ENC_IF_BT656,
+	VID_ENC_IF_BT1120,
+	VID_ENC_IF_YCC8,
+	VID_ENC_IF_YCC16,
+	VID_ENC_IF_SRGB,
+	VID_ENC_IF_PRGB,
+};
+
+/**
+ * constant strings for standard names or mode names. All modules uses this to
+ * refer a specific standard or mode name
+ */
+#define VID_ENC_STD_NTSC         "NTSC"
+#define VID_ENC_STD_NTSC_RGB     "NTSC-RGB"
+#define VID_ENC_STD_PAL          "PAL"
+#define VID_ENC_STD_PAL_RGB      "PAL-RGB"
+#define VID_ENC_STD_720P_25      "720P-25"
+#define VID_ENC_STD_720P_30      "720P-30"
+#define VID_ENC_STD_720P_50      "720P-50"
+#define VID_ENC_STD_720P_60      "720P-60"
+#define VID_ENC_STD_1080I_25     "1080I-25"
+#define VID_ENC_STD_1080I_30     "1080I-30"
+#define VID_ENC_STD_1080P_24	 "1080P-24"
+#define VID_ENC_STD_1080P_25     "1080P-25"
+#define VID_ENC_STD_1080P_30     "1080P-30"
+#define VID_ENC_STD_1080P_50     "1080P-50"
+#define VID_ENC_STD_1080P_60     "1080P-60"
+#define VID_ENC_STD_480P_60      "480P-60"
+#define VID_ENC_STD_576P_50      "576P-50"
+#define VID_ENC_STD_640x480      "640x480"
+#define VID_ENC_STD_640x400      "640x400"
+#define VID_ENC_STD_640x350      "640x350"
+#define VID_ENC_STD_NON_STANDARD "NON-STANDARD"
+
+/**
+ * enum vid_enc_ctrl_id
+ * @VID_ENC_CTRL_GAIN: Gain control
+ * @VID_ENC_CTRL_BRIGHTNESS: Brighness control
+ * @VID_ENC_CTRL_CONTRAST: Contrast control
+ * @VID_ENC_CTRL_HUE: Hue control
+ * @VID_ENC_CTRL_SATURATION: Saturation Control
+ *
+ * Description:
+ * Constants used for control type IDs
+*/
+enum vid_enc_ctrl_id {
+	VID_ENC_CTRL_GAIN,
+	VID_ENC_CTRL_BRIGHTNESS,
+	VID_ENC_CTRL_CONTRAST,
+	VID_ENC_CTRL_HUE,
+	VID_ENC_CTRL_SATURATION,
+};
+
+/**
+ * constant strings for output names. All modules uses this to
+ * refer a specific output at the encoder hardware or VPBE analog output.
+ * May add additional output names as per following convention. First
+ * output of a type is always with out a suffix, and subsequent outputs
+ * of the same type is defined with suffix x increasing from 1 to max
+ * output names supported as shown below.
+ */
+#define VID_ENC_OUTPUT_COMPOSITE  "COMPOSITE"
+#define VID_ENC_OUTPUT_COMPOSITE1 "COMPOSITE1"
+#define VID_ENC_OUTPUT_SVIDEO     "SVIDEO"
+#define VID_ENC_OUTPUT_SVIDEO1    "SVIDEO1"
+#define	VID_ENC_OUTPUT_COMPONENT  "COMPONENT"
+#define	VID_ENC_OUTPUT_COMPONENT1 "COMPONENT1"
+#define VID_ENC_OUTPUT_LCD        "LCD"
+#define VID_ENC_OUTPUT_LCD1       "LCD1"
+
+/**
+ * struct vid_enc_fract
+ * @numerator: numerator part of a fractional number
+ * @denominator: denominator part of a fractional number
+ *
+ * Description:
+ *  Structure used to represent fractional numbers
+ */
+struct vid_enc_fract {
+	unsigned int numerator;
+	unsigned int denominator;
+};
+
+/* Set of macros for sliced vbi services */
+#define VID_ENC_SLICED_VBI_WSS_PAL	0x0001
+#define VID_ENC_SLICED_VBI_CGMS_NTSC	0x0002
+#define VID_ENC_SLICED_VBI_CC_NTSC	0x0004
+
+/**
+ * struct vid_enc_sliced_vbi_service
+ * @service_set: set of services to be enabled in encoder
+ * @line: line number of the field in which data for these
+ * services is to be included.
+ *
+ * Description:
+ *  Structure used to enable set of sliced VBI services in encoder
+ */
+struct vid_enc_sliced_vbi_data {
+
+	unsigned int service_id;
+	unsigned char field;
+	unsigned char data[48];
+};
+
+struct vid_enc_sliced_vbi_service {
+	unsigned short service_set;
+	unsigned int line[2][23];
+};
+
+/**
+ * struct vid_enc_mode_info
+ * @name: ptr to name string of the standard, "NTSC", "PAL" etc
+ * @std: standard or non-standard mode. 1 - standard, 0 - nonstandard
+ * @if_type: interface type used for this standard configuration
+ * @interlaced: 1 - interlaced, 0 - non interlaced/progressive
+ * @xres: x or horizontal resolution of the display
+ * @yres: y or vertical resolution of the display
+ * @fps: frame per second
+ * @left_margin: left margin of the display
+ * @right_margin: right margin of the display
+ * @upper_margin: upper margin of the display
+ * @lower_margin: lower margin of the display
+ * @hsync_len: h-sync length
+ * @vsync_len: v-sync length
+ * @flags: bit field: bit usage is documented below
+ *
+ * Description:
+ *  Structure holding timing and resolution information of a standard.
+ *  Notes
+ *  ------
+ *  if_type should be used only by encoder manager and encoder.
+ *  flags usage
+ *     b0 (LSB) - hsync polarity, 0 - negative, 1 - positive
+ *     b1       - vsync polarity, 0 - negative, 1 - positive
+ *     b2       - field id polarity, 0 - negative, 1  - positive
+ */
+struct vid_enc_mode_info {
+	unsigned char *name;
+	unsigned int std;
+	enum vid_enc_if_type if_type;
+	unsigned int interlaced;
+	unsigned int xres;
+	unsigned int yres;
+	struct vid_enc_fract fps;
+	unsigned int left_margin;
+	unsigned int right_margin;
+	unsigned int upper_margin;
+	unsigned int lower_margin;
+	unsigned int hsync_len;
+	unsigned int vsync_len;
+	unsigned int flags;
+};
+
+#endif				/* #ifdef __KERNEL__ */
+
+#endif				/* #ifdef VID_ENCODER_TYPES_H */
Index: linux-2.6.18/include/video/davinci_osd.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/video/davinci_osd.h
@@ -0,0 +1,887 @@
+/*
+ * Header file for the TI DaVinci On-Screen Display Manager
+ *
+ * Andy Lowe (alowe@mvista.com), MontaVista Software
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef _DAVINCI_OSD_H
+#define _DAVINCI_OSD_H
+
+/**
+ * enum davinci_disp_layer
+ * @WIN_OSD0: On-Screen Display Window 0
+ * @WIN_VID0: Video Window 0
+ * @WIN_OSD1: On-Screen Display Window 1
+ * @WIN_VID1: Video Window 1
+ *
+ * Description:
+ * An enumeration of the DaVinci display layers.
+ */
+enum davinci_disp_layer {
+	WIN_OSD0,
+	WIN_VID0,
+	WIN_OSD1,
+	WIN_VID1,
+};
+
+/**
+ * enum davinci_osd_layer
+ * @OSDWIN_OSD0: On-Screen Display Window 0
+ * @OSDWIN_OSD1: On-Screen Display Window 1
+ *
+ * Description:
+ * An enumeration of the DaVinci OSD layers.
+ */
+enum davinci_osd_layer {
+	OSDWIN_OSD0,
+	OSDWIN_OSD1,
+};
+
+/**
+ * enum davinci_pix_format
+ * @PIXFMT_1BPP: 1-bit-per-pixel bitmap
+ * @PIXFMT_2BPP: 2-bits-per-pixel bitmap
+ * @PIXFMT_4BPP: 4-bits-per-pixel bitmap
+ * @PIXFMT_8BPP: 8-bits-per-pixel bitmap
+ * @PIXFMT_RGB565: 16-bits-per-pixel RGB565
+ * @PIXFMT_YCbCrI: YUV 4:2:2
+ * @PIXFMT_RGB888: 24-bits-per-pixel RGB888
+ * @PIXFMT_YCrCbI: YUV 4:2:2 with chroma swap
+ * @PIXFMT_OSD_ATTR: OSD Attribute Window pixel format (4bpp)
+ *
+ * Description:
+ * An enumeration of the DaVinci pixel formats.
+ */
+enum davinci_pix_format {
+	PIXFMT_1BPP = 0,
+	PIXFMT_2BPP,
+	PIXFMT_4BPP,
+	PIXFMT_8BPP,
+	PIXFMT_RGB565,
+	PIXFMT_YCbCrI,
+	PIXFMT_RGB888,
+	PIXFMT_YCrCbI,
+	PIXFMT_OSD_ATTR,
+};
+
+/**
+ * enum davinci_h_exp_ratio
+ * @H_EXP_OFF: no expansion (1/1)
+ * @H_EXP_9_OVER_8: 9/8 expansion ratio
+ * @H_EXP_3_OVER_2: 3/2 expansion ratio
+ *
+ * Description:
+ * An enumeration of the available horizontal expansion ratios.
+ */
+enum davinci_h_exp_ratio {
+	H_EXP_OFF,
+	H_EXP_9_OVER_8,
+	H_EXP_3_OVER_2,
+};
+
+/**
+ * enum davinci_v_exp_ratio
+ * @V_EXP_OFF: no expansion (1/1)
+ * @V_EXP_6_OVER_5: 6/5 expansion ratio
+ *
+ * Description:
+ * An enumeration of the available vertical expansion ratios.
+ */
+enum davinci_v_exp_ratio {
+	V_EXP_OFF,
+	V_EXP_6_OVER_5,
+};
+
+/**
+ * enum davinci_zoom_factor
+ * @ZOOM_X1: no zoom (x1)
+ * @ZOOM_X2: x2 zoom
+ * @ZOOM_X4: x4 zoom
+ *
+ * Description:
+ * An enumeration of the available zoom factors.
+ */
+enum davinci_zoom_factor {
+	ZOOM_X1,
+	ZOOM_X2,
+	ZOOM_X4,
+};
+
+/**
+ * enum davinci_clut
+ * @ROM_CLUT: ROM CLUT
+ * @RAM_CLUT: RAM CLUT
+ *
+ * Description:
+ * An enumeration of the available Color Lookup Tables (CLUTs).
+ */
+enum davinci_clut {
+	ROM_CLUT,
+	RAM_CLUT,
+};
+
+/**
+ * enum davinci_rom_clut
+ * @ROM_CLUT0: Macintosh CLUT
+ * @ROM_CLUT1: CLUT from DM270 and prior devices
+ *
+ * Description:
+ * An enumeration of the ROM Color Lookup Table (CLUT) options.
+ */
+enum davinci_rom_clut {
+	ROM_CLUT0,
+	ROM_CLUT1,
+};
+
+/**
+ * enum davinci_blending_factor
+ * @OSD_0_VID_8: OSD pixels are fully transparent
+ * @OSD_1_VID_7: OSD pixels contribute 1/8, video pixels contribute 7/8
+ * @OSD_2_VID_6: OSD pixels contribute 2/8, video pixels contribute 6/8
+ * @OSD_3_VID_5: OSD pixels contribute 3/8, video pixels contribute 5/8
+ * @OSD_4_VID_4: OSD pixels contribute 4/8, video pixels contribute 4/8
+ * @OSD_5_VID_3: OSD pixels contribute 5/8, video pixels contribute 3/8
+ * @OSD_6_VID_2: OSD pixels contribute 6/8, video pixels contribute 2/8
+ * @OSD_8_VID_0: OSD pixels are fully opaque
+ *
+ * Description:
+ * An enumeration of the DaVinci pixel blending factor options.
+ */
+enum davinci_blending_factor {
+	OSD_0_VID_8,
+	OSD_1_VID_7,
+	OSD_2_VID_6,
+	OSD_3_VID_5,
+	OSD_4_VID_4,
+	OSD_5_VID_3,
+	OSD_6_VID_2,
+	OSD_8_VID_0,
+};
+
+/**
+ * enum davinci_blink_interval
+ * @BLINK_X1: blink interval is 1 vertical refresh cycle
+ * @BLINK_X2: blink interval is 2 vertical refresh cycles
+ * @BLINK_X3: blink interval is 3 vertical refresh cycles
+ * @BLINK_X4: blink interval is 4 vertical refresh cycles
+ *
+ * Description:
+ * An enumeration of the DaVinci pixel blinking interval options.
+ */
+enum davinci_blink_interval {
+	BLINK_X1,
+	BLINK_X2,
+	BLINK_X3,
+	BLINK_X4,
+};
+
+/**
+ * enum davinci_cursor_h_width
+ * @H_WIDTH_1: horizontal line width is 1 pixel
+ * @H_WIDTH_4: horizontal line width is 4 pixels
+ * @H_WIDTH_8: horizontal line width is 8 pixels
+ * @H_WIDTH_12: horizontal line width is 12 pixels
+ * @H_WIDTH_16: horizontal line width is 16 pixels
+ * @H_WIDTH_20: horizontal line width is 20 pixels
+ * @H_WIDTH_24: horizontal line width is 24 pixels
+ * @H_WIDTH_28: horizontal line width is 28 pixels
+ */
+enum davinci_cursor_h_width {
+	H_WIDTH_1,
+	H_WIDTH_4,
+	H_WIDTH_8,
+	H_WIDTH_12,
+	H_WIDTH_16,
+	H_WIDTH_20,
+	H_WIDTH_24,
+	H_WIDTH_28,
+};
+
+/**
+ * enum davinci_cursor_v_width
+ * @V_WIDTH_1: vertical line width is 1 line
+ * @V_WIDTH_2: vertical line width is 2 lines
+ * @V_WIDTH_4: vertical line width is 4 lines
+ * @V_WIDTH_6: vertical line width is 6 lines
+ * @V_WIDTH_8: vertical line width is 8 lines
+ * @V_WIDTH_10: vertical line width is 10 lines
+ * @V_WIDTH_12: vertical line width is 12 lines
+ * @V_WIDTH_14: vertical line width is 14 lines
+ */
+enum davinci_cursor_v_width {
+	V_WIDTH_1,
+	V_WIDTH_2,
+	V_WIDTH_4,
+	V_WIDTH_6,
+	V_WIDTH_8,
+	V_WIDTH_10,
+	V_WIDTH_12,
+	V_WIDTH_14,
+};
+
+/**
+ * struct davinci_cursor_config
+ * @xsize: horizontal size in pixels
+ * @ysize: vertical size in lines
+ * @xpos: horizontal offset in pixels from the left edge of the display
+ * @ypos: vertical offset in lines from the top of the display
+ * @interlaced: Non-zero if the display is interlaced, or zero otherwise
+ * @h_width: horizontal line width
+ * @v_width: vertical line width
+ * @clut: the CLUT selector (ROM or RAM) for the cursor color
+ * @clut_index: an index into the CLUT for the cursor color
+ *
+ * Description:
+ * A structure describing the configuration parameters of the hardware
+ * rectangular cursor.
+ */
+struct davinci_cursor_config {
+	unsigned xsize;
+	unsigned ysize;
+	unsigned xpos;
+	unsigned ypos;
+	int interlaced;
+	enum davinci_cursor_h_width h_width;
+	enum davinci_cursor_v_width v_width;
+	enum davinci_clut clut;
+	unsigned char clut_index;
+};
+
+/**
+ * struct davinci_disp_callback
+ * @next: used internally by the display manager to maintain a liked list of
+ *        callbacks
+ * @mask: a bitmask specifying the display manager event(s) for which the
+ *        callback will be invoked
+ * @handler: the callback routine
+ * @arg: a null pointer that is passed as the second argument to the callback
+ *       routine
+ */
+struct davinci_disp_callback {
+	struct davinci_disp_callback *next;
+	unsigned mask;
+	void (*handler) (unsigned event, void *arg);
+	void *arg;
+};
+
+/* display manager events */
+#define DAVINCI_DISP_END_OF_FRAME	1
+#define DAVINCI_DISP_FIRST_FIELD	2
+#define DAVINCI_DISP_SECOND_FIELD	4
+
+/**
+ * struct davinci_layer_config
+ * @pixfmt: pixel format
+ * @line_length: offset in bytes between start of each line in memory
+ * @xsize: number of horizontal pixels displayed per line
+ * @ysize: number of lines displayed
+ * @xpos: horizontal offset in pixels from the left edge of the display
+ * @ypos: vertical offset in lines from the top of the display
+ * @interlaced: Non-zero if the display is interlaced, or zero otherwise
+ *
+ * Description:
+ * A structure describing the configuration parameters of an On-Screen Display
+ * (OSD) or video layer related to how the image is stored in memory.
+ * @line_length must be a multiple of the cache line size (32 bytes).
+ */
+struct davinci_layer_config {
+	enum davinci_pix_format pixfmt;
+	unsigned line_length;
+	unsigned xsize;
+	unsigned ysize;
+	unsigned xpos;
+	unsigned ypos;
+	int interlaced;
+};
+
+/**
+ * davinci_disp_request_layer
+ * @layer: layer id
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Request to use an On-Screen Display (OSD) or video layer (window).
+ */
+int davinci_disp_request_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_release_layer
+ * @layer: layer id
+ *
+ * Description:
+ * Release a layer previously obtained via davinci_disp_request_layer().
+ */
+void davinci_disp_release_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_init_layer
+ * @layer: layer id
+ *
+ * Description:
+ * Initialize all parameters that are uniquely associated with the specified
+ * display layer to their default values.  Parameters that are common to
+ * multiple display layers (e.g. expansion ratios) are not affected.  The
+ * default state of a layer is disabled with X1 zoom.  The OSD layers default
+ * to 8-bits-per-pixel bitmap format, RAM CLUT, REC601 attenuation disabled,
+ * color key blending disabled, and are fully opaque.  Video layers maintain
+ * their current pixel format, either YCbCrI or YCrCbI, but will default to
+ * YCbCrI when first initialized.
+ * In general, it is not necessary for a display manager user to call this
+ * routine.  The display manager calls this routine automatically for every
+ * layer at initialization time and for an individual layer when the layer is
+ * released.
+ */
+void davinci_disp_init_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_enable_layer
+ * @layer: layer id
+ * Returns: Zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Enable a video layer so that it is displayed.
+ */
+int davinci_disp_enable_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_disable_layer
+ * @layer: layer id
+ *
+ * Description:
+ * Disable a video layer so that it is not displayed.
+ */
+void davinci_disp_disable_layer(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_layer_is_enabled
+ * @layer: layer id
+ * Returns: 1 if the layer is enabled, or 0 otherwise
+ *
+ * Description:
+ * Determine whether or not a video layer is enabled..
+ */
+int davinci_disp_layer_is_enabled(enum davinci_disp_layer layer);
+
+/**
+ * davinci_disp_set_layer_config
+ * @layer: layer id
+ * @lconfig: a pointer to a davinci_layer_config structure
+ * Returns: 1 if the requested configuration is rejected, or 0 otherwise.
+ *          When the configuration is rejected, the value of @lconfig on
+ *          exit will be the current layer configuration.
+ *
+ * Description:
+ * Configure the parameters of an On-Screen Display (OSD) or video layer
+ * related to how the image is stored in memory.  On entry, the values of the
+ * members of the @lconfig struct specify the desired configuration.  On exit,
+ * the values of the members of the @lconfig struct will be updated to reflect
+ * the actual configuration, which is subject to the constraints of the
+ * DaVinci OSD controller.
+ */
+int davinci_disp_set_layer_config(enum davinci_disp_layer layer,
+				  struct davinci_layer_config *lconfig);
+
+/**
+ * davinci_disp_try_layer_config
+ * @layer: layer id
+ * @lconfig: a pointer to a davinci_layer_config structure
+ * Returns: 1 if the requested configuration is rejected, or 0 otherwise.
+ *          When the configuration is rejected, the value of @lconfig on
+ *          exit will be the current layer configuration.
+ *
+ * Description:
+ * Evaluate the parameters of an On-Screen Display (OSD) or video layer
+ * configuration.  On entry, the values of the members of the @lconfig struct
+ * specify the desired configuration.  On exit, the values of the members of the
+ * @lconfig struct will be updated to reflect the closest actual configuration
+ * which could currently be set and enabled subject to the constraints of the
+ * DaVinci OSD controller.  The actual layer configuration is not modified by
+ * this routine.
+ *
+ * Note that some of the constraints depend on the current configuration of
+ * other windows, so it is possible for a configuration returned by
+ * davinci_disp_try_layer_config() to fail to be set or enabled successfully
+ * if the configuration of other windows has changed.
+ */
+int davinci_disp_try_layer_config(enum davinci_disp_layer layer,
+				  struct davinci_layer_config *lconfig);
+
+/**
+ * davinci_disp_get_layer_config
+ * @layer: layer id
+ * @lconfig: a pointer to a davinci_layer_config structure
+ *
+ * Description:
+ * Get the parameters of an On-Screen Display (OSD) or video layer
+ * related to how the image is stored in memory.  On exit, the values of the
+ * members of the @lconfig struct will be updated to reflect the current
+ * configuration.
+ */
+void davinci_disp_get_layer_config(enum davinci_disp_layer layer,
+				   struct davinci_layer_config *lconfig);
+
+/**
+ * davinci_disp_start_layer
+ * @layer: layer id
+ * @fb_base_phys: physical base address of the framebuffer
+ *
+ * Description:
+ * Initialize the framebuffer base address \of an On-Screen Display (OSD) or
+ * video layer.  Display of the layer may be either enabled or disabled on
+ * entry and will be unchanged on exit.  @fb_base_phys must be cache-line
+ * (32-byte) aligned.
+ */
+void davinci_disp_start_layer(enum davinci_disp_layer layer,
+			      unsigned long fb_base_phys);
+
+/**
+ * davinci_disp_set_interpolation_filter
+ * @filter: non-zero to enable the interpolation filter, or zero to disable
+ *
+ * Description:
+ * Globally enable or disable the scaling (zoom and expansion) interpolation
+ * filter.  It applies to all OSD and video windows.
+ */
+void davinci_disp_set_interpolation_filter(int filter);
+
+/**
+ * davinci_disp_get_interpolation_filter
+ * Returns: 1 if the interpolation filter is enabled, or 0 otherwise
+ *
+ * Description:
+ * Get the enabled/disabled status of the scaling (zoom and expansion)
+ * interpolation filter.
+ */
+int davinci_disp_get_interpolation_filter(void);
+
+/**
+ * davinci_disp_set_osd_expansion
+ * @h_exp: the horizontal expansion ratio
+ * @v_exp: the vertical expansion ratio
+ * Returns: zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Configure the expansion ratio for the OSD windows.
+ */
+int davinci_disp_set_osd_expansion(enum davinci_h_exp_ratio h_exp,
+				   enum davinci_v_exp_ratio v_exp);
+
+/**
+ * davinci_disp_get_osd_expansion
+ * @h_exp: the horizontal expansion ratio
+ * @v_exp: the vertical expansion ratio
+ *
+ * Description:
+ * Get the expansion ratio for the OSD windows.
+ */
+void davinci_disp_get_osd_expansion(enum davinci_h_exp_ratio *h_exp,
+				    enum davinci_v_exp_ratio *v_exp);
+
+/**
+ * davinci_disp_set_vid_expansion
+ * @h_exp: the horizontal expansion ratio
+ * @v_exp: the vertical expansion ratio
+ * Returns: zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Configure the expansion ratio for the video windows.
+ */
+int davinci_disp_set_vid_expansion(enum davinci_h_exp_ratio h_exp,
+				   enum davinci_v_exp_ratio v_exp);
+
+/**
+ * davinci_disp_get_vid_expansion
+ * @h_exp: the horizontal expansion ratio
+ * @v_exp: the vertical expansion ratio
+ *
+ * Description:
+ * Get the expansion ratio for the video windows.
+ */
+void davinci_disp_get_vid_expansion(enum davinci_h_exp_ratio *h_exp,
+				    enum davinci_v_exp_ratio *v_exp);
+
+/**
+ * davinci_disp_set_zoom
+ * @layer: layer id
+ * @h_zoom: horizontal zoom factor
+ * @v_zoom: vertical zoom factor
+ *
+ * Description:
+ * Set the horizontal and vertical zoom factors.
+ */
+void davinci_disp_set_zoom(enum davinci_disp_layer layer,
+			   enum davinci_zoom_factor h_zoom,
+			   enum davinci_zoom_factor v_zoom);
+
+/**
+ * davinci_disp_get_zoom
+ * @layer: layer id
+ * @h_zoom: horizontal zoom factor
+ * @v_zoom: vertical zoom factor
+ *
+ * Description:
+ * Get the horizontal and vertical zoom factors.
+ */
+void davinci_disp_get_zoom(enum davinci_disp_layer layer,
+			   enum davinci_zoom_factor *h_zoom,
+			   enum davinci_zoom_factor *v_zoom);
+
+/**
+ * davinci_disp_set_background
+ * @clut: the CLUT selector
+ * @clut_index: an index into the CLUT
+ *
+ * Description:
+ * Set the background color that is displayed in any region not covered by one
+ * of the display layers.  The color is selected by specifying a Color Lookup
+ * Table (either ROM or RAM) and an index into the CLUT.
+ */
+void davinci_disp_set_background(enum davinci_clut clut,
+				 unsigned char clut_index);
+
+/**
+ * davinci_disp_get_background
+ * @clut: the CLUT selector
+ * @clut_index: an index into the CLUT
+ *
+ * Description:
+ * Get the background color that is displayed in any region not covered by one
+ * of the display layers.  The color is selected by specifying a Color Lookup
+ * Table (either ROM or RAM) and an index into the CLUT.
+ */
+void davinci_disp_get_background(enum davinci_clut *clut,
+				 unsigned char *clut_index);
+
+/**
+ * davinci_disp_set_rom_clut
+ * @rom_clut: the ROM CLUT selector
+ *
+ * Description:
+ * Choose which of the two ROM Color Lookup Tables will be used.
+ */
+void davinci_disp_set_rom_clut(enum davinci_rom_clut rom_clut);
+
+/**
+ * davinci_disp_get_rom_clut
+ * Returns: the ROM CLUT selector
+ *
+ * Description:
+ * Query which of the two ROM Color Lookup Tables is currently selected.
+ */
+enum davinci_rom_clut davinci_disp_get_rom_clut(void);
+
+/**
+ * davinci_disp_set_clut_ycbcr
+ * @clut_index: an index into the CLUT
+ * @y: Luma (Y) value
+ * @cb: Blue Chroma (Cb) value
+ * @cr: Red Chroma (Cr) value
+ *
+ * Description:
+ * Set a YCbCr value in the Color Lookup Table (CLUT).
+ */
+void davinci_disp_set_clut_ycbcr(unsigned char clut_index, unsigned char y,
+				 unsigned char cb, unsigned char cr);
+
+/**
+ * davinci_disp_set_clut_rgb
+ * @clut_index: an index into the CLUT
+ * @r: Red value
+ * @g: Green value
+ * @b: Blue value
+ *
+ * Description:
+ * Set an RGB value in the Color Lookup Table (CLUT).
+ */
+void davinci_disp_set_clut_rgb(unsigned char clut_index, unsigned char r,
+			       unsigned char g, unsigned char b);
+
+/**
+ * davinci_disp_set_osd_clut
+ * @osdwin: OSD0 or OSD1 layer id
+ * @clut: the CLUT selector
+ *
+ * Description:
+ * Select whether the RAM CLUT or the ROM CLUT is to be used for an OSD window.
+ * The selection is only significant if the window is using a 1-, 2-, 4-, or
+ * 8-bit pixel format.
+ */
+void davinci_disp_set_osd_clut(enum davinci_osd_layer osdwin,
+			       enum davinci_clut clut);
+
+/**
+ * davinci_disp_get_osd_clut
+ * @osdwin: OSD0 or OSD1 layer id
+ * Returns: the CLUT selector
+ *
+ * Description:
+ * Query whether the RAM CLUT or the ROM CLUT is currently selected for an OSD
+ * window.  The selection is only significant if the window is using a 1-, 2-,
+ * 4-, or 8-bit pixel format.
+ */
+enum davinci_clut davinci_disp_get_osd_clut(enum davinci_osd_layer osdwin);
+
+/**
+ * davinci_disp_enable_color_key
+ * @osdwin: OSD0 or OSD1 layer id
+ * @colorkey: the transparency color key
+ *
+ * Description:
+ * Enable transparency color key blending.  Any pixel in the specified OSD
+ * window which matches the color key will be transparent (or partially
+ * transparent) and allow the underlying video pixel to be displayed based on
+ * the blending factor.
+ *
+ * Interpretation of the @colorkey argument is determined by the pixel format
+ * assigned to the window.  The pixel format must be specified via
+ * davinci_disp_set_layer_config() before calling this routine.
+ *
+ * %PIXFMT_1BPP pixels matching @colorkey bit 0 are blended.
+ * %PIXFMT_2BPP pixels matching @colorkey bits 1-0 are blended.
+ * %PIXFMT_4BPP pixels matching @colorkey bits 3-0 are blended.
+ * %PIXFMT_8BPP pixels matching @colorkey bits 7-0 are blended.
+ * %PIXFMT_RGB565 pixels matching @colorkey bits 15-0 are blended.
+ * %PIXFMT_YCbCrI pixels with Luma (Y) matching @colorkey bits 15-8 are blended.
+ * %PIXFMT_RGB888 pixels matching @colorkey bits 23-0 are blended.
+ * %PIXFMT_YCrCbI pixels with Luma (Y) matching @colorkey bits 15-8 are blended.
+ * Color keying is not applicable to %PIXFMT_OSD_ATTR pixels.
+ *
+ * For DM644x processors, only the four %PIXFMT_nBPP pixel formats and
+ * %PIXFMT_RGB565 are supported.  The color key for the bitmap formats is fixed
+ * at zero on DM644x processors, so the value passed in the @colorkey argument
+ * is only significant for the %PIXFMT_RGB565 pixel format.
+ */
+void davinci_disp_enable_color_key(enum davinci_osd_layer osdwin,
+				   unsigned colorkey);
+
+/**
+ * davinci_disp_disable_color_key
+ * @osdwin: OSD0 or OSD1 layer id
+ *
+ * Description:
+ * Disable transparency color key blending for the specified OSD layer.  All
+ * pixels in the OSD window will be blended with video pixels according to the
+ * blending factor.
+ */
+void davinci_disp_disable_color_key(enum davinci_osd_layer osdwin);
+
+/**
+ * davinci_disp_set_blending_factor
+ * @osdwin: OSD0 or OSD1 layer id
+ * @blend: the blending factor
+ *
+ * Description:
+ * Set the blending factor for an OSD window.  The blending factor determines
+ * the degree of opacity or transparency of OSD pixels.  Transparent or
+ * partially transparent pixels allow the underlying video pixels to be
+ * displayed based on the blending factor.  All OSD pixels are blended unless
+ * color keying is enabled, in which case only pixels matching the color key
+ * are blended.
+ */
+void davinci_disp_set_blending_factor(enum davinci_osd_layer osdwin,
+				      enum davinci_blending_factor blend);
+
+/**
+ * davinci_disp_get_blending_factor
+ * @osdwin: OSD0 or OSD1 layer id
+ * Returns: the blending factor
+ *
+ * Description:
+ * Get the blending factor for an OSD window.
+ */
+enum davinci_blending_factor davinci_disp_get_blending_factor(enum
+							      davinci_osd_layer
+							      osdwin);
+
+/**
+ * davinci_disp_set_rec601_attenuation
+ * @osdwin: OSD0 or OSD1 layer id
+ * @enable: non-zero to enable REC601 attenuation, or zero to disable
+ *
+ * Description:
+ * Enable or disable REC601 attenuation of data in an OSD window.
+ */
+void davinci_disp_set_rec601_attenuation(enum davinci_osd_layer osdwin,
+					 int enable);
+
+/**
+ * davinci_disp_get_rec601_attenuation
+ * @osdwin: OSD0 or OSD1 layer id
+ * Returns: 1 if REC601 attenuation is enabled, or 0 otherwise
+ *
+ * Description:
+ * Get the REC601 attenuation status for an OSD window.
+ */
+int davinci_disp_get_rec601_attenuation(enum davinci_osd_layer osdwin);
+
+/**
+ * davinci_disp_set_palette_map
+ * @osdwin: OSD0 or OSD1 layer id
+ * @pixel_value: a bitmap pixel value
+ * @clut_index: an index into the CLUT
+ *
+ * Description:
+ * A 256-entry Color Lookup Table (CLUT) is used for bitmap pixel formats.
+ * Every entry in the CLUT is used when the color depth is 8 bits.  However,
+ * only a subset of the CLUT entries are needed for color depths of 1, 2,
+ * or 4 bits.  Each pixel value for color depths of 1, 2, or 4 bits can be
+ * mapped to any of the 256 CLUT entries.  Two CLUT entries are used for a
+ * color depth of 1 bit, four CLUT entries are used for a color depth of
+ * 2 bits, and sixteen CLUT entries are used for a color depth of 4 bits.
+ *
+ * Interpretation of the @pixel_value argument is determined by the pixel
+ * format assigned to the window.  The pixel format must be specified via
+ * davinci_disp_set_layer_config() before calling this routine.
+ */
+void davinci_disp_set_palette_map(enum davinci_osd_layer osdwin,
+				  unsigned char pixel_value,
+				  unsigned char clut_index);
+
+/**
+ * davinci_disp_get_palette_map
+ * @osdwin: OSD0 or OSD1 layer id
+ * @pixel_value: a bitmap pixel value
+ * Returns: an index into the CLUT
+ *
+ * Description:
+ * Given a pixel value, return the corresponding clut index from the palette
+ * map.
+ *
+ * Interpretation of the @pixel_value argument is determined by the pixel
+ * format assigned to the window.  The pixel format must be specified via
+ * davinci_disp_set_layer_config() before calling this routine.
+ */
+unsigned char davinci_disp_get_palette_map(enum davinci_osd_layer osdwin,
+				  unsigned char pixel_value);
+
+/**
+ * davinci_disp_set_blink_attribute
+ * @enable: non-zero to enable blinking, zero to disable
+ * @blink: the blinking interval
+ *
+ * Description:
+ * Set the blinking attributes when OSD1 is configured as an attribute window.
+ * If blinking is enabled, then OSD0 pixels which have their corresponding
+ * per-pixel blinking bit set in OSD1 will blink.  The blinking interval is a
+ * multiple of the vertical refresh interval.
+ */
+void davinci_disp_set_blink_attribute(int enable,
+				      enum davinci_blink_interval blink);
+
+/**
+ * davinci_disp_get_blink_attribute
+ * @enable: one if blinking is enabled, or zero if disabled
+ * @blink: the blinking interval
+ *
+ * Description:
+ * Get the blinking attributes when OSD1 is configured as an attribute window.
+ * If blinking is enabled, then OSD0 pixels which have their corresponding
+ * per-pixel blinking bit set in OSD1 will blink.  The blinking interval is a
+ * multiple of the vertical refresh interval.
+ */
+void davinci_disp_get_blink_attribute(int *enable,
+				      enum davinci_blink_interval *blink);
+
+/**
+ * davinci_disp_cursor_enable
+ *
+ * Description:
+ * Enable display of the hardware cursor.
+ */
+void davinci_disp_cursor_enable(void);
+
+/**
+ * davinci_disp_cursor_disable
+ *
+ * Description:
+ * Disable display of the hardware cursor.
+ */
+void davinci_disp_cursor_disable(void);
+
+/**
+ * davinci_disp_cursor_is_enabled
+ * Returns: 1 if cursor is enabled, or 0 otherwise
+ *
+ * Description:
+ * Query whether or not display of the hardware cursor is enabled.
+ */
+int davinci_disp_cursor_is_enabled(void);
+
+/**
+ * davinci_disp_set_cursor_config
+ * @cursor: the cursor configuration
+ *
+ * Description:
+ * Set the configuration (color, line width, position, and size) of the hardware
+ * rectangular cursor.
+ */
+void davinci_disp_set_cursor_config(struct davinci_cursor_config *cursor);
+
+/**
+ * davinci_disp_get_cursor_config
+ * @cursor: the cursor configuration
+ *
+ * Description:
+ * Get the configuration (color, line width, position, and size) of the hardware
+ * rectangular cursor.
+ */
+void davinci_disp_get_cursor_config(struct davinci_cursor_config *cursor);
+
+/**
+ * davinci_disp_set_field_inversion
+ * @enable: non-zero to enable field signal inversion, or zero to disable
+ *
+ * Description:
+ * Enable or disable field signal inversion, which inverts the polarity of the
+ * field ID signal from the video encoder.  This setting applies to all OSD and
+ * video windows.  It is only significant when the display is interlaced.
+ */
+void davinci_disp_set_field_inversion(int enable);
+
+/**
+ * davinci_disp_get_field_inversion
+ * Returns: 1 if field signal inversion is enabled, or 0 otherwise
+ *
+ * Description:
+ * Get the field signal inversion state.
+ */
+int davinci_disp_get_field_inversion(void);
+
+/**
+ * davinci_disp_register_callback
+ * @callback: a pointer to a davinci_disp_callback struct
+ * Returns: zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Register a callback routine for a DaVinci display manager event.
+ * @callback->handler is a pointer to the callback routine.  The first argument
+ * passed to the callback routine is the display manager event bitmask
+ * indicating which event(s) occurred.  The second argument passed to the
+ * callback routine is @callback->arg.  @callback->mask is a bitmask specifying
+ * the events for which the caller wishes to be notified.  @callback->next is
+ * used internally by the display manager and need not be initialized by the
+ * caller.  Once a callback routine has been registered, the caller must not
+ * modify the @callback struct until the callback has been unregistered.
+ *
+ * The display manager events are %DAVINCI_DISP_END_OF_FRAME,
+ * %DAVINCI_DISP_FIRST_FIELD, and %DAVINCI_DISP_SECOND_FIELD.
+ */
+int davinci_disp_register_callback(struct davinci_disp_callback *callback);
+
+/**
+ * davinci_disp_unregister_callback
+ * @callback: a pointer to a davinci_disp_callback struct
+ * Returns: zero if successful, or non-zero otherwise
+ *
+ * Description:
+ * Unregister a display manager callback routine previously registered with
+ * davinci_disp_register_callback().
+ */
+int davinci_disp_unregister_callback(struct davinci_disp_callback *callback);
+
+#endif				/* ifndef _DAVINCI_OSD_H */
Index: linux-2.6.18/include/video/davinci_vpbe.h
===================================================================
--- /dev/null
+++ linux-2.6.18/include/video/davinci_vpbe.h
@@ -0,0 +1,497 @@
+/*
+ * Copyright (C) 2006 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef _DAVINCI_VPBE_H_
+#define _DAVINCI_VPBE_H_
+
+/* VPBE register base addresses */
+#define DM644X_VENC_REG_BASE		0x01C72400
+#define DM644X_OSD_REG_BASE		0x01C72600
+#define DM644X_VPBE_REG_BASE		0x01C72780
+
+#define DM355_VPSSCLK_REG_BASE		0x01C70000
+#define DM355_OSD_REG_BASE		0x01C70200
+#define DM355_VENC_REG_BASE		0x01C70400
+#define DM355_VPSSBL_REG_BASE		0x01C70800
+
+#define OSD_REG_SIZE			0x00000100
+
+/* SYS register addresses */
+#define SYS_VPSS_CLKCTL			0x01C40044
+
+#define DM355_VDAC_CONFIG		0x01C4002C
+#define DM355_USB_PHY_CTRL		0x01c40034
+
+/* VPBE Global Registers */
+#define VPBE_PID				0x0
+#define VPBE_PCR				0x4
+
+/* VPSS CLock Registers */
+#define VPSSCLK_PID				0x00
+#define VPSSCLK_CLKCTRL				0x04
+
+/* VPSS Buffer Logic Registers */
+#define VPSSBL_PID				0x00
+#define VPSSBL_PCR				0x04
+#define VPSSBL_INTSTAT				0x0C
+#define VPSSBL_INTSEL				0x10
+#define VPSSBL_EVTSEL				0x14
+#define VPSSBL_MEMCTRL				0x18
+#define VPSSBL_CCDCMUX				0x1C
+
+/* VPBE Video Encoder / Digital LCD Subsystem Registers (VENC) */
+#define VENC_VMOD				0x00
+#define VENC_VIDCTL				0x04
+#define VENC_VDPRO				0x08
+#define VENC_SYNCCTL				0x0C
+#define VENC_HSPLS				0x10
+#define VENC_VSPLS				0x14
+#define VENC_HINT				0x18
+#define VENC_HSTART				0x1C
+#define VENC_HVALID				0x20
+#define VENC_VINT				0x24
+#define VENC_VSTART				0x28
+#define VENC_VVALID				0x2C
+#define VENC_HSDLY				0x30
+#define VENC_VSDLY				0x34
+#define VENC_YCCCTL				0x38
+#define VENC_RGBCTL				0x3C
+#define VENC_RGBCLP				0x40
+#define VENC_LINECTL				0x44
+#define VENC_CULLLINE				0x48
+#define VENC_LCDOUT				0x4C
+#define VENC_BRTS				0x50
+#define VENC_BRTW				0x54
+#define VENC_ACCTL				0x58
+#define VENC_PWMP				0x5C
+#define VENC_PWMW				0x60
+#define VENC_DCLKCTL				0x64
+#define VENC_DCLKPTN0				0x68
+#define VENC_DCLKPTN1				0x6C
+#define VENC_DCLKPTN2				0x70
+#define VENC_DCLKPTN3				0x74
+#define VENC_DCLKPTN0A				0x78
+#define VENC_DCLKPTN1A				0x7C
+#define VENC_DCLKPTN2A				0x80
+#define VENC_DCLKPTN3A				0x84
+#define VENC_DCLKHS				0x88
+#define VENC_DCLKHSA				0x8C
+#define VENC_DCLKHR				0x90
+#define VENC_DCLKVS				0x94
+#define VENC_DCLKVR				0x98
+#define VENC_CAPCTL				0x9C
+#define VENC_CAPDO				0xA0
+#define VENC_CAPDE				0xA4
+#define VENC_ATR0				0xA8
+#define VENC_ATR1				0xAC
+#define VENC_ATR2				0xB0
+#define VENC_VSTAT				0xB8
+#define VENC_RAMADR				0xBC
+#define VENC_RAMPORT				0xC0
+#define VENC_DACTST				0xC4
+#define VENC_YCOLVL				0xC8
+#define VENC_SCPROG				0xCC
+#define VENC_CVBS				0xDC
+#define VENC_CMPNT				0xE0
+#define VENC_ETMG0				0xE4
+#define VENC_ETMG1				0xE8
+#define VENC_ETMG2				0xEC
+#define VENC_ETMG3				0xF0
+#define VENC_DACSEL				0xF4
+#define VENC_ARGBX0				0x100
+#define VENC_ARGBX1				0x104
+#define VENC_ARGBX2				0x108
+#define VENC_ARGBX3				0x10C
+#define VENC_ARGBX4				0x110
+#define VENC_DRGBX0				0x114
+#define VENC_DRGBX1				0x118
+#define VENC_DRGBX2				0x11C
+#define VENC_DRGBX3				0x120
+#define VENC_DRGBX4				0x124
+#define VENC_VSTARTA				0x128
+#define VENC_OSDCLK0				0x12C
+#define VENC_OSDCLK1				0x130
+#define VENC_HVLDCL0				0x134
+#define VENC_HVLDCL1				0x138
+#define VENC_OSDHADV				0x13C
+#define VENC_CLKCTL				0x140
+#define VENC_GAMCTL				0x144
+
+/* VPBE On-Screen Display Subsystem Registers (OSD) */
+#define OSD_MODE				0x00
+#define OSD_VIDWINMD				0x04
+#define OSD_OSDWIN0MD				0x08
+#define OSD_OSDWIN1MD				0x0C
+#define OSD_OSDATRMD				0x0C
+#define OSD_RECTCUR				0x10
+#define OSD_VIDWIN0OFST				0x18
+#define OSD_VIDWIN1OFST				0x1C
+#define OSD_OSDWIN0OFST				0x20
+#define OSD_OSDWIN1OFST				0x24
+#define OSD_VIDWINADH				0x28
+#define OSD_VIDWIN0ADL				0x2C
+#define OSD_VIDWIN0ADR				0x2C
+#define OSD_VIDWIN1ADL				0x30
+#define OSD_VIDWIN1ADR				0x30
+#define OSD_OSDWINADH				0x34
+#define OSD_OSDWIN0ADL				0x38
+#define OSD_OSDWIN0ADR				0x38
+#define OSD_OSDWIN1ADL				0x3C
+#define OSD_OSDWIN1ADR				0x3C
+#define OSD_BASEPX				0x40
+#define OSD_BASEPY				0x44
+#define OSD_VIDWIN0XP				0x48
+#define OSD_VIDWIN0YP				0x4C
+#define OSD_VIDWIN0XL				0x50
+#define OSD_VIDWIN0YL				0x54
+#define OSD_VIDWIN1XP				0x58
+#define OSD_VIDWIN1YP				0x5C
+#define OSD_VIDWIN1XL				0x60
+#define OSD_VIDWIN1YL				0x64
+#define OSD_OSDWIN0XP				0x68
+#define OSD_OSDWIN0YP				0x6C
+#define OSD_OSDWIN0XL				0x70
+#define OSD_OSDWIN0YL				0x74
+#define OSD_OSDWIN1XP				0x78
+#define OSD_OSDWIN1YP				0x7C
+#define OSD_OSDWIN1XL				0x80
+#define OSD_OSDWIN1YL				0x84
+#define OSD_CURXP				0x88
+#define OSD_CURYP				0x8C
+#define OSD_CURXL				0x90
+#define OSD_CURYL				0x94
+#define OSD_W0BMP01				0xA0
+#define OSD_W0BMP23				0xA4
+#define OSD_W0BMP45				0xA8
+#define OSD_W0BMP67				0xAC
+#define OSD_W0BMP89				0xB0
+#define OSD_W0BMPAB				0xB4
+#define OSD_W0BMPCD				0xB8
+#define OSD_W0BMPEF				0xBC
+#define OSD_W1BMP01				0xC0
+#define OSD_W1BMP23				0xC4
+#define OSD_W1BMP45				0xC8
+#define OSD_W1BMP67				0xCC
+#define OSD_W1BMP89				0xD0
+#define OSD_W1BMPAB				0xD4
+#define OSD_W1BMPCD				0xD8
+#define OSD_W1BMPEF				0xDC
+#define OSD_VBNDRY				0xE0
+#define OSD_EXTMODE				0xE4
+#define OSD_MISCCTL				0xE8
+#define OSD_CLUTRAMYCB				0xEC
+#define OSD_CLUTRAMCR				0xF0
+#define OSD_TRANSPVAL				0xF4
+#define OSD_TRANSPVALL				0xF4
+#define OSD_TRANSPVALU				0xF8
+#define OSD_TRANSPBMPIDX			0xFC
+#define OSD_PPVWIN0ADR				0xFC
+
+/* bit definitions */
+#define VPBE_PCR_VENC_DIV			(1 << 1)
+#define VPBE_PCR_CLK_OFF			(1 << 0)
+
+#define VPSSBL_INTSTAT_HSSIINT			(1 << 14)
+#define VPSSBL_INTSTAT_CFALDINT			(1 << 13)
+#define VPSSBL_INTSTAT_IPIPE_INT5		(1 << 12)
+#define VPSSBL_INTSTAT_IPIPE_INT4		(1 << 11)
+#define VPSSBL_INTSTAT_IPIPE_INT3		(1 << 10)
+#define VPSSBL_INTSTAT_IPIPE_INT2		(1 << 9)
+#define VPSSBL_INTSTAT_IPIPE_INT1		(1 << 8)
+#define VPSSBL_INTSTAT_IPIPE_INT0		(1 << 7)
+#define VPSSBL_INTSTAT_IPIPEIFINT		(1 << 6)
+#define VPSSBL_INTSTAT_OSDINT			(1 << 5)
+#define VPSSBL_INTSTAT_VENCINT			(1 << 4)
+#define VPSSBL_INTSTAT_H3AINT			(1 << 3)
+#define VPSSBL_INTSTAT_CCDC_VDINT2		(1 << 2)
+#define VPSSBL_INTSTAT_CCDC_VDINT1		(1 << 1)
+#define VPSSBL_INTSTAT_CCDC_VDINT0		(1 << 0)
+
+#define VENC_VMOD_VDMD_SHIFT			12
+#define VENC_VMOD_VDMD_YCBCR16			0
+#define VENC_VMOD_VDMD_YCBCR8			1
+#define VENC_VMOD_VDMD_RGB666			2
+#define VENC_VMOD_VDMD_RGB8			3
+#define VENC_VMOD_VDMD_EPSON			4
+#define VENC_VMOD_VDMD_CASIO			5
+#define VENC_VMOD_VDMD_UDISPQVGA		6
+#define VENC_VMOD_VDMD_STNLCD			7
+#define VENC_VMOD_VIE_SHIFT			1
+#define VENC_VMOD_VDMD				(7 << 12)
+#define VENC_VMOD_ITLCL				(1 << 11)
+#define VENC_VMOD_ITLC				(1 << 10)
+#define VENC_VMOD_NSIT				(1 << 9)
+#define VENC_VMOD_HDMD				(1 << 8)
+#define VENC_VMOD_TVTYP_SHIFT			6
+#define VENC_VMOD_TVTYP				(3 << 6)
+#define VENC_VMOD_SLAVE				(1 << 5)
+#define VENC_VMOD_VMD				(1 << 4)
+#define VENC_VMOD_BLNK				(1 << 3)
+#define VENC_VMOD_VIE				(1 << 1)
+#define VENC_VMOD_VENC				(1 << 0)
+
+/* VMOD TVTYP options for HDMD=0 */
+#define SDTV_NTSC				0
+#define SDTV_PAL				1
+/* VMOD TVTYP options for HDMD=1 */
+#define HDTV_525P				0
+#define HDTV_625P				1
+
+#define VENC_VIDCTL_VCLKP			(1 << 14)
+#define VENC_VIDCTL_VCLKE_SHIFT			13
+#define VENC_VIDCTL_VCLKE			(1 << 13)
+#define VENC_VIDCTL_VCLKZ_SHIFT			12
+#define VENC_VIDCTL_VCLKZ			(1 << 12)
+#define VENC_VIDCTL_SYDIR_SHIFT			8
+#define VENC_VIDCTL_SYDIR			(1 << 8)
+#define VENC_VIDCTL_DOMD_SHIFT			4
+#define VENC_VIDCTL_DOMD			(3 << 4)
+#define VENC_VIDCTL_YCDIR_SHIFT			0
+#define VENC_VIDCTL_YCDIR			(1 << 0)
+
+#define VENC_VDPRO_ATYCC_SHIFT			5
+#define VENC_VDPRO_ATYCC			(1 << 5)
+#define VENC_VDPRO_ATCOM_SHIFT			4
+#define VENC_VDPRO_ATCOM			(1 << 4)
+#define VENC_VDPRO_DAFRQ			(1 << 3)
+#define VENC_VDPRO_DAUPS			(1 << 2)
+#define VENC_VDPRO_CUPS				(1 << 1)
+#define VENC_VDPRO_YUPS				(1 << 0)
+
+#define VENC_SYNCCTL_VPL_SHIFT    		3
+#define VENC_SYNCCTL_VPL  			(1 << 3)
+#define VENC_SYNCCTL_HPL_SHIFT 	  		2
+#define VENC_SYNCCTL_HPL  			(1 << 2)
+#define VENC_SYNCCTL_SYEV_SHIFT   		1
+#define VENC_SYNCCTL_SYEV  			(1 << 1)
+#define VENC_SYNCCTL_SYEH_SHIFT   		0
+#define VENC_SYNCCTL_SYEH  			(1 << 0)
+#define VENC_SYNCCTL_OVD_SHIFT   		14
+#define VENC_SYNCCTL_OVD  			(1 << 14)
+
+#define VENC_DCLKCTL_DCKEC_SHIFT		11
+#define VENC_DCLKCTL_DCKEC			(1 << 11)
+#define VENC_DCLKCTL_DCKPW_SHIFT		0
+#define VENC_DCLKCTL_DCKPW			(0x3f << 0)
+
+#define VENC_VSTAT_FIDST			(1 << 4)
+
+#define VENC_CMPNT_MRGB_SHIFT			14
+#define VENC_CMPNT_MRGB				(1 << 14)
+
+#define OSD_MODE_CS				(1 << 15)
+#define OSD_MODE_OVRSZ				(1 << 14)
+#define OSD_MODE_OHRSZ				(1 << 13)
+#define OSD_MODE_EF				(1 << 12)
+#define OSD_MODE_VVRSZ				(1 << 11)
+#define OSD_MODE_VHRSZ				(1 << 10)
+#define OSD_MODE_FSINV				(1 << 9)
+#define OSD_MODE_BCLUT				(1 << 8)
+#define OSD_MODE_CABG_SHIFT			0
+#define OSD_MODE_CABG				(0xff << 0)
+
+#define OSD_VIDWINMD_VFINV			(1 << 15)
+#define OSD_VIDWINMD_V1EFC			(1 << 14)
+#define OSD_VIDWINMD_VHZ1_SHIFT			12
+#define OSD_VIDWINMD_VHZ1			(3 << 12)
+#define OSD_VIDWINMD_VVZ1_SHIFT			10
+#define OSD_VIDWINMD_VVZ1			(3 << 10)
+#define OSD_VIDWINMD_VFF1			(1 << 9)
+#define OSD_VIDWINMD_ACT1			(1 << 8)
+#define OSD_VIDWINMD_V0EFC			(1 << 6)
+#define OSD_VIDWINMD_VHZ0_SHIFT			4
+#define OSD_VIDWINMD_VHZ0			(3 << 4)
+#define OSD_VIDWINMD_VVZ0_SHIFT			2
+#define OSD_VIDWINMD_VVZ0			(3 << 2)
+#define OSD_VIDWINMD_VFF0			(1 << 1)
+#define OSD_VIDWINMD_ACT0			(1 << 0)
+
+#define OSD_OSDWIN0MD_ATN0E			(1 << 14)
+#define OSD_OSDWIN0MD_RGB0E			(1 << 13)
+#define OSD_OSDWIN0MD_BMP0MD_SHIFT		13
+#define OSD_OSDWIN0MD_BMP0MD			(3 << 13)
+#define OSD_OSDWIN0MD_CLUTS0			(1 << 12)
+#define OSD_OSDWIN0MD_OHZ0_SHIFT		10
+#define OSD_OSDWIN0MD_OHZ0			(3 << 10)
+#define OSD_OSDWIN0MD_OVZ0_SHIFT		8
+#define OSD_OSDWIN0MD_OVZ0			(3 << 8)
+#define OSD_OSDWIN0MD_BMW0_SHIFT		6
+#define OSD_OSDWIN0MD_BMW0			(3 << 6)
+#define OSD_OSDWIN0MD_BLND0_SHIFT		3
+#define OSD_OSDWIN0MD_BLND0			(7 << 3)
+#define OSD_OSDWIN0MD_TE0			(1 << 2)
+#define OSD_OSDWIN0MD_OFF0			(1 << 1)
+#define OSD_OSDWIN0MD_OACT0			(1 << 0)
+
+#define OSD_OSDWIN1MD_OASW			(1 << 15)
+#define OSD_OSDWIN1MD_ATN1E			(1 << 14)
+#define OSD_OSDWIN1MD_RGB1E			(1 << 13)
+#define OSD_OSDWIN1MD_BMP1MD_SHIFT		13
+#define OSD_OSDWIN1MD_BMP1MD			(3 << 13)
+#define OSD_OSDWIN1MD_CLUTS1			(1 << 12)
+#define OSD_OSDWIN1MD_OHZ1_SHIFT		10
+#define OSD_OSDWIN1MD_OHZ1			(3 << 10)
+#define OSD_OSDWIN1MD_OVZ1_SHIFT		8
+#define OSD_OSDWIN1MD_OVZ1			(3 << 8)
+#define OSD_OSDWIN1MD_BMW1_SHIFT		6
+#define OSD_OSDWIN1MD_BMW1			(3 << 6)
+#define OSD_OSDWIN1MD_BLND1_SHIFT		3
+#define OSD_OSDWIN1MD_BLND1			(7 << 3)
+#define OSD_OSDWIN1MD_TE1			(1 << 2)
+#define OSD_OSDWIN1MD_OFF1			(1 << 1)
+#define OSD_OSDWIN1MD_OACT1			(1 << 0)
+
+#define OSD_OSDATRMD_OASW			(1 << 15)
+#define OSD_OSDATRMD_OHZA_SHIFT			10
+#define OSD_OSDATRMD_OHZA			(3 << 10)
+#define OSD_OSDATRMD_OVZA_SHIFT			8
+#define OSD_OSDATRMD_OVZA			(3 << 8)
+#define OSD_OSDATRMD_BLNKINT_SHIFT		6
+#define OSD_OSDATRMD_BLNKINT			(3 << 6)
+#define OSD_OSDATRMD_OFFA			(1 << 1)
+#define OSD_OSDATRMD_BLNK			(1 << 0)
+
+#define OSD_RECTCUR_RCAD_SHIFT			8
+#define OSD_RECTCUR_RCAD			(0xff << 8)
+#define OSD_RECTCUR_CLUTSR			(1 << 7)
+#define OSD_RECTCUR_RCHW_SHIFT			4
+#define OSD_RECTCUR_RCHW			(7 << 4)
+#define OSD_RECTCUR_RCVW_SHIFT			1
+#define OSD_RECTCUR_RCVW			(7 << 1)
+#define OSD_RECTCUR_RCACT			(1 << 0)
+
+#define OSD_VIDWIN0OFST_V0LO			(0x1ff << 0)
+
+#define OSD_VIDWIN1OFST_V1LO			(0x1ff << 0)
+
+#define OSD_OSDWIN0OFST_O0LO			(0x1ff << 0)
+
+#define OSD_OSDWIN1OFST_O1LO			(0x1ff << 0)
+
+#define OSD_VIDWINADH_V1AH_SHIFT		8
+#define OSD_VIDWINADH_V1AH			(0x7f << 8)
+#define OSD_VIDWINADH_V0AH_SHIFT		0
+#define OSD_VIDWINADH_V0AH			(0x7f << 0)
+
+#define OSD_VIDWIN0ADL_V0AL			(0xffff << 0)
+
+#define OSD_VIDWIN1ADL_V1AL			(0xffff << 0)
+
+#define OSD_OSDWINADH_O1AH_SHIFT		8
+#define OSD_OSDWINADH_O1AH			(0x7f << 8)
+#define OSD_OSDWINADH_O0AH_SHIFT		0
+#define OSD_OSDWINADH_O0AH			(0x7f << 0)
+
+#define OSD_OSDWIN0ADL_O0AL			(0xffff << 0)
+
+#define OSD_OSDWIN1ADL_O1AL			(0xffff << 0)
+
+#define OSD_BASEPX_BPX				(0x3ff << 0)
+
+#define OSD_BASEPY_BPY				(0x1ff << 0)
+
+#define OSD_VIDWIN0XP_V0X			(0x7ff << 0)
+
+#define OSD_VIDWIN0YP_V0Y			(0x7ff << 0)
+
+#define OSD_VIDWIN0XL_V0W			(0x7ff << 0)
+
+#define OSD_VIDWIN0YL_V0H			(0x7ff << 0)
+
+#define OSD_VIDWIN1XP_V1X			(0x7ff << 0)
+
+#define OSD_VIDWIN1YP_V1Y			(0x7ff << 0)
+
+#define OSD_VIDWIN1XL_V1W			(0x7ff << 0)
+
+#define OSD_VIDWIN1YL_V1H			(0x7ff << 0)
+
+#define OSD_OSDWIN0XP_W0X			(0x7ff << 0)
+
+#define OSD_OSDWIN0YP_W0Y			(0x7ff << 0)
+
+#define OSD_OSDWIN0XL_W0W			(0x7ff << 0)
+
+#define OSD_OSDWIN0YL_W0H			(0x7ff << 0)
+
+#define OSD_OSDWIN1XP_W1X			(0x7ff << 0)
+
+#define OSD_OSDWIN1YP_W1Y			(0x7ff << 0)
+
+#define OSD_OSDWIN1XL_W1W			(0x7ff << 0)
+
+#define OSD_OSDWIN1YL_W1H			(0x7ff << 0)
+
+#define OSD_CURXP_RCSX				(0x7ff << 0)
+
+#define OSD_CURYP_RCSY				(0x7ff << 0)
+
+#define OSD_CURXL_RCSW				(0x7ff << 0)
+
+#define OSD_CURYL_RCSH				(0x7ff << 0)
+
+#define OSD_EXTMODE_EXPMDSEL			(1 << 15)
+#define OSD_EXTMODE_SCRNHEXP_SHIFT		13
+#define OSD_EXTMODE_SCRNHEXP			(3 << 13)
+#define OSD_EXTMODE_SCRNVEXP			(1 << 12)
+#define OSD_EXTMODE_OSD1BLDCHR			(1 << 11)
+#define OSD_EXTMODE_OSD0BLDCHR			(1 << 10)
+#define OSD_EXTMODE_ATNOSD1EN			(1 << 9)
+#define OSD_EXTMODE_ATNOSD0EN			(1 << 8)
+#define OSD_EXTMODE_OSDHRSZ15			(1 << 7)
+#define OSD_EXTMODE_VIDHRSZ15			(1 << 6)
+#define OSD_EXTMODE_ZMFILV1HEN			(1 << 5)
+#define OSD_EXTMODE_ZMFILV1VEN			(1 << 4)
+#define OSD_EXTMODE_ZMFILV0HEN			(1 << 3)
+#define OSD_EXTMODE_ZMFILV0VEN			(1 << 2)
+#define OSD_EXTMODE_EXPFILHEN			(1 << 1)
+#define OSD_EXTMODE_EXPFILVEN			(1 << 0)
+
+#define OSD_MISCCTL_RGBEN			(1 << 7)
+#define OSD_MISCCTL_RGBWIN			(1 << 6)
+#define OSD_MISCCTL_DMANG			(1 << 6)
+#define OSD_MISCCTL_TMON			(1 << 5)
+#define OSD_MISCCTL_RSEL			(1 << 4)
+#define OSD_MISCCTL_CPBSY			(1 << 3)
+#define OSD_MISCCTL_PPSW			(1 << 2)
+#define OSD_MISCCTL_PPRV			(1 << 1)
+
+#define OSD_CLUTRAMYCB_Y_SHIFT			8
+#define OSD_CLUTRAMYCB_Y			(0xff << 8)
+#define OSD_CLUTRAMYCB_CB_SHIFT			0
+#define OSD_CLUTRAMYCB_CB			(0xff << 0)
+
+#define OSD_CLUTRAMCR_CR_SHIFT			8
+#define OSD_CLUTRAMCR_CR			(0xff << 8)
+#define OSD_CLUTRAMCR_CADDR_SHIFT		0
+#define OSD_CLUTRAMCR_CADDR			(0xff << 0)
+
+#define OSD_TRANSPVAL_RGBTRANS			(0xffff << 0)
+
+#define OSD_TRANSPVALL_RGBL			(0xffff << 0)
+
+#define OSD_TRANSPVALU_Y_SHIFT			8
+#define OSD_TRANSPVALU_Y 			(0xff << 8)
+#define OSD_TRANSPVALU_RGBU_SHIFT		0
+#define OSD_TRANSPVALU_RGBU			(0xff << 0)
+
+#define OSD_TRANSPBMPIDX_BMP1_SHIFT		8
+#define OSD_TRANSPBMPIDX_BMP1			(0xff << 8)
+#define OSD_TRANSPBMPIDX_BMP0_SHIFT		0
+#define OSD_TRANSPBMPIDX_BMP0			0xff
+
+#endif				/* _DAVINCI_VPBE_H_ */
Index: linux-2.6.18/drivers/media/video/Makefile
===================================================================
--- linux-2.6.18.orig/drivers/media/video/Makefile
+++ linux-2.6.18/drivers/media/video/Makefile
@@ -98,6 +98,8 @@ obj-$(CONFIG_USB_QUICKCAM_MESSENGER)	+= 
 
 obj-$(CONFIG_VIDEO_VIVI) += vivi.o
 
+obj-$(CONFIG_ARCH_DAVINCI)        += davinci/
+
 EXTRA_CFLAGS += -Idrivers/media/dvb/dvb-core
 extra-cflags-$(CONFIG_VIDEO_V4L1_COMPAT) += -DCONFIG_VIDEO_V4L1_COMPAT
 
Index: linux-2.6.18/mvl_patches/pro50-1578.c
===================================================================
--- /dev/null
+++ linux-2.6.18/mvl_patches/pro50-1578.c
@@ -0,0 +1,16 @@
+/*
+ * Author: MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/init.h>
+#include <linux/mvl_patch.h>
+
+static __init int regpatch(void)
+{
+        return mvl_register_patch(1578);
+}
+module_init(regpatch);
EOF

    rv=0
    cat /tmp/mvl_patch_$$
    if [ "$?" != "0" ]; then
	# Patch had a hard error, return 2
	rv=2
    elif grep '^Hunk' ${TMPFILE}; then
	rv=1
    fi

    rm -f ${TMPFILE}
    return $rv
}

function options() {
    echo "Options are:"
    echo "  --force-unsupported - Force the patch to be applied even if the"
    echo "      patch is out of order or the current kernel is unsupported."
    echo "      Use of this option is strongly discouraged."
    echo "  --force-apply-fuzz - If the patch has fuzz, go ahead and apply"
    echo "      it anyway.  This can occur if the patch is applied to an"
    echo "      unsupported kernel or applied out of order or if you have"
    echo "      made your own modifications to the kernel.  Use with"
    echo "      caution."
    echo "  --remove - Remove the patch"
}


function checkpatchnum() {
    local level;

    if [ ! -e ${1} ]; then
	echo "${1} does not exist, make sure you are in the kernel" 1>&2
	echo "base directory" 1>&2
	exit 1;
    fi

    # Extract the current patch number from the lsp info file.
    level=`grep '#define LSP_.*PATCH_LEVEL' ${1} | sed 's/^.*\"\\(.*\\)\".*\$/\\1/'`
    if [ "a$level" = "a" ]; then
	echo "No patch level defined in ${1}, are you sure this is" 1>&2
	echo "a valid MVL kernel LSP?" 1>&2
	exit 1;
    fi

    expr $level + 0 >/dev/null 2>&1
    isnum=$?

    # Check if the kernel is supported
    if [ "$level" = "unsupported" ]; then
	echo "**Current kernel is unsupported by MontaVista due to patches"
	echo "  begin applied out of order."
	if [ $force_unsupported == 't' ]; then
	    echo "  Application is forced, applying patch anyway"
	    unsupported=t
	    fix_patch_level=f
	else
	    echo "  Patch application aborted.  Use --force-unsupported to"
	    echo "  force the patch to be applied, but the kernel will not"
	    echo "  be supported by MontaVista."
	    exit 1;
	fi

    # Check the patch number from the lspinfo file to make sure it is
    # a valid number
    elif [ $isnum = 2 ]; then
	echo "**Patch level from ${1} was not a valid number, " 1>&2
	echo "  are you sure this is a valid MVL kernel LSP?" 1>&2
	exit 1;

    # Check that this is the right patch number to be applied.
    elif [ `expr $level $3` ${4} ${2} ]; then
	echo "**Application of this patch is out of order and will cause the"
	echo "  kernel to be unsupported by MontaVista."
	if [ $force_unsupported == 't' ]; then
	    echo "  application is forced, applying patch anyway"
	    unsupported=t
	else
	    echo "  Patch application aborted.  Please get all the patches in"
	    echo "  proper order from MontaVista Zone and apply them in order"
	    echo "  If you really want to apply this patch, use"
	    echo "  --force-unsupported to force the patch to be applied, but"
	    echo "  the kernel will not be supported by MontaVista."
	    exit 1;
	fi
    fi
}

#
# Update the patch level in the file.  Note that we use patch to do
# this.  Certain weak version control systems don't take kindly to
# arbitrary changes directly to files, but do have a special version
# of "patch" that understands this.
#
function setpatchnum() {
    sed "s/^#define LSP_\(.*\)PATCH_LEVEL[ \t*]\"[0-9]*\".*$/#define LSP_\1PATCH_LEVEL \"${2}\"/" <${1} >/tmp/$$.tmp1
    diff -u ${1} /tmp/$$.tmp1 >/tmp/$$.tmp2
    rm /tmp/$$.tmp1
    sed "s/^+++ \/tmp\/$$.tmp1/+++ include\/linux\/lsppatchlevel.h/" </tmp/$$.tmp2 >/tmp/$$.tmp1
    rm /tmp/$$.tmp2
    patch -p0 </tmp/$$.tmp1
    rm /tmp/$$.tmp1
}

force_unsupported=f
force_apply_fuzz=""
unsupported=f
fix_patch_level=t
reverse=f
common_patchnum_diff='+ 1'
common_patchnum=$PATCHNUM
patch_extraopts=''

# Extract command line parameters.
while [ $# -gt 0 ]; do
    if [ "a$1" == 'a--force-unsupported' ]; then
	force_unsupported=t
    elif [ "a$1" == 'a--force-apply-fuzz' ]; then
	force_apply_fuzz=y
    elif [ "a$1" == 'a--remove' ]; then
	reverse=t
	common_patchnum_diff=''
	common_patchnum=`expr $PATCHNUM - 1`
	patch_extraopts='--reverse'
    else
	echo "'$1' is an invalid command line parameter."
	options
	exit 1
    fi
    shift
done

echo "Checking patch level"
checkpatchnum ${LSPINFO} ${PATCHNUM} "${common_patchnum_diff}" "-ne"

if ! dopatch -p1 --dry-run --force $patch_extraopts; then
    if [ $? = 2 ]; then
	echo -n "**Patch had errors, application aborted" 1>&2
	exit 1;
    fi

    # Patch has warnings
    clean_apply=${force_apply_fuzz}
    while [ "a$clean_apply" != 'ay' -a "a$clean_apply" != 'an' ]; do
	echo -n "**Patch did not apply cleanly.  Do you still want to apply? (y/n) > "
	read clean_apply
	clean_apply=`echo "$clean_apply" | tr '[:upper:]' '[:lower:]'`
    done
    if [ $clean_apply = 'n' ]; then
	exit 1;
    fi
fi

dopatch -p1 --force $patch_extraopts

if [ $fix_patch_level = 't' ]; then 
    if [ $unsupported = 't' ]; then
	common_patchnum="unsupported"
    fi

    setpatchnum ${LSPINFO} ${common_patchnum}
fi

# Move the patch file into the mvl_patches directory if we are not reversing
if [ $reverse != 't' ]; then 
    if echo $0 | grep '/' >/dev/null; then
	# Filename is a path, either absolute or from the current directory.
	srcfile=$0
    else
	# Filename is from the path
	for i in `echo $PATH | tr ':;' '  '`; do
	    if [ -e ${i}/$0 ]; then
		srcfile=${i}/$0
	    fi
	done
    fi

    fname=`basename ${srcfile}`
    diff -uN mvl_patches/${fname} ${srcfile} | (cd mvl_patches; patch)
fi

